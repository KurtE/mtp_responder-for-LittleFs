
.vsteensy/build/mtp-test.elf:     file format elf32-littlearm

SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
0000c864 l    d  .fini	00000000 .fini
0000c868 l    d  .ARM.exidx	00000000 .ARM.exidx
1fff0000 l    d  .usbdescriptortable	00000000 .usbdescriptortable
1fff0200 l    d  .dmabuffers	00000000 .dmabuffers
1fff03d0 l    d  .usbbuffers	00000000 .usbbuffers
1fff0970 l    d  .data	00000000 .data
1fff12dc l    d  .bss	00000000 .bss
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 mk20dx128.c
0000907c l     F .text	0000000c startup_default_early_hook
00009088 l     F .text	00000002 startup_default_late_hook
00000000 l    df *ABS*	00000000 crtstuff.c
00000410 l     F .text	00000000 __do_global_dtors_aux
1fff12dc l       .bss	00000000 completed.8605
00000434 l     F .text	00000000 frame_dummy
1fff12e0 l       .bss	00000000 object.8610
0000c858 l     O .text	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 mtp-test.ino
0000059c l     F .text	00000034 logg(unsigned long, char const*) [clone .part.12]
00000634 l     F .text	00000078 _GLOBAL__sub_I_storage
1fff12f8 l     O .bss	00000004 logg(unsigned long, char const*)::to
00000000 l    df *ABS*	00000000 ExFatFormatter.cpp
00000000 l    df *ABS*	00000000 ExFatFile.cpp
000006c8 l     F .text	0000003c dbgPrint(unsigned short)
00000000 l    df *ABS*	00000000 ExFatPartition.cpp
00001190 l     F .text	0000003c dbgPrint(unsigned short)
000011cc l     F .text	0000002c FsCache::sync() [clone .part.2]
00000000 l    df *ABS*	00000000 upcase.cpp
00000000 l    df *ABS*	00000000 ExFatFileWrite.cpp
00001824 l     F .text	0000003c dbgPrint(unsigned short)
00000000 l    df *ABS*	00000000 FatFile.cpp
00002414 l     F .text	0000003c dbgPrint(unsigned short)
00002594 l     F .text	000000a4 FatFile::sync() [clone .part.38]
00000000 l    df *ABS*	00000000 FatPartition.cpp
00003434 l     F .text	0000003c dbgPrint(unsigned short)
00003470 l     F .text	00000058 FatCache::sync() [clone .part.8]
00000000 l    df *ABS*	00000000 FatFileLFN.cpp
00003994 l     F .text	00000028 lfnGetChar(DirLfn_t*, unsigned char)
000039bc l     F .text	0000003c dbgPrint(unsigned short)
00000000 l    df *ABS*	00000000 FatFileSFN.cpp
000044c8 l     F .text	0000003c dbgPrint(unsigned short)
00000000 l    df *ABS*	00000000 FsFile.cpp
00000000 l    df *ABS*	00000000 FsVolume.cpp
00000000 l    df *ABS*	00000000 FsNew.cpp
00000000 l    df *ABS*	00000000 SdSpiCard.cpp
000048bc l     F .text	0000009c SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]
00004958 l     F .text	00000070 SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]
00000000 l    df *ABS*	00000000 SdioTeensy.cpp
00005078 l     F .text	00000030 sdIrs()
000050a8 l     F .text	00000018 isBusyCommandComplete()
000050c0 l     F .text	00000010 isBusyCommandInhibit()
000050d0 l     F .text	0000000c isBusyDMA()
000050dc l     F .text	00000014 isBusyFifoRead()
000050f0 l     F .text	00000014 isBusyFifoWrite()
00005104 l     F .text	00000018 isBusyTransferComplete()
0000511c l     F .text	000000cc setSdclk(unsigned long)
0000524c l     F .text	00000028 waitTimeout(bool (*)())
00005274 l     F .text	0000004c yieldTimeout(bool (*)())
000052f0 l     F .text	0000005c cardCommand(unsigned long, unsigned long)
0000536c l     F .text	00000064 readReg16(unsigned long, void*)
000053d0 l     F .text	0000002c isBusyCMD13()
00005418 l     F .text	00000020 waitDmaStatus() [clone .part.6]
00005438 l     F .text	000000b4 rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)
0000562c l     F .text	00000078 transferStop()
000059dc l     F .text	000000ac cardCMD6(unsigned long, unsigned char*)
1fff13d0 l     O .bss	00000001 m_version2
1fff13d4 l     O .bss	00000010 m_cid
1fff13e4 l     O .bss	00000004 m_busyFcn
1fff13e8 l     O .bss	00000001 m_highCapacity
1fff13ec l     O .bss	00000004 m_ocr
1fff13f0 l     O .bss	00000004 m_rca
1fff13f4 l     O .bss	00000004 m_irqstat
1fff0974 l     O .data	00000001 m_errorCode
1fff13f8 l     O .bss	00000001 m_initDone
1fff13fc l     O .bss	00000010 m_csd
1fff140c l     O .bss	00000001 m_dmaBusy
1fff1410 l     O .bss	00000004 m_sdClkKhz
1fff1414 l     O .bss	00000004 m_errorLine
00000000 l    df *ABS*	00000000 MTP_Storage.cpp
000060d0 l     F .text	00000048 MTPStorage_SD::OpenIndex() [clone .part.41] [clone .constprop.61]
00006330 l     F .text	000000f0 MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]
00006c70 l     F .text	00000032 MTPStorage_SD::ScanAll() [clone .part.45] [clone .constprop.58]
00006e08 l     F .text	00000054 _GLOBAL__sub_I_SD
00000000 l    df *ABS*	00000000 MTP.cpp
00006e5c l     F .text	000000c0 MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]
00006f34 l     F .text	00000074 MTPD::write(char const*, int) [clone .part.4]
00007050 l     F .text	000000bc MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]
000081b8 l     F .text	00000028 MTPD::setObjectPropValue(unsigned long, unsigned long) [clone .part.8]
0000c4a4 l     O .text	00000024 supported_op
0000c4c8 l     O .text	00000014 propertyList
00000000 l    df *ABS*	00000000 SPI.cpp
00000000 l    df *ABS*	00000000 Time.cpp
00008aa8 l     F .text	00000018 refreshCache(long) [clone .part.0]
1fff18cc l     O .bss	00000004 cacheTime
1fff18d0 l     O .bss	00000007 tm
1fff18d8 l     O .bss	00000004 sysTime
1fff18dc l     O .bss	00000001 Status
1fff18e4 l     O .bss	00000004 prevMillis
1fff097c l     O .data	00000004 syncInterval
0000c544 l     O .text	0000000c monthDays
1fff18e8 l     O .bss	00000004 nextSyncTime
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 usb_serial.c
1fff18ed l     O .bss	00000001 tx_noautoflush
1fff18f0 l     O .bss	00000004 tx_packet
1fff18f4 l     O .bss	00000001 transmit_previous_timeout
1fff18f8 l     O .bss	00000004 rx_packet
00000000 l    df *ABS*	00000000 serial1.c
000090f4 l     F .text	000000a4 serial_putchar.part.0
1fff1900 l     O .bss	00000004 rts_pin
1fff1904 l     O .bss	00000001 rx_buffer_head
1fff1905 l     O .bss	00000001 rx_buffer_tail
1fff1908 l     O .bss	00000040 tx_buffer
1fff1948 l     O .bss	00000001 rx_pin_num
1fff194c l     O .bss	00000040 rx_buffer
1fff198c l     O .bss	00000001 transmitting
1fff0984 l     O .data	00000001 tx_pin_num
1fff198d l     O .bss	00000001 tx_buffer_tail
1fff1990 l     O .bss	00000004 transmit_pin
1fff1994 l     O .bss	00000001 tx_buffer_head
00000000 l    df *ABS*	00000000 pins_teensy.c
000098f8 l     F .text	0000004c digitalWrite.part.1
00009944 l     F .text	00000078 pinMode.part.2
00000000 l    df *ABS*	00000000 usb_mem.c
1fff0988 l     O .data	00000004 usb_buffer_available
00000000 l    df *ABS*	00000000 usb_dev.c
1fff199c l     O .bss	00000004 ep0_tx_ptr
1fff19a0 l     O .bss	00000018 rx_last
1fff19b8 l     O .bss	00000002 ep0_tx_len
1fff19bc l     O .bss	00000040 ep0_rx0_buf
1fff19fc l     O .bss	00000018 rx_first
1fff1a14 l     O .bss	00000001 ep0_tx_data_toggle
1fff1a18 l     O .bss	00000040 ep0_rx1_buf
1fff1a58 l     O .bss	00000018 tx_first
1fff0000 l     O .usbdescriptortable	000000e0 table
1fff1a70 l     O .bss	00000018 tx_last
1fff1a88 l     O .bss	00000008 setup
1fff1a90 l     O .bss	00000001 ep0_tx_bdt_bank
1fff1a94 l     O .bss	00000008 reply_buffer
1fff1aa0 l     O .bss	00000006 tx_state
00000000 l    df *ABS*	00000000 HardwareSerial1.cpp
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 yield.cpp
1fff1ac4 l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 HardwareSerial5.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 HardwareSerial2.cpp
00000000 l    df *ABS*	00000000 HardwareSerial4.cpp
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 HardwareSerial6.cpp
00000000 l    df *ABS*	00000000 new.cpp
00000000 l    df *ABS*	00000000 serial5.c
1fff1ac8 l     O .bss	00000004 rts_pin
1fff1acc l     O .bss	00000001 rx_buffer_head
1fff1acd l     O .bss	00000001 rx_buffer_tail
1fff1ad0 l     O .bss	00000028 tx_buffer
1fff1af8 l     O .bss	00000040 rx_buffer
1fff1b38 l     O .bss	00000001 transmitting
1fff1b39 l     O .bss	00000001 tx_buffer_tail
1fff1b3c l     O .bss	00000004 transmit_pin
1fff1b40 l     O .bss	00000001 tx_buffer_head
00000000 l    df *ABS*	00000000 analog.c
1fff1b41 l     O .bss	00000001 calibrating
1fff09ac l     O .data	00000001 analog_config_bits
1fff1b42 l     O .bss	00000001 analog_reference_internal
1fff09ad l     O .data	00000001 analog_num_average
00000000 l    df *ABS*	00000000 serial2.c
1fff1b44 l     O .bss	00000004 rts_pin
1fff1b48 l     O .bss	00000001 transmitting
1fff1b49 l     O .bss	00000001 rx_buffer_tail
1fff1b4c l     O .bss	00000028 tx_buffer
1fff1b74 l     O .bss	00000040 rx_buffer
1fff1bb4 l     O .bss	00000001 rx_buffer_head
1fff1bb5 l     O .bss	00000001 tx_buffer_tail
1fff1bb8 l     O .bss	00000004 transmit_pin
1fff1bbc l     O .bss	00000001 tx_buffer_head
00000000 l    df *ABS*	00000000 serial4.c
1fff1bc0 l     O .bss	00000004 rts_pin
1fff1bc4 l     O .bss	00000001 rx_buffer_head
1fff1bc5 l     O .bss	00000001 rx_buffer_tail
1fff1bc8 l     O .bss	00000028 tx_buffer
1fff1bf0 l     O .bss	00000040 rx_buffer
1fff1c30 l     O .bss	00000001 transmitting
1fff1c31 l     O .bss	00000001 tx_buffer_tail
1fff1c34 l     O .bss	00000004 transmit_pin
1fff1c38 l     O .bss	00000001 tx_buffer_head
00000000 l    df *ABS*	00000000 serial6_lpuart.c
1fff1c3c l     O .bss	00000004 rts_pin
1fff1c40 l     O .bss	00000001 rx_buffer_head
1fff1c41 l     O .bss	00000001 rx_buffer_tail
1fff1c44 l     O .bss	00000028 tx_buffer
1fff1c6c l     O .bss	00000040 rx_buffer
1fff1cac l     O .bss	00000001 transmitting
1fff1cad l     O .bss	00000001 tx_buffer_tail
1fff1cb0 l     O .bss	00000004 transmit_pin
1fff1cb4 l     O .bss	00000001 tx_buffer_head
00000000 l    df *ABS*	00000000 usb_desc.c
1fff09b0 l     O .data	00000012 device_descriptor
1fff09dc l     O .data	00000069 config_descriptor
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 serial3.c
1fff1cb8 l     O .bss	00000004 rts_pin
1fff1cbc l     O .bss	00000001 rx_buffer_head
1fff1cbd l     O .bss	00000001 rx_buffer_tail
1fff1cc0 l     O .bss	00000028 tx_buffer
1fff1ce8 l     O .bss	00000040 rx_buffer
1fff1d28 l     O .bss	00000001 transmitting
1fff1d29 l     O .bss	00000001 tx_buffer_tail
1fff1d2c l     O .bss	00000004 transmit_pin
1fff1d30 l     O .bss	00000001 tx_buffer_head
00000000 l    df *ABS*	00000000 HardwareSerial3.cpp
00000000 l    df *ABS*	00000000 atexit_arm.cc
00000000 l    df *ABS*	00000000 cxa_atexit.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 strcat.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0000bf60 l     F .text	00000014 register_fini
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 fini.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 impure.c
1fff0aa0 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.10/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.10/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 FsDateTime.cpp
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
1fff12dc l       .bss	00000000 __bss_start__
1fff1d84 l       .bss	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __stack
00009074  w    F .text	00000006 adc0_isr
000062c8 g     F .text	00000068 MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)
00008dd0 g     F .text	0000001c usb_serial_available
0000b154 g     F .text	00000020 serial4_available
0000bc84 g     F .text	000000ba strcpy
0000aa00  w    F .text	00000018 HardwareSerial::write(char const*)
000057e8 g     F .text	00000088 SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)
0000ac8c  w    F .text	000000c4 yield
000031e8 g     F .text	0000024c FatFile::write(void const*, unsigned int)
00004830  w    F .text	00000002 SdSpiCard::~SdSpiCard()
00000bfc g     F .text	00000430 ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)
1fff12fc g     O .bss	000000bc storage
1fff09c4 g     O .data	00000018 usb_string_manufacturer_name_default
000096e8 g     F .text	00000020 serial_available
0000aa5c  w    F .text	00000006 HardwareSerial::transmitterEnable(unsigned char)
0000902c  w    F .text	00000048 hard_fault_isr
0000aa2c  w    F .text	00000010 HardwareSerial::attachCts(unsigned char)
00009074  w    F .text	00000006 dma_ch6_isr
1fff13c8 g     O .bss	00000004 FsDateTime::callback
0000ad80 g     F .text	00000020 Print::println()
0000b028 g     F .text	00000020 serial2_available
00009074  w    F .text	00000006 uart0_lon_isr
00000ae0 g     F .text	0000011c ExFatFile::seekSet(unsigned long long)
00009d48 g     F .text	00000108 usb_rx_memory
0000652c g     F .text	00000040 MTPStorage_SD::SetObjectInfo(unsigned long, char*, unsigned long, unsigned long, unsigned long)
0000ad50  w    F .text	00000002 serialEvent5()
00004804  w    F .text	00000004 SdSpiCard::errorCode() const
00009074  w    F .text	00000006 dma_ch8_isr
0000b24c g     F .text	00000020 serial6_available
0000bc1c g     F .text	00000002 __malloc_unlock
1fff13cc g     O .bss	00000004 FsVolume::m_cwv
000026a4 g     F .text	00000104 FatFile::open(FatFile*, char const*, int)
0000af48 g     F .text	000000e0 analog_init
00009e50 g     F .text	00000084 usb_tx
00009074  w    F .text	00000006 portcd_isr
00009434 g     F .text	00000094 serial_set_tx
0000abe4 g     F .text	00000098 MillisTimer::runFromTimer()
0000aa9c  w    F .text	00000004 HardwareSerial::peek()
00009074  w    F .text	00000006 can1_rx_warn_isr
0000c870 g       .ARM.exidx	00000000 __exidx_end
00009074  w    F .text	00000006 dma_error_isr
00003734 g     F .text	00000056 FatPartition::freeChain(unsigned long)
1fff1abc g     O .bss	00000001 EventResponder::runningFromYield
00004b28 g     F .text	000000b0 SdSpiCard::cardCommand(unsigned char, unsigned long)
00009074  w    F .text	00000006 i2c0_isr
00006884 g     F .text	000000cc MTPStorage_SD::move(unsigned long, unsigned long)
000039f8 g     F .text	00000024 FatFile::lfnChecksum(unsigned char*)
0000b52c g     F .text	0000000c __errno
00006b20 g     F .text	00000150 MTPStorage_SD::ScanDir(unsigned long)
00009074  w    F .text	00000006 portd_isr
00009074  w    F .text	00000006 enet_error_isr
1fff1aa8 g     O .bss	00000004 EventResponder::firstInterrupt
00007360 g     F .text	00000078 MTPD::GetObjectHandles(unsigned long, unsigned long)
000097a0 g     F .text	0000004c serial_clear
00004834  w    F .text	0000000e SdSpiCard::~SdSpiCard()
1fff098c g     O .data	00000010 Serial1
00009074  w    F .text	00000006 tpm1_isr
000062a0  w    F .text	00000024 Print::println(__FlashStringHelper const*)
00001754 g     F .text	0000003c ExFatPartition::rootLength()
00004808  w    F .text	00000004 SdSpiCard::errorData() const
0000ad6c  w    F .text	00000008 usb_serial_class::write(unsigned char const*, unsigned int)
0000c550 g     O .text	00000200 digital_pin_to_info_PGM
1fff1d80 g     O .bss	00000004 errno
00004bd8 g     F .text	00000064 SdSpiCard::readOCR(unsigned long*)
000040b4 g     F .text	00000412 FatFile::open(FatFile*, fname_t*, int)
00001560 g     F .text	0000004a ExFatPartition::fatGet(unsigned long, unsigned long*)
0000c870 g       .ARM.exidx	00000000 _etext
1fff12dc g       .bss	00000000 _sbss
000051f4 g     F .text	0000000c SdioCard::errorData() const
0000a9c8  w    F .text	00000008 HardwareSerial::write(unsigned long)
0000ae48  w    F .text	00000002 serialEvent6()
000058f8 g     F .text	000000b4 SdioCard::writeSector(unsigned long, unsigned char const*)
0000aaa4  w    F .text	00000004 HardwareSerial::available()
00009074  w    F .text	00000006 porte_isr
000005f8 g     F .text	0000003c loop
00009074  w    F .text	00000006 portb_isr
00009074  w    F .text	00000006 spi1_isr
00007824 g     F .text	0000012c MTPD::GetStorageInfo(unsigned long)
0000b174 g     F .text	000000d8 uart3_status_isr
0000aab0  w    F .text	00000002 serialEvent1()
00000808 g     F .text	000000c4 ExFatFile::parsePathName(char const*, ExName_t*, char const**)
00009074  w    F .text	00000006 mcm_isr
00005e1c g     F .text	000000cc SdioCard::readData(unsigned char*)
0000ab7c g     F .text	00000068 MillisTimer::addToActiveList()
00006ca4 g     F .text	00000068 MTPStorage_SD::StartGetObjectHandles(unsigned long)
0000a9f4  w    F .text	0000000c HardwareSerial::write(unsigned char)
00004a18 g     F .text	000000c0 SdSpiCard::readData(unsigned char*, unsigned int)
1fff1aac g     O .bss	00000004 EventResponder::lastInterrupt
0000b048 g     F .text	0000010c uart1_status_isr
00004588 g     F .text	00000028 FsBaseFile::close()
00008c24 g     F .text	00000134 memcpy
00009074  w    F .text	00000006 randnum_isr
00001644 g     F .text	0000009c ExFatPartition::freeChain(unsigned long)
00002998 g     F .text	0000002a FatFile::peek()
1fff1998 g     O .bss	00000004 systick_millis_count
00001f3c g     F .text	000000d8 ExFatFile::rename(ExFatFile*, char const*)
0000902c  w    F .text	00000048 bus_fault_isr
00008330 g     F .text	000005ac MTPD::loop()
00009074  w    F .text	00000006 watchdog_isr
000090b8 g     F .text	0000003c nvic_execution_priority
00009074  w    F .text	00000006 i2c1_isr
1fff1a9c g     O .bss	00000001 usb_configuration
00009074  w    F .text	00000006 dma_ch11_isr
000047fc  w    F .text	00000006 SdCardInterface::status()
000059ac g     F .text	00000030 SdioCard::syncDevice()
000056a8 g     F .text	000000cc SdioCard::writeData(unsigned char const*)
00000000  w      *UND*	00000000 __fini_array_end
000004fc  w    F .text	00000058 StreamFile<FsBaseFile, unsigned long long>::available()
000029c4 g     F .text	0000004e FatFile::readDirCache(bool)
0000ae30  w    F .text	00000002 serialEvent2()
00009074  w    F .text	00000006 i2c2_isr
1fff09c4  w    O .data	00000018 usb_string_manufacturer_name
1fff1d74 g     O .bss	0000000c usb_rx_byte_count_data
00009074  w    F .text	00000006 pit1_isr
1fff0a48 g     O .data	00000008 usb_string_mtp
0000b588 g     F .text	00000010 malloc
00009074  w    F .text	00000006 dma_ch4_isr
00009074  w    F .text	00000006 software_isr
0000c238  w    O .text	00000024 vtable for FsFile
00009074  w    F .text	00000006 dma_ch7_isr
000088dc  w    F .text	0000001c EventResponder::triggerEvent(int, void*)
0000a900 g     F .text	000000c8 usb_init
000045b0 g     F .text	0000007c FsBaseFile::operator=(FsBaseFile const&)
0000aa54  w    F .text	00000006 HardwareSerial::setRX(unsigned char)
0000481c  w    F .text	00000004 SdSpiCard::type() const
00009074  w    F .text	00000006 lptmr_isr
1fff1d3c g     O .bss	00000004 __malloc_top_pad
000099cc g     F .text	00000024 rtc_set
00004844 g     F .text	00000076 SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
00002014 g     F .text	00000120 ExFatFile::truncate()
1fff0970 g     O .data	00000000 .hidden __dso_handle
000099bc g     F .text	00000010 attachInterruptVector
0000a9d0  w    F .text	00000008 HardwareSerial::write(long)
1fff0970 g       .data	00000000 _sdata
00003544 g     F .text	0000000e FatCache::sync()
00007680 g     F .text	000001a4 MTPD::getObjectPropValue(unsigned long, unsigned long)
00002450 g     F .text	00000042 FatFile::addCluster()
0000bc20 g     F .text	00000024 _sbrk_r
00004c3c g     F .text	0000004a SdSpiCard::readRegister(unsigned char, void*)
000096ac g     F .text	00000018 serial_flush
000052d0 g     F .text	00000020 SdioCard::type() const
000001d0 g     F .text	000001f0 ResetHandler
00008d58 g     F .text	00000048 usb_serial_getchar
00009074  w    F .text	00000006 can1_bus_off_isr
00009074  w    F .text	00000006 ftm2_isr
1fff1d68 g     O .bss	00000008 usb_cdc_line_coding
000099f0 g     F .text	0000000a digitalWrite
1fff1ab4 g     O .bss	00000004 EventResponder::lastYield
00009074  w    F .text	00000006 uart5_status_isr
0000b26c g     F .text	000000e4 lpuart0_status_isr
000007d8 g     F .text	0000002e ExFatFile::openRoot(ExFatVolume*)
0000c7dc g     O .text	00000006 usb_endpoint_config_table
00009074  w    F .text	00000006 dma_ch9_isr
0000aa68  w    F .text	00000012 HardwareSerial::begin(unsigned long)
000006ac  w    F .text	0000001c Print::write(char const*)
000004c4  w    F .text	00000038 StreamFile<FsBaseFile, unsigned long long>::read()
00009074  w    F .text	00000006 pit2_isr
0000b418 g     F .text	00000020 serial3_available
1fff1d38 g     O .bss	00000004 __malloc_max_sbrked_mem
000099fc g     F .text	0000000a pinMode
00006ac8 g     F .text	00000056 MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)
00004f38 g     F .text	00000050 SdSpiCard::writeStop()
00009c94 g     F .text	0000004c usb_free
00009074  w    F .text	00000006 i2c3_isr
00007614 g     F .text	0000006c MTPD::getObjectPropsSupported(unsigned long)
00006fa8 g     F .text	000000a8 MTPD::writestring(char const*)
00005044 g     F .text	00000032 SdSpiCard::writeData(unsigned char const*)
0000378c g     F .text	000000c6 FatPartition::freeClusterCount()
0000c868 g       .ARM.exidx	00000000 __exidx_start
00004e30 g     F .text	00000050 SdSpiCard::writeStart(unsigned long)
00009074  w    F .text	00000006 pit0_isr
0000aa4c  w    F .text	00000008 HardwareSerial::setTX(unsigned char, bool)
1fff1ab8 g     O .bss	00000004 EventResponder::firstYield
0000c844 g     O .text	00000004 _global_impure_ptr
000061bc g     F .text	00000018 MTPStorage_SD::write(char const*, unsigned long)
00009074  w    F .text	00000006 can1_error_isr
00000554  w    F .text	00000034 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)
0000b538 g     F .text	00000050 __libc_init_array
1fff1d84 g       .bss	00000000 __bss_end
00009074  w    F .text	00000006 can0_wakeup_isr
00001144 g     F .text	0000000e ExFatFile::open(ExFatVolume*, char const*, int)
00005200 g     F .text	0000001c SdioCard::readCID(CID*)
00001cac g     F .text	00000114 ExFatFile::addDirCluster()
00009074  w    F .text	00000006 flash_cmd_isr
00004fb4 g     F .text	00000090 SdSpiCard::writeData(unsigned char, unsigned char const*)
0000ad54  w    F .text	00000004 usb_serial_class::clear()
0000b438 g     F .text	000000d8 uart2_status_isr
0000908c g     F .text	0000002c _sbrk
000064fc g     F .text	00000030 MTPStorage_SD::GetObjectInfo(unsigned long, char*, unsigned long*, unsigned long*, unsigned long*)
00006950 g     F .text	00000084 MTPStorage_SD::OpenFileByIndex(unsigned long, int)
1fff1ac0 g     O .bss	00000004 MillisTimer::listWaiting
1fff0980 g     O .data	00000004 __brkval
1fff18fc g     O .bss	00000001 usb_cdc_line_rtsdtr
00008fe4 g     F .text	00000048 usb_serial_flush_callback
0000c848 g     F .text	00000000 _init
00002568 g     F .text	0000002a FatFile::cacheDirEntry(unsigned char)
00009074  w    F .text	00000006 svcall_isr
00009074  w    F .text	00000006 dma_ch15_isr
000081e0 g     F .text	0000001c MTPD::read_until_short_packet()
00009198 g     F .text	00000110 serial_begin
0000aa7c  w    F .text	00000020 HardwareSerial::begin(unsigned long, unsigned long)
00008bc0 g     F .text	00000020 day()
00009074  w    F .text	00000006 uart1_error_isr
0000bf80 g     F .text	00000028 __libc_fini_array
00009074  w    F .text	00000006 usbhs_phy_isr
1fff1d84 g       .bss	00000000 _ebss
00005870 g     F .text	00000088 SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)
0000710c g     F .text	00000214 MTPD::WriteDescriptor()
1fff0978 g     O .data	00000004 propertyListNum
000096c4 g     F .text	00000024 serial_write_buffer_free
00000498  w    F .text	00000014 StreamFile<FsBaseFile, unsigned long long>::flush()
000034c8 g     F .text	0000007a FatCache::read(unsigned long, unsigned char)
0000aaac  w    F .text	00000004 HardwareSerial::availableForWrite()
00001dc0 g     F .text	00000072 ExFatFile::mkdir(ExFatFile*, ExName_t*)
00009074 g     F .text	00000006 unused_isr
00007320 g     F .text	0000003e MTPD::WriteStorageIDs()
00009074  w    F .text	00000006 spi0_isr
00009074  w    F .text	00000006 dma_ch3_isr
0000aa3c  w    F .text	00000010 HardwareSerial::attachRts(unsigned char)
0000a9e8  w    F .text	0000000c HardwareSerial::write9bit(unsigned long)
00008c00 g     F .text	00000024 year()
0000ae4c g     F .text	00000004 operator delete(void*, unsigned int)
0000aa28  w    F .text	00000004 HardwareSerial::clear()
00009074  w    F .text	00000006 flash_error_isr
00008140 g     F .text	00000020 MTPD::ReadMTPHeader()
0000aaa8  w    F .text	00000004 HardwareSerial::flush()
0000ae50 g     F .text	00000020 serial5_available
000095d0 g     F .text	00000014 serial_putchar
0000bc44 g     F .text	0000003e strcat
00009074  w    F .text	00000006 uart5_error_isr
00009074  w    F .text	00000006 rtc_seconds_isr
00009074  w    F .text	00000006 pdb_isr
00002ad0 g     F .text	00000068 FatFile::rmdir()
0000902c  w    F .text	00000048 usage_fault_isr
00009074  w    F .text	00000006 dac1_isr
00000000 g     O .text	000001d0 _VectorsFlash
00003680 g     F .text	000000b2 FatPartition::allocateCluster(unsigned long, unsigned long*)
00009074  w    F .text	00000006 dma_ch14_isr
00000000  w      *UND*	00000000 __deregister_frame_info
1fff1d70 g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
0000ac7c g     F .text	00000010 systick_isr
00009074  w    F .text	00000006 rtc_alarm_isr
00004504 g     F .text	00000084 FatFile::getSFN(char*)
00004d80 g     F .text	00000076 SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)
00009074  w    F .text	00000006 dma_ch2_isr
1fff099c g     O .data	00000010 Serial
00009074  w    F .text	00000006 ftm1_isr
0000c750  w    O .text	00000060 vtable for HardwareSerial
0000ad74  w    F .text	00000006 usb_serial_class::write(unsigned char)
000046ac g     F .text	0000005e FsBaseFile::openNext(FsBaseFile*, int)
0000907c  w    F .text	0000000c startup_early_hook
00009074  w    F .text	00000006 dma_ch13_isr
00001860 g     F .text	000000c6 ExFatFile::addCluster()
00009074  w    F .text	00000006 uart2_error_isr
00008da0 g     F .text	00000030 usb_serial_peekchar
000062c4 g     F .text	00000002 mtp_yield()
000035f4 g     F .text	0000008a FatPartition::fatPut(unsigned long, unsigned long)
1fff0a84 g     O .data	00000016 usb_string_serial_number_default
0000902c g     F .text	00000048 fault_isr
0000c044 g     F .text	000001d0 _free_r
000056a4 g     F .text	00000004 SdioCard::readStop()
00001204 g     F .text	0000008c FsCache::get(unsigned long, unsigned char)
00009074  w    F .text	00000006 usb_charge_isr
0000ad64  w    F .text	00000004 usb_serial_class::flush()
00009074  w    F .text	00000006 cmt_isr
00003854 g     F .text	00000140 FatPartition::init(BlockDeviceInterface*, unsigned char)
00009074  w    F .text	00000006 usbhs_isr
00002d20 g     F .text	00000188 FatFile::mkdir(FatFile*, fname_t*)
1fff12d8 g     O .data	00000004 __malloc_sbrk_base
0000ad5c  w    F .text	00000004 usb_serial_class::read()
00009074  w    F .text	00000006 ftm3_isr
00009074  w    F .text	00000006 tsi0_isr
00003dcc g     F .text	000001b2 FatFile::remove()
0000aa64  w    F .text	00000004 HardwareSerial::end()
00002ea8 g     F .text	000000fc FatFile::mkdir(FatFile*, char const*, bool)
00009074  w    F .text	00000006 spi2_isr
000017cc g     F .text	00000058 exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)
0000649c g     F .text	0000005e MTPStorage_SD::GetNextObjectHandle()
0000ae34  w    F .text	00000002 serialEvent4()
00006034  w    F .text	00000002 SdFs::~SdFs()
0000ad7c  w    F .text	00000002 serialEvent()
1fff1a15 g     O .bss	00000001 usb_reboot_timer
0000bebc g     F .text	000000a4 __register_exitproc
0000102c g     F .text	00000116 ExFatFile::open(ExFatFile*, char const*, int)
0000be1c g     F .text	000000a0 strncmp
00001e34 g     F .text	00000108 ExFatFile::mkdir(ExFatFile*, char const*, bool)
00008dec g     F .text	00000038 usb_serial_flush_input
000016e0 g     F .text	00000072 ExFatPartition::freeClusterCount()
00008f2c g     F .text	00000018 usb_serial_putchar
00000022 g       *ABS*	00000000 _teensy_model_identifier
1fff1d40 g     O .bss	00000028 __malloc_current_mallinfo
00009074  w    F .text	00000006 can0_bus_off_isr
000052c0  w    F .text	0000000e SdioCard::~SdioCard()
00000718 g     F .text	000000be ExFatFile::getName(char*, unsigned int)
0000602c g     F .text	00000004 MTPStorage_SD::readonly()
1fff1a91 g     O .bss	00000001 usb_rx_memory_needed
00005774 g     F .text	00000074 SdioCard::writeStart(unsigned long)
00009ed4 g     F .text	00000a2c usb_isr
0000b520 g     F .text	0000000c __cxa_atexit
000008cc g     F .text	000001e4 ExFatFile::read(void*, unsigned int)
00001290 g     F .text	0000000e FsCache::sync()
0000bb18 g     F .text	00000062 memcmp
0000c7b0  w    O .text	00000028 vtable for usb_serial_class
00009074  w    F .text	00000006 uart3_error_isr
00008054 g     F .text	0000007c MTPD::GetObject(unsigned long)
000092a8 g     F .text	0000006c serial_format
1fff1ab0 g     O .bss	00000004 MillisTimer::listActive
00001a50 g     F .text	00000072 ExFatFile::rmdir()
00009074  w    F .text	00000006 porta_isr
00007950 g     F .text	000006e6 MTPD::getObjectPropDesc(unsigned long, unsigned long)
1fff03d0 g     O .usbbuffers	000005a0 usb_buffer_memory
00004c98 g     F .text	00000098 SdSpiCard::sectorCount()
00009074  w    F .text	00000006 low_voltage_isr
00006da4 g     F .text	00000064 MTPStorage_SD::init()
1fff0ecc g     O .data	00000408 __malloc_av_
00009074  w    F .text	00000006 can0_error_isr
000095e4 g     F .text	000000c8 serial_write
00009ae8 g     F .text	0000016c _init_Teensyduino_internal_
00008f8c g     F .text	00000058 usb_serial_flush_output
00009074  w    F .text	00000006 dma_ch12_isr
0000bc18 g     F .text	00000002 __malloc_lock
00000000  w      *UND*	00000000 __fini_array_start
00003b80 g     F .text	0000024c FatFile::parsePathName(char const*, fname_t*, char const**)
00009074  w    F .text	00000006 can1_wakeup_isr
1fff0200 g     O .dmabuffers	000001d0 _VectorsRam
000094c8 g     F .text	00000074 serial_set_rx
00009074  w    F .text	00000006 pit3_isr
000080d0 g     F .text	0000006e MTPD::read(char*, unsigned long)
1fff18e0 g     O .bss	00000004 getTimePtr
00009074  w    F .text	00000006 enet_rx_isr
00001c44 g     F .text	00000066 ExFatFile::sync()
00002fa4 g     F .text	00000238 FatFile::rename(FatFile*, char const*)
000053fc g     F .text	0000001c SdioCard::isBusy()
00009074  w    F .text	00000006 portc_isr
00004df8 g     F .text	00000038 SdSpiCard::readStop()
0000bb7c g     F .text	0000009a memset
0000ae38 g     F .text	00000010 main
00006034  w    F .text	00000002 SdFs::~SdFs()
1fff1d34 g     O .bss	00000004 __malloc_max_total_mem
000012a0 g     F .text	000000b4 ExFatPartition::bitmapFind(unsigned long, unsigned long)
00008ac0 g     F .text	000000a0 now()
00002134 g     F .text	000002e0 ExFatFile::write(void const*, unsigned int)
0000c408 g     O .text	0000004c vtable for MTPStorage_SD
000081fc g     F .text	000000d0 MTPD::SendObjectInfo(unsigned long, unsigned long)
0000902c  w    F .text	00000048 memmanage_fault_isr
0000b350 g     F .text	0000007c usb_init_serialnumber
0000c864 g       .text	00000000 __init_array_end
0000b5a8 g     F .text	00000570 _malloc_r
00009074  w    F .text	00000006 debugmonitor_isr
0000aab4 g     F .text	00000080 EventResponder::triggerEventNotImmediate()
00000031 g       *ABS*	00000000 __rtc_localtime
00009a08 g     F .text	00000044 micros
00000000  w      *UND*	00000000 __libc_fini
00009074  w    F .text	00000006 cmp1_isr
00009074  w    F .text	00000006 ftm0_isr
00001ac4 g     F .text	00000180 ExFatFile::syncDir()
0000bfa8 g     F .text	0000009c _malloc_trim_r
1fff0a80 g     O .data	00000004 string0
00008e24 g     F .text	00000108 usb_serial_write
00009088  w    F .text	00000002 startup_late_hook
0000ad60  w    F .text	00000004 usb_serial_class::available()
00008160 g     F .text	00000056 MTPD::readstring(char*)
000031dc g     F .text	0000000c FatFile::sync()
1fff0a50  w    O .data	0000002e usb_string_product_name
0000953c g     F .text	00000044 serial_set_rts
00009314 g     F .text	000000e8 serial_end
00009a4c g     F .text	0000009c delay
00009074  w    F .text	00000006 tpm0_isr
00006118 g     F .text	00000048 MTPStorage_SD::size()
0000c864 g     F .fini	00000000 _fini
0000a9d8  w    F .text	00000008 HardwareSerial::write(unsigned int)
00006f1c g     F .text	00000018 MTPD::get_buffer()
00008be0 g     F .text	00000020 month()
00004d30 g     F .text	00000050 SdSpiCard::readStart(unsigned long)
00001154 g     F .text	0000003a ExFatFile::openNext(ExFatFile*, int)
00009074  w    F .text	00000006 i2s0_rx_isr
00009074  w    F .text	00000006 uart4_error_isr
0000ae20 g     F .text	00000010 Print::print(long)
00002638 g     F .text	0000001e FatFile::close()
00003554 g     F .text	0000000c FatPartition::clusterStartSector(unsigned long) const
0000bf74 g     F .text	0000000c atexit
00005248  w    F .text	00000002 SdioCard::~SdioCard()
000004ac  w    F .text	00000018 StreamFile<FsBaseFile, unsigned long long>::peek()
1fff1418 g     O .bss	000004b4 SD
00005558 g     F .text	000000d4 SdioCard::erase(unsigned long, unsigned long)
00009074  w    F .text	00000006 can0_message_isr
1fff0ec8 g     O .data	00000004 _impure_ptr
00009074  w    F .text	00000006 can1_message_isr
00000ab0 g     F .text	0000002e ExFatFile::peek()
0000c214  w    O .text	00000024 vtable for StreamFile<FsBaseFile, unsigned long long>
00009074  w    F .text	00000006 nmi_isr
00003f80 g     F .text	00000134 FatFile::lfnUniqueSfn(fname_t*)
000047d0 g     F .text	00000028 FsVolume::open(char const*, int)
000051e8 g     F .text	0000000c SdioCard::errorCode() const
000027a8 g     F .text	0000000e FatFile::open(FatVolume*, char const*, int)
00000588  w    F .text	00000014 StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)
0000c854 g       .text	00000000 __preinit_array_end
00006038 g     F .text	00000098 dateTime(unsigned short*, unsigned short*, unsigned char*)
00004830  w    F .text	00000002 SdSpiCard::~SdSpiCard()
00009074  w    F .text	00000006 sdhc_isr
00008b80 g     F .text	00000020 minute()
00001354 g     F .text	00000110 ExFatPartition::init(BlockDeviceInterface*, unsigned char)
0000152c g     F .text	00000034 ExFatPartition::dirCache(DirPos_t*, unsigned char)
00006648 g     F .text	00000188 MTPStorage_SD::DeleteObject(unsigned long)
00004e80 g     F .text	000000b8 SdSpiCard::erase(unsigned long, unsigned long)
000049c8 g     F .text	0000004e SdSpiCard::isBusy()
0000c358 g     O .text	00000058 vtable for SdSpiCard
00004c90  w    F .text	00000008 SdSpiCard::readCID(CID*)
000005d0 g     F .text	00000028 setup
0000c7e4 g     O .text	00000060 usb_descriptor_list
00009ce0 g     F .text	0000003c usb_rx
0000534c g     F .text	00000020 SdioCard::status()
000061d4 g     F .text	000000cc MTPStorage_SD::ResetIndex()
00009074  w    F .text	00000006 dma_ch10_isr
0000a9e0  w    F .text	00000008 HardwareSerial::write(int)
00009074  w    F .text	00000006 uart0_error_isr
00009c54 g     F .text	00000040 usb_malloc
000027b8 g     F .text	000001de FatFile::read(void*, unsigned int)
00009074  w    F .text	00000006 i2s0_isr
00002658 g     F .text	0000004a FatFile::openRoot(FatVolume*)
20030000 g       .bss	00000000 _estack
000047f8 g     F .text	00000004 operator new(unsigned int, unsigned long*)
00004c88  w    F .text	00000008 SdSpiCard::readCSD(csd_t*)
00008f44 g     F .text	00000048 usb_serial_write_buffer_free
00004ad8 g     F .text	00000050 SdSpiCard::waitNotBusy(unsigned short)
00009074  w    F .text	00000006 enet_timer_isr
000065fc g     F .text	0000004c MTPStorage_SD::ConstructFilename(int, char*)
1fff12dc g       .data	00000000 _edata
000015f4 g     F .text	0000004e ExFatPartition::fatPut(unsigned long, unsigned long)
000073d8 g     F .text	0000023c MTPD::GetObjectInfo(unsigned long)
00005248  w    F .text	00000002 SdioCard::~SdioCard()
00009074  w    F .text	00000006 i2s0_tx_isr
00009074  w    F .text	00000006 adc1_isr
00004f88 g     F .text	0000002c SdSpiCard::syncDevice()
00002494 g     F .text	000000d4 FatFile::addDirCluster()
0000ad68  w    F .text	00000004 usb_serial_class::availableForWrite()
00009074  w    F .text	00000006 cmp0_isr
0000b3cc g     F .text	0000004c ultoa
00008ba0 g     F .text	00000020 second()
00006d0c  w    F .text	00000098 SdBase<FsVolume>::errorHalt(Print*)
0000462c g     F .text	00000080 FsBaseFile::open(FsVolume*, char const*, int)
00006420 g     F .text	0000007c MTPStorage_SD::ReadIndexRecord(unsigned long)
0000ab34 g     F .text	00000044 EventResponder::runFromInterrupt()
1fff12d4 g     O .data	00000004 __malloc_trim_threshold
0000ad58  w    F .text	00000004 usb_serial_class::peek()
00000470  w    F .text	00000028 MTPStorage_SD::~MTPStorage_SD()
1fff13b8 g     O .bss	00000010 mtpd
00005238 g     F .text	00000010 SdioCard::readOCR(unsigned long*)
0000aaa0  w    F .text	00000004 HardwareSerial::read()
000015ac g     F .text	00000048 ExFatPartition::dirSeek(DirPos_t*, unsigned long)
1fff18ec g     O .bss	00000001 usb_cdc_transmit_flush_timer
00009074  w    F .text	00000006 pit_isr
00008b60 g     F .text	00000020 hour()
000056a4 g     F .text	00000004 SdioCard::writeStop()
00004820  w    F .text	00000010 SdSpiCard::writeSector(unsigned long, unsigned char const*)
00006160 g     F .text	0000005c MTPStorage_SD::free()
00000704 g     F .text	00000014 ExFatFile::close()
00009074  w    F .text	00000006 dac0_isr
0000480c  w    F .text	00000010 SdSpiCard::readSector(unsigned long, unsigned char*)
0000c854 g       .text	00000000 __init_array_start
00009074  w    F .text	00000006 can1_tx_warn_isr
000097ec g     F .text	0000010c uart0_status_isr
00009074  w    F .text	00000006 mcg_isr
00000400 g     O .text	00000010 flashconfigbytes
0000bd40 g     F .text	000000dc strlen
00003a1c g     F .text	0000002e FatFile::openCluster(FatFile*)
00002a14 g     F .text	000000ba FatFile::seekSet(unsigned long)
000069d4 g     F .text	000000f4 MTPStorage_SD::Create(unsigned long, bool, char const*)
1fff0a50 g     O .data	0000002e usb_string_product_name_default
0000aa18  w    F .text	00000010 HardwareSerial::write(unsigned char const*, unsigned int)
00009074  w    F .text	00000006 dma_ch1_isr
000054ec g     F .text	0000006c SdioCard::sectorCount()
0000470c g     F .text	000000c4 FsVolume::begin(BlockDeviceInterface*)
00009d1c g     F .text	0000002c usb_tx_packet_count
00002c68 g     F .text	000000b8 FatFile::openNext(FatFile*, int)
0000c3b0 g     O .text	00000058 vtable for SdioCard
00009074  w    F .text	00000006 dma_ch5_isr
00006584 g     F .text	00000076 MTPStorage_SD::close()
00003a4c g     F .text	00000134 FatFile::getName(char*, unsigned int)
00009074  w    F .text	00000006 can0_rx_warn_isr
00000470  w    F .text	00000028 MTPStorage_SD::~MTPStorage_SD()
000067d0 g     F .text	000000b4 MTPStorage_SD::rename(unsigned long, char const*)
00009708 g     F .text	00000068 serial_getchar
00009074  w    F .text	00000006 can0_tx_warn_isr
0000ae70 g     F .text	000000d8 uart4_status_isr
00005ee8 g     F .text	00000074 SdioCard::readStart(unsigned long)
00000000  w      *UND*	00000000 _Jv_RegisterClasses
0000c854 g       .text	00000000 __preinit_array_start
00001464 g     F .text	000000c8 ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)
0000656c g     F .text	00000018 MTPStorage_SD::GetSize(unsigned long)
00009580 g     F .text	00000050 serial_set_cts
00006030 g     F .text	00000004 MTPStorage_SD::has_directories()
00009770 g     F .text	00000030 serial_peek
00002b38 g     F .text	00000130 FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)
0000b510  w    F .text	00000002 serialEvent3()
0000b514 g     F .text	0000000a __aeabi_atexit
00008038 g     F .text	0000001a MTPD::receive_buffer()
00000000  w      *UND*	00000000 __register_frame_info
000093fc g     F .text	00000038 serial_set_transmit_pin
00001928 g     F .text	00000126 ExFatFile::remove()
00009074  w    F .text	00000006 cmp2_isr
0000ab78 g     F .text	00000004 pendablesrvreq_isr
000082cc g     F .text	00000062 MTPD::SendObject()
0000046c  w    F .text	00000004 Print::availableForWrite()
00009074  w    F .text	00000006 wakeup_isr
00005a88 g     F .text	00000394 SdioCard::begin(SdioConfig)
000011f8 g     F .text	0000000c FsCache::invalidate()
00009074  w    F .text	00000006 cmp3_isr
000088f8 g     F .text	000001b0 breakTime(long, tmElements_t&)
0000ada0 g     F .text	0000007e Print::printNumber(unsigned long, unsigned char, unsigned char)
00003560 g     F .text	00000092 FatPartition::fatGet(unsigned long, unsigned long*)
0000b598 g     F .text	00000010 free
00009074  w    F .text	00000006 tpm2_isr
00009074  w    F .text	00000006 dma_ch0_isr
1fff0a84  w    O .data	00000016 usb_string_serial_number
00009074  w    F .text	00000006 enet_tx_isr
00001790 g     F .text	0000003a exFatHashName(char const*, unsigned int, unsigned short)
00005f5c g     F .text	000000d0 SdioCard::readSector(unsigned long, unsigned char*)
0000521c g     F .text	0000001c SdioCard::readCSD(csd_t*)



Disassembly of section .text:

00000000 <_VectorsFlash>:
  str = fsFmtField(str, 2*(time & 31) + sec100/100, '.');
  *--str = ':';
  return fsFmtTime(str, time);
}
//------------------------------------------------------------------------------
char* fsFmtTimeZone(char* str, int8_t tz) {
       0:	... ....u...-...
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      10:	-...-...-...-...
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
  }
  str = fmtBase10(str, n);
      20:	-...-...-...u...
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      str = fsFmtField(str, tz/4, ':');
      30:	u...-...y...}...
  }
}  // namespace FsDateTime
//------------------------------------------------------------------------------
static char* fsFmtField(char* str, uint16_t n, char sep) {
  if (sep) {
    *--str = sep;
      40:	u...u...u...u...
  }
  str = fmtBase10(str, n);
  if (n < 10) {
    *--str = '0';
      50:	u...u...u...u...
      tz = -tz;
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      60:	u...u...u...u...
      str = fsFmtField(str, 15*(tz%4), 0);
      str = fsFmtField(str, tz/4, ':');
      *--str = sign;
    }
    *--str = 'C';
    *--str = 'T';
      70:	u...u...u...u...
    } else {
      sign = '+';
      tz &= 0X7F;
    }
    if (tz) {
      str = fsFmtField(str, 15*(tz%4), 0);
      80:	u...u...u...u...
      90:	u...u...u...u...
      a0:	u...u...u...u...
      b0:	u...u...u.......
      c0:	u...I...u...9...
      d0:	u...u...u...u...
      e0:	u...u...u...u...
      f0:	u...u...u...u...
     100:	u...u...u...u...
     110:	u.......u...u...
     120:	u...u...u...u...
     130:	u...u...u...u...
     140:	u...u...q...u...
     150:	u...u...u...u...
     160:	u...u...u...u...
     170:	u...u...u...u...
     180:	u...u...u...u...
     190:	u...u...m...u...
     1a0:	u...u...u...u...
     1b0:	u...u...u...u...
     1c0:	u...u...u...u...

000001d0 <ResetHandler>:
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d0:	ldr	r3, [pc, #356]	; (338 <ResetHandler+0x168>)
     1d2:	movw	r2, #50464	; 0xc520
#else
// hopefully all others fit into startup section (below 0x400)
__attribute__ ((section(".startup"),optimize("-Os")))
#endif
void ResetHandler(void)
{
     1d6:	push	{r4, lr}
	volatile int n;
#endif
	//volatile int count;

#ifdef KINETISK
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ1;
     1d8:	strh	r2, [r3, #0]
	WDOG_UNLOCK = WDOG_UNLOCK_SEQ2;
     1da:	movw	r2, #55592	; 0xd928
     1de:	strh	r2, [r3, #0]
	__asm__ volatile ("nop");
     1e0:	nop
	__asm__ volatile ("nop");
     1e2:	nop
#endif
	// programs using the watchdog timer or needing to initialize hardware as
	// early as possible can implement startup_early_hook()
	startup_early_hook();
     1e4:	bl	907c <startup_early_hook>
#elif defined(__MK20DX256__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2;
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
#elif defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SIM_SCGC3 = SIM_SCGC3_ADC1 | SIM_SCGC3_FTM2 | SIM_SCGC3_FTM3;
     1e8:	ldr	r3, [pc, #336]	; (33c <ResetHandler+0x16c>)
     1ea:	mov.w	r2, #184549376	; 0xb000000
     1ee:	str	r2, [r3, #0]
	SIM_SCGC5 = 0x00043F82;		// clocks active to all GPIO
     1f0:	ldr	r2, [pc, #332]	; (340 <ResetHandler+0x170>)
     1f2:	str	r2, [r3, #8]
	SIM_SCGC6 = SIM_SCGC6_RTC | SIM_SCGC6_FTM0 | SIM_SCGC6_FTM1 | SIM_SCGC6_ADC0 | SIM_SCGC6_FTFL;
     1f4:	ldr	r2, [pc, #332]	; (344 <ResetHandler+0x174>)
     1f6:	str	r2, [r3, #12]
	SIM_SCGC4 = SIM_SCGC4_USBOTG | 0xF0000030;
	SIM_SCGC5 = 0x00003F82;		// clocks active to all GPIO
	SIM_SCGC6 = SIM_SCGC6_ADC0 | SIM_SCGC6_TPM0 | SIM_SCGC6_TPM1 | SIM_SCGC6_TPM2 | SIM_SCGC6_FTFL;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	SCB_CPACR = 0x00F00000;
     1f8:	ldr	r3, [pc, #332]	; (348 <ResetHandler+0x178>)
     1fa:	mov.w	r2, #15728640	; 0xf00000
     1fe:	str	r2, [r3, #0]
#endif
#if defined(__MK66FX1M0__)
	LMEM_PCCCR = 0x85000003;
     200:	ldr	r3, [pc, #328]	; (34c <ResetHandler+0x17c>)
     202:	ldr	r2, [pc, #332]	; (350 <ResetHandler+0x180>)
     204:	str	r2, [r3, #0]
		RTC_SR = 0;
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
	}
#endif
	// release I/O pins hold, if we woke up from VLLS mode
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;
     206:	ldr	r3, [pc, #332]	; (354 <ResetHandler+0x184>)
     208:	ldrb	r2, [r3, #0]
     20a:	lsls	r1, r2, #28
     20c:	bpl.n	216 <ResetHandler+0x46>
     20e:	ldrb	r2, [r3, #0]
     210:	orr.w	r2, r2, #8
     214:	strb	r2, [r3, #0]

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     216:	ldr	r3, [pc, #320]	; (358 <ResetHandler+0x188>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     218:	ldr	r1, [pc, #320]	; (35c <ResetHandler+0x18c>)
	if (PMC_REGSC & PMC_REGSC_ACKISO) PMC_REGSC |= PMC_REGSC_ACKISO;

    // since this is a write once register, make it visible to all F_CPU's
    // so we can into other sleep modes in the future at any speed
#if defined(__MK66FX1M0__)
	SMC_PMPROT = SMC_PMPROT_AHSRUN | SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
     21a:	movs	r2, #170	; 0xaa
     21c:	strb	r2, [r3, #0]
     21e:	ldr	r2, [pc, #320]	; (360 <ResetHandler+0x190>)
     220:	ldr	r3, [pc, #320]	; (364 <ResetHandler+0x194>)
#else
	SMC_PMPROT = SMC_PMPROT_AVLP | SMC_PMPROT_ALLS | SMC_PMPROT_AVLLS;
#endif
    
	// TODO: do this while the PLL is waiting to lock....
	while (dest < &_edata) *dest++ = *src++;
     222:	cmp	r3, r1
     224:	bcs.n	230 <ResetHandler+0x60>
     226:	ldr.w	r0, [r2, #4]!
     22a:	str.w	r0, [r3], #4
     22e:	b.n	222 <ResetHandler+0x52>
     230:	ldr	r3, [pc, #308]	; (368 <ResetHandler+0x198>)
	dest = &_sbss;
	while (dest < &_ebss) *dest++ = 0;
     232:	ldr	r1, [pc, #312]	; (36c <ResetHandler+0x19c>)
     234:	movs	r2, #0
     236:	cmp	r3, r1
     238:	bcs.n	240 <ResetHandler+0x70>
     23a:	str.w	r2, [r3], #4
     23e:	b.n	236 <ResetHandler+0x66>

	// default all interrupts to medium priority level
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = _VectorsFlash[i];
     240:	ldr	r1, [pc, #300]	; (370 <ResetHandler+0x1a0>)
     242:	ldr	r2, [pc, #304]	; (374 <ResetHandler+0x1a4>)
     244:	movs	r3, #0
     246:	ldr.w	r0, [r2, r3, lsl #2]
     24a:	str.w	r0, [r1, r3, lsl #2]
     24e:	adds	r3, #1
     250:	cmp	r3, #116	; 0x74
     252:	bne.n	246 <ResetHandler+0x76>
     254:	ldr	r3, [pc, #288]	; (378 <ResetHandler+0x1a8>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
     256:	ldr	r2, [pc, #292]	; (37c <ResetHandler+0x1ac>)
     258:	movs	r1, #128	; 0x80
     25a:	strb.w	r1, [r3], #1
     25e:	cmp	r3, r2
     260:	bne.n	25a <ResetHandler+0x8a>
	SCB_VTOR = (uint32_t)_VectorsRam;	// use vector table in RAM
     262:	ldr	r3, [pc, #284]	; (380 <ResetHandler+0x1b0>)
     264:	ldr	r2, [pc, #264]	; (370 <ResetHandler+0x1a0>)
     266:	str	r2, [r3, #0]
	//  C6[PLLS] bit is written to 0
	//  C2[LP] bit is written to 1
#else
    #if defined(KINETISK)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
     268:	ldr	r3, [pc, #280]	; (384 <ResetHandler+0x1b4>)
     26a:	movs	r2, #138	; 0x8a
     26c:	strb	r2, [r3, #0]
    #elif defined(KINETISL)
    // enable capacitors for crystal
    OSC0_CR = OSC_SC8P | OSC_SC2P | OSC_ERCLKEN;
    #endif
	// enable osc, 8-32 MHz range, low power mode
	MCG_C2 = MCG_C2_RANGE0(2) | MCG_C2_EREFS;
     26e:	sub.w	r3, r3, #4096	; 0x1000
     272:	movs	r2, #36	; 0x24
     274:	strb	r2, [r3, #1]
	// switch to crystal as clock source, FLL input = 16 MHz / 512
	MCG_C1 =  MCG_C1_CLKS(2) | MCG_C1_FRDIV(4);
     276:	movs	r2, #160	; 0xa0
     278:	strb	r2, [r3, #0]
	// wait for crystal oscillator to begin
	while ((MCG_S & MCG_S_OSCINIT0) == 0) ;
     27a:	ldrb	r2, [r3, #6]
     27c:	lsls	r2, r2, #30
     27e:	bpl.n	27a <ResetHandler+0xaa>
	// wait for FLL to use oscillator
	while ((MCG_S & MCG_S_IREFST) != 0) ;
     280:	ldrb	r2, [r3, #6]
     282:	lsls	r4, r2, #27
     284:	bmi.n	280 <ResetHandler+0xb0>
	// wait for MCGOUT to use oscillator
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(2)) ;
     286:	ldr	r2, [pc, #256]	; (388 <ResetHandler+0x1b8>)
     288:	ldrb	r3, [r2, #6]
     28a:	and.w	r3, r3, #12
     28e:	cmp	r3, #8
     290:	ldr	r3, [pc, #244]	; (388 <ResetHandler+0x1b8>)
     292:	bne.n	288 <ResetHandler+0xb8>
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(2);
    #elif F_CPU == 120000000
	MCG_C5 = MCG_C5_PRDIV0(1);
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(14);
    #elif F_CPU == 96000000 || F_CPU == 48000000 || F_CPU == 24000000
	MCG_C5 = MCG_C5_PRDIV0(1);
     294:	movs	r2, #1
     296:	strb	r2, [r3, #4]
	MCG_C6 = MCG_C6_PLLS | MCG_C6_VDIV0(8);
     298:	movs	r2, #72	; 0x48
     29a:	strb	r2, [r3, #5]
    #error "This clock speed isn't supported..."
    #endif
   #endif

	// wait for PLL to start using xtal as its input
	while (!(MCG_S & MCG_S_PLLST)) ;
     29c:	ldrb	r2, [r3, #6]
     29e:	lsls	r0, r2, #26
     2a0:	bpl.n	29c <ResetHandler+0xcc>
	// wait for PLL to lock
	while (!(MCG_S & MCG_S_LOCK0)) ;
     2a2:	ldr	r2, [pc, #228]	; (388 <ResetHandler+0x1b8>)
     2a4:	ldrb	r1, [r2, #6]
     2a6:	ldr	r3, [pc, #224]	; (388 <ResetHandler+0x1b8>)
     2a8:	lsls	r1, r1, #25
     2aa:	bpl.n	2a4 <ResetHandler+0xd4>
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(4) | SIM_CLKDIV2_USBFRAC;
#elif F_CPU == 96000000
	// config divisors: 96 MHz core, 48 MHz bus, 24 MHz flash, USB = 96 / 2
	#if F_BUS == 48000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(1) | SIM_CLKDIV1_OUTDIV4(3);
     2ac:	ldr	r2, [pc, #220]	; (38c <ResetHandler+0x1bc>)
     2ae:	ldr	r1, [pc, #224]	; (390 <ResetHandler+0x1c0>)
     2b0:	str	r1, [r2, #0]
	#elif F_BUS == 96000000
	SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0) | SIM_CLKDIV1_OUTDIV2(0) | SIM_CLKDIV1_OUTDIV4(3);
	#else
	#error "This F_CPU & F_BUS combination is not supported"
	#endif
	SIM_CLKDIV2 = SIM_CLKDIV2_USBDIV(1);
     2b2:	movs	r1, #2
     2b4:	str	r1, [r2, #4]
#error "Error, F_CPU must be 256, 240, 216, 192, 180, 168, 144, 120, 96, 72, 48, 24, 16, 8, 4, or 2 MHz"
#endif

#if F_CPU > 16000000
	// switch to PLL as clock source, FLL input = 16 MHz / 512
	MCG_C1 = MCG_C1_CLKS(0) | MCG_C1_FRDIV(4);
     2b6:	movs	r2, #32
     2b8:	strb	r2, [r3, #0]
	// wait for PLL clock to be used
	while ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) ;
     2ba:	ldrb	r2, [r3, #6]
     2bc:	and.w	r2, r2, #12
     2c0:	cmp	r2, #12
     2c2:	bne.n	2ba <ResetHandler+0xea>
	#if F_CPU == 256000000 || F_CPU == 216000000 || F_CPU == 180000000
	// USB uses IRC48
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_IRC48SEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
	#else
	// USB uses PLL clock
	SIM_SOPT2 = SIM_SOPT2_USBSRC | SIM_SOPT2_PLLFLLSEL | SIM_SOPT2_TRACECLKSEL | SIM_SOPT2_CLKOUTSEL(6);
     2c4:	ldr	r3, [pc, #204]	; (394 <ResetHandler+0x1c4>)
     2c6:	ldr	r2, [pc, #208]	; (398 <ResetHandler+0x1c8>)
     2c8:	str	r2, [r3, #0]
#endif

#if defined(__MK66FX1M0__)
	// If the RTC oscillator isn't enabled, get it started.  For Teensy 3.6
	// we don't do this early.  See comment above about slow rising power.
	if (!(RTC_CR & RTC_CR_OSCE)) {
     2ca:	ldr	r2, [pc, #208]	; (39c <ResetHandler+0x1cc>)
     2cc:	ldr	r4, [pc, #208]	; (3a0 <ResetHandler+0x1d0>)
     2ce:	ldr	r3, [r2, #0]
     2d0:	ands.w	r3, r3, #256	; 0x100
     2d4:	bne.n	2de <ResetHandler+0x10e>
		RTC_SR = 0;
     2d6:	str	r3, [r4, #0]
		RTC_CR = RTC_CR_SC16P | RTC_CR_SC4P | RTC_CR_OSCE;
     2d8:	mov.w	r3, #5376	; 0x1500
     2dc:	str	r3, [r2, #0]
	}
#endif

	// initialize the SysTick counter
	SYST_RVR = (F_CPU / 1000) - 1;
     2de:	ldr	r3, [pc, #196]	; (3a4 <ResetHandler+0x1d4>)
     2e0:	ldr	r2, [pc, #196]	; (3a8 <ResetHandler+0x1d8>)
     2e2:	str	r2, [r3, #0]
	SYST_CVR = 0;
     2e4:	movs	r2, #0
     2e6:	str	r2, [r3, #4]
	SYST_CSR = SYST_CSR_CLKSOURCE | SYST_CSR_TICKINT | SYST_CSR_ENABLE;
     2e8:	movs	r2, #7
     2ea:	str.w	r2, [r3, #-4]
	SCB_SHPR3 = 0x20200000;  // Systick = priority 32
     2ee:	ldr	r2, [pc, #188]	; (3ac <ResetHandler+0x1dc>)
     2f0:	str.w	r2, [r3, #3340]	; 0xd0c

	//init_pins();
	__enable_irq();
     2f4:	cpsie	i

	_init_Teensyduino_internal_();
     2f6:	bl	9ae8 <_init_Teensyduino_internal_>

#if defined(KINETISK)
	// RTC initialization
	if (RTC_SR & RTC_SR_TIF) {
     2fa:	ldr	r3, [r4, #0]
     2fc:	lsls	r2, r3, #31
     2fe:	bpl.n	30c <ResetHandler+0x13c>
		// compiled-in time will be stale.  Write a special
		// flag into the VBAT register file indicating the
		// RTC is set with known-stale time and should be
		// updated when fresh time is known.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     300:	ldr	r0, [pc, #172]	; (3b0 <ResetHandler+0x1e0>)
     302:	bl	99cc <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0x5A94C3A5;
     306:	ldr	r3, [pc, #172]	; (3b4 <ResetHandler+0x1e4>)
     308:	ldr	r2, [pc, #172]	; (3b8 <ResetHandler+0x1e8>)
     30a:	str	r2, [r3, #0]
	}
	if ((RCM_SRS0 & RCM_SRS0_PIN) && (*(uint32_t *)0x4003E01C == 0x5A94C3A5)) {
     30c:	ldr	r3, [pc, #172]	; (3bc <ResetHandler+0x1ec>)
     30e:	ldrb	r3, [r3, #0]
     310:	lsls	r3, r3, #25
     312:	bpl.n	328 <ResetHandler+0x158>
     314:	ldr	r4, [pc, #156]	; (3b4 <ResetHandler+0x1e4>)
     316:	ldr	r3, [pc, #160]	; (3b8 <ResetHandler+0x1e8>)
     318:	ldr	r2, [r4, #0]
     31a:	cmp	r2, r3
     31c:	bne.n	328 <ResetHandler+0x158>
		// Our compiled-in time will be very fresh, so set
		// the RTC with this, and clear the VBAT resister file
		// data so we don't mess with the time after it's been
		// set well.
		#if ARDUINO >= 10600
		rtc_set((uint32_t)&__rtc_localtime);
     31e:	ldr	r0, [pc, #144]	; (3b0 <ResetHandler+0x1e0>)
     320:	bl	99cc <rtc_set>
		#else
		rtc_set(TIME_T);
		#endif
		*(uint32_t *)0x4003E01C = 0;
     324:	movs	r3, #0
     326:	str	r3, [r4, #0]
	}
#endif

	__libc_init_array();
     328:	bl	b538 <__libc_init_array>

	startup_late_hook();
     32c:	bl	9088 <startup_late_hook>
	main();
     330:	bl	ae38 <main>
     334:	b.n	334 <ResetHandler+0x164>
     336:	nop
     338:	.word	0x4005200e
     33c:	.word	0x40048030
     340:	.word	0x00043f82
     344:	.word	0x2b000001
     348:	.word	0xe000ed88
     34c:	.word	0xe0082000
     350:	.word	0x85000003
     354:	.word	0x4007d002
     358:	.word	0x4007e000
     35c:	.word	0x1fff12dc
     360:	.word	0x0000c86c
     364:	.word	0x1fff0970
     368:	.word	0x1fff12dc
     36c:	.word	0x1fff1d84
     370:	.word	0x1fff0200
     374:	.word	0x00000000
     378:	.word	0xe000e400
     37c:	.word	0xe000e464
     380:	.word	0xe000ed08
     384:	.word	0x40065000
     388:	.word	0x40064000
     38c:	.word	0x40048044
     390:	.word	0x01030000
     394:	.word	0x40048004
     398:	.word	0x000510c0
     39c:	.word	0x4003d010
     3a0:	.word	0x4003d014
     3a4:	.word	0xe000e014
     3a8:	.word	0x000176ff
     3ac:	.word	0x20200000
     3b0:	.word	0x00000031
     3b4:	.word	0x4003e01c
     3b8:	.word	0x5a94c3a5
     3bc:	.word	0x4007f000
     3c0:	.word	0xffffffff
     3c4:	.word	0xffffffff
     3c8:	.word	0xffffffff
     3cc:	.word	0xffffffff
     3d0:	.word	0xffffffff
     3d4:	.word	0xffffffff
     3d8:	.word	0xffffffff
     3dc:	.word	0xffffffff
     3e0:	.word	0xffffffff
     3e4:	.word	0xffffffff
     3e8:	.word	0xffffffff
     3ec:	.word	0xffffffff
     3f0:	.word	0xffffffff
     3f4:	.word	0xffffffff
     3f8:	.word	0xffffffff
     3fc:	.word	0xffffffff

00000400 <flashconfigbytes>:
     400:	................

00000410 <__do_global_dtors_aux>:
     410:	push	{r4, lr}
     412:	ldr	r4, [pc, #20]	; (428 <__do_global_dtors_aux+0x18>)
     414:	ldrb	r3, [r4, #0]
     416:	cbnz	r3, 426 <__do_global_dtors_aux+0x16>
     418:	ldr	r3, [pc, #16]	; (42c <__do_global_dtors_aux+0x1c>)
     41a:	cbz	r3, 422 <__do_global_dtors_aux+0x12>
     41c:	ldr	r0, [pc, #16]	; (430 <__do_global_dtors_aux+0x20>)
     41e:	nop.w
     422:	movs	r3, #1
     424:	strb	r3, [r4, #0]
     426:	pop	{r4, pc}
     428:	.word	0x1fff12dc
     42c:	.word	0x00000000
     430:	.word	0x0000c868

00000434 <frame_dummy>:
     434:	ldr	r3, [pc, #32]	; (458 <frame_dummy+0x24>)
     436:	push	{r4, lr}
     438:	cbz	r3, 442 <frame_dummy+0xe>
     43a:	ldr	r1, [pc, #32]	; (45c <frame_dummy+0x28>)
     43c:	ldr	r0, [pc, #32]	; (460 <frame_dummy+0x2c>)
     43e:	nop.w
     442:	ldr	r0, [pc, #32]	; (464 <frame_dummy+0x30>)
     444:	ldr	r3, [r0, #0]
     446:	cbnz	r3, 44a <frame_dummy+0x16>
     448:	pop	{r4, pc}
     44a:	ldr	r3, [pc, #28]	; (468 <frame_dummy+0x34>)
     44c:	cmp	r3, #0
     44e:	beq.n	448 <frame_dummy+0x14>
     450:	ldmia.w	sp!, {r4, lr}
     454:	bx	r3
     456:	nop
     458:	.word	0x00000000
     45c:	.word	0x1fff12e0
     460:	.word	0x0000c868
     464:	.word	0x1fff12dc
     468:	.word	0x00000000

0000046c <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
     46c:	movs	r0, #0
     46e:	bx	lr

00000470 <MTPStorage_SD::~MTPStorage_SD()>:
    char name[80];
  }  Record;


// Storage implementation for SD. SD needs to be already initialized.
class MTPStorage_SD : public MTPStorageInterface {
     470:	push	{r3, r4, r5, lr}
     472:	mov	r4, r0
     474:	ldr	r3, [pc, #24]	; (490 <MTPStorage_SD::~MTPStorage_SD()+0x20>)
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
     476:	ldr	r5, [pc, #28]	; (494 <MTPStorage_SD::~MTPStorage_SD()+0x24>)
     478:	str	r3, [r0, #0]
     47a:	str	r5, [r0, #84]	; 0x54
 */
class FsBaseFile {
 public:
  FsBaseFile() : m_fFile(nullptr), m_xFile(nullptr) {}

  ~FsBaseFile() {close();}
     47c:	adds	r0, #100	; 0x64
     47e:	bl	4588 <FsBaseFile::close()>
     482:	str	r5, [r4, #4]
     484:	add.w	r0, r4, #20
     488:	bl	4588 <FsBaseFile::close()>
     48c:	mov	r0, r4
     48e:	pop	{r3, r4, r5, pc}
     490:	.word	0x0000c410
     494:	.word	0x0000c21c

00000498 <StreamFile<FsBaseFile, unsigned long long>::flush()>:
   */
  int available() {
    return BaseFile::available();
  }
  /** Ensure that any bytes written to the file are saved to the SD card. */
  void flush() {
     498:	ldr	r3, [r0, #72]	; 0x48
   *
   * \return true for success or false for failure.
   */
  bool sync() {
    return m_fFile ? m_fFile->sync() :
           m_xFile ? m_xFile->sync() : false;
     49a:	cbz	r3, 4a2 <StreamFile<FsBaseFile, unsigned long long>::flush()+0xa>
     49c:	mov	r0, r3
     49e:	b.w	31dc <FatFile::sync()>
     4a2:	ldr	r0, [r0, #76]	; 0x4c
     4a4:	cbz	r0, 4aa <StreamFile<FsBaseFile, unsigned long long>::flush()+0x12>
     4a6:	b.w	1c44 <ExFatFile::sync()>
     4aa:	bx	lr

000004ac <StreamFile<FsBaseFile, unsigned long long>::peek()>:
  }
  /** Return the next available byte without consuming it.
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
     4ac:	ldr	r3, [r0, #72]	; 0x48
   *
   * \return The byte if no error and not at eof else -1;
   */
  int peek() {
    return m_fFile ? m_fFile->peek() :
           m_xFile ? m_xFile->peek() : -1;
     4ae:	cbz	r3, 4b6 <StreamFile<FsBaseFile, unsigned long long>::peek()+0xa>
     4b0:	mov	r0, r3
     4b2:	b.w	2998 <FatFile::peek()>
     4b6:	ldr	r0, [r0, #76]	; 0x4c
     4b8:	cbz	r0, 4be <StreamFile<FsBaseFile, unsigned long long>::peek()+0x12>
     4ba:	b.w	ab0 <ExFatFile::peek()>
    return BaseFile::peek();
  }
     4be:	mov.w	r0, #4294967295
     4c2:	bx	lr

000004c4 <StreamFile<FsBaseFile, unsigned long long>::read()>:
  /** Read the next byte from a file.
   *
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
     4c4:	push	{lr}
     4c6:	ldr	r3, [r0, #72]	; 0x48
     4c8:	sub	sp, #12
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
     4ca:	cbz	r3, 4e6 <StreamFile<FsBaseFile, unsigned long long>::read()+0x22>
     4cc:	mov	r0, r3
     4ce:	movs	r2, #1
     4d0:	add.w	r1, sp, #7
     4d4:	bl	27b8 <FatFile::read(void*, unsigned int)>
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     4d8:	cmp	r0, #1
     4da:	bne.n	4f6 <StreamFile<FsBaseFile, unsigned long long>::read()+0x32>
     4dc:	ldrb.w	r0, [sp, #7]
    return BaseFile::read();
  }
     4e0:	add	sp, #12
     4e2:	ldr.w	pc, [sp], #4
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
     4e6:	ldr	r0, [r0, #76]	; 0x4c
     4e8:	cbz	r0, 4f6 <StreamFile<FsBaseFile, unsigned long long>::read()+0x32>
     4ea:	movs	r2, #1
     4ec:	add.w	r1, sp, #7
     4f0:	bl	8cc <ExFatFile::read(void*, unsigned int)>
     4f4:	b.n	4d8 <StreamFile<FsBaseFile, unsigned long long>::read()+0x14>
   * \return For success return the next byte in the file as an int.
   * If an error occurs or end of file is reached return -1.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     4f6:	mov.w	r0, #4294967295
     4fa:	b.n	4e0 <StreamFile<FsBaseFile, unsigned long long>::read()+0x1c>

000004fc <StreamFile<FsBaseFile, unsigned long long>::available()>:
  StreamFile() {}

  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
     4fc:	ldr	r2, [r0, #72]	; 0x48
  /** \return number of bytes available from the current position to EOF
   *   or INT_MAX if more than INT_MAX bytes are available.
   */
  int available() {
    return m_fFile ? m_fFile->available() :
           m_xFile ? m_xFile->available() : 0;
     4fe:	cbz	r2, 51a <StreamFile<FsBaseFile, unsigned long long>::available()+0x1e>
  void fsetpos(const fspos_t* pos);
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint32_t available32() {
    return isFile() ? fileSize() - curPosition() : 0;
     500:	ldrb	r3, [r2, #0]
     502:	and.w	r3, r3, #8
     506:	and.w	r0, r3, #255	; 0xff
     50a:	cbz	r3, 54e <StreamFile<FsBaseFile, unsigned long long>::available()+0x52>
   * Zero is returned for directory files.
   *
   */
  int available() {
    uint32_t n = available32();
    return n > INT_MAX ? INT_MAX : n;
     50c:	ldr	r3, [r2, #28]
     50e:	ldr	r0, [r2, #20]
     510:	subs	r0, r3, r0
     512:	it	mi
     514:	mvnmi.w	r0, #2147483648	; 0x80000000
     518:	bx	lr
     51a:	ldr	r1, [r0, #76]	; 0x4c
     51c:	cbz	r1, 550 <StreamFile<FsBaseFile, unsigned long long>::available()+0x54>
  }
  /** \return The number of bytes available from the current position
   * to EOF for normal files.  Zero is returned for directory files.
   */
  uint64_t available64() {
    return isFile() ? fileSize() - curPosition() : 0;
     51e:	ldrb.w	r3, [r1, #49]	; 0x31
     522:	and.w	r3, r3, #8
     526:	and.w	r0, r3, #255	; 0xff
     52a:	cbz	r3, 54e <StreamFile<FsBaseFile, unsigned long long>::available()+0x52>
     52c:	ldrd	r2, r3, [r1, #16]
     530:	ldrd	r0, r1, [r1]
     534:	subs	r0, r2, r0
     536:	push	{r4, r5}
     538:	sbc.w	r1, r3, r1
     53c:	movs	r5, #0
     53e:	mvn.w	r4, #2147483648	; 0x80000000
     542:	cmp	r5, r1
     544:	it	eq
     546:	cmpeq	r4, r0
     548:	bcs.n	54c <StreamFile<FsBaseFile, unsigned long long>::available()+0x50>
     54a:	mov	r0, r4
    return BaseFile::available();
  }
     54c:	pop	{r4, r5}
     54e:	bx	lr
     550:	mov	r0, r1
     552:	bx	lr

00000554 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)>:
  /** Write a byte to a file. Required by the Arduino Print class.
   * \param[in] b the byte to be written.
   * Use getWriteError to check for errors.
   * \return 1 for success and 0 for failure.
   */
  size_t write(uint8_t b) {
     554:	push	{lr}
     556:	ldr	r3, [r0, #72]	; 0x48
     558:	sub	sp, #12
     55a:	strb.w	r1, [sp, #7]
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
     55e:	cbz	r3, 572 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)+0x1e>
     560:	mov	r0, r3
     562:	movs	r2, #1
     564:	add.w	r1, sp, #7
     568:	bl	31e8 <FatFile::write(void const*, unsigned int)>
    return BaseFile::write(b);
  }
     56c:	add	sp, #12
     56e:	ldr.w	pc, [sp], #4
     572:	ldr	r0, [r0, #76]	; 0x4c
     574:	cmp	r0, #0
     576:	beq.n	56c <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char)+0x18>
     578:	movs	r2, #1
     57a:	add.w	r1, sp, #7
     57e:	bl	2134 <ExFatFile::write(void const*, unsigned int)>
     582:	add	sp, #12
     584:	ldr.w	pc, [sp], #4

00000588 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)>:
   * \param[in] size Number of bytes to write.
   *
   * \return For success write() returns the number of bytes written, always
   * \a size.
   */
  size_t write(const uint8_t* buffer, size_t size) {
     588:	ldr	r3, [r0, #72]	; 0x48
     58a:	cbz	r3, 592 <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)+0xa>
     58c:	mov	r0, r3
     58e:	b.w	31e8 <FatFile::write(void const*, unsigned int)>
     592:	ldr	r0, [r0, #76]	; 0x4c
     594:	cbz	r0, 59a <StreamFile<FsBaseFile, unsigned long long>::write(unsigned char const*, unsigned int)+0x12>
     596:	b.w	2134 <ExFatFile::write(void const*, unsigned int)>
    return BaseFile::write(buffer, size);
  }
     59a:	bx	lr

0000059c <logg(unsigned long, char const*) [clone .part.12]>:
  #include "MTP.h"

  MTPStorage_SD storage;
  MTPD       mtpd(&storage);

void logg(uint32_t del, const char *txt)
     59c:	push	{r4, lr}
     59e:	sub	sp, #8
     5a0:	mov	r4, r0
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     5a2:	bl	bd40 <strlen>
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     5a6:	mov	r1, r0
     5a8:	mov	r0, r4
     5aa:	bl	8e24 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     5ae:	ldr	r0, [pc, #20]	; (5c4 <logg(unsigned long, char const*) [clone .part.12]+0x28>)
     5b0:	bl	ad80 <Print::println()>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     5b4:	ldr	r2, [pc, #16]	; (5c8 <logg(unsigned long, char const*) [clone .part.12]+0x2c>)
{ static uint32_t to;
  if(millis()-to > del)
  {
    Serial.println(txt); 
    to=millis();
     5b6:	ldr	r3, [pc, #20]	; (5cc <logg(unsigned long, char const*) [clone .part.12]+0x30>)
     5b8:	ldr	r2, [r2, #0]
     5ba:	str	r2, [sp, #4]
	return ret;
     5bc:	ldr	r2, [sp, #4]
     5be:	str	r2, [r3, #0]
  }
}
     5c0:	add	sp, #8
     5c2:	pop	{r4, pc}
     5c4:	.word	0x1fff099c
     5c8:	.word	0x1fff1998
     5cc:	.word	0x1fff12f8

000005d0 <setup>:

void setup()
{ 
     5d0:	push	{r3, lr}
     5d2:	movs	r1, #8
     5d4:	ldr	r0, [pc, #20]	; (5ec <setup+0x1c>)
     5d6:	bl	8e24 <usb_serial_write>
     5da:	ldr	r0, [pc, #20]	; (5f0 <setup+0x20>)
     5dc:	bl	ad80 <Print::println()>
  //while(!Serial || millis()<4000);
  Serial.println("MTP test");
  //Serial1.begin(115200);

  storage.init();
     5e0:	ldr	r0, [pc, #16]	; (5f4 <setup+0x24>)

}
     5e2:	ldmia.w	sp!, {r3, lr}
{ 
  //while(!Serial || millis()<4000);
  Serial.println("MTP test");
  //Serial1.begin(115200);

  storage.init();
     5e6:	b.w	6da4 <MTPStorage_SD::init()>
     5ea:	nop
     5ec:	.word	0x0000c25c
     5f0:	.word	0x1fff099c
     5f4:	.word	0x1fff12fc

000005f8 <loop>:

}

void loop()
{ 
     5f8:	push	{lr}
  mtpd.loop();
     5fa:	ldr	r0, [pc, #40]	; (624 <loop+0x2c>)
  storage.init();

}

void loop()
{ 
     5fc:	sub	sp, #12
  mtpd.loop();
     5fe:	bl	8330 <MTPD::loop()>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
     602:	ldr	r3, [pc, #36]	; (628 <loop+0x30>)
  MTPStorage_SD storage;
  MTPD       mtpd(&storage);

void logg(uint32_t del, const char *txt)
{ static uint32_t to;
  if(millis()-to > del)
     604:	ldr	r2, [pc, #36]	; (62c <loop+0x34>)
     606:	ldr	r3, [r3, #0]
     608:	str	r3, [sp, #4]
	return ret;
     60a:	ldr	r3, [sp, #4]
     60c:	ldr	r2, [r2, #0]
     60e:	subs	r3, r3, r2
     610:	cmp.w	r3, #1000	; 0x3e8
     614:	bls.n	61c <loop+0x24>
     616:	ldr	r0, [pc, #24]	; (630 <loop+0x38>)
     618:	bl	59c <logg(unsigned long, char const*) [clone .part.12]>
{ 
  mtpd.loop();

  logg(1000,"loop");
  
}
     61c:	add	sp, #12
     61e:	ldr.w	pc, [sp], #4
     622:	nop
     624:	.word	0x1fff13b8
     628:	.word	0x1fff1998
     62c:	.word	0x1fff12f8
     630:	.word	0x0000c268

00000634 <_GLOBAL__sub_I_storage>:
     634:	push	{r3, r4, r5, r6, r7, lr}
     636:	ldr	r4, [pc, #92]	; (694 <_GLOBAL__sub_I_storage+0x60>)
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
     638:	ldr	r3, [pc, #92]	; (698 <_GLOBAL__sub_I_storage+0x64>)
     63a:	ldr	r0, [pc, #96]	; (69c <_GLOBAL__sub_I_storage+0x68>)
     63c:	str	r0, [r4, #0]
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
     63e:	movs	r5, #0
#include "Print.h"

class Stream : public Print
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
     640:	mov.w	r6, #1000	; 0x3e8
     644:	str	r3, [r4, #4]
     646:	str	r3, [r4, #84]	; 0x54
#include "Arduino.h"

  #include "MTP.h"

  MTPStorage_SD storage;
     648:	ldr	r2, [pc, #84]	; (6a0 <_GLOBAL__sub_I_storage+0x6c>)
     64a:	ldr	r1, [pc, #88]	; (6a4 <_GLOBAL__sub_I_storage+0x70>)
     64c:	strb	r5, [r4, #8]
     64e:	mvn.w	r7, #1
     652:	mov	r0, r4
     654:	strb	r5, [r4, #16]
 * \class FsBaseFile
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  FsBaseFile() : m_fFile(nullptr), m_xFile(nullptr) {}
     656:	str	r5, [r4, #76]	; 0x4c
     658:	str	r5, [r4, #80]	; 0x50
     65a:	strb.w	r5, [r4, #88]	; 0x58
     65e:	strb.w	r5, [r4, #96]	; 0x60
     662:	str.w	r5, [r4, #156]	; 0x9c
     666:	str.w	r5, [r4, #160]	; 0xa0
     66a:	str	r6, [r4, #12]
     66c:	str	r6, [r4, #92]	; 0x5c
     66e:	str.w	r7, [r4, #168]	; 0xa8
     672:	strh.w	r5, [r4, #164]	; 0xa4
     676:	str.w	r5, [r4, #172]	; 0xac
     67a:	strb.w	r5, [r4, #176]	; 0xb0
     67e:	strb.w	r5, [r4, #177]	; 0xb1
     682:	bl	b514 <__aeabi_atexit>

// MTP Responder.

class MTPD {
public:
  explicit MTPD(MTPStorageInterface* storage) : storage_(storage) {}
     686:	ldr	r3, [pc, #32]	; (6a8 <_GLOBAL__sub_I_storage+0x74>)
     688:	stmia.w	r3, {r4, r5}
     68c:	strb	r5, [r3, #8]
     68e:	str	r5, [r3, #12]
     690:	pop	{r3, r4, r5, r6, r7, pc}
     692:	nop
     694:	.word	0x1fff12fc
     698:	.word	0x0000c240
     69c:	.word	0x0000c410
     6a0:	.word	0x1fff0970
     6a4:	.word	0x00000471
     6a8:	.word	0x1fff13b8

000006ac <Print::write(char const*)>:
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     6ac:	push	{r4, r5, r6, lr}
     6ae:	mov	r4, r0
     6b0:	mov	r0, r1
     6b2:	mov	r5, r1
     6b4:	bl	bd40 <strlen>
     6b8:	ldr	r3, [r4, #0]
     6ba:	mov	r2, r0
     6bc:	mov	r1, r5
     6be:	mov	r0, r4
     6c0:	ldr	r3, [r3, #4]
     6c2:	ldmia.w	sp!, {r4, r5, r6, lr}
     6c6:	bx	r3

000006c8 <dbgPrint(unsigned short)>:
#if USE_DBG_MACROS
#include "Arduino.h"
#ifndef DBG_FILE
#error DBG_FILE not defined
#endif  // DBG_FILE
static void dbgPrint(uint16_t line) {
     6c8:	push	{r3, r4, r5, lr}
     6ca:	movs	r1, #10
     6cc:	mov	r5, r0
     6ce:	ldr	r0, [pc, #40]	; (6f8 <dbgPrint(unsigned short)+0x30>)
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
     6d0:	ldr	r4, [pc, #40]	; (6fc <dbgPrint(unsigned short)+0x34>)
     6d2:	bl	8e24 <usb_serial_write>
     6d6:	movs	r1, #13
     6d8:	ldr	r0, [pc, #36]	; (700 <dbgPrint(unsigned short)+0x38>)
     6da:	bl	8e24 <usb_serial_write>
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
     6de:	movs	r0, #46	; 0x2e
     6e0:	bl	8f2c <usb_serial_putchar>
     6e4:	mov	r1, r5
     6e6:	mov	r0, r4
     6e8:	bl	ae20 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
     6ec:	mov	r0, r4
  Serial.print(F("DBG_FAIL: "));
  Serial.print(F(DBG_FILE));
  Serial.write('.');
  Serial.println(line);
}
     6ee:	ldmia.w	sp!, {r3, r4, r5, lr}
     6f2:	b.w	ad80 <Print::println()>
     6f6:	nop
     6f8:	.word	0x0000c270
     6fc:	.word	0x1fff099c
     700:	.word	0x0000c27c

00000704 <ExFatFile::close()>:
#include "../common/DebugMacros.h"
#include "ExFatFile.h"
#include "ExFatVolume.h"
#include "upcase.h"
//-----------------------------------------------------------------------------
bool ExFatFile::close() {
     704:	push	{r4, lr}
     706:	mov	r4, r0
  bool rtn = sync();
     708:	bl	1c44 <ExFatFile::sync()>
  m_attributes = FILE_ATTR_CLOSED;
     70c:	movs	r3, #0
     70e:	strb.w	r3, [r4, #49]	; 0x31
  m_flags = 0;
     712:	strb.w	r3, [r4, #51]	; 0x33
  return rtn;
}
     716:	pop	{r4, pc}

00000718 <ExFatFile::getName(char*, unsigned int)>:
void ExFatFile::fsetpos(const fspos_t* pos) {
  m_curPosition = pos->position;
  m_curCluster = pos->cluster;
}
//-----------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t *name, size_t length) {
     718:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
     71c:	add.w	r3, r0, #36	; 0x24
void ExFatFile::fsetpos(const fspos_t* pos) {
  m_curPosition = pos->position;
  m_curCluster = pos->cluster;
}
//-----------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t *name, size_t length) {
     720:	mov	r9, r0
     722:	mov	r8, r1
     724:	mov	r5, r2
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
     726:	ldmia.w	r3, {r0, r1, r2}
void ExFatFile::fsetpos(const fspos_t* pos) {
  m_curPosition = pos->position;
  m_curCluster = pos->cluster;
}
//-----------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t *name, size_t length) {
     72a:	sub	sp, #20
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
  size_t n = 0;
  if (!isOpen()) {
     72c:	ldrb.w	r3, [r9, #49]	; 0x31
  m_curCluster = pos->cluster;
}
//-----------------------------------------------------------------------------
size_t ExFatFile::getName(ExChar_t *name, size_t length) {
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
     730:	add	r6, sp, #4
     732:	stmia.w	r6, {r0, r1, r2}
  size_t n = 0;
  if (!isOpen()) {
     736:	cmp	r3, #0
     738:	beq.n	7b0 <ExFatFile::getName(char*, unsigned int)+0x98>
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
     73a:	ldrb.w	r3, [r9, #48]	; 0x30
     73e:	cmp	r3, #1
     740:	bls.n	7d2 <ExFatFile::getName(char*, unsigned int)+0xba>
     742:	movs	r7, #1
     744:	movs	r4, #0
    if (m_vol->dirSeek(&pos, is == 1 ? 64: 32) != 1) {
     746:	cmp	r7, #1
     748:	ite	eq
     74a:	moveq	r2, #64	; 0x40
     74c:	movne	r2, #32
     74e:	mov	r1, r6
     750:	ldr.w	r0, [r9, #32]
     754:	bl	15ac <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
     758:	cmp	r0, #1
     75a:	bne.n	7ca <ExFatFile::getName(char*, unsigned int)+0xb2>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dn = reinterpret_cast<DirName_t*>
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
     75c:	movs	r2, #0
     75e:	mov	r1, r6
     760:	ldr.w	r0, [r9, #32]
     764:	bl	152c <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
     768:	cbz	r0, 7c2 <ExFatFile::getName(char*, unsigned int)+0xaa>
     76a:	ldrb	r3, [r0, #0]
     76c:	cmp	r3, #193	; 0xc1
     76e:	bne.n	7c2 <ExFatFile::getName(char*, unsigned int)+0xaa>
     770:	add.w	r1, r0, #30
     774:	add.w	r2, r8, r4
     778:	mov	r3, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
      if ((n + 1) >= length) {
     77a:	adds	r4, #1
     77c:	cmp	r4, r5
     77e:	bcs.n	7a2 <ExFatFile::getName(char*, unsigned int)+0x8a>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
     780:	ldrh.w	r3, [r0, #2]!
        goto done;
      }
      uint16_t c = getLe16(dn->unicode + 2*in);
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
     784:	cmp	r3, #126	; 0x7e
     786:	ite	ls
     788:	uxtbls	r3, r3
     78a:	movhi	r3, #63	; 0x3f
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
     78c:	cmp	r0, r1
      if ((n + 1) >= length) {
        goto done;
      }
      uint16_t c = getLe16(dn->unicode + 2*in);
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
     78e:	strb.w	r3, [r2], #1
     792:	mov	r3, r4
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (uint8_t in = 0; in < 15; in++) {
     794:	bne.n	77a <ExFatFile::getName(char*, unsigned int)+0x62>
  size_t n = 0;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
     796:	adds	r7, #1
     798:	ldrb.w	r2, [r9, #48]	; 0x30
     79c:	uxtb	r7, r7
     79e:	cmp	r2, r7
     7a0:	bhi.n	746 <ExFatFile::getName(char*, unsigned int)+0x2e>
      uint16_t c = getLe16(dn->unicode + 2*in);
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    }
  }
 done:
  name[n] = 0;
     7a2:	movs	r2, #0
  return n;
     7a4:	mov	r0, r3
      uint16_t c = getLe16(dn->unicode + 2*in);
      name[n++] = sizeof(ExChar_t) > 1 || c < 0X7F ? c : '?';
    }
  }
 done:
  name[n] = 0;
     7a6:	strb.w	r2, [r8, r3]
  return n;

 fail:
  *name = 0;
  return 0;
}
     7aa:	add	sp, #20
     7ac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
size_t ExFatFile::getName(ExChar_t *name, size_t length) {
  DirName_t* dn;
  DirPos_t pos = m_dirPos;
  size_t n = 0;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
     7b0:	movs	r0, #81	; 0x51
     7b2:	bl	6c8 <dbgPrint(unsigned short)>
 done:
  name[n] = 0;
  return n;

 fail:
  *name = 0;
     7b6:	movs	r0, #0
     7b8:	strb.w	r0, [r8]
  return 0;
}
     7bc:	add	sp, #20
     7be:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      goto fail;
    }
    dn = reinterpret_cast<DirName_t*>
         (m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ));
    if (!dn || dn->type != EXFAT_TYPE_NAME) {
      DBG_FAIL_MACRO;
     7c2:	movs	r0, #92	; 0x5c
     7c4:	bl	6c8 <dbgPrint(unsigned short)>
      goto fail;
     7c8:	b.n	7b6 <ExFatFile::getName(char*, unsigned int)+0x9e>
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
    if (m_vol->dirSeek(&pos, is == 1 ? 64: 32) != 1) {
      DBG_FAIL_MACRO;
     7ca:	movs	r0, #86	; 0x56
     7cc:	bl	6c8 <dbgPrint(unsigned short)>
      goto fail;
     7d0:	b.n	7b6 <ExFatFile::getName(char*, unsigned int)+0x9e>
  size_t n = 0;
  if (!isOpen()) {
      DBG_FAIL_MACRO;
      goto fail;
  }
  for (uint8_t is = 1; is < m_setCount; is++) {
     7d2:	movs	r3, #0
     7d4:	b.n	7a2 <ExFatFile::getName(char*, unsigned int)+0x8a>
     7d6:	nop

000007d8 <ExFatFile::openRoot(ExFatVolume*)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//-----------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
     7d8:	push	{r3, r4, r5, lr}
     7da:	mov	r5, r1
  if (isOpen()) {
     7dc:	ldrb.w	r1, [r0, #49]	; 0x31
     7e0:	cbnz	r1, 7fa <ExFatFile::openRoot(ExFatVolume*)+0x22>
     7e2:	mov	r4, r0
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
     7e4:	movs	r2, #56	; 0x38
     7e6:	bl	bb7c <memset>
  m_attributes = FILE_ATTR_ROOT;
     7ea:	movs	r3, #64	; 0x40
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
     7ec:	movs	r0, #1
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
     7ee:	strb.w	r3, [r4, #49]	; 0x31
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
     7f2:	strb.w	r0, [r4, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(ExFatFile));
  m_attributes = FILE_ATTR_ROOT;
  m_vol = vol;
     7f6:	str	r5, [r4, #32]
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
}
     7f8:	pop	{r3, r4, r5, pc}
  return false;
}
//-----------------------------------------------------------------------------
bool ExFatFile::openRoot(ExFatVolume* vol) {
  if (isOpen()) {
    DBG_FAIL_MACRO;
     7fa:	mov.w	r0, #444	; 0x1bc
     7fe:	bl	6c8 <dbgPrint(unsigned short)>
  m_vol = vol;
  m_flags = FILE_FLAG_READ;
  return true;

 fail:
  return false;
     802:	movs	r0, #0
     804:	pop	{r3, r4, r5, pc}
     806:	nop

00000808 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>:
}
//------------------------------------------------------------------------------
bool ExFatFile::parsePathName(const ExChar_t* path,
                            ExName_t* fname, const ExChar_t** ptr) {
     808:	push	{r4, r5, r6, r7, lr}
  ExChar_t c;
  int end;
  int len = 0;

  // Skip leading spaces.
  while (*path == ' ') {
     80a:	ldrb	r0, [r1, #0]
     80c:	cmp	r0, #32
     80e:	bne.n	818 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x10>
     810:	ldrb.w	r0, [r1, #1]!
     814:	cmp	r0, #32
     816:	beq.n	810 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x8>
    path++;
  }
  fname->lfn = path;
     818:	str	r1, [r2, #4]

  for (len = 0; ; len++) {
    c = path[len];
     81a:	ldrb	r0, [r1, #0]
    if (c == 0 || isDirSeparator(c)) {
     81c:	cmp	r0, #0
     81e:	beq.n	8c4 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xbc>
     820:	cmp	r0, #47	; 0x2f
     822:	beq.n	87c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x74>
 * \param[in] c character to be tested.
 *
 * \return true for legal character else false.
 */
inline bool lfnLegalChar(ExChar_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
     824:	cmp	r0, #92	; 0x5c
     826:	beq.n	86a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
     828:	sub.w	r4, r0, #34	; 0x22
     82c:	uxtb	r4, r4
     82e:	cmp	r4, #29
     830:	bls.n	86e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x66>
     832:	ldr.w	lr, [pc, #148]	; 8c8 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xc0>
     836:	adds	r6, r1, #1
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
     838:	movs	r4, #0
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
     83a:	cmp	r0, #124	; 0x7c
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
     83c:	sub.w	r5, r0, #32
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
     840:	mov	r7, r6
     842:	beq.n	86a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
     844:	cmp	r5, #94	; 0x5e
     846:	bhi.n	86a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
     848:	ldrb.w	r0, [r6], #1
 * \param[in] c character to be tested.
 *
 * \return true for legal character else false.
 */
inline bool lfnLegalChar(ExChar_t c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
     84c:	sub.w	r5, r0, #34	; 0x22
     850:	uxtb	r5, r5
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
     852:	adds	r4, #1
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
     854:	cbz	r0, 8b6 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xae>
     856:	cmp	r0, #47	; 0x2f
     858:	beq.n	87e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x76>
     85a:	cmp	r0, #92	; 0x5c
     85c:	lsr.w	r7, lr, r5
     860:	beq.n	86a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x62>
     862:	cmp	r5, #29
     864:	bhi.n	83a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x32>
     866:	lsls	r5, r7, #31
     868:	bpl.n	83a <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x32>
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
     86a:	movs	r0, #0
     86c:	pop	{r4, r5, r6, r7, pc}
     86e:	ldr	r5, [pc, #88]	; (8c8 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xc0>)
     870:	lsr.w	r4, r5, r4
     874:	lsls	r6, r4, #31
     876:	bpl.n	832 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x2a>
     878:	movs	r0, #0
     87a:	pop	{r4, r5, r6, r7, pc}
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
     87c:	movs	r4, #0
     87e:	adds	r7, r1, r4
     880:	mov	r6, r7
     882:	mov	r5, r4
     884:	movs	r0, #47	; 0x2f
     886:	b.n	88e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x86>
     888:	ldrb.w	r0, [r6, #1]!
    if (!lfnLegalChar(c)) {
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
     88c:	adds	r5, #1
     88e:	cmp	r0, #32
     890:	beq.n	888 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x80>
     892:	cmp	r0, #47	; 0x2f
     894:	beq.n	888 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x80>
  *ptr = &path[end];
     896:	add	r1, r5
     898:	str	r1, [r3, #0]

  // Back over spaces and dots.
  while (len) {
     89a:	cbz	r4, 8ae <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa6>
     89c:	mov	r1, r7
    c = path[len - 1];
     89e:	ldrb.w	r3, [r1, #-1]!
    if (c != '.' && c != ' ') {
     8a2:	cmp	r3, #46	; 0x2e
     8a4:	beq.n	8aa <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa2>
     8a6:	cmp	r3, #32
     8a8:	bne.n	8bc <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xb4>
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
     8aa:	subs	r4, #1
     8ac:	bne.n	89e <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x96>
     8ae:	mov	r0, r4
  }
  // Max length of LFN is 255.
  if (len > EXFAT_MAX_NAME_LENGTH) {
    return false;
  }
  fname->len = len;
     8b0:	str	r0, [r2, #0]
  return true;
     8b2:	movs	r0, #1
     8b4:	pop	{r4, r5, r6, r7, pc}
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
     8b6:	str	r7, [r3, #0]
     8b8:	adds	r7, r1, r4
     8ba:	b.n	89c <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0x94>
      break;
    }
    len--;
  }
  // Max length of LFN is 255.
  if (len > EXFAT_MAX_NAME_LENGTH) {
     8bc:	cmp	r4, #255	; 0xff
     8be:	ble.n	8ae <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa6>
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
     8c0:	movs	r0, #0
     8c2:	pop	{r4, r5, r6, r7, pc}
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
     8c4:	str	r1, [r3, #0]
     8c6:	b.n	8b0 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)+0xa8>
     8c8:	.word	0x35000101

000008cc <ExFatFile::read(void*, unsigned int)>:

 fail:
  return 0;
}
//-----------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
     8cc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     8d0:	ldrb.w	r3, [r0, #51]	; 0x33
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
     8d4:	lsls	r5, r3, #31

 fail:
  return 0;
}
//-----------------------------------------------------------------------------
int ExFatFile::read(void* buf, size_t count) {
     8d6:	sub	sp, #12
     8d8:	mov	r4, r0
  uint8_t* cache;
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
     8da:	bpl.w	aa6 <ExFatFile::read(void*, unsigned int)+0x1da>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
     8de:	lsls	r0, r3, #25
     8e0:	mov	r5, r1
     8e2:	mov	r6, r2
     8e4:	bpl.w	a2e <ExFatFile::read(void*, unsigned int)+0x162>
    if ((m_curPosition + count) > m_validLength) {
     8e8:	ldrd	r0, r1, [r4]
     8ec:	ldrd	r2, r3, [r4, #16]
     8f0:	adds.w	r8, r0, r6
     8f4:	adc.w	r9, r1, #0
     8f8:	cmp	r3, r9
     8fa:	it	eq
     8fc:	cmpeq	r2, r8
     8fe:	bcc.w	a3a <ExFatFile::read(void*, unsigned int)+0x16e>
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
     902:	cmp	r6, #0
     904:	beq.w	a3e <ExFatFile::read(void*, unsigned int)+0x172>
     908:	mov	r9, r4
     90a:	ldrd	r2, r3, [r9], #24
     90e:	mov	r8, r6
     910:	b.n	9b2 <ExFatFile::read(void*, unsigned int)+0xe6>
    clusterOffset = m_curPosition & m_vol->clusterMask();
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      if (m_curPosition == 0) {
     912:	orrs	r3, r2
     914:	bne.n	9f0 <ExFatFile::read(void*, unsigned int)+0x124>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
     916:	ldrb.w	r3, [r4, #49]	; 0x31
     91a:	lsls	r2, r3, #25
     91c:	ite	mi
     91e:	ldrmi.w	r1, [r0, #1068]	; 0x42c
     922:	ldrpl	r1, [r4, #28]
      } else if (isContiguous()) {
        m_curCluster++;
     924:	str	r1, [r4, #24]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
     926:	ldrb.w	ip, [r0, #1085]	; 0x43d
          goto fail;
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
     92a:	ldr.w	r2, [r0, #1060]	; 0x424
     92e:	subs	r1, #2
     930:	lsrs	r7, r7, #9
     932:	lsl.w	lr, r1, ip
     936:	adds	r1, r7, r2
     938:	add	r1, lr
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
     93a:	cmp.w	sl, #0
     93e:	bne.n	9c6 <ExFatFile::read(void*, unsigned int)+0xfa>
        }
      }
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
     940:	cmp.w	r8, #512	; 0x200
     944:	bcc.n	9c6 <ExFatFile::read(void*, unsigned int)+0xfa>
     946:	ldr.w	r2, [r0, #532]	; 0x214
                          || sector == m_vol->dataCacheSector()) {
     94a:	cmp	r1, r2
     94c:	beq.n	9c6 <ExFatFile::read(void*, unsigned int)+0xfa>
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
     94e:	cmp.w	r8, #1024	; 0x400
     952:	bcc.n	9fe <ExFatFile::read(void*, unsigned int)+0x132>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      // Limit writes to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
     954:	movs	r3, #1
     956:	lsl.w	ip, r3, ip
     95a:	rsb	r7, r7, ip
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
     95e:	mov.w	r3, r8, lsr #9
     962:	cmp	r7, r3
     964:	it	cs
     966:	movcs	r7, r3
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
      // Check for cache sector in read range.
      if (sector <= m_vol->dataCacheSector()
          && m_vol->dataCacheSector() < (sector + ns)) {
     968:	cmp	r1, r2
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
     96a:	mov.w	fp, r7, lsl #9
      // Check for cache sector in read range.
      if (sector <= m_vol->dataCacheSector()
          && m_vol->dataCacheSector() < (sector + ns)) {
     96e:	bhi.n	988 <ExFatFile::read(void*, unsigned int)+0xbc>
     970:	adds	r3, r7, r1
     972:	cmp	r3, r2
     974:	bls.n	988 <ExFatFile::read(void*, unsigned int)+0xbc>
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
  }
  uint32_t dataCacheSector() {return m_dataCache.sector();}
  bool dataCacheSync() {return m_dataCache.sync();}
     976:	add.w	r0, r0, #524	; 0x20c
     97a:	str	r1, [sp, #4]
     97c:	bl	1290 <FsCache::sync()>
        // Flush cache if a cache sector is in the range.
        if (!m_vol->dataCacheSync()) {
     980:	cmp	r0, #0
     982:	beq.n	a74 <ExFatFile::read(void*, unsigned int)+0x1a8>
     984:	ldr	r0, [r4, #32]
     986:	ldr	r1, [sp, #4]
     988:	ldr.w	r0, [r0, #1080]	; 0x438
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
  }
#if USE_MULTI_SECTOR_IO
  bool readSectors(uint32_t sector, uint8_t* dst, size_t count) {
    return m_blockDev->readSectors(sector, dst, count);
     98c:	ldr	r2, [r0, #0]
     98e:	mov	r3, r7
     990:	ldr	r7, [r2, #12]
     992:	mov	r2, r5
     994:	blx	r7
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
      if (!m_vol->readSectors(sector, dst, ns)) {
     996:	cmp	r0, #0
     998:	beq.n	a6a <ExFatFile::read(void*, unsigned int)+0x19e>
     99a:	mov	r0, fp
     99c:	movs	r1, #0
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
     99e:	ldrd	r2, r3, [r4]
     9a2:	adds	r2, r2, r0
     9a4:	adcs	r3, r1
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
     9a6:	subs.w	r8, r8, fp
      if (!m_vol->readSector(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
     9aa:	add	r5, fp
    m_curPosition += n;
     9ac:	strd	r2, r3, [r4]
  if (isContiguous() || isFile()) {
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
    }
  }
  while (toRead) {
     9b0:	beq.n	a3e <ExFatFile::read(void*, unsigned int)+0x172>
    clusterOffset = m_curPosition & m_vol->clusterMask();
     9b2:	ldr	r0, [r4, #32]
     9b4:	ldr.w	r7, [r0, #1072]	; 0x430
     9b8:	ands	r7, r2
    sectorOffset = clusterOffset & m_vol->sectorMask();
     9ba:	ubfx	sl, r7, #0, #9
    if (clusterOffset == 0) {
     9be:	cmp	r7, #0
     9c0:	beq.n	912 <ExFatFile::read(void*, unsigned int)+0x46>
     9c2:	ldr	r1, [r4, #24]
     9c4:	b.n	926 <ExFatFile::read(void*, unsigned int)+0x5a>
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
     9c6:	add.w	r0, r0, #524	; 0x20c
     9ca:	movs	r2, #0
     9cc:	bl	1204 <FsCache::get(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      cache = m_vol->dataCacheGet(sector, FsCache::CACHE_FOR_READ);
      if (!cache) {
     9d0:	cmp	r0, #0
     9d2:	beq.n	a4c <ExFatFile::read(void*, unsigned int)+0x180>
    }
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    if (sectorOffset != 0 || toRead < m_vol->bytesPerSector()
                          || sector == m_vol->dataCacheSector()) {
      n = m_vol->bytesPerSector() - sectorOffset;
     9d4:	rsb	fp, sl, #512	; 0x200
     9d8:	cmp	fp, r8
     9da:	it	cs
     9dc:	movcs	fp, r8
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = cache + sectorOffset;
      memcpy(dst, src, n);
     9de:	add.w	r1, r0, sl
     9e2:	mov	r2, fp
     9e4:	mov	r0, r5
     9e6:	bl	8c24 <memcpy>
     9ea:	mov	r0, fp
     9ec:	movs	r1, #0
     9ee:	b.n	99e <ExFatFile::read(void*, unsigned int)+0xd2>
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      if (m_curPosition == 0) {
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
     9f0:	ldrb.w	r3, [r4, #51]	; 0x33
     9f4:	lsls	r3, r3, #25
     9f6:	bpl.n	a18 <ExFatFile::read(void*, unsigned int)+0x14c>
        m_curCluster++;
     9f8:	ldr	r1, [r4, #24]
     9fa:	adds	r1, #1
     9fc:	b.n	924 <ExFatFile::read(void*, unsigned int)+0x58>
     9fe:	ldr.w	r0, [r0, #1080]	; 0x438
  uint16_t sectorMask() {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
     a02:	ldr	r3, [r0, #0]
     a04:	mov	r2, r5
     a06:	ldr	r3, [r3, #8]
     a08:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->readSector(sector, dst)) {
     a0a:	cbz	r0, a7e <ExFatFile::read(void*, unsigned int)+0x1b2>
     a0c:	mov.w	r0, #512	; 0x200
     a10:	movs	r1, #0
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
     a12:	mov.w	fp, #512	; 0x200
     a16:	b.n	99e <ExFatFile::read(void*, unsigned int)+0xd2>
        m_curCluster = isRoot()
                       ? m_vol->rootDirectoryCluster() : m_firstCluster;
      } else if (isContiguous()) {
        m_curCluster++;
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
     a18:	mov	r2, r9
     a1a:	ldr	r1, [r4, #24]
     a1c:	bl	1560 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
     a20:	sxtb	r0, r0
        if (fg < 0) {
     a22:	cmp	r0, #0
     a24:	blt.n	a88 <ExFatFile::read(void*, unsigned int)+0x1bc>
          DBG_FAIL_MACRO;
          goto fail;
        }
        if (fg == 0) {
     a26:	beq.n	a92 <ExFatFile::read(void*, unsigned int)+0x1c6>
     a28:	ldr	r0, [r4, #32]
     a2a:	ldr	r1, [r4, #24]
     a2c:	b.n	926 <ExFatFile::read(void*, unsigned int)+0x5a>

  if (!isReadable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isContiguous() || isFile()) {
     a2e:	ldrb.w	r3, [r4, #49]	; 0x31
     a32:	lsls	r1, r3, #28
     a34:	bmi.w	8e8 <ExFatFile::read(void*, unsigned int)+0x1c>
     a38:	b.n	902 <ExFatFile::read(void*, unsigned int)+0x36>
    if ((m_curPosition + count) > m_validLength) {
      count = toRead = m_validLength - m_curPosition;
     a3a:	subs	r6, r2, r0
     a3c:	b.n	902 <ExFatFile::read(void*, unsigned int)+0x36>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
     a3e:	mov.w	r8, #0
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return count - toRead;
     a42:	rsb	r0, r8, r6

fail:
  m_error |= READ_ERROR;
  return -1;
}
     a46:	add	sp, #12
     a48:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        n = toRead;
      }
      // read sector to cache and copy data to caller
      cache = m_vol->dataCacheGet(sector, FsCache::CACHE_FOR_READ);
      if (!cache) {
        DBG_FAIL_MACRO;
     a4c:	movw	r0, #597	; 0x255
     a50:	bl	6c8 <dbgPrint(unsigned short)>
    toRead -= n;
  }
  return count - toRead;

fail:
  m_error |= READ_ERROR;
     a54:	ldrb.w	r3, [r4, #50]	; 0x32
  return -1;
     a58:	mov.w	r0, #4294967295
    toRead -= n;
  }
  return count - toRead;

fail:
  m_error |= READ_ERROR;
     a5c:	orr.w	r3, r3, #2
     a60:	strb.w	r3, [r4, #50]	; 0x32
  return -1;
}
     a64:	add	sp, #12
     a66:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
      if (!m_vol->readSectors(sector, dst, ns)) {
        DBG_FAIL_MACRO;
     a6a:	movw	r0, #622	; 0x26e
     a6e:	bl	6c8 <dbgPrint(unsigned short)>
        goto fail;
     a72:	b.n	a54 <ExFatFile::read(void*, unsigned int)+0x188>
      // Check for cache sector in read range.
      if (sector <= m_vol->dataCacheSector()
          && m_vol->dataCacheSector() < (sector + ns)) {
        // Flush cache if a cache sector is in the range.
        if (!m_vol->dataCacheSync()) {
          DBG_FAIL_MACRO;
     a74:	movw	r0, #617	; 0x269
     a78:	bl	6c8 <dbgPrint(unsigned short)>
          goto fail;
     a7c:	b.n	a54 <ExFatFile::read(void*, unsigned int)+0x188>
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->readSector(sector, dst)) {
        DBG_FAIL_MACRO;
     a7e:	movw	r0, #630	; 0x276
     a82:	bl	6c8 <dbgPrint(unsigned short)>
        goto fail;
     a86:	b.n	a54 <ExFatFile::read(void*, unsigned int)+0x188>
      } else if (isContiguous()) {
        m_curCluster++;
      } else {
        fg = m_vol->fatGet(m_curCluster, &m_curCluster);
        if (fg < 0) {
          DBG_FAIL_MACRO;
     a88:	movw	r0, #573	; 0x23d
     a8c:	bl	6c8 <dbgPrint(unsigned short)>
          goto fail;
     a90:	b.n	a54 <ExFatFile::read(void*, unsigned int)+0x188>
        }
        if (fg == 0) {
          // EOF if directory.
          if (isDir()) {
     a92:	ldrb.w	r3, [r4, #49]	; 0x31
     a96:	tst.w	r3, #80	; 0x50
     a9a:	bne.n	a42 <ExFatFile::read(void*, unsigned int)+0x176>
            break;
          }
          DBG_FAIL_MACRO;
     a9c:	movw	r0, #581	; 0x245
     aa0:	bl	6c8 <dbgPrint(unsigned short)>
          goto fail;
     aa4:	b.n	a54 <ExFatFile::read(void*, unsigned int)+0x188>
  uint16_t sectorOffset;
  uint32_t sector;
  uint32_t clusterOffset;

  if (!isReadable()) {
    DBG_FAIL_MACRO;
     aa6:	movw	r0, #553	; 0x229
     aaa:	bl	6c8 <dbgPrint(unsigned short)>
    goto fail;
     aae:	b.n	a54 <ExFatFile::read(void*, unsigned int)+0x188>

00000ab0 <ExFatFile::peek()>:
  }
  fname->len = len;
  return true;
}
//-----------------------------------------------------------------------------
int ExFatFile::peek() {
     ab0:	push	{r4, r5, r6, r7, lr}
     ab2:	sub	sp, #12
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
     ab4:	movs	r2, #1
     ab6:	add.w	r1, sp, #7
     aba:	mov	r4, r0
  uint64_t curPosition = m_curPosition;
     abc:	ldrd	r6, r7, [r0]
  uint32_t curCluster = m_curCluster;
     ac0:	ldr	r5, [r0, #24]
     ac2:	bl	8cc <ExFatFile::read(void*, unsigned int)>
     ac6:	cmp	r0, #1
     ac8:	it	eq
     aca:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
  m_curCluster = curCluster;
     ace:	str	r5, [r4, #24]
     ad0:	it	ne
     ad2:	movne.w	r0, #4294967295
//-----------------------------------------------------------------------------
int ExFatFile::peek() {
  uint64_t curPosition = m_curPosition;
  uint32_t curCluster = m_curCluster;
  int c = read();
  m_curPosition = curPosition;
     ad6:	strd	r6, r7, [r4]
  m_curCluster = curCluster;
  return c;
}
     ada:	add	sp, #12
     adc:	pop	{r4, r5, r6, r7, pc}
     ade:	nop

00000ae0 <ExFatFile::seekSet(unsigned long long)>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
     ae0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     ae4:	ldrb.w	ip, [r0, #49]	; 0x31
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
     ae8:	ldr	r5, [r0, #24]

fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
     aea:	sub	sp, #12
     aec:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
     aee:	cmp.w	ip, #0
     af2:	beq.n	bca <ExFatFile::seekSet(unsigned long long)+0xea>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
     af4:	ldrd	r0, r1, [r0]
     af8:	cmp	r1, r3
     afa:	it	eq
     afc:	cmpeq	r0, r2
     afe:	mov	r6, r2
     b00:	mov	r7, r3
     b02:	beq.n	be4 <ExFatFile::seekSet(unsigned long long)+0x104>
    return true;
  }
  if (pos == 0) {
     b04:	orrs.w	r3, r6, r7
     b08:	bne.n	b1a <ExFatFile::seekSet(unsigned long long)+0x3a>
    // set position to start of file
    m_curCluster = 0;
     b0a:	movs	r3, #0
     b0c:	str	r3, [r4, #24]
    }
  }

done:
  m_curPosition = pos;
  return true;
     b0e:	movs	r0, #1
      goto fail;
    }
  }

done:
  m_curPosition = pos;
     b10:	strd	r6, r7, [r4]
  return true;

fail:
  m_curCluster = tmp;
  return false;
}
     b14:	add	sp, #12
     b16:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
     b1a:	tst.w	ip, #8
     b1e:	beq.n	b2c <ExFatFile::seekSet(unsigned long long)+0x4c>
    if (pos > m_validLength) {
     b20:	ldrd	r2, r3, [r4, #16]
     b24:	cmp	r3, r7
     b26:	it	eq
     b28:	cmpeq	r2, r6
     b2a:	bcc.n	bec <ExFatFile::seekSet(unsigned long long)+0x10c>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
     b2c:	ldr	r3, [r4, #32]
     b2e:	str	r3, [sp, #4]
     b30:	ldrb.w	lr, [r3, #1085]	; 0x43d
  if (isContiguous()) {
     b34:	ldrb.w	sl, [r4, #51]	; 0x33
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
     b38:	add.w	lr, lr, #9
     b3c:	uxtb.w	lr, lr
     b40:	adds.w	r2, r6, #4294967295
     b44:	adc.w	r3, r7, #4294967295
     b48:	rsb	r8, lr, #32
     b4c:	lsl.w	fp, r3, r8
     b50:	lsr.w	r2, r2, lr
     b54:	orr.w	r2, r2, fp
     b58:	sub.w	fp, lr, #32
     b5c:	lsr.w	r3, r3, fp
  if (isContiguous()) {
     b60:	tst.w	sl, #64	; 0x40
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
     b64:	orr.w	r2, r2, r3
  if (isContiguous()) {
     b68:	bne.n	bdc <ExFatFile::seekSet(unsigned long long)+0xfc>
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
     b6a:	adds.w	r9, r0, #4294967295
     b6e:	adc.w	sl, r1, #4294967295
     b72:	lsr.w	lr, r9, lr
     b76:	lsl.w	r8, sl, r8
     b7a:	orr.w	lr, lr, r8
     b7e:	lsr.w	fp, sl, fp
     b82:	orr.w	lr, lr, fp
  if (nNew < nCur || m_curPosition == 0) {
     b86:	cmp	r2, lr
  if (isContiguous()) {
    m_curCluster = m_firstCluster + nNew;
    goto done;
  }
  // calculate cluster index for current position
  nCur = (m_curPosition - 1) >> m_vol->bytesPerClusterShift();
     b88:	mov	r3, sl
  if (nNew < nCur || m_curPosition == 0) {
     b8a:	bcc.n	b92 <ExFatFile::seekSet(unsigned long long)+0xb2>
     b8c:	orrs.w	r3, r0, r1
     b90:	bne.n	bf6 <ExFatFile::seekSet(unsigned long long)+0x116>
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
     b92:	tst.w	ip, #64	; 0x40
     b96:	itet	ne
     b98:	ldrne	r3, [sp, #4]
     b9a:	ldreq	r3, [r4, #28]
     b9c:	ldrne.w	r3, [r3, #1068]	; 0x42c
     ba0:	str	r3, [r4, #24]

fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::seekSet(uint64_t pos) {
     ba2:	mov	r8, r2
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
     ba4:	add.w	r9, r4, #24
     ba8:	mov	r2, r9
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
     baa:	cmp.w	r8, #0
     bae:	beq.n	b0e <ExFatFile::seekSet(unsigned long long)+0x2e>
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
     bb0:	ldr	r1, [r4, #24]
     bb2:	ldr	r0, [r4, #32]
     bb4:	bl	1560 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
     bb8:	add.w	r8, r8, #4294967295
     bbc:	cmp	r0, #0
     bbe:	bne.n	ba8 <ExFatFile::seekSet(unsigned long long)+0xc8>
      DBG_FAIL_MACRO;
     bc0:	movw	r0, #698	; 0x2ba
     bc4:	bl	6c8 <dbgPrint(unsigned short)>
      goto fail;
     bc8:	b.n	bd2 <ExFatFile::seekSet(unsigned long long)+0xf2>
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    DBG_FAIL_MACRO;
     bca:	movw	r0, #663	; 0x297
     bce:	bl	6c8 <dbgPrint(unsigned short)>
  m_curPosition = pos;
  return true;

fail:
  m_curCluster = tmp;
  return false;
     bd2:	movs	r0, #0
done:
  m_curPosition = pos;
  return true;

fail:
  m_curCluster = tmp;
     bd4:	str	r5, [r4, #24]
  return false;
}
     bd6:	add	sp, #12
     bd8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }
  }
  // calculate cluster index for new position
  nNew = (pos - 1) >> m_vol->bytesPerClusterShift();
  if (isContiguous()) {
    m_curCluster = m_firstCluster + nNew;
     bdc:	ldr	r3, [r4, #28]
     bde:	add	r2, r3
     be0:	str	r2, [r4, #24]
    goto done;
     be2:	b.n	b0e <ExFatFile::seekSet(unsigned long long)+0x2e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
     be4:	movs	r0, #1
  return true;

fail:
  m_curCluster = tmp;
  return false;
}
     be6:	add	sp, #12
     be8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    if (pos > m_validLength) {
      DBG_FAIL_MACRO;
     bec:	movw	r0, #677	; 0x2a5
     bf0:	bl	6c8 <dbgPrint(unsigned short)>
      goto fail;
     bf4:	b.n	bd2 <ExFatFile::seekSet(unsigned long long)+0xf2>
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot() ? m_vol->rootDirectoryCluster() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
     bf6:	rsb	r2, lr, r2
     bfa:	b.n	ba2 <ExFatFile::seekSet(unsigned long long)+0xc2>

00000bfc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>:
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
     bfc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     c00:	mov	r5, r1
     c02:	sub	sp, #76	; 0x4c
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;

  // error if already open
  if (isOpen() || !dir->isDir()) {
     c04:	ldrb.w	r1, [r0, #49]	; 0x31
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
     c08:	str	r2, [sp, #0]
     c0a:	mov	r6, r0
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;

  // error if already open
  if (isOpen() || !dir->isDir()) {
     c0c:	cbnz	r1, c1a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1e>
     c0e:	mov	fp, r3
     c10:	ldrb.w	r3, [r5, #49]	; 0x31
     c14:	tst.w	r3, #80	; 0x50
     c18:	bne.n	c30 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x34>
    DBG_FAIL_MACRO;
     c1a:	movs	r0, #206	; 0xce
     c1c:	bl	6c8 <dbgPrint(unsigned short)>
  return sync();
#endif  // READ_ONLY
 fail:

  // close file
  m_attributes = FILE_ATTR_CLOSED;
     c20:	movs	r0, #0
     c22:	strb.w	r0, [r6, #49]	; 0x31
  m_flags = 0;
     c26:	strb.w	r0, [r6, #51]	; 0x33
  return false;
}
     c2a:	add	sp, #76	; 0x4c
     c2c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  // error if already open
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  switch (oflag & O_ACCMODE) {
     c30:	ldr	r3, [sp, #112]	; 0x70
     c32:	and.w	r3, r3, #3
     c36:	cmp	r3, #1
     c38:	beq.w	e58 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x25c>
     c3c:	cmp	r3, #2
     c3e:	beq.n	c4e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x52>
     c40:	cmp	r3, #0
     c42:	beq.w	e54 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x258>
      break;
    case O_RDWR:
      modeFlags = FILE_FLAG_READ | FILE_FLAG_WRITE;
      break;
    default:
      DBG_FAIL_MACRO;
     c46:	movs	r0, #220	; 0xdc
     c48:	bl	6c8 <dbgPrint(unsigned short)>
      goto fail;
     c4c:	b.n	c20 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24>
  // error if already open
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  switch (oflag & O_ACCMODE) {
     c4e:	movs	r3, #3
      break;
    default:
      DBG_FAIL_MACRO;
      goto fail;
  }
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
     c50:	ldr	r2, [sp, #112]	; 0x70
     c52:	and.w	r2, r2, #8
     c56:	orrs	r3, r2
     c58:	str	r3, [sp, #4]
  if (name) {
     c5a:	ldr	r3, [sp, #0]
     c5c:	cmp	r3, #0
     c5e:	beq.w	e64 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x268>
    nameHash = exFatHashName(name, nameLength, 0);
     c62:	movs	r2, #0
     c64:	mov	r0, r3
     c66:	mov	r1, fp
     c68:	bl	1790 <exFatHashName(char const*, unsigned int, unsigned short)>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
     c6c:	movs	r2, #0
     c6e:	str	r0, [sp, #8]
     c70:	movs	r3, #0
     c72:	mov	r0, r5
     c74:	bl	ae0 <ExFatFile::seekSet(unsigned long long)>
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;
     c78:	ldr	r2, [pc, #708]	; (f40 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x344>)
     c7a:	add.w	r3, fp, #14
     c7e:	smull	r1, r2, r2, r3
     c82:	add	r2, r3
     c84:	asrs	r3, r3, #31
     c86:	rsb	r3, r3, r2, asr #3
     c8a:	uxtb	r3, r3
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
  uint8_t freeNeed;
  bool inSet = false;
     c8c:	mov.w	r9, #0
  modeFlags |= oflag & O_APPEND ? FILE_FLAG_APPEND : 0;
  if (name) {
    nameHash = exFatHashName(name, nameLength, 0);
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;
     c90:	add.w	sl, r3, #2
     c94:	str	r3, [sp, #12]
     c96:	uxtb.w	sl, sl

  DirFile_t*   dirFile;
  DirStream_t* dirStream;
  DirName_t*   dirName;
  uint8_t buf[32];
  uint8_t freeCount = 0;
     c9a:	mov	r4, r9
}
//------------------------------------------------------------------------------
bool ExFatFile::openRootFile(ExFatFile* dir, const ExChar_t* name,
                          uint8_t nameLength, oflag_t oflag) {
  int n;
  uint8_t nameOffset = 0;
     c9c:	mov	r7, r9
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;

  while (1) {
    n = dir->read(buf, 32);
     c9e:	movs	r2, #32
     ca0:	add	r1, sp, #40	; 0x28
     ca2:	mov	r0, r5
     ca4:	bl	8cc <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
     ca8:	cmp	r0, #0
     caa:	beq.n	d2a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x12e>
      goto create;
    }
    if (n != 32) {
     cac:	cmp	r0, #32
     cae:	bne.w	e5c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x260>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
     cb2:	ldrb.w	r3, [sp, #40]	; 0x28
     cb6:	lsls	r2, r3, #24
     cb8:	bmi.n	d8a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x18e>
      if (freeCount == 0) {
     cba:	cmp	r4, #0
     cbc:	bne.n	d84 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x188>
        freePos.position = dir->curPosition() - 32;
     cbe:	ldr	r2, [r5, #0]
        freePos.cluster = dir->curCluster();
     cc0:	ldr	r1, [r5, #24]
     cc2:	str	r1, [sp, #28]
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(buf[0] & 0x80)) {
      if (freeCount == 0) {
        freePos.position = dir->curPosition() - 32;
     cc4:	subs	r2, #32
     cc6:	str	r2, [sp, #32]
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
        freeCount++;
     cc8:	adds	r4, #1
     cca:	uxtb	r4, r4
      }
      if (!buf[0]) {
     ccc:	cbz	r3, d2a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x12e>
      if (buf[0] != EXFAT_TYPE_FILE) {
        continue;
      }
      inSet = true;
    }
    switch (buf[0]) {
     cce:	cmp	r3, #192	; 0xc0
     cd0:	beq.w	df8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1fc>
     cd4:	cmp	r3, #193	; 0xc1
     cd6:	beq.n	da0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1a4>
     cd8:	cmp	r3, #133	; 0x85
     cda:	bne.n	c9e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa2>
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
     cdc:	movs	r2, #56	; 0x38
     cde:	movs	r1, #0
     ce0:	mov	r0, r6
     ce2:	bl	bb7c <memset>
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
     ce6:	ldrb.w	r3, [sp, #44]	; 0x2c
    }
    switch (buf[0]) {
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
     cea:	ldrb.w	r2, [sp, #41]	; 0x29
     cee:	strb.w	r2, [r6, #48]	; 0x30
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
     cf2:	lsls	r0, r3, #27
    switch (buf[0]) {
      case EXFAT_TYPE_FILE:
        memset(this, 0, sizeof(ExFatFile));
        dirFile = reinterpret_cast<DirFile_t*>(buf);
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
     cf4:	and.w	r2, r3, #55	; 0x37
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
     cf8:	it	pl
     cfa:	orrpl.w	r2, r2, #8
     cfe:	strb.w	r2, [r6, #49]	; 0x31
        }
        m_vol = dir->volume();

        m_dirPos.cluster = dir->curCluster();
        m_dirPos.position = dir->curPosition() - 32;
     d02:	ldr	r3, [r5, #0]
     d04:	ldr	r1, [r5, #32]
     d06:	ldr	r2, [r5, #24]
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
        }
        m_vol = dir->volume();

        m_dirPos.cluster = dir->curCluster();
     d08:	str	r2, [r6, #36]	; 0x24
        m_dirPos.position = dir->curPosition() - 32;
     d0a:	subs	r3, #32
        m_setCount = dirFile->setCount;
        m_attributes = getLe16(dirFile->attributes) & FILE_ATTR_COPY;
        if (!(m_attributes & EXFAT_ATTRIB_DIRECTORY)) {
          m_attributes |= FILE_ATTR_FILE;
        }
        m_vol = dir->volume();
     d0c:	str	r1, [r6, #32]

        m_dirPos.cluster = dir->curCluster();
        m_dirPos.position = dir->curPosition() - 32;
     d0e:	str	r3, [r6, #40]	; 0x28
        m_dirPos.isContiguous = dir->isContiguous();
     d10:	ldrb.w	r3, [r5, #51]	; 0x33
     d14:	ubfx	r3, r3, #6, #1
     d18:	strb.w	r3, [r6, #44]	; 0x2c
    dir->rewind();
  }
  freeNeed = 2 + (nameLength + 14)/15;

  while (1) {
    n = dir->read(buf, 32);
     d1c:	movs	r2, #32
     d1e:	add	r1, sp, #40	; 0x28
     d20:	mov	r0, r5
     d22:	bl	8cc <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
     d26:	cmp	r0, #0
     d28:	bne.n	cac <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xb0>
#if READ_ONLY
  DBG_FAIL_MACRO;
  goto fail;
#else  // READ_ONLY
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !name) {
     d2a:	ldr	r3, [sp, #112]	; 0x70
     d2c:	lsls	r1, r3, #22
     d2e:	bpl.w	e4a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24e>
     d32:	ldr	r3, [sp, #4]
     d34:	lsls	r2, r3, #30
     d36:	bpl.w	e4a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24e>
     d3a:	ldr	r3, [sp, #0]
     d3c:	cmp	r3, #0
     d3e:	beq.w	e4a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
     d42:	cmp	r4, sl
     d44:	bcc.n	d62 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x166>
     d46:	b.n	e74 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x278>
        goto fail;
      }
      dir->m_curCluster = curCluster;
      continue;
    }
    if (n != 32) {
     d48:	cmp	r0, #32
     d4a:	bne.w	f36 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x33a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
     d4e:	cbnz	r4, d5a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x15e>
      freePos.position = dir->curPosition() - 32;
     d50:	ldr	r2, [r5, #0]
      freePos.cluster = dir->curCluster();
     d52:	ldr	r1, [r5, #24]
     d54:	str	r1, [sp, #28]
    if (n != 32) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (freeCount == 0) {
      freePos.position = dir->curPosition() - 32;
     d56:	subs	r2, #32
     d58:	str	r2, [sp, #32]
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
     d5a:	uxtb	r4, r3
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !name) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
     d5c:	cmp	sl, r4
     d5e:	bls.w	e74 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x278>
    n = dir->read(buf, 32);
     d62:	movs	r2, #32
     d64:	add	r1, sp, #40	; 0x28
     d66:	mov	r0, r5
     d68:	bl	8cc <ExFatFile::read(void*, unsigned int)>
    }
    if (freeCount == 0) {
      freePos.position = dir->curPosition() - 32;
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
     d6c:	adds	r3, r4, #1
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
     d6e:	cmp	r0, #0
     d70:	bne.n	d48 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x14c>
      curCluster = dir->m_curCluster;
      if (!dir->addDirCluster()) {
     d72:	mov	r0, r5
    goto fail;
  }
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
      curCluster = dir->m_curCluster;
     d74:	ldr	r7, [r5, #24]
      if (!dir->addDirCluster()) {
     d76:	bl	1cac <ExFatFile::addDirCluster()>
     d7a:	cmp	r0, #0
     d7c:	beq.w	f92 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x396>
        DBG_FAIL_MACRO;
        goto fail;
      }
      dir->m_curCluster = curCluster;
     d80:	str	r7, [r5, #24]
      continue;
     d82:	b.n	d5c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x160>
    if (!(buf[0] & 0x80)) {
      if (freeCount == 0) {
        freePos.position = dir->curPosition() - 32;
        freePos.cluster = dir->curCluster();
      }
      if (freeCount < freeNeed) {
     d84:	cmp	r4, sl
     d86:	bcs.n	ccc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xd0>
     d88:	b.n	cc8 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xcc>
        freeCount++;
      }
      if (!buf[0]) {
        goto create;
      }
    } else if (!inSet) {
     d8a:	cmp.w	r9, #0
     d8e:	bne.n	cce <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xd2>
      if (freeCount < freeNeed) {
        freeCount = 0;
     d90:	cmp	r4, sl
     d92:	it	cc
     d94:	movcc	r4, #0
      }
      if (buf[0] != EXFAT_TYPE_FILE) {
     d96:	cmp	r3, #133	; 0x85
     d98:	bne.n	c9e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa2>
        continue;
      }
      inSet = true;
     d9a:	mov.w	r9, #1
     d9e:	b.n	cdc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xe0>
        }
        break;

      case EXFAT_TYPE_NAME:
        dirName = reinterpret_cast<DirName_t*>(buf);
        nCmp = nameLength - nameOffset;
     da0:	rsb	r8, r7, fp
     da4:	uxtb.w	r8, r8
     da8:	cmp.w	r8, #15
     dac:	it	cs
     dae:	movcs.w	r8, #15
        if (nCmp > 15) {
          nCmp = 15;
        }
        if (!exFatCmpName(dirName, name, nameOffset, nCmp)) {
     db2:	mov	r3, r8
     db4:	mov	r2, r7
     db6:	ldr	r1, [sp, #0]
     db8:	add	r0, sp, #40	; 0x28
     dba:	bl	17cc <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)>
     dbe:	cmp	r0, #0
     dc0:	beq.n	e38 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x23c>
          inSet = false;
          break;
        }
        nameOffset += nCmp;
     dc2:	add	r7, r8
     dc4:	uxtb	r7, r7

        if (nameOffset == nameLength) {
     dc6:	cmp	fp, r7
     dc8:	bne.w	c9e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa2>
    }
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
     dcc:	ldr	r3, [sp, #112]	; 0x70
     dce:	lsls	r3, r3, #20
     dd0:	bmi.n	e6a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x26e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
     dd2:	ldr	r3, [sp, #112]	; 0x70
     dd4:	tst.w	r3, #17408	; 0x4400
     dd8:	bne.w	f44 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x348>
     ddc:	ldrb.w	r3, [r6, #51]	; 0x33
     de0:	lsls	r7, r3, #30
     de2:	bmi.w	f44 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x348>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
     de6:	ldr	r3, [sp, #112]	; 0x70
     de8:	lsls	r3, r3, #21
     dea:	bpl.w	f88 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x38c>
    if (!(m_flags & FILE_FLAG_WRITE)) {
      DBG_FAIL_MACRO;
     dee:	mov.w	r0, #334	; 0x14e
     df2:	bl	6c8 <dbgPrint(unsigned short)>
      goto fail;
     df6:	b.n	c20 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24>
        break;

      case EXFAT_TYPE_STREAM:
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
     df8:	ldrb.w	r3, [sp, #41]	; 0x29
        m_dirPos.isContiguous = dir->isContiguous();
        break;

      case EXFAT_TYPE_STREAM:
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
     dfc:	ldr	r2, [sp, #4]
     dfe:	strb.w	r2, [r6, #51]	; 0x33
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
     e02:	lsls	r1, r3, #30
     e04:	bpl.n	e0e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x212>
          m_flags |= FILE_FLAG_CONTIGUOUS;
     e06:	orr.w	r3, r2, #64	; 0x40
     e0a:	strb.w	r3, [r6, #51]	; 0x33
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
     e0e:	ldrd	r2, r3, [sp, #48]	; 0x30
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
     e12:	ldrd	r0, r1, [sp, #64]	; 0x40
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
     e16:	strd	r2, r3, [r6, #16]
        m_firstCluster = getLe32(dirStream->firstCluster);
     e1a:	ldr	r3, [sp, #60]	; 0x3c
     e1c:	str	r3, [r6, #28]
        m_dataLength = getLe64(dirStream->dataLength);
        if (!name) {
     e1e:	ldr	r3, [sp, #0]
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
        m_validLength = getLe64(dirStream->validLength);
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
     e20:	strd	r0, r1, [r6, #8]
        if (!name) {
     e24:	cmp	r3, #0
     e26:	beq.n	dcc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1d0>
          goto found;
        }
        if (nameLength != dirStream->nameLength ||
     e28:	ldrb.w	r3, [sp, #43]	; 0x2b
     e2c:	cmp	r3, fp
     e2e:	beq.n	e3c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x240>
            nameHash != getLe16(dirStream->nameHash)) {
          inSet = false;
     e30:	mov.w	r9, #0
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
     e34:	mov	r7, r9
     e36:	b.n	c9e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa2>
        nCmp = nameLength - nameOffset;
        if (nCmp > 15) {
          nCmp = 15;
        }
        if (!exFatCmpName(dirName, name, nameOffset, nCmp)) {
          inSet = false;
     e38:	mov	r9, r0
     e3a:	b.n	c9e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa2>
        m_firstCluster = getLe32(dirStream->firstCluster);
        m_dataLength = getLe64(dirStream->dataLength);
        if (!name) {
          goto found;
        }
        if (nameLength != dirStream->nameLength ||
     e3c:	ldrh.w	r3, [sp, #44]	; 0x2c
     e40:	ldr	r2, [sp, #8]
     e42:	cmp	r3, r2
     e44:	bne.n	e30 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x234>
        dirStream = reinterpret_cast<DirStream_t*>(buf);
        m_flags = modeFlags;
        if (dirStream->flags & EXFAT_FLAG_CONTIGUOUS) {
          m_flags |= FILE_FLAG_CONTIGUOUS;
        }
        nameOffset = 0;
     e46:	movs	r7, #0
     e48:	b.n	c9e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0xa2>
  DBG_FAIL_MACRO;
  goto fail;
#else  // READ_ONLY
  // don't create unless O_CREAT and write
  if (!(oflag & O_CREAT) || !(modeFlags & FILE_FLAG_WRITE) || !name) {
    DBG_FAIL_MACRO;
     e4a:	movw	r0, #355	; 0x163
     e4e:	bl	6c8 <dbgPrint(unsigned short)>
    goto fail;
     e52:	b.n	c20 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24>
  // error if already open
  if (isOpen() || !dir->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  switch (oflag & O_ACCMODE) {
     e54:	movs	r3, #1
     e56:	b.n	c50 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x54>
     e58:	movs	r3, #2
     e5a:	b.n	c50 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x54>
    n = dir->read(buf, 32);
    if (n == 0) {
      goto create;
    }
    if (n != 32) {
      DBG_FAIL_MACRO;
     e5c:	movs	r0, #236	; 0xec
     e5e:	bl	6c8 <dbgPrint(unsigned short)>
      goto fail;
     e62:	b.n	c20 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24>
                          uint8_t nameLength, oflag_t oflag) {
  int n;
  uint8_t nameOffset = 0;
  uint8_t nCmp;
  uint8_t modeFlags;
  uint16_t nameHash = 0;
     e64:	ldr	r3, [sp, #0]
     e66:	str	r3, [sp, #8]
     e68:	b.n	c78 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x7c>
  }

 found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    DBG_FAIL_MACRO;
     e6a:	mov.w	r0, #320	; 0x140
     e6e:	bl	6c8 <dbgPrint(unsigned short)>
    goto fail;
     e72:	b.n	c20 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24>
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
     e74:	ldrb.w	r3, [r5, #51]	; 0x33
  memset(this, 0, sizeof(ExFatFile));
     e78:	movs	r2, #56	; 0x38
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
     e7a:	ubfx	r3, r3, #6, #1
  memset(this, 0, sizeof(ExFatFile));
     e7e:	movs	r1, #0
     e80:	mov	r0, r6
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
     e82:	add.w	r8, sp, #28
      freePos.cluster = dir->curCluster();
    }
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
     e86:	strb.w	r3, [sp, #36]	; 0x24
  memset(this, 0, sizeof(ExFatFile));
     e8a:	bl	bb7c <memset>
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
     e8e:	ldr	r4, [sp, #12]
     e90:	ldr	r3, [r5, #32]
     e92:	str.w	fp, [sp, #12]

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
     e96:	ldmia.w	r8, {r0, r1, r2}
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
     e9a:	add.w	r9, r4, #1
  }

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
     e9e:	movs	r4, #8
     ea0:	strb.w	r4, [r6, #49]	; 0x31
     ea4:	add.w	r7, fp, #30
  m_dirPos = freePos;
     ea8:	add.w	r4, r6, #36	; 0x24
     eac:	ldr.w	fp, [sp]
    freeCount++;
  }

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
     eb0:	str	r3, [r6, #32]
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
     eb2:	uxtb.w	r9, r9

  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
     eb6:	stmia.w	r4, {r0, r1, r2}
     eba:	uxtb	r7, r7
  for (uint8_t i = 0; i < freeNeed; i++) {
     ebc:	movs	r5, #0
     ebe:	mov	r0, r3
      if (1 != m_vol->dirSeek(&freePos, 32)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    cache = m_vol->dirCache(&freePos, FsCache::CACHE_FOR_WRITE);
     ec0:	movs	r2, #1
     ec2:	mov	r1, r8
     ec4:	bl	152c <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    if (!cache || (cache[0] & 0x80)) {
     ec8:	mov	r4, r0
     eca:	cmp	r0, #0
     ecc:	beq.n	f7e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x382>
     ece:	ldrsb.w	r3, [r0]
     ed2:	cmp	r3, #0
     ed4:	blt.n	f7e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x382>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memset(cache, 0 , 32);
     ed6:	movs	r2, #32
     ed8:	movs	r1, #0
     eda:	bl	bb7c <memset>
    if (i == 0) {
     ede:	cmp	r5, #0
     ee0:	beq.w	ff2 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x3f6>
        FsDateTime::callback(&date, &time, &ms10);
        dirFile->createTimeMs = ms10;
        setLe16(dirFile->createTime, time);
        setLe16(dirFile->createDate, date);
      }
    } else if (i == 1) {
     ee4:	cmp	r5, #1
     ee6:	beq.n	fd2 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x3d6>
     ee8:	rsb	r3, r5, r5, lsl #4
     eec:	cmp	r7, #15
     eee:	sub.w	r3, r3, #30

      dirStream->nameLength = nameLength;
      setLe16(dirStream->nameHash, nameHash);
    } else {
      dirName = reinterpret_cast<DirName_t*>(cache);
      dirName->type = EXFAT_TYPE_NAME;
     ef2:	mov.w	r2, #193	; 0xc1
     ef6:	mov	r1, r7
     ef8:	it	cs
     efa:	movcs	r1, #15
     efc:	uxtb	r3, r3
     efe:	strb	r2, [r4, #0]
      nameOffset = 15*(i - 2);
      nCmp = nameLength - nameOffset;
      if (nCmp > 15) {
        nCmp = 15;
      }
      for (size_t k = 0; k < nCmp; k++) {
     f00:	cbz	r1, f18 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x31c>
     f02:	adds	r4, #2
     f04:	sxth	r1, r1
     f06:	add.w	r1, r4, r1, lsl #1
     f0a:	add	r3, fp
        setLe16(dirName->unicode + 2*k, name[k + nameOffset]);
     f0c:	ldrb.w	r2, [r3], #1
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
     f10:	strh.w	r2, [r4], #2
      nameOffset = 15*(i - 2);
      nCmp = nameLength - nameOffset;
      if (nCmp > 15) {
        nCmp = 15;
      }
      for (size_t k = 0; k < nCmp; k++) {
     f14:	cmp	r1, r4
     f16:	bne.n	f0c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x310>
  freePos.isContiguous = dir->isContiguous();
  memset(this, 0, sizeof(ExFatFile));
  m_vol = dir->volume();
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  for (uint8_t i = 0; i < freeNeed; i++) {
     f18:	adds	r5, #1
     f1a:	uxtb	r5, r5
     f1c:	cmp	sl, r5
     f1e:	bls.n	fa6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x3aa>
    if (i) {
      if (1 != m_vol->dirSeek(&freePos, 32)) {
     f20:	movs	r2, #32
     f22:	mov	r1, r8
     f24:	ldr	r0, [r6, #32]
     f26:	bl	15ac <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
     f2a:	cmp	r0, #1
     f2c:	bne.n	f9c <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x3a0>
     f2e:	subs	r7, #15
     f30:	ldr	r0, [r6, #32]
     f32:	uxtb	r7, r7
     f34:	b.n	ec0 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2c4>
      }
      dir->m_curCluster = curCluster;
      continue;
    }
    if (n != 32) {
      DBG_FAIL_MACRO;
     f36:	mov.w	r0, #370	; 0x172
     f3a:	bl	6c8 <dbgPrint(unsigned short)>
      goto fail;
     f3e:	b.n	c20 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24>
     f40:	.word	0x88888889
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    if (isSubDir() || isReadOnly() || READ_ONLY) {
     f44:	ldrb.w	r3, [r6, #49]	; 0x31
     f48:	tst.w	r3, #17
     f4c:	bne.n	f74 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x378>
      goto fail;
    }
  }

#if !READ_ONLY
  if (oflag & O_TRUNC) {
     f4e:	ldr	r3, [sp, #112]	; 0x70
     f50:	lsls	r5, r3, #21
     f52:	bpl.n	f88 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x38c>
    if (!(m_flags & FILE_FLAG_WRITE)) {
     f54:	ldrb.w	r3, [r6, #51]	; 0x33
     f58:	lsls	r4, r3, #30
     f5a:	bpl.w	dee <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x1f2>
   * \param[in] length The desired length for the file.
   *
   * \return true for success or false for failure.
   */
  bool truncate(uint64_t length) {
    return seekSet(length) && truncate();
     f5e:	movs	r2, #0
     f60:	movs	r3, #0
     f62:	mov	r0, r6
     f64:	bl	ae0 <ExFatFile::seekSet(unsigned long long)>
     f68:	cbnz	r0, fc6 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x3ca>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
     f6a:	mov.w	r0, #338	; 0x152
     f6e:	bl	6c8 <dbgPrint(unsigned short)>
      goto fail;
     f72:	b.n	c20 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24>
    goto fail;
  }
  // Write, truncate, or at end is an error for a directory or read-only file.
  if ((oflag & (O_TRUNC | O_AT_END)) || (m_flags & FILE_FLAG_WRITE)) {
    if (isSubDir() || isReadOnly() || READ_ONLY) {
      DBG_FAIL_MACRO;
     f74:	mov.w	r0, #326	; 0x146
     f78:	bl	6c8 <dbgPrint(unsigned short)>
      goto fail;
     f7c:	b.n	c20 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24>
        goto fail;
      }
    }
    cache = m_vol->dirCache(&freePos, FsCache::CACHE_FOR_WRITE);
    if (!cache || (cache[0] & 0x80)) {
      DBG_FAIL_MACRO;
     f7e:	mov.w	r0, #394	; 0x18a
     f82:	bl	6c8 <dbgPrint(unsigned short)>
      goto fail;
     f86:	b.n	c20 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24>
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
     f88:	ldr	r3, [sp, #112]	; 0x70
     f8a:	lsls	r0, r3, #17
     f8c:	bmi.n	fae <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x3b2>
    DBG_FAIL_MACRO;
    goto fail;
  }
#endif  // READ_ONLY
  return true;
     f8e:	movs	r0, #1
     f90:	b.n	c2a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2e>
  while (freeCount < freeNeed) {
    n = dir->read(buf, 32);
    if (n == 0) {
      curCluster = dir->m_curCluster;
      if (!dir->addDirCluster()) {
        DBG_FAIL_MACRO;
     f92:	movw	r0, #363	; 0x16b
     f96:	bl	6c8 <dbgPrint(unsigned short)>
        goto fail;
     f9a:	b.n	c20 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24>
  m_attributes = FILE_ATTR_FILE;
  m_dirPos = freePos;
  for (uint8_t i = 0; i < freeNeed; i++) {
    if (i) {
      if (1 != m_vol->dirSeek(&freePos, 32)) {
        DBG_FAIL_MACRO;
     f9c:	mov.w	r0, #388	; 0x184
     fa0:	bl	6c8 <dbgPrint(unsigned short)>
        goto fail;
     fa4:	b.n	c20 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24>
      for (size_t k = 0; k < nCmp; k++) {
        setLe16(dirName->unicode + 2*k, name[k + nameOffset]);
      }
    }
  }
  return sync();
     fa6:	mov	r0, r6
     fa8:	bl	1c44 <ExFatFile::sync()>
     fac:	b.n	c2a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x2e>
    }
    if (!truncate(0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if ((oflag & O_AT_END) && !seekSet(fileSize())) {
     fae:	ldrd	r2, r3, [r6, #16]
     fb2:	mov	r0, r6
     fb4:	bl	ae0 <ExFatFile::seekSet(unsigned long long)>
     fb8:	cmp	r0, #0
     fba:	bne.n	f8e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x392>
    DBG_FAIL_MACRO;
     fbc:	mov.w	r0, #342	; 0x156
     fc0:	bl	6c8 <dbgPrint(unsigned short)>
    goto fail;
     fc4:	b.n	c20 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x24>
     fc6:	mov	r0, r6
     fc8:	bl	2014 <ExFatFile::truncate()>
     fcc:	cmp	r0, #0
     fce:	beq.n	f6a <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x36e>
     fd0:	b.n	f8e <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x392>
        setLe16(dirFile->createTime, time);
        setLe16(dirFile->createDate, date);
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
     fd2:	movs	r3, #192	; 0xc0
     fd4:	strb	r3, [r4, #0]
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
     fd6:	ldr	r3, [sp, #4]
        setLe16(dirFile->createDate, date);
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
     fd8:	movs	r2, #3
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
     fda:	orn	r3, r3, #63	; 0x3f
        setLe16(dirFile->createDate, date);
      }
    } else if (i == 1) {
      dirStream = reinterpret_cast<DirStream_t*>(cache);
      dirStream->type = EXFAT_TYPE_STREAM;
      dirStream->flags = EXFAT_FLAG_ALWAYS1 | EXFAT_FLAG_CONTIGUOUS;
     fde:	strb	r2, [r4, #1]
      m_flags = modeFlags | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
     fe0:	strb.w	r3, [r6, #51]	; 0x33

      dirStream->nameLength = nameLength;
     fe4:	ldrb.w	r3, [sp, #12]
     fe8:	strb	r3, [r4, #3]
     fea:	ldrh.w	r3, [sp, #8]
     fee:	strh	r3, [r4, #4]
     ff0:	b.n	f18 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x31c>
      goto fail;
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
     ff2:	movs	r3, #133	; 0x85
     ff4:	strb	r3, [r4, #0]
      m_setCount = freeNeed - 1;
      dirFile->setCount = m_setCount;
      if (FsDateTime::callback) {
     ff6:	ldr	r3, [pc, #48]	; (1028 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x42c>)
    }
    memset(cache, 0 , 32);
    if (i == 0) {
      dirFile = reinterpret_cast<DirFile_t*>(cache);
      dirFile->type = EXFAT_TYPE_FILE;
      m_setCount = freeNeed - 1;
     ff8:	strb.w	r9, [r6, #48]	; 0x30
      dirFile->setCount = m_setCount;
     ffc:	strb.w	r9, [r4, #1]
      if (FsDateTime::callback) {
    1000:	ldr	r3, [r3, #0]
    1002:	cmp	r3, #0
    1004:	beq.n	f18 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x31c>
        uint16_t date, time;
        uint8_t ms10;
        FsDateTime::callback(&date, &time, &ms10);
    1006:	add.w	r2, sp, #23
    100a:	add.w	r1, sp, #26
    100e:	add	r0, sp, #24
    1010:	blx	r3
        dirFile->createTimeMs = ms10;
    1012:	ldrb.w	r1, [sp, #23]
    1016:	ldrh.w	r2, [sp, #26]
    101a:	ldrh.w	r3, [sp, #24]
    101e:	strb	r1, [r4, #20]
    1020:	strh	r2, [r4, #8]
    1022:	strh	r3, [r4, #10]
    1024:	b.n	f18 <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)+0x31c>
    1026:	nop
    1028:	.word	0x1fff13c8

0000102c <ExFatFile::open(ExFatFile*, char const*, int)>:
//-----------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const ExChar_t* path, oflag_t oflag) {
    102c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1030:	mov	r6, r0
    1032:	sub	sp, #84	; 0x54
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    1034:	ldrb.w	r4, [r6, #49]	; 0x31
//-----------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool ExFatFile::open(ExFatFile* dirFile, const ExChar_t* path, oflag_t oflag) {
    1038:	str	r2, [sp, #12]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() : m_attributes(FILE_ATTR_CLOSED), m_error(0), m_flags(0) {}
    103a:	movs	r0, #0
    103c:	strb.w	r0, [sp, #73]	; 0x49
    1040:	strb.w	r0, [sp, #74]	; 0x4a
    1044:	strb.w	r0, [sp, #75]	; 0x4b
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    1048:	cmp	r4, #0
    104a:	bne.n	10e8 <ExFatFile::open(ExFatFile*, char const*, int)+0xbc>
    104c:	mov	r9, r3
    104e:	ldrb.w	r3, [r1, #49]	; 0x31
    1052:	tst.w	r3, #80	; 0x50
    1056:	mov	r5, r1
    1058:	beq.n	10e8 <ExFatFile::open(ExFatFile*, char const*, int)+0xbc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    105a:	ldrb	r3, [r2, #0]
    105c:	cmp	r3, #47	; 0x2f
    105e:	mov	r1, r2
    1060:	beq.n	10ca <ExFatFile::open(ExFatFile*, char const*, int)+0x9e>
  uint8_t setCount() {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    1062:	mov.w	r8, #0
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    1066:	add	r3, sp, #12
    1068:	add	r2, sp, #16
    106a:	mov	r0, r6
    106c:	bl	808 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    1070:	mov	r4, r0
    1072:	cmp	r0, #0
    1074:	beq.n	10f8 <ExFatFile::open(ExFatFile*, char const*, int)+0xcc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    1076:	ldr	r3, [sp, #12]
    1078:	ldrb	r3, [r3, #0]
    107a:	cmp	r3, #0
    107c:	beq.n	1106 <ExFatFile::open(ExFatFile*, char const*, int)+0xda>
    107e:	ldrb.w	r3, [sp, #16]
    1082:	ldr	r2, [sp, #20]
    1084:	str.w	r8, [sp]
    1088:	mov	r1, r5
    108a:	mov	r0, r6
    108c:	bl	bfc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    1090:	mov	r4, r0
    1092:	cmp	r0, #0
    1094:	beq.n	1122 <ExFatFile::open(ExFatFile*, char const*, int)+0xf6>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    1096:	mov	r4, r6
    1098:	add	r7, sp, #24
    109a:	add.w	lr, r6, #48	; 0x30
    109e:	ldr	r0, [r4, #0]
    10a0:	ldr	r1, [r4, #4]
    10a2:	ldr	r2, [r4, #8]
    10a4:	ldr	r3, [r4, #12]
    10a6:	mov	r5, r7
    10a8:	stmia	r5!, {r0, r1, r2, r3}
    10aa:	adds	r4, #16
    10ac:	cmp	r4, lr
    10ae:	mov	r7, r5
    10b0:	bne.n	109e <ExFatFile::open(ExFatFile*, char const*, int)+0x72>
    10b2:	ldr	r0, [r4, #0]
    10b4:	str	r0, [r5, #0]
#include "ExFatFile.h"
#include "ExFatVolume.h"
#include "upcase.h"
//-----------------------------------------------------------------------------
bool ExFatFile::close() {
  bool rtn = sync();
    10b6:	mov	r0, r6
    10b8:	bl	1c44 <ExFatFile::sync()>
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    10bc:	add	r5, sp, #24
#include "ExFatVolume.h"
#include "upcase.h"
//-----------------------------------------------------------------------------
bool ExFatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    10be:	strb.w	r8, [r6, #49]	; 0x31
  m_flags = 0;
    10c2:	strb.w	r8, [r6, #51]	; 0x33
    10c6:	ldr	r1, [sp, #12]
    10c8:	b.n	1066 <ExFatFile::open(ExFatFile*, char const*, int)+0x3a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    10ca:	adds	r1, #1
    10cc:	str	r1, [sp, #12]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    10ce:	ldrb	r3, [r1, #0]
    10d0:	cmp	r3, #47	; 0x2f
    10d2:	beq.n	10ca <ExFatFile::open(ExFatFile*, char const*, int)+0x9e>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    10d4:	ldr	r1, [r5, #32]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    10d6:	cbz	r3, 1130 <ExFatFile::open(ExFatFile*, char const*, int)+0x104>
      return openRoot(dirFile->m_vol);
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    10d8:	add	r0, sp, #24
    10da:	bl	7d8 <ExFatFile::openRoot(ExFatVolume*)>
    10de:	mov	r4, r0
    10e0:	cbz	r0, 113a <ExFatFile::open(ExFatFile*, char const*, int)+0x10e>
    10e2:	ldr	r1, [sp, #12]
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    10e4:	add	r5, sp, #24
    10e6:	b.n	1062 <ExFatFile::open(ExFatFile*, char const*, int)+0x36>
bool ExFatFile::open(ExFatFile* dirFile, const ExChar_t* path, oflag_t oflag) {
  ExFatFile tmpDir;
  ExName_t fname;
  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    10e8:	movs	r0, #125	; 0x7d
    10ea:	bl	6c8 <dbgPrint(unsigned short)>
    close();
  }
  return open(dirFile, &fname, oflag);

fail:
  return false;
    10ee:	movs	r4, #0
}
    10f0:	mov	r0, r4
    10f2:	add	sp, #84	; 0x54
    10f4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
    10f8:	movs	r0, #143	; 0x8f
    10fa:	bl	6c8 <dbgPrint(unsigned short)>
  }
  return open(dirFile, &fname, oflag);

fail:
  return false;
}
    10fe:	mov	r0, r4
    1100:	add	sp, #84	; 0x54
    1102:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    1106:	ldrb.w	r3, [sp, #16]
    110a:	ldr	r2, [sp, #20]
    110c:	str.w	r9, [sp]
    1110:	mov	r1, r5
    1112:	mov	r0, r6
    1114:	bl	bfc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
    1118:	mov	r4, r0
    111a:	mov	r0, r4
    111c:	add	sp, #84	; 0x54
    111e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
    1122:	movs	r0, #150	; 0x96
    1124:	bl	6c8 <dbgPrint(unsigned short)>
  }
  return open(dirFile, &fname, oflag);

fail:
  return false;
}
    1128:	mov	r0, r4
    112a:	add	sp, #84	; 0x54
    112c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    1130:	mov	r0, r6
    1132:	bl	7d8 <ExFatFile::openRoot(ExFatVolume*)>
    1136:	mov	r4, r0
    1138:	b.n	10f0 <ExFatFile::open(ExFatFile*, char const*, int)+0xc4>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
      DBG_FAIL_MACRO;
    113a:	movs	r0, #136	; 0x88
    113c:	bl	6c8 <dbgPrint(unsigned short)>
      goto fail;
    1140:	b.n	10f0 <ExFatFile::open(ExFatFile*, char const*, int)+0xc4>
    1142:	nop

00001144 <ExFatFile::open(ExFatVolume*, char const*, int)>:
bool ExFatFile::open(const ExChar_t* path, int oflag) {
  return open(ExFatVolume::cwv(), path, oflag);
}
//-----------------------------------------------------------------------------
bool ExFatFile::open(ExFatVolume* vol, const ExChar_t* path, int oflag) {
  return vol && open(vol->vwd(), path, oflag);
    1144:	cbz	r1, 114e <ExFatFile::open(ExFatVolume*, char const*, int)+0xa>
    1146:	add.w	r1, r1, #1088	; 0x440
    114a:	b.w	102c <ExFatFile::open(ExFatFile*, char const*, int)>
}
    114e:	mov	r0, r1
    1150:	bx	lr
    1152:	nop

00001154 <ExFatFile::openNext(ExFatFile*, int)>:
    DBG_FAIL_MACRO;
  }
  return false;
}
//-----------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    1154:	push	{r4, r5, lr}
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    1156:	ldrb.w	r3, [r0, #49]	; 0x31
    DBG_FAIL_MACRO;
  }
  return false;
}
//-----------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
    115a:	sub	sp, #12
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    115c:	cbnz	r3, 1168 <ExFatFile::openNext(ExFatFile*, int)+0x14>
    115e:	ldrb.w	r5, [r1, #49]	; 0x31
    1162:	tst.w	r5, #80	; 0x50
    1166:	bne.n	1174 <ExFatFile::openNext(ExFatFile*, int)+0x20>
    DBG_FAIL_MACRO;
    1168:	movs	r0, #176	; 0xb0
    116a:	bl	6c8 <dbgPrint(unsigned short)>
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);

 fail:
  return false;
    116e:	movs	r0, #0
}
    1170:	add	sp, #12
    1172:	pop	{r4, r5, pc}
  }
  return false;
}
//-----------------------------------------------------------------------------
bool ExFatFile::openNext(ExFatFile* dir, oflag_t oflag) {
  if (isOpen() || !dir->isDir() || (dir->curPosition() & 0X1F)) {
    1174:	ldrd	r4, r5, [r1]
    1178:	movs	r5, #0
    117a:	and.w	r4, r4, #31
    117e:	orrs	r4, r5
    1180:	bne.n	1168 <ExFatFile::openNext(ExFatFile*, int)+0x14>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return openRootFile(dir, nullptr, 0, oflag);
    1182:	str	r2, [sp, #0]
    1184:	mov	r2, r3
    1186:	bl	bfc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>

 fail:
  return false;
}
    118a:	add	sp, #12
    118c:	pop	{r4, r5, pc}
    118e:	nop

00001190 <dbgPrint(unsigned short)>:
#if USE_DBG_MACROS
#include "Arduino.h"
#ifndef DBG_FILE
#error DBG_FILE not defined
#endif  // DBG_FILE
static void dbgPrint(uint16_t line) {
    1190:	push	{r3, r4, r5, lr}
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1192:	movs	r1, #10
    1194:	mov	r5, r0
    1196:	ldr	r0, [pc, #40]	; (11c0 <dbgPrint(unsigned short)+0x30>)
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    1198:	ldr	r4, [pc, #40]	; (11c4 <dbgPrint(unsigned short)+0x34>)
    119a:	bl	8e24 <usb_serial_write>
    119e:	movs	r1, #18
    11a0:	ldr	r0, [pc, #36]	; (11c8 <dbgPrint(unsigned short)+0x38>)
    11a2:	bl	8e24 <usb_serial_write>
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    11a6:	movs	r0, #46	; 0x2e
    11a8:	bl	8f2c <usb_serial_putchar>
    11ac:	mov	r1, r5
    11ae:	mov	r0, r4
    11b0:	bl	ae20 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    11b4:	mov	r0, r4
  Serial.print(F("DBG_FAIL: "));
  Serial.print(F(DBG_FILE));
  Serial.write('.');
  Serial.println(line);
}
    11b6:	ldmia.w	sp!, {r3, r4, r5, lr}
    11ba:	b.w	ad80 <Print::println()>
    11be:	nop
    11c0:	.word	0x0000c270
    11c4:	.word	0x1fff099c
    11c8:	.word	0x0000c28c

000011cc <FsCache::sync() [clone .part.2]>:

fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    11cc:	push	{r3, r4, r5, lr}
  if (m_status & CACHE_STATUS_DIRTY) {
    if (!m_blockDev->writeSector(m_sector, m_cacheBuffer)) {
    11ce:	add.w	r2, r0, #12

fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
    11d2:	mov	r4, r0
  if (m_status & CACHE_STATUS_DIRTY) {
    if (!m_blockDev->writeSector(m_sector, m_cacheBuffer)) {
    11d4:	ldr	r0, [r0, #4]
    11d6:	ldr	r1, [r4, #8]
    11d8:	ldr	r3, [r0, #0]
    11da:	ldr	r3, [r3, #24]
    11dc:	blx	r3
    11de:	mov	r5, r0
    11e0:	cbz	r0, 11ee <FsCache::sync() [clone .part.2]+0x22>
      DBG_FAIL_MACRO;
      goto fail;
    }
    m_status &= ~CACHE_STATUS_DIRTY;
    11e2:	ldrb	r3, [r4, #0]
    11e4:	bic.w	r3, r3, #1
    11e8:	strb	r3, [r4, #0]
  }
  return true;

fail:
  return false;
}
    11ea:	mov	r0, r5
    11ec:	pop	{r3, r4, r5, pc}
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
  if (m_status & CACHE_STATUS_DIRTY) {
    if (!m_blockDev->writeSector(m_sector, m_cacheBuffer)) {
      DBG_FAIL_MACRO;
    11ee:	movs	r0, #64	; 0x40
    11f0:	bl	1190 <dbgPrint(unsigned short)>
  }
  return true;

fail:
  return false;
}
    11f4:	mov	r0, r5
    11f6:	pop	{r3, r4, r5, pc}

000011f8 <FsCache::invalidate()>:
#include "../common/DebugMacros.h"
#include "ExFatVolume.h"
#include "../common/FsStructs.h"
//-----------------------------------------------------------------------------
void FsCache::invalidate() {
  m_status = 0;
    11f8:	movs	r2, #0
  m_sector = 0XFFFFFFFF;
    11fa:	mov.w	r3, #4294967295
#include "../common/DebugMacros.h"
#include "ExFatVolume.h"
#include "../common/FsStructs.h"
//-----------------------------------------------------------------------------
void FsCache::invalidate() {
  m_status = 0;
    11fe:	strb	r2, [r0, #0]
  m_sector = 0XFFFFFFFF;
    1200:	str	r3, [r0, #8]
    1202:	bx	lr

00001204 <FsCache::get(unsigned long, unsigned char)>:
}
//-----------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
    1204:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (!m_blockDev) {
    1208:	ldr	r4, [r0, #4]
    120a:	cmp	r4, #0
    120c:	beq.n	1284 <FsCache::get(unsigned long, unsigned char)+0x80>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    120e:	ldr	r3, [r0, #8]
    1210:	cmp	r3, r1
    1212:	mov	r6, r0
    1214:	mov	r8, r1
    1216:	mov	r7, r2
    1218:	beq.n	123c <FsCache::get(unsigned long, unsigned char)+0x38>
fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
  if (m_status & CACHE_STATUS_DIRTY) {
    121a:	ldrb	r3, [r0, #0]
    121c:	lsls	r2, r3, #31
    121e:	bmi.n	124c <FsCache::get(unsigned long, unsigned char)+0x48>
  if (m_sector != sector) {
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    1220:	lsls	r3, r7, #30
    1222:	bpl.n	1262 <FsCache::get(unsigned long, unsigned char)+0x5e>
    1224:	add.w	r5, r6, #12
    1228:	movs	r3, #0
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    122a:	and.w	r7, r7, #1
    122e:	orrs	r7, r3
    1230:	strb	r7, [r6, #0]
    1232:	mov	r0, r5
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
    m_sector = sector;
    1234:	str.w	r8, [r6, #8]
  m_status |= option & CACHE_STATUS_MASK;
  return m_cacheBuffer;

fail:
  return nullptr;
}
    1238:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    123c:	ldrsb.w	r3, [r0], #12
      }
    }
    m_status = 0;
    m_sector = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    1240:	and.w	r7, r7, #1
    1244:	orrs	r7, r3
    1246:	strb	r7, [r6, #0]
  return m_cacheBuffer;

fail:
  return nullptr;
}
    1248:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    124c:	bl	11cc <FsCache::sync() [clone .part.2]>
  if (!m_blockDev) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_sector != sector) {
    if (!sync()) {
    1250:	mov	r4, r0
    1252:	cmp	r0, #0
    1254:	bne.n	1220 <FsCache::get(unsigned long, unsigned char)+0x1c>
      DBG_FAIL_MACRO;
    1256:	movs	r0, #42	; 0x2a
    1258:	bl	1190 <dbgPrint(unsigned short)>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return m_cacheBuffer;

fail:
  return nullptr;
    125c:	mov	r0, r4
    goto fail;
  }
  if (m_sector != sector) {
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    125e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_blockDev->readSector(sector, m_cacheBuffer)) {
    1262:	ldr	r0, [r6, #4]
    1264:	ldr	r3, [r0, #0]
    1266:	add.w	r5, r6, #12
    126a:	ldr	r3, [r3, #8]
    126c:	mov	r2, r5
    126e:	mov	r1, r8
    1270:	blx	r3
    1272:	mov	r4, r0
    1274:	cmp	r0, #0
    1276:	bne.n	1228 <FsCache::get(unsigned long, unsigned char)+0x24>
        DBG_FAIL_MACRO;
    1278:	movs	r0, #47	; 0x2f
    127a:	bl	1190 <dbgPrint(unsigned short)>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return m_cacheBuffer;

fail:
  return nullptr;
    127e:	mov	r0, r4
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_blockDev->readSector(sector, m_cacheBuffer)) {
        DBG_FAIL_MACRO;
        goto fail;
    1280:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  m_sector = 0XFFFFFFFF;
}
//-----------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    DBG_FAIL_MACRO;
    1284:	movs	r0, #37	; 0x25
    1286:	bl	1190 <dbgPrint(unsigned short)>
  }
  m_status |= option & CACHE_STATUS_MASK;
  return m_cacheBuffer;

fail:
  return nullptr;
    128a:	mov	r0, r4
}
//-----------------------------------------------------------------------------
uint8_t* FsCache::get(uint32_t sector, uint8_t option) {
  if (!m_blockDev) {
    DBG_FAIL_MACRO;
    goto fail;
    128c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00001290 <FsCache::sync()>:
fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FsCache::sync() {
  if (m_status & CACHE_STATUS_DIRTY) {
    1290:	ldrb	r3, [r0, #0]
    1292:	lsls	r3, r3, #31
    1294:	bmi.n	129a <FsCache::sync()+0xa>
  }
  return true;

fail:
  return false;
}
    1296:	movs	r0, #1
    1298:	bx	lr
    129a:	b.w	11cc <FsCache::sync() [clone .part.2]>
    129e:	nop

000012a0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>:
 fail:
  return false;
}
//-----------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
    12a0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    12a4:	mov	r8, r0
    12a6:	mov	r9, r2
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    12a8:	mov	fp, r1
    12aa:	cmp	r1, #0
    12ac:	beq.n	1338 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x98>
    12ae:	subs	r7, r1, #2
  if (start >= m_clusterCount) {
    12b0:	ldr.w	r3, [r8, #1064]	; 0x428
    12b4:	cmp	r7, r3
    12b6:	bcs.n	1330 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x90>
    12b8:	and.w	r5, r7, #7
    12bc:	movs	r3, #1
    12be:	lsl.w	r5, r3, r5
    12c2:	uxtb	r5, r5
    12c4:	ubfx	sl, r7, #3, #9
    start = 0;
  }
  uint32_t endAlloc = start;
  uint32_t bgnAlloc = start;
    12c8:	mov	r6, r7
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
  }
  uint32_t endAlloc = start;
    12ca:	mov	r4, r7
  bool bitmapModify(uint32_t cluster, uint32_t count, bool value);
  //----------------------------------------------------------------------------
  // Cache functions.
  uint8_t* bitmapCacheGet(uint32_t sector, uint8_t option) {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.get(sector, option);
    12cc:	ldr.w	r1, [r8, #1060]	; 0x424
    12d0:	movs	r2, #0
    12d2:	add.w	r1, r1, r4, lsr #12
    12d6:	mov	r0, r8
    12d8:	bl	1204 <FsCache::get(unsigned long, unsigned char)>
  uint8_t mask = 1 << (start & 7);
  while (true) {
    uint32_t sector = m_clusterHeapStartSector +
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
    12dc:	cbz	r0, 1310 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x70>
    12de:	ldrb.w	r1, [r0, sl]
    12e2:	b.n	12fa <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x5a>
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
    12e4:	cmp	r2, r9
    12e6:	beq.n	133e <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x9e>
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    12e8:	cmp	r7, r4
    12ea:	beq.n	130e <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x6e>
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
    12ec:	ldr.w	r2, [r8, #1064]	; 0x428
    12f0:	cmp	r4, r2
    12f2:	bcs.n	1324 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x84>
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    12f4:	ands.w	r5, r3, #255	; 0xff
    12f8:	beq.n	1314 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x74>
        endAlloc++;
    12fa:	adds	r4, #1
        if (!(mask & cache[i])) {
    12fc:	tst	r5, r1
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
    12fe:	mov.w	r3, r5, lsl #1
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
    1302:	sub.w	r2, r4, r6
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
    1306:	beq.n	12e4 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x44>
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    1308:	cmp	r7, r4
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
    130a:	mov	r6, r4
            return bgnAlloc + 2;
          }
        } else {
          bgnAlloc = endAlloc;
        }
        if (endAlloc == start) {
    130c:	bne.n	12ec <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x4c>
          return 1;
    130e:	movs	r0, #1
      mask = 1;
    }
    i = 0;
  }
  return 0;
}
    1310:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1314:	add.w	sl, sl, #1
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    1318:	cmp.w	sl, #512	; 0x200
          endAlloc = bgnAlloc = 0;
          i = sectorSize;
          break;
        }
      }
      mask = 1;
    131c:	mov.w	r5, #1
                     (endAlloc >> (m_bytesPerSectorShift + 3));
    cache = bitmapCacheGet(sector, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (; i < sectorSize; i++) {
    1320:	bne.n	12de <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x3e>
    1322:	b.n	1328 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x88>
        }
        if (endAlloc == start) {
          return 1;
        }
        if (endAlloc >= m_clusterCount) {
          endAlloc = bgnAlloc = 0;
    1324:	movs	r6, #0
    1326:	mov	r4, r6
          break;
        }
      }
      mask = 1;
    }
    i = 0;
    1328:	mov.w	sl, #0
    132c:	movs	r5, #1
    132e:	b.n	12cc <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x2c>
    1330:	movs	r7, #0
//-----------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
  if (start >= m_clusterCount) {
    start = 0;
    1332:	mov	sl, r7
    1334:	movs	r5, #1
    1336:	b.n	12c8 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x28>
  return false;
}
//-----------------------------------------------------------------------------
// return 0 if error, 1 if no space, else start cluster.
uint32_t ExFatPartition::bitmapFind(uint32_t cluster, uint32_t count) {
  uint32_t start = cluster ? cluster - 2 : m_bitmapStart;
    1338:	ldr.w	r7, [r0, #1048]	; 0x418
    133c:	b.n	12b0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0x10>
    for (; i < sectorSize; i++) {
      for (; mask; mask <<= 1) {
        endAlloc++;
        if (!(mask & cache[i])) {
          if ((endAlloc - bgnAlloc) == count) {
            if (cluster == 0 && count == 1) {
    133e:	cmp.w	fp, #0
    1342:	bne.n	134e <ExFatPartition::bitmapFind(unsigned long, unsigned long)+0xae>
    1344:	cmp.w	r9, #1
              // Start at found sector.  bitmapModify may increase this.
              m_bitmapStart = bgnAlloc;
    1348:	it	eq
    134a:	streq.w	r6, [r8, #1048]	; 0x418
            }
            return bgnAlloc + 2;
    134e:	adds	r0, r6, #2
    1350:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00001354 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>:

fail:
  return false;
}
//=============================================================================
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    1354:	push	{r3, r4, r5, r6, r7, lr}
    1356:	mov	r4, r0
  pbs_t* pbs;
  BpbExFat_t* bpb;
  MbrSector_t* mbr;
  MbrPart_t* mp;

  m_fatType = 0;
    1358:	movs	r3, #0
#include "ExFatVolume.h"
#include "../common/FsStructs.h"
//-----------------------------------------------------------------------------
void FsCache::invalidate() {
  m_status = 0;
  m_sector = 0XFFFFFFFF;
    135a:	mov.w	r6, #4294967295
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    135e:	add.w	r7, r0, #524	; 0x20c
  BpbExFat_t* bpb;
  MbrSector_t* mbr;
  MbrPart_t* mp;

  m_fatType = 0;
  m_blockDev = dev;
    1362:	str.w	r1, [r0, #1080]	; 0x438
  }
  /** Initialize the cache.
   * \param[in] blockDev Block device for this partition.
   */
  void init(BlockDevice* blockDev) {
    m_blockDev = blockDev;
    1366:	str	r1, [r0, #4]
    1368:	str.w	r1, [r0, #528]	; 0x210

fail:
  return false;
}
//=============================================================================
bool ExFatPartition::init(BlockDevice* dev, uint8_t part) {
    136c:	mov	r5, r2
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    136e:	mov	r0, r7
  pbs_t* pbs;
  BpbExFat_t* bpb;
  MbrSector_t* mbr;
  MbrPart_t* mp;

  m_fatType = 0;
    1370:	strb.w	r3, [r4, #1084]	; 0x43c
#include "../common/DebugMacros.h"
#include "ExFatVolume.h"
#include "../common/FsStructs.h"
//-----------------------------------------------------------------------------
void FsCache::invalidate() {
  m_status = 0;
    1374:	strb	r3, [r4, #0]
    1376:	strb.w	r3, [r4, #524]	; 0x20c
  m_sector = 0XFFFFFFFF;
    137a:	str	r6, [r4, #8]
    137c:	str.w	r6, [r4, #532]	; 0x214
    1380:	mov	r2, r3
    1382:	mov	r1, r3
    1384:	bl	1204 <FsCache::get(unsigned long, unsigned char)>

  m_fatType = 0;
  m_blockDev = dev;
  cacheInit(m_blockDev);
  cache = dataCacheGet(0, FsCache::CACHE_FOR_READ);
  if (part > 4 || !cache) {
    1388:	cmp	r5, #4
    138a:	bhi.n	13f6 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xa2>
    138c:	mov	r6, r0
    138e:	cbz	r0, 13f6 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xa2>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (part >= 1) {
    1390:	cbnz	r5, 13b4 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x60>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  pbs = reinterpret_cast<pbs_t*>(cache);
  if (strncmp(pbs->oemName, "EXFAT", 5)) {
    1392:	movs	r2, #5
    1394:	ldr	r1, [pc, #200]	; (1460 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x10c>)
    1396:	adds	r0, r6, #3
    1398:	bl	be1c <strncmp>
    139c:	mov	r7, r0
    139e:	cmp	r0, #0
    13a0:	bne.n	1454 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x100>
    DBG_FAIL_MACRO;
    goto fail;
  }
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    13a2:	ldrb.w	r3, [r6, #108]	; 0x6c
    13a6:	cmp	r3, #9
    13a8:	beq.n	1400 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0xac>
    DBG_FAIL_MACRO;
    13aa:	movs	r0, #112	; 0x70
    13ac:	bl	1190 <dbgPrint(unsigned short)>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    13b0:	mov	r0, r7
    goto fail;
  }
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    DBG_FAIL_MACRO;
    goto fail;
    13b2:	pop	{r3, r4, r5, r6, r7, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (part >= 1) {
    mbr = reinterpret_cast<MbrSector_t*>(cache);
    mp = &mbr->part[part - 1];
    13b4:	subs	r3, r5, #1
    if ((mp->boot != 0 && mp->boot != 0X80) || mp->type == 0) {
    13b6:	add.w	r3, r0, r3, lsl #4
    13ba:	ldrb.w	r2, [r3, #446]	; 0x1be
    13be:	ands.w	r2, r2, #127	; 0x7f
    13c2:	beq.n	13ce <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x7a>
      DBG_FAIL_MACRO;
    13c4:	movs	r0, #95	; 0x5f
    13c6:	bl	1190 <dbgPrint(unsigned short)>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    13ca:	movs	r0, #0
  if (part >= 1) {
    mbr = reinterpret_cast<MbrSector_t*>(cache);
    mp = &mbr->part[part - 1];
    if ((mp->boot != 0 && mp->boot != 0X80) || mp->type == 0) {
      DBG_FAIL_MACRO;
      goto fail;
    13cc:	pop	{r3, r4, r5, r6, r7, pc}
    goto fail;
  }
  if (part >= 1) {
    mbr = reinterpret_cast<MbrSector_t*>(cache);
    mp = &mbr->part[part - 1];
    if ((mp->boot != 0 && mp->boot != 0X80) || mp->type == 0) {
    13ce:	ldrb.w	r3, [r3, #450]	; 0x1c2
    13d2:	cmp	r3, #0
    13d4:	beq.n	13c4 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x70>
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    13d6:	add.w	r5, r0, r5, lsl #4
    13da:	mov	r0, r7
    13dc:	ldr.w	r5, [r5, #438]	; 0x1b6
    13e0:	mov	r1, r5
    13e2:	bl	1204 <FsCache::get(unsigned long, unsigned char)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    volStart = getLe32(mp->relativeSectors);
    cache = dataCacheGet(volStart, FsCache::CACHE_FOR_READ);
    if (!cache) {
    13e6:	mov	r6, r0
    13e8:	cmp	r0, #0
    13ea:	bne.n	1392 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)+0x3e>
      DBG_FAIL_MACRO;
    13ec:	movs	r0, #101	; 0x65
    13ee:	bl	1190 <dbgPrint(unsigned short)>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    13f2:	mov	r0, r6
    }
    volStart = getLe32(mp->relativeSectors);
    cache = dataCacheGet(volStart, FsCache::CACHE_FOR_READ);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    13f4:	pop	{r3, r4, r5, r6, r7, pc}
  m_fatType = 0;
  m_blockDev = dev;
  cacheInit(m_blockDev);
  cache = dataCacheGet(0, FsCache::CACHE_FOR_READ);
  if (part > 4 || !cache) {
    DBG_FAIL_MACRO;
    13f6:	movs	r0, #88	; 0x58
    13f8:	bl	1190 <dbgPrint(unsigned short)>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    13fc:	movs	r0, #0
  m_blockDev = dev;
  cacheInit(m_blockDev);
  cache = dataCacheGet(0, FsCache::CACHE_FOR_READ);
  if (part > 4 || !cache) {
    DBG_FAIL_MACRO;
    goto fail;
    13fe:	pop	{r3, r4, r5, r6, r7, pc}
  bpb = reinterpret_cast<BpbExFat_t*>(pbs->bpb);
  if (bpb->bytesPerSectorShift != m_bytesPerSectorShift) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_fatStartSector = volStart + getLe32(bpb->fatOffset);
    1400:	ldr	r3, [r6, #80]	; 0x50
    1402:	add	r3, r5
    1404:	str.w	r3, [r4, #1052]	; 0x41c
    1408:	ldr	r3, [r6, #84]	; 0x54
  m_fatLength = getLe32(bpb->fatLength);
    140a:	str.w	r3, [r4, #1056]	; 0x420
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
    140e:	ldr	r3, [r6, #88]	; 0x58
    1410:	add	r5, r3
    1412:	str.w	r5, [r4, #1060]	; 0x424
    1416:	ldr	r3, [r6, #92]	; 0x5c
  m_clusterCount = getLe32(bpb->clusterCount);
    1418:	str.w	r3, [r4, #1064]	; 0x428
    141c:	ldr	r3, [r6, #96]	; 0x60
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
    141e:	str.w	r3, [r4, #1068]	; 0x42c
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
    1422:	ldrb.w	r3, [r6, #109]	; 0x6d
    1426:	strb.w	r3, [r4, #1085]	; 0x43d
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    142a:	movs	r6, #1
    142c:	adds	r3, #9
    142e:	lsl.w	r3, r6, r3
  m_clusterMask = m_bytesPerCluster - 1;
    1432:	subs	r2, r3, #1
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
    1434:	str.w	r0, [r4, #1048]	; 0x418
  bitmapFind(0, 1);
    1438:	mov	r1, r0
  m_fatLength = getLe32(bpb->fatLength);
  m_clusterHeapStartSector = volStart + getLe32(bpb->clusterHeapOffset);
  m_clusterCount = getLe32(bpb->clusterCount);
  m_rootDirectoryCluster = getLe32(bpb->rootDirectoryCluster);
  m_sectorsPerClusterShift = bpb->sectorsPerClusterShift;
  m_bytesPerCluster = 1UL << (m_bytesPerSectorShift + m_sectorsPerClusterShift);
    143a:	str.w	r3, [r4, #1076]	; 0x434
  m_clusterMask = m_bytesPerCluster - 1;
    143e:	str.w	r2, [r4, #1072]	; 0x430
  // Set m_bitmapStart to first free cluster.
  m_bitmapStart = 0;
  bitmapFind(0, 1);
    1442:	mov	r0, r4
    1444:	mov	r2, r6
    1446:	bl	12a0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  m_fatType = FAT_TYPE_EXFAT;
    144a:	movs	r3, #64	; 0x40
    144c:	strb.w	r3, [r4, #1084]	; 0x43c
  return true;
    1450:	mov	r0, r6

 fail:
  return false;
}
    1452:	pop	{r3, r4, r5, r6, r7, pc}
      goto fail;
    }
  }
  pbs = reinterpret_cast<pbs_t*>(cache);
  if (strncmp(pbs->oemName, "EXFAT", 5)) {
    DBG_FAIL_MACRO;
    1454:	movs	r0, #107	; 0x6b
    1456:	bl	1190 <dbgPrint(unsigned short)>
  bitmapFind(0, 1);
  m_fatType = FAT_TYPE_EXFAT;
  return true;

 fail:
  return false;
    145a:	movs	r0, #0
    }
  }
  pbs = reinterpret_cast<pbs_t*>(cache);
  if (strncmp(pbs->oemName, "EXFAT", 5)) {
    DBG_FAIL_MACRO;
    goto fail;
    145c:	pop	{r3, r4, r5, r6, r7, pc}
    145e:	nop
    1460:	.word	0x0000c2a0

00001464 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>:
  }
  return 0;
}
//-----------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    1464:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t sector;
  uint32_t start = cluster - 2;
    1468:	subs	r1, #2
  }
  return 0;
}
//-----------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    146a:	mov	r9, r0
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    146c:	ldr.w	r0, [r0, #1064]	; 0x428
  }
  return 0;
}
//-----------------------------------------------------------------------------
bool ExFatPartition::bitmapModify(uint32_t cluster,
                                  uint32_t count, bool value) {
    1470:	mov	r5, r2
  uint32_t start = cluster - 2;
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    1472:	adds	r2, r1, r2
    1474:	cmp	r2, r0
    1476:	bhi.n	1514 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0xb0>
    1478:	mov	sl, r3
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    147a:	ldr.w	r3, [r9, #1048]	; 0x418
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    147e:	cmp.w	sl, #0
    1482:	bne.n	14ee <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x8a>
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    }
  } else {
    if (start < m_bitmapStart) {
    1484:	cmp	r1, r3
      m_bitmapStart = start;
    1486:	it	cc
    1488:	strcc.w	r1, [r9, #1048]	; 0x418
    }
  }
  mask = 1 << (start & 7);
    148c:	and.w	r4, r1, #7
    1490:	movs	r2, #1
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    1492:	ldr.w	r3, [r9, #1060]	; 0x424
  } else {
    if (start < m_bitmapStart) {
      m_bitmapStart = start;
    }
  }
  mask = 1 << (start & 7);
    1496:	lsl.w	r4, r2, r4
    149a:	uxtb	r4, r4
  sector = m_clusterHeapStartSector +
                   (start >> (m_bytesPerSectorShift + 3));
    149c:	add.w	r8, r3, r1, lsr #12
  i = (start >> 3) & m_sectorMask;
    14a0:	ubfx	fp, r1, #3, #9
  bool bitmapModify(uint32_t cluster, uint32_t count, bool value);
  //----------------------------------------------------------------------------
  // Cache functions.
  uint8_t* bitmapCacheGet(uint32_t sector, uint8_t option) {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.get(sector, option);
    14a4:	movs	r2, #1
    14a6:	mov	r1, r8
    14a8:	mov	r0, r9
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    14aa:	add	r8, r2
    14ac:	bl	1204 <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    14b0:	mov	r6, r0
    14b2:	cbz	r0, 1520 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0xbc>
    14b4:	add.w	r7, r0, fp
    14b8:	add.w	r3, r0, #512	; 0x200
    14bc:	ldrb.w	r2, [r7], #1
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
    14c0:	tst	r2, r4
    14c2:	ite	ne
    14c4:	movne	r6, #1
    14c6:	moveq	r6, #0
    14c8:	cmp	r6, sl
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    14ca:	eor.w	r2, r2, r4
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    14ce:	mov.w	r4, r4, lsl #1
        if (value == static_cast<bool>(cache[i] & mask)) {
    14d2:	beq.n	1502 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x9e>
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
        if (--count == 0) {
    14d4:	subs	r5, #1
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
          DBG_FAIL_MACRO;
          goto fail;
        }
        cache[i] ^= mask;
    14d6:	strb.w	r2, [r7, #-1]
        if (--count == 0) {
    14da:	beq.n	150e <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0xaa>
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
    14dc:	ands.w	r4, r4, #255	; 0xff
    14e0:	bne.n	14c0 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x5c>
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    14e2:	cmp	r3, r7
          return true;
        }
      }
      mask = 1;
    }
    i = 0;
    14e4:	mov	fp, r4
    14e6:	mov.w	r4, #1
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
    14ea:	bne.n	14bc <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x58>
    14ec:	b.n	14a4 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x40>
  if ((start + count) > m_clusterCount) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (value) {
    if (start  <= m_bitmapStart && m_bitmapStart < (start + count)) {
    14ee:	cmp	r1, r3
    14f0:	bhi.n	148c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
    14f2:	cmp	r2, r3
    14f4:	bls.n	148c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
      m_bitmapStart = (start + count) < m_clusterCount ? start + count : 0;
    14f6:	cmp	r2, r0
    14f8:	it	cs
    14fa:	movcs	r2, #0
    14fc:	str.w	r2, [r9, #1048]	; 0x418
    1500:	b.n	148c <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)+0x28>
      goto fail;
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
          DBG_FAIL_MACRO;
    1502:	movs	r0, #216	; 0xd8
    1504:	bl	1190 <dbgPrint(unsigned short)>
    }
    i = 0;
  }

 fail:
  return false;
    1508:	movs	r0, #0
    }
    for (; i < m_bytesPerSector; i++) {
      for (; mask; mask <<= 1) {
        if (value == static_cast<bool>(cache[i] & mask)) {
          DBG_FAIL_MACRO;
          goto fail;
    150a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        }
        cache[i] ^= mask;
        if (--count == 0) {
          return true;
    150e:	movs	r0, #1
    i = 0;
  }

 fail:
  return false;
}
    1510:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  size_t i;
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    DBG_FAIL_MACRO;
    1514:	movs	r0, #191	; 0xbf
    1516:	bl	1190 <dbgPrint(unsigned short)>
    }
    i = 0;
  }

 fail:
  return false;
    151a:	movs	r0, #0
  uint8_t* cache;
  uint8_t mask;
  cluster -= 2;
  if ((start + count) > m_clusterCount) {
    DBG_FAIL_MACRO;
    goto fail;
    151c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                   (start >> (m_bytesPerSectorShift + 3));
  i = (start >> 3) & m_sectorMask;
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
    1520:	movs	r0, #210	; 0xd2
    1522:	bl	1190 <dbgPrint(unsigned short)>
    }
    i = 0;
  }

 fail:
  return false;
    1526:	mov	r0, r6
  i = (start >> 3) & m_sectorMask;
  while (true) {
    cache = bitmapCacheGet(sector++, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
      goto fail;
    1528:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000152c <ExFatPartition::dirCache(DirPos_t*, unsigned char)>:
    n++;
  } while (status);
  return n;
}
//-----------------------------------------------------------------------------
uint8_t* ExFatPartition::dirCache(DirPos_t* pos, uint8_t options) {
    152c:	push	{r3, r4, r5, r6, r7, lr}
    152e:	mov	r6, r1
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    1530:	ldmia.w	r6, {r3, r5}
    1534:	ldr.w	r1, [r0, #1072]	; 0x430
    1538:	ldr.w	r4, [r0, #1060]	; 0x424
    153c:	ldrb.w	r7, [r0, #1085]	; 0x43d
    1540:	ands	r1, r5
    1542:	subs	r3, #2
    1544:	add.w	r1, r4, r1, lsr #9
    1548:	lsls	r3, r7
    154a:	add	r1, r3
    154c:	add.w	r0, r0, #524	; 0x20c
    1550:	bl	1204 <FsCache::get(unsigned long, unsigned char)>
  uint32_t sector = clusterStartSector(pos->cluster);
  sector += (m_clusterMask & pos->position) >> m_bytesPerSectorShift;
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
    1554:	cbz	r0, 155e <ExFatPartition::dirCache(DirPos_t*, unsigned char)+0x32>
    1556:	ldr	r3, [r6, #4]
    1558:	ubfx	r3, r3, #0, #9
    155c:	add	r0, r3
}
    155e:	pop	{r3, r4, r5, r6, r7, pc}

00001560 <ExFatPartition::fatGet(unsigned long, unsigned long*)>:
    }
  }
  return 1;
}
//-----------------------------------------------------------------------------
uint8_t ExFatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    1560:	push	{r3, r4, r5, lr}
  uint8_t* cache;
uint32_t next;
  uint32_t sector;

  if (cluster > (m_clusterCount + 1)) {
    1562:	ldr.w	r3, [r0, #1064]	; 0x428
    1566:	adds	r3, #1
    1568:	cmp	r3, r1
    156a:	bcs.n	1578 <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x18>
    DBG_FAIL_MACRO;
    156c:	mov.w	r0, #276	; 0x114
    1570:	bl	1190 <dbgPrint(unsigned short)>
    return -1;
    1574:	movs	r0, #255	; 0xff
    1576:	pop	{r3, r4, r5, pc}
    1578:	mov	r4, r1
    157a:	ldr.w	r1, [r0, #1052]	; 0x41c
    157e:	mov	r5, r2
    1580:	add.w	r0, r0, #524	; 0x20c
    1584:	add.w	r1, r1, r4, lsr #7
    1588:	movs	r2, #0
    158a:	bl	1204 <FsCache::get(unsigned long, unsigned char)>
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    158e:	cbz	r0, 15a2 <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x42>
    1590:	lsls	r4, r4, #2
    1592:	ubfx	r4, r4, #0, #9
    1596:	ldr	r3, [r0, r4]
    return -1;
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));

  if (next == EXFAT_EOC) {
    1598:	adds	r2, r3, #1
    159a:	beq.n	15a6 <ExFatPartition::fatGet(unsigned long, unsigned long*)+0x46>
    return 0;
  }
  *value = next;
    159c:	str	r3, [r5, #0]
  return 1;
    159e:	movs	r0, #1
    15a0:	pop	{r3, r4, r5, pc}
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));

  cache = dataCacheGet(sector, FsCache::CACHE_FOR_READ);
  if (!cache) {
    return -1;
    15a2:	movs	r0, #255	; 0xff
    15a4:	pop	{r3, r4, r5, pc}
  }
  next = getLe32(cache + ((cluster << 2) & m_sectorMask));

  if (next == EXFAT_EOC) {
    return 0;
    15a6:	movs	r0, #0
  }
  *value = next;
  return 1;
}
    15a8:	pop	{r3, r4, r5, pc}
    15aa:	nop

000015ac <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>:
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//-----------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    15ac:	push	{r4, r5, r6, lr}
    15ae:	mov	r5, r1
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    15b0:	ldr	r1, [r1, #4]
    15b2:	ldr.w	r3, [r0, #1072]	; 0x430
  uint8_t* cache = dataCacheGet(sector, options);
  return cache ? cache + (pos->position & m_sectorMask) : nullptr;
}
//-----------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
    15b6:	mov	r6, r0
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
    15b8:	adds	r0, r1, r2
    15ba:	str	r0, [r5, #4]
  tmp >>= bytesPerClusterShift();
    15bc:	ldrb.w	r4, [r6, #1085]	; 0x43d
}
//-----------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    15c0:	ands	r3, r1
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    15c2:	adds	r4, #9
}
//-----------------------------------------------------------------------------
// return -1 error, 0 EOC, 1 OK
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
    15c4:	add	r2, r3
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
    15c6:	uxtb	r4, r4
    15c8:	lsr.w	r4, r2, r4
  while (tmp--) {
    15cc:	cbz	r4, 15de <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x32>
    if (pos->isContiguous) {
    15ce:	ldrb	r3, [r5, #8]
    15d0:	cbz	r3, 15e2 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x36>
      pos->cluster++;
    15d2:	ldr	r3, [r5, #0]
    15d4:	adds	r3, #1
    15d6:	str	r3, [r5, #0]
    15d8:	subs	r4, #1
int8_t ExFatPartition::dirSeek(DirPos_t* pos, uint32_t offset) {
  int8_t status;
  uint32_t tmp = (m_clusterMask & pos->position) + offset;
  pos->position += offset;
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    15da:	cmp	r4, #0
    15dc:	bne.n	15ce <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x22>
      if (status != 1) {
        return status;
      }
    }
  }
  return 1;
    15de:	movs	r0, #1
}
    15e0:	pop	{r4, r5, r6, pc}
  tmp >>= bytesPerClusterShift();
  while (tmp--) {
    if (pos->isContiguous) {
      pos->cluster++;
    } else {
      status = fatGet(pos->cluster, &pos->cluster);
    15e2:	mov	r2, r5
    15e4:	ldr	r1, [r5, #0]
    15e6:	mov	r0, r6
    15e8:	bl	1560 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    15ec:	sxtb	r0, r0
      if (status != 1) {
    15ee:	cmp	r0, #1
    15f0:	beq.n	15d8 <ExFatPartition::dirSeek(DirPos_t*, unsigned long)+0x2c>
    15f2:	pop	{r4, r5, r6, pc}

000015f4 <ExFatPartition::fatPut(unsigned long, unsigned long)>:
}
//-----------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    15f4:	cmp	r1, #1
  }
  *value = next;
  return 1;
}
//-----------------------------------------------------------------------------
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
    15f6:	push	{r4, r5, r6, lr}
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    15f8:	bls.n	1606 <ExFatPartition::fatPut(unsigned long, unsigned long)+0x12>
    15fa:	ldr.w	r3, [r0, #1064]	; 0x428
    15fe:	adds	r3, #1
    1600:	cmp	r1, r3
    1602:	mov	r4, r1
    1604:	bls.n	1612 <ExFatPartition::fatPut(unsigned long, unsigned long)+0x1e>
    DBG_FAIL_MACRO;
    1606:	mov.w	r0, #298	; 0x12a
    160a:	bl	1190 <dbgPrint(unsigned short)>
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;

 fail:
  return false;
    160e:	movs	r0, #0
bool ExFatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  uint8_t* cache;
  if (cluster < 2 || cluster > (m_clusterCount + 1)) {
    DBG_FAIL_MACRO;
    goto fail;
    1610:	pop	{r4, r5, r6, pc}
    1612:	ldr.w	r1, [r0, #1052]	; 0x41c
    1616:	mov	r5, r2
    1618:	add.w	r0, r0, #524	; 0x20c
    161c:	add.w	r1, r1, r4, lsr #7
    1620:	movs	r2, #1
    1622:	bl	1204 <FsCache::get(unsigned long, unsigned char)>
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
  cache = dataCacheGet(sector, FsCache::CACHE_FOR_WRITE);
  if (!cache) {
    1626:	mov	r6, r0
    1628:	cbz	r0, 1636 <ExFatPartition::fatPut(unsigned long, unsigned long)+0x42>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    162a:	lsls	r4, r4, #2
    162c:	ubfx	r4, r4, #0, #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;
    1630:	movs	r0, #1
    1632:	str	r5, [r6, r4]

 fail:
  return false;
}
    1634:	pop	{r4, r5, r6, pc}
    goto fail;
  }
  sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
  cache = dataCacheGet(sector, FsCache::CACHE_FOR_WRITE);
  if (!cache) {
    DBG_FAIL_MACRO;
    1636:	mov.w	r0, #304	; 0x130
    163a:	bl	1190 <dbgPrint(unsigned short)>
  }
  setLe32(cache + ((cluster << 2) & m_sectorMask), value);
  return true;

 fail:
  return false;
    163e:	mov	r0, r6
    1640:	pop	{r4, r5, r6, pc}
    1642:	nop

00001644 <ExFatPartition::freeChain(unsigned long)>:
}
//-----------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
    1644:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1648:	mov	r4, r1
    164a:	sub	sp, #12
    164c:	mov	r6, r0
  uint32_t next;
  uint32_t start = cluster;
    164e:	mov	r8, r1
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    1650:	mov	r1, r4
    1652:	add	r2, sp, #4
    1654:	mov	r0, r6
    1656:	bl	1560 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    165a:	movs	r2, #0
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    165c:	sxtb	r5, r0
    if (status < 0) {
    165e:	cmp	r5, r2
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    1660:	mov	r1, r4
    1662:	mov	r0, r6
      DBG_FAIL_MACRO;
      goto fail;
    }
    if ((cluster + 1) != next || status == 0) {
    1664:	add.w	r4, r4, #1
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    if (status < 0) {
    1668:	blt.n	16bc <ExFatPartition::freeChain(unsigned long)+0x78>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    166a:	bl	15f4 <ExFatPartition::fatPut(unsigned long, unsigned long)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if ((cluster + 1) != next || status == 0) {
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    166e:	rsb	r2, r8, r4
    status = fatGet(cluster, &next);
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    1672:	mov	r9, r0
      DBG_FAIL_MACRO;
      goto fail;
    }
    if ((cluster + 1) != next || status == 0) {
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    1674:	mov	r1, r8
    1676:	movs	r3, #0
    status = fatGet(cluster, &next);
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
    1678:	cbz	r0, 16d0 <ExFatPartition::freeChain(unsigned long)+0x8c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if ((cluster + 1) != next || status == 0) {
    167a:	ldr	r7, [sp, #4]
    167c:	cmp	r4, r7
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    167e:	mov	r0, r6
    }
    if (!fatPut(cluster, 0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if ((cluster + 1) != next || status == 0) {
    1680:	bne.n	16aa <ExFatPartition::freeChain(unsigned long)+0x66>
    1682:	cmp	r5, #0
    1684:	bne.n	1650 <ExFatPartition::freeChain(unsigned long)+0xc>
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    1686:	mov	r3, r5
    1688:	rsb	r2, r8, r4
    168c:	mov	r1, r8
    168e:	mov	r0, r6
    1690:	bl	1464 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    1694:	cbnz	r0, 16a2 <ExFatPartition::freeChain(unsigned long)+0x5e>
        DBG_FAIL_MACRO;
    1696:	mov.w	r0, #330	; 0x14a
    169a:	bl	1190 <dbgPrint(unsigned short)>
  } while (status);

  return true;

 fail:
  return false;
    169e:	mov.w	r9, #0
}
    16a2:	mov	r0, r9
    16a4:	add	sp, #12
    16a6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (!fatPut(cluster, 0)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if ((cluster + 1) != next || status == 0) {
      if (!bitmapModify(start, cluster - start + 1, 0)) {
    16aa:	bl	1464 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    16ae:	cmp	r0, #0
    16b0:	beq.n	1696 <ExFatPartition::freeChain(unsigned long)+0x52>
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    16b2:	ldr	r4, [sp, #4]
//-----------------------------------------------------------------------------
bool ExFatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  uint32_t start = cluster;
  int8_t status;
  do {
    16b4:	cmp	r5, #0
    16b6:	beq.n	16a2 <ExFatPartition::freeChain(unsigned long)+0x5e>
    if ((cluster + 1) != next || status == 0) {
      if (!bitmapModify(start, cluster - start + 1, 0)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      start = next;
    16b8:	mov	r8, r4
    16ba:	b.n	1650 <ExFatPartition::freeChain(unsigned long)+0xc>
  uint32_t start = cluster;
  int8_t status;
  do {
    status = fatGet(cluster, &next);
    if (status < 0) {
      DBG_FAIL_MACRO;
    16bc:	movw	r0, #321	; 0x141
    16c0:	bl	1190 <dbgPrint(unsigned short)>
  } while (status);

  return true;

 fail:
  return false;
    16c4:	mov.w	r9, #0
}
    16c8:	mov	r0, r9
    16ca:	add	sp, #12
    16cc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (status < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!fatPut(cluster, 0)) {
      DBG_FAIL_MACRO;
    16d0:	movw	r0, #325	; 0x145
    16d4:	bl	1190 <dbgPrint(unsigned short)>

  return true;

 fail:
  return false;
}
    16d8:	mov	r0, r9
    16da:	add	sp, #12
    16dc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

000016e0 <ExFatPartition::freeClusterCount()>:
//-----------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    16e0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
    16e4:	movs	r4, #0
  return false;
}
//-----------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
  uint32_t nc = 0;
  uint32_t sector = m_clusterHeapStartSector;
    16e6:	ldr.w	r6, [r0, #1060]	; 0x424

 fail:
  return false;
}
//-----------------------------------------------------------------------------
uint32_t ExFatPartition::freeClusterCount() {
    16ea:	mov	r8, r0
    16ec:	add.w	r7, r0, #524	; 0x20c
  uint32_t nc = 0;
    16f0:	mov	r5, r4
    16f2:	mov	r1, r6
    16f4:	movs	r2, #0
    16f6:	mov	r0, r7
  uint32_t sector = m_clusterHeapStartSector;
  uint32_t usedCount = 0;
  uint8_t* cache;

  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    16f8:	adds	r6, #1
    16fa:	bl	1204 <FsCache::get(unsigned long, unsigned char)>
    if (!cache) {
    16fe:	cbz	r0, 174e <ExFatPartition::freeClusterCount()+0x6e>
    1700:	add.w	lr, r0, #4294967295
    1704:	ldr.w	ip, [r8, #1064]	; 0x428
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
    1708:	ldrb.w	r0, [lr, #1]!
    170c:	cmp	r0, #255	; 0xff
    170e:	add.w	r9, r5, #4096	; 0x1000
    1712:	beq.n	173c <ExFatPartition::freeClusterCount()+0x5c>
        usedCount+= 8;
      } else if (cache[i]) {
    1714:	cbz	r0, 172a <ExFatPartition::freeClusterCount()+0x4a>
    1716:	movs	r2, #8
    1718:	movs	r3, #1
        for (uint8_t mask = 1; mask ; mask <<=1) {
          if ((mask & cache[i])) {
    171a:	tst	r0, r3
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    171c:	mov.w	r1, r3, lsl #1
          if ((mask & cache[i])) {
            usedCount++;
    1720:	it	ne
    1722:	addne	r4, #1
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
      } else if (cache[i]) {
        for (uint8_t mask = 1; mask ; mask <<=1) {
    1724:	subs	r2, #1
    1726:	uxtb	r3, r1
    1728:	bne.n	171a <ExFatPartition::freeClusterCount()+0x3a>
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    172a:	adds	r5, #8
      if (nc >= m_clusterCount) {
    172c:	cmp	ip, r5
    172e:	bls.n	1746 <ExFatPartition::freeClusterCount()+0x66>
  while (true) {
    cache = dataCacheGet(sector++, FsCache::CACHE_FOR_READ);
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
    1730:	cmp	r5, r9
    1732:	beq.n	16f2 <ExFatPartition::freeClusterCount()+0x12>
      if (cache[i] == 0XFF) {
    1734:	ldrb.w	r0, [lr, #1]!
    1738:	cmp	r0, #255	; 0xff
    173a:	bne.n	1714 <ExFatPartition::freeClusterCount()+0x34>
          if ((mask & cache[i])) {
            usedCount++;
          }
        }
      }
      nc += 8;
    173c:	adds	r5, #8
      if (nc >= m_clusterCount) {
    173e:	cmp	ip, r5
    if (!cache) {
      return 0;
    }
    for (size_t i = 0; i < m_bytesPerSector; i++) {
      if (cache[i] == 0XFF) {
        usedCount+= 8;
    1740:	add.w	r4, r4, #8
            usedCount++;
          }
        }
      }
      nc += 8;
      if (nc >= m_clusterCount) {
    1744:	bhi.n	1730 <ExFatPartition::freeClusterCount()+0x50>
        return m_clusterCount - usedCount;
    1746:	rsb	r0, r4, ip
    174a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      }
    }
  }
}
    174e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    1752:	nop

00001754 <ExFatPartition::rootLength()>:
//-----------------------------------------------------------------------------
uint32_t ExFatPartition::rootLength() {
    1754:	push	{r4, r5, r6, lr}
    1756:	sub	sp, #8
    1758:	add	r6, sp, #8
  uint32_t nc = chainSize(m_rootDirectoryCluster);
    175a:	ldr.w	r1, [r0, #1068]	; 0x42c
    175e:	str.w	r1, [r6, #-4]!
      }
    }
  }
}
//-----------------------------------------------------------------------------
uint32_t ExFatPartition::rootLength() {
    1762:	mov	r5, r0
 fail:
  return false;
}
//-----------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
    1764:	movs	r4, #0
    1766:	b.n	1770 <ExFatPartition::rootLength()+0x1c>
  int8_t status;
  do {
    status = fatGet(cluster, & cluster);
    if (status < 0) return 0;
    n++;
    1768:	add.w	r4, r4, #1
}
//-----------------------------------------------------------------------------
uint32_t ExFatPartition::chainSize(uint32_t cluster) {
  uint32_t n = 0;
  int8_t status;
  do {
    176c:	beq.n	1780 <ExFatPartition::rootLength()+0x2c>
    176e:	ldr	r1, [sp, #4]
    status = fatGet(cluster, & cluster);
    1770:	mov	r2, r6
    1772:	mov	r0, r5
    1774:	bl	1560 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    1778:	sxtb	r0, r0
    if (status < 0) return 0;
    177a:	cmp	r0, #0
    177c:	bge.n	1768 <ExFatPartition::rootLength()+0x14>
    177e:	movs	r4, #0
  }
}
//-----------------------------------------------------------------------------
uint32_t ExFatPartition::rootLength() {
  uint32_t nc = chainSize(m_rootDirectoryCluster);
  return nc << bytesPerClusterShift();
    1780:	ldrb.w	r0, [r5, #1085]	; 0x43d
    1784:	adds	r0, #9
    1786:	uxtb	r0, r0
}
    1788:	lsl.w	r0, r4, r0
    178c:	add	sp, #8
    178e:	pop	{r4, r5, r6, pc}

00001790 <exFatHashName(char const*, unsigned int, unsigned short)>:
static char toUpper(char c) {
  return c - ('a' <= c && c <= 'z' ? 'a' - 'A' : 0);
}
//-----------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
  for (size_t i = 0; i < n; i++) {
    1790:	cbz	r1, 17c6 <exFatHashName(char const*, unsigned int, unsigned short)+0x36>
//-----------------------------------------------------------------------------
static char toUpper(char c) {
  return c - ('a' <= c && c <= 'z' ? 'a' - 'A' : 0);
}
//-----------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
    1792:	push	{r4}
    1794:	add	r1, r0
    1796:	lsls	r3, r2, #15
    1798:	orr.w	r3, r3, r2, lsr #1
  for (size_t i = 0; i < n; i++) {
    uint8_t c = name[i];
    179c:	ldrb.w	r2, [r0], #1
    if ('a' <= c && c <= 'z') {
    17a0:	sub.w	r4, r2, #97	; 0x61
    17a4:	cmp	r4, #25
      c -= 'a' - 'A';
    17a6:	itt	ls
    17a8:	subls	r2, #32
    17aa:	uxtbls	r2, r2
    }
    hash = ((hash << 15) | (hash >> 1)) + c;
    17ac:	uxtah	r2, r2, r3
    17b0:	uxth	r2, r2
    17b2:	lsls	r3, r2, #15
    17b4:	orr.w	r2, r3, r2, lsr #1
static char toUpper(char c) {
  return c - ('a' <= c && c <= 'z' ? 'a' - 'A' : 0);
}
//-----------------------------------------------------------------------------
uint16_t exFatHashName(const char* name, size_t n, uint16_t hash) {
  for (size_t i = 0; i < n; i++) {
    17b8:	cmp	r1, r0
    17ba:	uxth	r2, r2
    17bc:	bne.n	1796 <exFatHashName(char const*, unsigned int, unsigned short)+0x6>
    }
    hash = ((hash << 15) | (hash >> 1)) + c;
    hash = ((hash << 15) | (hash >> 1));
  }
  return hash;
}
    17be:	mov	r0, r2
    17c0:	ldr.w	r4, [sp], #4
    17c4:	bx	lr
    17c6:	mov	r0, r2
    17c8:	bx	lr
    17ca:	nop

000017cc <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)>:
//-----------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    17cc:	cbz	r3, 1820 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x54>
  }
  return hash;
}
//-----------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
    17ce:	push	{r4, r5, r6}
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    17d0:	ldrh	r4, [r0, #2]
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    17d2:	cmp	r4, #126	; 0x7e
    17d4:	bhi.n	1814 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x48>
    17d6:	add	r3, r2
    17d8:	adds	r5, r1, r3
    17da:	add	r2, r1
    17dc:	adds	r0, #2
    17de:	ldrb.w	r3, [r2], #1
    17e2:	uxtb	r4, r4
  }
  return true;
}
//-----------------------------------------------------------------------------
static char toUpper(char c) {
  return c - ('a' <= c && c <= 'z' ? 'a' - 'A' : 0);
    17e4:	sub.w	r1, r3, #97	; 0x61
    17e8:	cmp	r1, #25
    17ea:	sub.w	r1, r4, #97	; 0x61
    17ee:	ite	ls
    17f0:	movls	r6, #32
    17f2:	movhi	r6, #0
    17f4:	cmp	r1, #25
    17f6:	ite	ls
    17f8:	movls	r1, #32
    17fa:	movhi	r1, #0
    17fc:	subs	r3, r3, r6
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    17fe:	subs	r4, r4, r1
  }
  return true;
}
//-----------------------------------------------------------------------------
static char toUpper(char c) {
  return c - ('a' <= c && c <= 'z' ? 'a' - 'A' : 0);
    1800:	uxtb	r3, r3
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    1802:	uxtb	r4, r4
    1804:	cmp	r4, r3
    1806:	bne.n	1814 <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x48>
}
//-----------------------------------------------------------------------------
bool exFatCmpName(const DirName_t* unicode,
                  const char* name, size_t offset, size_t n) {
  uint16_t u;
  for (size_t i = 0; i < n; i++) {
    1808:	cmp	r2, r5
    180a:	beq.n	181a <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x4e>
    180c:	ldrh.w	r4, [r0, #2]!
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
    1810:	cmp	r4, #126	; 0x7e
    1812:	bls.n	17de <exFatCmpName(DirName_t const*, char const*, unsigned int, unsigned int)+0x12>
      return false;
    1814:	movs	r0, #0
    }
  }
  return true;
}
    1816:	pop	{r4, r5, r6}
    1818:	bx	lr
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
      return false;
    }
  }
  return true;
    181a:	movs	r0, #1
}
    181c:	pop	{r4, r5, r6}
    181e:	bx	lr
    u = getLe16(unicode->unicode + 2*i);
    if (u >= 0x7F  || toUpper(name[i + offset]) != toUpper(u)) {
      return false;
    }
  }
  return true;
    1820:	movs	r0, #1
}
    1822:	bx	lr

00001824 <dbgPrint(unsigned short)>:
#if USE_DBG_MACROS
#include "Arduino.h"
#ifndef DBG_FILE
#error DBG_FILE not defined
#endif  // DBG_FILE
static void dbgPrint(uint16_t line) {
    1824:	push	{r3, r4, r5, lr}
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    1826:	movs	r1, #10
    1828:	mov	r5, r0
    182a:	ldr	r0, [pc, #40]	; (1854 <dbgPrint(unsigned short)+0x30>)
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    182c:	ldr	r4, [pc, #40]	; (1858 <dbgPrint(unsigned short)+0x34>)
    182e:	bl	8e24 <usb_serial_write>
    1832:	movs	r1, #18
    1834:	ldr	r0, [pc, #36]	; (185c <dbgPrint(unsigned short)+0x38>)
    1836:	bl	8e24 <usb_serial_write>
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    183a:	movs	r0, #46	; 0x2e
    183c:	bl	8f2c <usb_serial_putchar>
    1840:	mov	r1, r5
    1842:	mov	r0, r4
    1844:	bl	ae20 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    1848:	mov	r0, r4
  Serial.print(F("DBG_FAIL: "));
  Serial.print(F(DBG_FILE));
  Serial.write('.');
  Serial.println(line);
}
    184a:	ldmia.w	sp!, {r3, r4, r5, lr}
    184e:	b.w	ad80 <Print::println()>
    1852:	nop
    1854:	.word	0x0000c270
    1858:	.word	0x1fff099c
    185c:	.word	0x0000c2a8

00001860 <ExFatFile::addCluster()>:
  }
  return checksum;
}
//-----------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    1860:	ldr	r1, [r0, #24]
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
  }
  return checksum;
}
//-----------------------------------------------------------------------------
bool ExFatFile::addCluster() {
    1862:	push	{r3, r4, r5, r6, r7, lr}
    1864:	mov	r4, r0
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    1866:	ldr	r0, [r0, #32]
    1868:	cbz	r1, 186c <ExFatFile::addCluster()+0xc>
    186a:	adds	r1, #1
    186c:	movs	r2, #1
    186e:	bl	12a0 <ExFatPartition::bitmapFind(unsigned long, unsigned long)>
  if (find < 2) {
    1872:	cmp	r0, #1
  }
  return checksum;
}
//-----------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
    1874:	mov	r6, r0
  if (find < 2) {
    1876:	bls.n	18fc <ExFatFile::addCluster()+0x9c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    1878:	movs	r3, #1
    187a:	mov	r1, r0
    187c:	mov	r2, r3
    187e:	ldr	r0, [r4, #32]
    1880:	bl	1464 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    1884:	mov	r7, r0
    1886:	cmp	r0, #0
    1888:	beq.n	1908 <ExFatFile::addCluster()+0xa8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    188a:	ldr	r0, [r4, #24]
    m_flags |= FILE_FLAG_CONTIGUOUS;
    188c:	ldrb.w	r3, [r4, #51]	; 0x33
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_curCluster == 0) {
    1890:	cbnz	r0, 18a0 <ExFatFile::addCluster()+0x40>
    m_flags |= FILE_FLAG_CONTIGUOUS;
    1892:	orr.w	r3, r3, #64	; 0x40
    1896:	strb.w	r3, [r4, #51]	; 0x33
      goto fail;
    }
  }

 done:
  m_curCluster = find;
    189a:	str	r6, [r4, #24]
  return true;

 fail:
  return false;
}
    189c:	mov	r0, r7
    189e:	pop	{r3, r4, r5, r6, r7, pc}
  }
  if (m_curCluster == 0) {
    m_flags |= FILE_FLAG_CONTIGUOUS;
    goto done;
  }
  if (isContiguous()) {
    18a0:	lsls	r2, r3, #25
    18a2:	bpl.n	18ce <ExFatFile::addCluster()+0x6e>
    if (find == (m_curCluster + 1)) {
    18a4:	adds	r2, r0, #1
    18a6:	cmp	r6, r2
    18a8:	beq.n	189a <ExFatFile::addCluster()+0x3a>
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    18aa:	bic.w	r2, r3, #64	; 0x40
    18ae:	strb.w	r2, [r4, #51]	; 0x33

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    18b2:	ldr	r3, [r4, #28]
    18b4:	b.n	18c4 <ExFatFile::addCluster()+0x64>
      if (!m_vol->fatPut(c, c + 1)) {
    18b6:	ldr	r0, [r4, #32]
    18b8:	bl	15f4 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    18bc:	mov	r3, r0
    18be:	cbz	r0, 1912 <ExFatFile::addCluster()+0xb2>
    18c0:	ldr	r0, [r4, #24]
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    18c2:	mov	r3, r5
      if (!m_vol->fatPut(c, c + 1)) {
    18c4:	adds	r5, r3, #1
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    18c6:	cmp	r3, r0
      if (!m_vol->fatPut(c, c + 1)) {
    18c8:	mov	r1, r3
    18ca:	mov	r2, r5
      goto done;
    }
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
    18cc:	bcc.n	18b6 <ExFatFile::addCluster()+0x56>
        goto fail;
      }
    }
  }
  // New cluster is EOC.
  if (!m_vol->fatPut(find, EXFAT_EOC)) {
    18ce:	mov.w	r2, #4294967295
    18d2:	mov	r1, r6
    18d4:	ldr	r0, [r4, #32]
    18d6:	bl	15f4 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    18da:	mov	r3, r0
    18dc:	cbz	r0, 191c <ExFatFile::addCluster()+0xbc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Connect new cluster to existing chain.
  if (m_curCluster) {
    18de:	ldr	r1, [r4, #24]
    18e0:	cmp	r1, #0
    18e2:	beq.n	189a <ExFatFile::addCluster()+0x3a>
    if (!m_vol->fatPut(m_curCluster, find)) {
    18e4:	mov	r2, r6
    18e6:	ldr	r0, [r4, #32]
    18e8:	bl	15f4 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    18ec:	mov	r3, r0
    18ee:	cmp	r0, #0
    18f0:	bne.n	189a <ExFatFile::addCluster()+0x3a>
      DBG_FAIL_MACRO;
    18f2:	movs	r0, #110	; 0x6e
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    18f4:	mov	r7, r3
    goto fail;
  }
  // Connect new cluster to existing chain.
  if (m_curCluster) {
    if (!m_vol->fatPut(m_curCluster, find)) {
      DBG_FAIL_MACRO;
    18f6:	bl	1824 <dbgPrint(unsigned short)>
      goto fail;
    18fa:	b.n	189c <ExFatFile::addCluster()+0x3c>
}
//-----------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
  if (find < 2) {
    DBG_FAIL_MACRO;
    18fc:	movs	r0, #77	; 0x4d
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    18fe:	movs	r7, #0
}
//-----------------------------------------------------------------------------
bool ExFatFile::addCluster() {
  uint32_t find = m_vol->bitmapFind(m_curCluster ?  m_curCluster + 1 : 0, 1);
  if (find < 2) {
    DBG_FAIL_MACRO;
    1900:	bl	1824 <dbgPrint(unsigned short)>
  m_curCluster = find;
  return true;

 fail:
  return false;
}
    1904:	mov	r0, r7
    1906:	pop	{r3, r4, r5, r6, r7, pc}
  if (find < 2) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!m_vol->bitmapModify(find, 1, 1)) {
    DBG_FAIL_MACRO;
    1908:	movs	r0, #81	; 0x51
    190a:	bl	1824 <dbgPrint(unsigned short)>
  m_curCluster = find;
  return true;

 fail:
  return false;
}
    190e:	mov	r0, r7
    1910:	pop	{r3, r4, r5, r6, r7, pc}
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
      if (!m_vol->fatPut(c, c + 1)) {
        DBG_FAIL_MACRO;
    1912:	movs	r0, #97	; 0x61
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    1914:	mov	r7, r3
    // No longer contiguous so make FAT chain.
    m_flags &= ~FILE_FLAG_CONTIGUOUS;

    for (uint32_t c = m_firstCluster; c < m_curCluster; c++) {
      if (!m_vol->fatPut(c, c + 1)) {
        DBG_FAIL_MACRO;
    1916:	bl	1824 <dbgPrint(unsigned short)>
        goto fail;
    191a:	b.n	189c <ExFatFile::addCluster()+0x3c>
      }
    }
  }
  // New cluster is EOC.
  if (!m_vol->fatPut(find, EXFAT_EOC)) {
    DBG_FAIL_MACRO;
    191c:	movs	r0, #104	; 0x68
 done:
  m_curCluster = find;
  return true;

 fail:
  return false;
    191e:	mov	r7, r3
      }
    }
  }
  // New cluster is EOC.
  if (!m_vol->fatPut(find, EXFAT_EOC)) {
    DBG_FAIL_MACRO;
    1920:	bl	1824 <dbgPrint(unsigned short)>
    goto fail;
    1924:	b.n	189c <ExFatFile::addCluster()+0x3c>
    1926:	nop

00001928 <ExFatFile::remove()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    1928:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  DirPos_t pos = m_dirPos;
    192c:	add.w	r3, r0, #36	; 0x24

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    1930:	mov	r5, r0
  DirPos_t pos = m_dirPos;
    1932:	ldmia.w	r3, {r0, r1, r2}
    1936:	ldrb.w	r7, [r5, #51]	; 0x33

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
    193a:	sub	sp, #20
  DirPos_t pos = m_dirPos;
    193c:	add	r6, sp, #4
  uint8_t* cache;
  if (!isWritable()) {
    193e:	and.w	r4, r7, #2
 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
  DirPos_t pos = m_dirPos;
    1942:	stmia.w	r6, {r0, r1, r2}
  uint8_t* cache;
  if (!isWritable()) {
    1946:	cmp	r4, #0
    1948:	beq.n	1a24 <ExFatFile::remove()+0xfc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    194a:	ldr	r1, [r5, #28]
    194c:	cbnz	r1, 1998 <ExFatFile::remove()+0x70>
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    194e:	movs	r4, #0
  for (uint8_t i = 0; i <= m_setCount; i++) {
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_WRITE);
    1950:	movs	r2, #1
    1952:	mov	r1, r6
    1954:	ldr	r0, [r5, #32]
    1956:	bl	152c <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
        goto fail;
      }
    }
  }

  for (uint8_t i = 0; i <= m_setCount; i++) {
    195a:	adds	r4, #1
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
    195c:	mov	r3, r0
        goto fail;
      }
    }
  }

  for (uint8_t i = 0; i <= m_setCount; i++) {
    195e:	uxtb	r4, r4
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
    1960:	cmp	r0, #0
    1962:	beq.n	1a12 <ExFatFile::remove()+0xea>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
    1964:	ldrb	r2, [r3, #0]
    1966:	and.w	r2, r2, #127	; 0x7f
    196a:	strb	r2, [r3, #0]
        goto fail;
      }
    }
  }

  for (uint8_t i = 0; i <= m_setCount; i++) {
    196c:	ldrb.w	r3, [r5, #48]	; 0x30
    1970:	cmp	r3, r4
    1972:	bcc.n	19e2 <ExFatFile::remove()+0xba>
    if (i && m_vol->dirSeek(&pos, 32) != 1) {
    1974:	cmp	r4, #0
    1976:	beq.n	1950 <ExFatFile::remove()+0x28>
    1978:	movs	r2, #32
    197a:	mov	r1, r6
    197c:	ldr	r0, [r5, #32]
    197e:	bl	15ac <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    1982:	cmp	r0, #1
    1984:	beq.n	1950 <ExFatFile::remove()+0x28>
      DBG_FAIL_MACRO;
    1986:	movw	r0, #287	; 0x11f
    198a:	bl	1824 <dbgPrint(unsigned short)>

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    198e:	movs	r4, #0
}
    1990:	mov	r0, r4
    1992:	add	sp, #20
    1994:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    1998:	lsls	r3, r7, #25
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    199a:	ldr	r0, [r5, #32]
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster) {
    if (isContiguous()) {
    199c:	bpl.n	1a3a <ExFatFile::remove()+0x112>
      uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
      if (!m_vol->bitmapModify(m_firstCluster, nc, 0)) {
    199e:	ldrd	r2, r3, [r5, #8]
    19a2:	ldrb.w	r4, [r0, #1085]	; 0x43d
    19a6:	adds	r4, #9
    19a8:	uxtb	r4, r4
    19aa:	adds.w	r8, r2, #4294967295
    19ae:	adc.w	r9, r3, #4294967295
    19b2:	rsb	r7, r4, #32
    19b6:	lsr.w	r2, r8, r4
    19ba:	sub.w	r3, r4, #32
    19be:	lsl.w	r7, r9, r7
    19c2:	lsr.w	r3, r9, r3
    19c6:	orrs	r2, r7
    19c8:	orrs	r2, r3
    19ca:	adds	r2, #1
    19cc:	movs	r3, #0
    19ce:	bl	1464 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    19d2:	mov	r4, r0
    19d4:	cmp	r0, #0
    19d6:	bne.n	194e <ExFatFile::remove()+0x26>
        DBG_FAIL_MACRO;
    19d8:	mov.w	r0, #274	; 0x112
    19dc:	bl	1824 <dbgPrint(unsigned short)>
        goto fail;
    19e0:	b.n	1990 <ExFatFile::remove()+0x68>
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;

  // Write entry to device.
  return m_vol->cacheSync();
    19e2:	ldr	r4, [r5, #32]
    }
    // Mark entry not used.
    cache[0] &= 0x7F;
  }
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    19e4:	movs	r3, #0
    19e6:	mov	r0, r4
    19e8:	strb.w	r3, [r5, #49]	; 0x31
  m_flags = 0;
    19ec:	strb.w	r3, [r5, #51]	; 0x33
    19f0:	bl	1290 <FsCache::sync()>
    19f4:	cmp	r0, #0
    19f6:	beq.n	198e <ExFatFile::remove()+0x66>
    19f8:	add.w	r0, r4, #524	; 0x20c
    19fc:	bl	1290 <FsCache::sync()>
    1a00:	cmp	r0, #0
    1a02:	beq.n	198e <ExFatFile::remove()+0x66>
    1a04:	ldr.w	r0, [r4, #1080]	; 0x438
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    1a08:	ldr	r3, [r0, #0]
    1a0a:	ldr	r3, [r3, #20]
    1a0c:	blx	r3
    1a0e:	mov	r4, r0
    1a10:	b.n	1990 <ExFatFile::remove()+0x68>
      DBG_FAIL_MACRO;
      goto fail;
    }
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
    1a12:	mov.w	r0, #292	; 0x124

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    1a16:	mov	r4, r3
      DBG_FAIL_MACRO;
      goto fail;
    }
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_WRITE);
    if (!cache) {
      DBG_FAIL_MACRO;
    1a18:	bl	1824 <dbgPrint(unsigned short)>
  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
}
    1a1c:	mov	r0, r4
    1a1e:	add	sp, #20
    1a20:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    1a24:	and.w	r3, r4, #255	; 0xff
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
  DirPos_t pos = m_dirPos;
  uint8_t* cache;
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    1a28:	mov.w	r0, #266	; 0x10a

  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
    1a2c:	mov	r4, r3
//------------------------------------------------------------------------------
bool ExFatFile::remove() {
  DirPos_t pos = m_dirPos;
  uint8_t* cache;
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    1a2e:	bl	1824 <dbgPrint(unsigned short)>
  // Write entry to device.
  return m_vol->cacheSync();

 fail:
  return false;
}
    1a32:	mov	r0, r4
    1a34:	add	sp, #20
    1a36:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (!m_vol->bitmapModify(m_firstCluster, nc, 0)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    } else {
      if (!m_vol->freeChain(m_firstCluster)) {
    1a3a:	bl	1644 <ExFatPartition::freeChain(unsigned long)>
    1a3e:	mov	r4, r0
    1a40:	cmp	r0, #0
    1a42:	bne.n	194e <ExFatFile::remove()+0x26>
        DBG_FAIL_MACRO;
    1a44:	movw	r0, #279	; 0x117
    1a48:	bl	1824 <dbgPrint(unsigned short)>
        goto fail;
    1a4c:	b.n	1990 <ExFatFile::remove()+0x68>
    1a4e:	nop

00001a50 <ExFatFile::rmdir()>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    1a50:	push	{r4, r5, lr}
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    1a52:	ldrb.w	r3, [r0, #49]	; 0x31
    1a56:	and.w	r3, r3, #16

fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::rmdir() {
    1a5a:	sub	sp, #36	; 0x24
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    1a5c:	cbz	r3, 1aa2 <ExFatFile::rmdir()+0x52>
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    1a5e:	movs	r2, #0
    1a60:	movs	r3, #0
    1a62:	mov	r4, r0
    1a64:	bl	ae0 <ExFatFile::seekSet(unsigned long long)>
    1a68:	b.n	1a78 <ExFatFile::rmdir()+0x28>
  while (1) {
    n = read(dir, 32);
    if (n == 0) {
      break;
    }
    if (n != 32 || dir[0] & 0X80) {
    1a6a:	cmp	r0, #32
    1a6c:	bne.n	1ab4 <ExFatFile::rmdir()+0x64>
    1a6e:	ldrb.w	r3, [sp]
    1a72:	lsls	r2, r3, #24
    1a74:	bmi.n	1ab4 <ExFatFile::rmdir()+0x64>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (dir[0] == 0) {
    1a76:	cbz	r3, 1a86 <ExFatFile::rmdir()+0x36>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    n = read(dir, 32);
    1a78:	movs	r2, #32
    1a7a:	mov	r1, sp
    1a7c:	mov	r0, r4
    1a7e:	bl	8cc <ExFatFile::read(void*, unsigned int)>
    if (n == 0) {
    1a82:	cmp	r0, #0
    1a84:	bne.n	1a6a <ExFatFile::rmdir()+0x1a>
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
    1a86:	ldrb.w	r3, [r4, #51]	; 0x33
    if (dir[0] == 0) {
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    1a8a:	movs	r2, #8
  m_flags |= FILE_FLAG_WRITE;
    1a8c:	orr.w	r3, r3, #2
    1a90:	strb.w	r3, [r4, #51]	; 0x33
    if (dir[0] == 0) {
      break;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    1a94:	strb.w	r2, [r4, #49]	; 0x31
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    1a98:	mov	r0, r4
    1a9a:	bl	1928 <ExFatFile::remove()>

fail:
  return false;
}
    1a9e:	add	sp, #36	; 0x24
    1aa0:	pop	{r4, r5, pc}
bool ExFatFile::rmdir() {
  int n;
  uint8_t dir[32];
  // must be open subdirectory
  if (!isSubDir()) {
    DBG_FAIL_MACRO;
    1aa2:	mov.w	r0, #354	; 0x162
    1aa6:	and.w	r5, r3, #255	; 0xff
    1aaa:	bl	1824 <dbgPrint(unsigned short)>
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

fail:
  return false;
    1aae:	mov	r0, r5
}
    1ab0:	add	sp, #36	; 0x24
    1ab2:	pop	{r4, r5, pc}
    n = read(dir, 32);
    if (n == 0) {
      break;
    }
    if (n != 32 || dir[0] & 0X80) {
      DBG_FAIL_MACRO;
    1ab4:	mov.w	r0, #366	; 0x16e
    1ab8:	bl	1824 <dbgPrint(unsigned short)>
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();

fail:
  return false;
    1abc:	movs	r0, #0
}
    1abe:	add	sp, #36	; 0x24
    1ac0:	pop	{r4, r5, pc}
    1ac2:	nop

00001ac4 <ExFatFile::syncDir()>:
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    1ac4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    1ac8:	add.w	fp, r0, #36	; 0x24
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    1acc:	mov	r6, r0
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    1ace:	ldmia.w	fp, {r0, r1, r2}
 fail:
  m_error |= WRITE_ERROR;
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
    1ad2:	sub	sp, #28
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;
    1ad4:	add.w	r8, sp, #12
    1ad8:	stmia.w	r8, {r0, r1, r2}
    1adc:	movs	r7, #0
bool ExFatFile::syncDir() {
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
  uint8_t setCount = 0;
    1ade:	mov	sl, r7
//------------------------------------------------------------------------------
bool ExFatFile::syncDir() {
  DirFile_t* df;
  DirStream_t* ds;
  uint8_t* cache;
  uint16_t checksum = 0;
    1ae0:	mov	r4, r7
  uint8_t setCount = 0;

  DirPos_t pos = m_dirPos;

  for (uint8_t i = 0;; i++) {
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ);
    1ae2:	movs	r2, #0
    1ae4:	mov	r1, r8
    1ae6:	ldr	r0, [r6, #32]
    1ae8:	bl	152c <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
    1aec:	uxtb.w	r9, r7
    if (!cache) {
    1af0:	mov	r5, r0
    1af2:	cmp	r0, #0
    1af4:	beq.n	1bee <ExFatFile::syncDir()+0x12a>
      DBG_FAIL_MACRO;
      goto fail;
    }
    switch (cache[0]) {
    1af6:	ldrb	r2, [r0, #0]
    1af8:	cmp	r2, #192	; 0xc0
    1afa:	beq.n	1b68 <ExFatFile::syncDir()+0xa4>
    1afc:	cmp	r2, #193	; 0xc1
    1afe:	beq.n	1b20 <ExFatFile::syncDir()+0x5c>
    1b00:	cmp	r2, #133	; 0x85
    1b02:	beq.n	1ba4 <ExFatFile::syncDir()+0xe0>

      case EXFAT_TYPE_NAME:
        break;

      default:
        DBG_FAIL_MACRO;
    1b04:	mov.w	r0, #452	; 0x1c4
    1b08:	bl	1824 <dbgPrint(unsigned short)>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    1b0c:	ldrb.w	r3, [r6, #50]	; 0x32
    1b10:	orr.w	r3, r3, #1
    1b14:	strb.w	r3, [r6, #50]	; 0x32
  return false;
    1b18:	movs	r0, #0
}
    1b1a:	add	sp, #28
    1b1c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1b20:	mov	r0, r2
//=============================================================================
#else  // READ_ONLY
//-----------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    1b22:	movs	r1, #0
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    1b24:	ldrb	r2, [r5, r1]
    1b26:	lsls	r3, r4, #15
    1b28:	orr.w	r4, r3, r4, lsr #1
    1b2c:	uxtah	r4, r2, r4
//=============================================================================
#else  // READ_ONLY
//-----------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    1b30:	cmp	r1, #1
    checksum = ((checksum << 15) | (checksum >> 1)) + data[i];
    1b32:	uxth	r4, r4
//=============================================================================
#else  // READ_ONLY
//-----------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    1b34:	add.w	r1, r1, #1
    1b38:	beq.n	1b5e <ExFatFile::syncDir()+0x9a>
    1b3a:	cmp	r1, #31
    1b3c:	bls.n	1b24 <ExFatFile::syncDir()+0x60>
        DBG_FAIL_MACRO;
        goto fail;
        break;
    }
    checksum = exFatDirChecksum(cache, checksum);
    if (i == setCount) break;
    1b3e:	cmp	sl, r9
    1b40:	beq.n	1bf8 <ExFatFile::syncDir()+0x134>
    if (m_vol->dirSeek(&pos, 32) != 1) {
    1b42:	movs	r2, #32
    1b44:	mov	r1, r8
    1b46:	ldr	r0, [r6, #32]
    1b48:	bl	15ac <ExFatPartition::dirSeek(DirPos_t*, unsigned long)>
    1b4c:	cmp	r0, #1
    1b4e:	add.w	r7, r7, #1
    1b52:	beq.n	1ae2 <ExFatFile::syncDir()+0x1e>
      DBG_FAIL_MACRO;
    1b54:	movw	r0, #459	; 0x1cb
    1b58:	bl	1824 <dbgPrint(unsigned short)>
      goto fail;
    1b5c:	b.n	1b0c <ExFatFile::syncDir()+0x48>
//=============================================================================
#else  // READ_ONLY
//-----------------------------------------------------------------------------
static uint16_t exFatDirChecksum(const uint8_t* data, uint16_t checksum) {
  bool skip = data[0] == EXFAT_TYPE_FILE;
  for (size_t i = 0; i < 32; i += i == 1 && skip ? 3 : 1) {
    1b5e:	cmp	r0, #133	; 0x85
    1b60:	ite	eq
    1b62:	moveq	r1, #4
    1b64:	movne	r1, #2
    1b66:	b.n	1b24 <ExFatFile::syncDir()+0x60>
        }
        break;

      case EXFAT_TYPE_STREAM:
        ds = reinterpret_cast<DirStream_t*>(cache);
        if (isContiguous()) {
    1b68:	ldrb.w	r3, [r6, #51]	; 0x33
    1b6c:	tst.w	r3, #64	; 0x40
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
    1b70:	ldrb	r3, [r0, #1]
    1b72:	ite	ne
    1b74:	orrne.w	r3, r3, #2
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
    1b78:	biceq.w	r3, r3, #2
    1b7c:	strb	r3, [r0, #1]
        }
        setLe64(ds->validLength, m_validLength);
    1b7e:	ldrd	r2, r3, [r6, #16]

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    1b82:	strd	r2, r3, [r0, #8]
        setLe32(ds->firstCluster, m_firstCluster);
        setLe64(ds->dataLength, m_dataLength);
    1b86:	ldrd	r2, r3, [r6, #8]
          ds->flags |= EXFAT_FLAG_CONTIGUOUS;
        } else {
          ds->flags &= ~EXFAT_FLAG_CONTIGUOUS;
        }
        setLe64(ds->validLength, m_validLength);
        setLe32(ds->firstCluster, m_firstCluster);
    1b8a:	ldr	r1, [r6, #28]
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    1b8c:	str	r1, [r0, #20]
}
inline void setLe64(uint8_t* dst, uint64_t src) {
  *reinterpret_cast<uint64_t*>(dst) = src;
    1b8e:	strd	r2, r3, [r0, #24]
        setLe64(ds->dataLength, m_dataLength);
        m_vol->dataCacheDirty();
    1b92:	ldr	r2, [r6, #32]
    invalidate();
    return m_cacheBuffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    1b94:	ldrb.w	r3, [r2, #524]	; 0x20c
    1b98:	orr.w	r3, r3, #1
    1b9c:	strb.w	r3, [r2, #524]	; 0x20c
    1ba0:	ldrb	r0, [r0, #0]
    1ba2:	b.n	1b22 <ExFatFile::syncDir()+0x5e>
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setCount = df->setCount;
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    1ba4:	ldr	r3, [pc, #152]	; (1c40 <ExFatFile::syncDir()+0x17c>)
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    1ba6:	ldrb.w	r1, [r6, #49]	; 0x31
    1baa:	ldr	r3, [r3, #0]
      goto fail;
    }
    switch (cache[0]) {
      case EXFAT_TYPE_FILE:
        df = reinterpret_cast<DirFile_t*>(cache);
        setCount = df->setCount;
    1bac:	ldrb.w	sl, [r0, #1]
    1bb0:	and.w	r1, r1, #55	; 0x37
    1bb4:	strh	r1, [r0, #4]
        setLe16(df->attributes, m_attributes & FILE_ATTR_COPY);
        if (FsDateTime::callback) {
    1bb6:	cmp	r3, #0
    1bb8:	beq.n	1b20 <ExFatFile::syncDir()+0x5c>
          m_vol->dataCacheDirty();
    1bba:	ldr	r1, [r6, #32]
    1bbc:	ldrb.w	r2, [r1, #524]	; 0x20c
    1bc0:	orr.w	r2, r2, #1
    1bc4:	strb.w	r2, [r1, #524]	; 0x20c
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
    1bc8:	add	r0, sp, #8
    1bca:	add.w	r2, sp, #7
    1bce:	add.w	r1, sp, #10
    1bd2:	blx	r3
          df->modifyTimeMs = ms10;
          setLe16(df->modifyTime, time);
    1bd4:	ldrh.w	r2, [sp, #10]
          setLe16(df->modifyDate, date);
    1bd8:	ldrh.w	r3, [sp, #8]
        if (FsDateTime::callback) {
          m_vol->dataCacheDirty();
          uint16_t date, time;
          uint8_t ms10;
          FsDateTime::callback(&date, &time, &ms10);
          df->modifyTimeMs = ms10;
    1bdc:	ldrb.w	r1, [sp, #7]
    1be0:	strb	r1, [r5, #21]
    1be2:	strh	r2, [r5, #12]
    1be4:	strh	r2, [r5, #16]
    1be6:	strh	r3, [r5, #14]
    1be8:	strh	r3, [r5, #18]
    1bea:	ldrb	r0, [r5, #0]
    1bec:	b.n	1b22 <ExFatFile::syncDir()+0x5e>
  DirPos_t pos = m_dirPos;

  for (uint8_t i = 0;; i++) {
    cache = m_vol->dirCache(&pos, FsCache::CACHE_FOR_READ);
    if (!cache) {
      DBG_FAIL_MACRO;
    1bee:	mov.w	r0, #414	; 0x19e
    1bf2:	bl	1824 <dbgPrint(unsigned short)>
      goto fail;
    1bf6:	b.n	1b0c <ExFatFile::syncDir()+0x48>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  df = reinterpret_cast<DirFile_t *>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
    1bf8:	mov	r1, fp
    1bfa:	movs	r2, #1
    1bfc:	ldr	r0, [r6, #32]
    1bfe:	bl	152c <ExFatPartition::dirCache(DirPos_t*, unsigned char)>
  if (!df) {
    1c02:	cbz	r0, 1c1a <ExFatFile::syncDir()+0x156>
    DBG_FAIL_MACRO;
    goto fail;
  }
  setLe16(df->setChecksum, checksum);
  if (!m_vol->cacheSync()) {
    1c04:	ldr	r5, [r6, #32]
    1c06:	strh	r4, [r0, #2]
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    1c08:	mov	r0, r5
    1c0a:	bl	1290 <FsCache::sync()>
    1c0e:	cbnz	r0, 1c24 <ExFatFile::syncDir()+0x160>
    DBG_FAIL_MACRO;
    1c10:	movw	r0, #471	; 0x1d7
    1c14:	bl	1824 <dbgPrint(unsigned short)>
    goto fail;
    1c18:	b.n	1b0c <ExFatFile::syncDir()+0x48>
    }
  }
  df = reinterpret_cast<DirFile_t *>
       (m_vol->dirCache(&m_dirPos, FsCache::CACHE_FOR_WRITE));
  if (!df) {
    DBG_FAIL_MACRO;
    1c1a:	mov.w	r0, #466	; 0x1d2
    1c1e:	bl	1824 <dbgPrint(unsigned short)>
    goto fail;
    1c22:	b.n	1b0c <ExFatFile::syncDir()+0x48>
    1c24:	add.w	r0, r5, #524	; 0x20c
    1c28:	bl	1290 <FsCache::sync()>
    1c2c:	cmp	r0, #0
    1c2e:	beq.n	1c10 <ExFatFile::syncDir()+0x14c>
    1c30:	ldr.w	r0, [r5, #1080]	; 0x438
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    1c34:	ldr	r3, [r0, #0]
    1c36:	ldr	r3, [r3, #20]
    1c38:	blx	r3
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    1c3a:	cmp	r0, #0
    1c3c:	beq.n	1c10 <ExFatFile::syncDir()+0x14c>
    1c3e:	b.n	1b1a <ExFatFile::syncDir()+0x56>
    1c40:	.word	0x1fff13c8

00001c44 <ExFatFile::sync()>:
fail:
  return false;
}
//-----------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    1c44:	ldrb.w	r2, [r0, #49]	; 0x31
    1c48:	cbz	r2, 1c78 <ExFatFile::sync()+0x34>

fail:
  return false;
}
//-----------------------------------------------------------------------------
bool ExFatFile::sync() {
    1c4a:	push	{r3, r4, r5, lr}
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    1c4c:	ldrb.w	r2, [r0, #51]	; 0x33
    1c50:	lsls	r1, r2, #24
    1c52:	bmi.n	1c7c <ExFatFile::sync()+0x38>
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
  }
  if (!m_vol->cacheSync()) {
    1c54:	ldr	r5, [r0, #32]
    1c56:	mov	r4, r0
    1c58:	mov	r0, r5
    1c5a:	bl	1290 <FsCache::sync()>
    1c5e:	cbnz	r0, 1c8c <ExFatFile::sync()+0x48>
    DBG_FAIL_MACRO;
    1c60:	mov.w	r0, #392	; 0x188
    1c64:	bl	1824 <dbgPrint(unsigned short)>
    goto fail;
  }
  return true;

 fail:
  m_error |= WRITE_ERROR;
    1c68:	ldrb.w	r3, [r4, #50]	; 0x32
    1c6c:	orr.w	r3, r3, #1
    1c70:	strb.w	r3, [r4, #50]	; 0x32
    1c74:	movs	r0, #0
  return false;
}
    1c76:	pop	{r3, r4, r5, pc}
  return false;
}
//-----------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    return true;
    1c78:	movs	r0, #1
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    1c7a:	bx	lr
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    1c7c:	and.w	r2, r2, #127	; 0x7f
    1c80:	strb.w	r2, [r0, #51]	; 0x33
  return true;

 fail:
  m_error |= WRITE_ERROR;
  return false;
}
    1c84:	ldmia.w	sp!, {r3, r4, r5, lr}
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    return syncDir();
    1c88:	b.w	1ac4 <ExFatFile::syncDir()>
    1c8c:	add.w	r0, r5, #524	; 0x20c
    1c90:	bl	1290 <FsCache::sync()>
    1c94:	cmp	r0, #0
    1c96:	beq.n	1c60 <ExFatFile::sync()+0x1c>
    1c98:	ldr.w	r0, [r5, #1080]	; 0x438
  bool fatPut(uint32_t cluster, uint32_t value);
  uint32_t chainSize(uint32_t cluster);
  bool freeChain(uint32_t cluster);
  uint16_t sectorMask() {return m_sectorMask;}
  bool syncDevice() {
    return m_blockDev->syncDevice();
    1c9c:	ldr	r3, [r0, #0]
    1c9e:	ldr	r3, [r3, #20]
    1ca0:	blx	r3
#endif  // USE_EXFAT_BITMAP_CACHE
    m_dataCache.init(dev);
  }
  bool cacheSync() {
#if USE_EXFAT_BITMAP_CACHE
    return m_bitmapCache.sync() && m_dataCache.sync() && syncDevice();
    1ca2:	cmp	r0, #0
    1ca4:	beq.n	1c60 <ExFatFile::sync()+0x1c>
  return false;
}
//-----------------------------------------------------------------------------
bool ExFatFile::sync() {
  if (!isOpen()) {
    return true;
    1ca6:	movs	r0, #1
    1ca8:	pop	{r3, r4, r5, pc}
    1caa:	nop

00001cac <ExFatFile::addDirCluster()>:

 fail:
  return false;
}
//-----------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    1cac:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    1cb0:	ldrb.w	r3, [r0, #49]	; 0x31
    1cb4:	lsls	r1, r3, #25

 fail:
  return false;
}
//-----------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
    1cb6:	mov	r8, r0
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    1cb8:	bmi.n	1d68 <ExFatFile::addDirCluster()+0xbc>
    1cba:	ldr	r0, [r0, #8]
    1cbc:	ldr.w	r3, [r8, #32]
  uint8_t* cache;
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    1cc0:	ldr.w	r3, [r3, #1076]	; 0x434
    1cc4:	add	r0, r3
    1cc6:	cmp.w	r0, #67108864	; 0x4000000
    1cca:	bcs.n	1d5c <ExFatFile::addDirCluster()+0xb0>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    1ccc:	mov	r0, r8
    1cce:	bl	1860 <ExFatFile::addCluster()>
    1cd2:	cmp	r0, #0
    1cd4:	beq.n	1d50 <ExFatFile::addDirCluster()+0xa4>
    DBG_FAIL_MACRO;
    goto fail;
  }
  cache =  m_vol->cacheClear();
    1cd6:	ldr.w	r5, [r8, #32]
  uint8_t* cacheBuffer() {
    return m_cacheBuffer;
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    1cda:	ldrb.w	r3, [r5, #524]	; 0x20c
    1cde:	lsls	r2, r3, #31

  /** Clear the cache and returns a pointer to the cache.  Not for normal apps.
   * \return A pointer to the cache buffer or zero if an error occurs.
   */
  uint8_t* cacheClear() {
    return m_dataCache.clear();
    1ce0:	add.w	r4, r5, #524	; 0x20c
  uint8_t* cacheBuffer() {
    return m_cacheBuffer;
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    1ce4:	bmi.n	1dae <ExFatFile::addDirCluster()+0x102>
      return nullptr;
    }
    invalidate();
    1ce6:	mov	r0, r4
    return m_cacheBuffer;
    1ce8:	add.w	r5, r5, #536	; 0x218
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
      return nullptr;
    }
    invalidate();
    1cec:	bl	11f8 <FsCache::invalidate()>
  if (!cache) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(cache, 0, m_vol->bytesPerSector());
    1cf0:	mov.w	r2, #512	; 0x200
    1cf4:	movs	r1, #0
    1cf6:	mov	r0, r5
    1cf8:	bl	bb7c <memset>
  sector = m_vol->clusterStartSector(m_curCluster);
    1cfc:	ldr.w	r2, [r8, #32]
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    1d00:	ldr.w	r3, [r8, #24]
    1d04:	ldrb.w	r1, [r2, #1085]	; 0x43d
    1d08:	ldr.w	r7, [r2, #1060]	; 0x424
    1d0c:	subs	r3, #2
    1d0e:	lsls	r3, r1
  for (uint32_t i = 0; i < m_vol->sectorsPerCluster(); i++) {
    1d10:	movs	r6, #1
    1d12:	add	r7, r3
    1d14:	lsls.w	r3, r6, r1
    1d18:	it	ne
    1d1a:	movne	r4, #0
    1d1c:	bne.n	1d30 <ExFatFile::addDirCluster()+0x84>
    1d1e:	b.n	1d70 <ExFatFile::addDirCluster()+0xc4>
    1d20:	ldr.w	r2, [r8, #32]
    1d24:	ldrb.w	r3, [r2, #1085]	; 0x43d
    1d28:	lsl.w	r3, r6, r3
    1d2c:	cmp	r3, r4
    1d2e:	bls.n	1d70 <ExFatFile::addDirCluster()+0xc4>
    1d30:	ldr.w	r0, [r2, #1080]	; 0x438
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    1d34:	ldr	r3, [r0, #0]
    1d36:	adds	r1, r7, r4
    1d38:	ldr	r3, [r3, #24]
    1d3a:	mov	r2, r5
    1d3c:	blx	r3
    1d3e:	adds	r4, #1
    if (!m_vol->writeSector(sector + i, cache)) {
    1d40:	cmp	r0, #0
    1d42:	bne.n	1d20 <ExFatFile::addDirCluster()+0x74>
      DBG_FAIL_MACRO;
    1d44:	movs	r0, #145	; 0x91
    1d46:	bl	1824 <dbgPrint(unsigned short)>
  }
  return sync();

 fail:
  return false;
}
    1d4a:	movs	r0, #0
    1d4c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (dl >= 0X4000000) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    DBG_FAIL_MACRO;
    1d50:	movs	r0, #133	; 0x85
    1d52:	bl	1824 <dbgPrint(unsigned short)>
  }
  return sync();

 fail:
  return false;
}
    1d56:	movs	r0, #0
    1d58:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
  uint8_t* cache;
  dl += m_vol->bytesPerCluster();
  if (dl >= 0X4000000) {
    DBG_FAIL_MACRO;
    1d5c:	movs	r0, #129	; 0x81
    1d5e:	bl	1824 <dbgPrint(unsigned short)>
  }
  return sync();

 fail:
  return false;
}
    1d62:	movs	r0, #0
    1d64:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return false;
}
//-----------------------------------------------------------------------------
bool ExFatFile::addDirCluster() {
  uint32_t sector;
  uint32_t dl = isRoot() ? m_vol->rootLength() : m_dataLength;
    1d68:	ldr	r0, [r0, #32]
    1d6a:	bl	1754 <ExFatPartition::rootLength()>
    1d6e:	b.n	1cbc <ExFatFile::addDirCluster()+0x10>
    if (!m_vol->writeSector(sector + i, cache)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  if (!isRoot()) {
    1d70:	ldrb.w	r3, [r8, #49]	; 0x31
    1d74:	lsls	r3, r3, #25
    1d76:	bmi.n	1da4 <ExFatFile::addDirCluster()+0xf8>
    m_flags |= FILE_FLAG_DIR_DIRTY;
    1d78:	ldrb.w	r3, [r8, #51]	; 0x33
    1d7c:	orn	r3, r3, #127	; 0x7f
    1d80:	strb.w	r3, [r8, #51]	; 0x33
    m_dataLength  += m_vol->bytesPerCluster();
    1d84:	ldr.w	r4, [r2, #1076]	; 0x434
    1d88:	ldrd	r2, r3, [r8, #8]
    m_validLength += m_vol->bytesPerCluster();
    1d8c:	ldrd	r0, r1, [r8, #16]
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    1d90:	adds	r2, r2, r4
    1d92:	mov.w	r5, #0
    1d96:	adcs	r3, r5
    m_validLength += m_vol->bytesPerCluster();
    1d98:	adds	r0, r0, r4
    1d9a:	adcs	r1, r5
      goto fail;
    }
  }
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    1d9c:	strd	r2, r3, [r8, #8]
    m_validLength += m_vol->bytesPerCluster();
    1da0:	strd	r0, r1, [r8, #16]
  }
  return sync();
    1da4:	mov	r0, r8

 fail:
  return false;
}
    1da6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  if (!isRoot()) {
    m_flags |= FILE_FLAG_DIR_DIRTY;
    m_dataLength  += m_vol->bytesPerCluster();
    m_validLength += m_vol->bytesPerCluster();
  }
  return sync();
    1daa:	b.w	1c44 <ExFatFile::sync()>
  uint8_t* cacheBuffer() {
    return m_cacheBuffer;
  }
  /** \return Clear the cache and returns a pointer to the cache. */
  uint8_t* clear() {
    if (isDirty() && !sync()) {
    1dae:	mov	r0, r4
    1db0:	bl	1290 <FsCache::sync()>
    1db4:	cmp	r0, #0
    1db6:	bne.n	1ce6 <ExFatFile::addDirCluster()+0x3a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  cache =  m_vol->cacheClear();
  if (!cache) {
    DBG_FAIL_MACRO;
    1db8:	movs	r0, #138	; 0x8a
    1dba:	bl	1824 <dbgPrint(unsigned short)>
    1dbe:	b.n	1d56 <ExFatFile::addDirCluster()+0xaa>

00001dc0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    1dc0:	push	{r4, r5, lr}
  if (!parent->isDir()) {
    1dc2:	ldrb.w	r3, [r1, #49]	; 0x31
    1dc6:	tst.w	r3, #80	; 0x50

fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
    1dca:	sub	sp, #12
  if (!parent->isDir()) {
    1dcc:	beq.n	1e1a <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x5a>
  uint8_t setCount() {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    1dce:	movw	r5, #2562	; 0xa02
    1dd2:	ldrb	r3, [r2, #0]
    1dd4:	ldr	r2, [r2, #4]
    1dd6:	str	r5, [sp, #0]
    1dd8:	mov	r4, r0
    1dda:	bl	bfc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    1dde:	cbz	r0, 1e0e <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x4e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory

  m_attributes = FILE_ATTR_SUBDIR;
    1de0:	movs	r3, #16
    1de2:	strb.w	r3, [r4, #49]	; 0x31

  // allocate and zero first cluster
  if (!addDirCluster()) {
    1de6:	mov	r0, r4
    1de8:	bl	1cac <ExFatFile::addDirCluster()>
    1dec:	cbz	r0, 1e26 <ExFatFile::mkdir(ExFatFile*, ExName_t*)+0x66>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    1dee:	ldr	r3, [r4, #24]
    1df0:	str	r3, [r4, #28]
   * \return true for success or false for failure.
   */
  bool rename(ExFatFile* dirFile, const ExChar_t* newPath);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    1df2:	movs	r2, #0
    1df4:	movs	r3, #0
    1df6:	mov	r0, r4
    1df8:	bl	ae0 <ExFatFile::seekSet(unsigned long long)>

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    1dfc:	movs	r3, #193	; 0xc1
  return sync();
    1dfe:	mov	r0, r4
  }
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
    1e00:	strb.w	r3, [r4, #51]	; 0x33
  return sync();

fail:
  return false;
}
    1e04:	add	sp, #12
    1e06:	ldmia.w	sp!, {r4, r5, lr}
  m_firstCluster = m_curCluster;

  // Set to start of dir
  rewind();
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();
    1e0a:	b.w	1c44 <ExFatFile::sync()>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    1e0e:	movs	r0, #209	; 0xd1
    1e10:	bl	1824 <dbgPrint(unsigned short)>
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();

fail:
  return false;
}
    1e14:	movs	r0, #0
    1e16:	add	sp, #12
    1e18:	pop	{r4, r5, pc}
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, ExName_t* fname) {
  if (!parent->isDir()) {
    DBG_FAIL_MACRO;
    1e1a:	movs	r0, #204	; 0xcc
    1e1c:	bl	1824 <dbgPrint(unsigned short)>
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();

fail:
  return false;
}
    1e20:	movs	r0, #0
    1e22:	add	sp, #12
    1e24:	pop	{r4, r5, pc}

  m_attributes = FILE_ATTR_SUBDIR;

  // allocate and zero first cluster
  if (!addDirCluster()) {
    DBG_FAIL_MACRO;
    1e26:	movs	r0, #218	; 0xda
    1e28:	bl	1824 <dbgPrint(unsigned short)>
  m_flags = FILE_FLAG_READ | FILE_FLAG_CONTIGUOUS | FILE_FLAG_DIR_DIRTY;
  return sync();

fail:
  return false;
}
    1e2c:	movs	r0, #0
    1e2e:	add	sp, #12
    1e30:	pop	{r4, r5, pc}
    1e32:	nop

00001e34 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const ExChar_t* path, bool pFlag) {
    1e34:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1e38:	mov	r6, r0
    1e3a:	sub	sp, #84	; 0x54
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    1e3c:	ldrb.w	r4, [r6, #49]	; 0x31

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::mkdir(ExFatFile* parent, const ExChar_t* path, bool pFlag) {
    1e40:	str	r2, [sp, #12]
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() : m_attributes(FILE_ATTR_CLOSED), m_error(0), m_flags(0) {}
    1e42:	movs	r0, #0
    1e44:	strb.w	r0, [sp, #73]	; 0x49
    1e48:	strb.w	r0, [sp, #74]	; 0x4a
    1e4c:	strb.w	r0, [sp, #75]	; 0x4b
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    1e50:	cmp	r4, #0
    1e52:	bne.n	1ece <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x9a>
    1e54:	mov	r9, r3
    1e56:	ldrb.w	r3, [r1, #49]	; 0x31
    1e5a:	tst.w	r3, #80	; 0x50
    1e5e:	mov	r5, r1
    1e60:	beq.n	1ece <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x9a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    1e62:	ldrb	r3, [r2, #0]
    1e64:	cmp	r3, #47	; 0x2f
    1e66:	mov	r1, r2
    1e68:	beq.n	1eb0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x7c>
  uint8_t setCount() {return m_setCount;}
  bool mkdir(ExFatFile* parent, ExName_t* fname);
  bool openRootFile(ExFatFile* dir,
                    const ExChar_t* name, uint8_t nameLength, oflag_t oflag);
  bool open(ExFatFile* dirFile, ExName_t* fname, oflag_t oflag) {
    return openRootFile(dirFile, fname->lfn, fname->len, oflag);
    1e6a:	mov.w	r8, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    1e6e:	add	r3, sp, #12
    1e70:	add	r2, sp, #16
    1e72:	mov	r0, r6
    1e74:	bl	808 <ExFatFile::parsePathName(char const*, ExName_t*, char const**)>
    1e78:	mov	r4, r0
    1e7a:	cmp	r0, #0
    1e7c:	beq.n	1f18 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xe4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    1e7e:	ldr	r3, [sp, #12]
    1e80:	ldrb	r3, [r3, #0]
    1e82:	cmp	r3, #0
    1e84:	beq.n	1f26 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xf2>
    1e86:	ldrb.w	r3, [sp, #16]
    1e8a:	ldr	r2, [sp, #20]
    1e8c:	str.w	r8, [sp]
    1e90:	mov	r1, r5
    1e92:	mov	r0, r6
    1e94:	bl	bfc <ExFatFile::openRootFile(ExFatFile*, char const*, unsigned char, int)>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    1e98:	mov	r4, r0
    1e9a:	cbnz	r0, 1eec <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xb8>
      if (!pFlag || !mkdir(parent, &fname)) {
    1e9c:	cmp.w	r9, #0
    1ea0:	bne.n	1ede <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xaa>
        DBG_FAIL_MACRO;
    1ea2:	movs	r0, #188	; 0xbc
    1ea4:	bl	1824 <dbgPrint(unsigned short)>
  }
  return mkdir(parent, &fname);

fail:
  return false;
}
    1ea8:	mov	r0, r4
    1eaa:	add	sp, #84	; 0x54
    1eac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    1eb0:	adds	r1, #1
    1eb2:	str	r1, [sp, #12]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    1eb4:	ldrb	r3, [r1, #0]
    1eb6:	cmp	r3, #47	; 0x2f
    1eb8:	beq.n	1eb0 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x7c>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    1eba:	ldr	r1, [r5, #32]
    1ebc:	add	r0, sp, #24
    1ebe:	bl	7d8 <ExFatFile::openRoot(ExFatVolume*)>
    1ec2:	mov	r4, r0
    1ec4:	cmp	r0, #0
    1ec6:	beq.n	1f34 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x100>
    1ec8:	ldr	r1, [sp, #12]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    1eca:	add	r5, sp, #24
    1ecc:	b.n	1e6a <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x36>
bool ExFatFile::mkdir(ExFatFile* parent, const ExChar_t* path, bool pFlag) {
  ExName_t fname;
  ExFatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    1ece:	movs	r0, #165	; 0xa5
    1ed0:	bl	1824 <dbgPrint(unsigned short)>
    close();
  }
  return mkdir(parent, &fname);

fail:
  return false;
    1ed4:	movs	r4, #0
}
    1ed6:	mov	r0, r4
    1ed8:	add	sp, #84	; 0x54
    1eda:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    1ede:	mov	r1, r5
    1ee0:	add	r2, sp, #16
    1ee2:	mov	r0, r6
    1ee4:	bl	1dc0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    1ee8:	cmp	r0, #0
    1eea:	beq.n	1ea2 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x6e>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    1eec:	mov	r4, r6
    1eee:	add	r7, sp, #24
    1ef0:	add.w	lr, r6, #48	; 0x30
    1ef4:	ldr	r0, [r4, #0]
    1ef6:	ldr	r1, [r4, #4]
    1ef8:	ldr	r2, [r4, #8]
    1efa:	ldr	r3, [r4, #12]
    1efc:	mov	r5, r7
    1efe:	stmia	r5!, {r0, r1, r2, r3}
    1f00:	adds	r4, #16
    1f02:	cmp	r4, lr
    1f04:	mov	r7, r5
    1f06:	bne.n	1ef4 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0xc0>
    1f08:	ldr	r0, [r4, #0]
    1f0a:	str	r0, [r5, #0]
    parent = &tmpDir;
    close();
    1f0c:	mov	r0, r6
    1f0e:	bl	704 <ExFatFile::close()>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    parent = &tmpDir;
    1f12:	add	r5, sp, #24
    1f14:	ldr	r1, [sp, #12]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    1f16:	b.n	1e6e <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x3a>
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
    1f18:	movs	r0, #180	; 0xb4
    1f1a:	bl	1824 <dbgPrint(unsigned short)>
  }
  return mkdir(parent, &fname);

fail:
  return false;
}
    1f1e:	mov	r0, r4
    1f20:	add	sp, #84	; 0x54
    1f22:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    1f26:	add	r2, sp, #16
    1f28:	mov	r1, r5
    1f2a:	mov	r0, r6
    1f2c:	bl	1dc0 <ExFatFile::mkdir(ExFatFile*, ExName_t*)>
    1f30:	mov	r4, r0
    1f32:	b.n	1ea8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x74>
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
      DBG_FAIL_MACRO;
    1f34:	movs	r0, #173	; 0xad
    1f36:	bl	1824 <dbgPrint(unsigned short)>
      goto fail;
    1f3a:	b.n	1ea8 <ExFatFile::mkdir(ExFatFile*, char const*, bool)+0x74>

00001f3c <ExFatFile::rename(ExFatFile*, char const*)>:
//------------------------------------------------------------------------------
bool ExFatFile::rename(const ExChar_t* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const ExChar_t* newPath) {
    1f3c:	push	{r4, r5, r6, r7, lr}
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    1f3e:	ldrb.w	r4, [r0, #49]	; 0x31
//------------------------------------------------------------------------------
bool ExFatFile::rename(const ExChar_t* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool ExFatFile::rename(ExFatFile* dirFile, const ExChar_t* newPath) {
    1f42:	sub	sp, #116	; 0x74
 * \brief Basic file class.
 */
class ExFatFile {
 public:
  /** Create an instance. */
  ExFatFile() : m_attributes(FILE_ATTR_CLOSED), m_error(0), m_flags(0) {}
    1f44:	movs	r3, #0
  ExFatFile file;
  ExFatFile oldFile;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    1f46:	ands.w	r4, r4, #24
    1f4a:	strb.w	r3, [sp, #49]	; 0x31
    1f4e:	strb.w	r3, [sp, #50]	; 0x32
    1f52:	strb.w	r3, [sp, #51]	; 0x33
    1f56:	strb.w	r3, [sp, #105]	; 0x69
    1f5a:	strb.w	r3, [sp, #106]	; 0x6a
    1f5e:	strb.w	r3, [sp, #107]	; 0x6b
    1f62:	bne.n	1f72 <ExFatFile::rename(ExFatFile*, char const*)+0x36>
    DBG_FAIL_MACRO;
    1f64:	movw	r0, #319	; 0x13f
    1f68:	bl	1824 <dbgPrint(unsigned short)>
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();

fail:
  return false;
}
    1f6c:	mov	r0, r4
    1f6e:	add	sp, #116	; 0x74
    1f70:	pop	{r4, r5, r6, r7, pc}
    1f72:	mov	r5, r0
  if (!(isFile() || isSubDir())) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    1f74:	ldr	r0, [r1, #32]
    1f76:	ldr	r4, [r5, #32]
    1f78:	cmp	r4, r0
    1f7a:	beq.n	1f8c <ExFatFile::rename(ExFatFile*, char const*)+0x50>
    DBG_FAIL_MACRO;
    1f7c:	mov.w	r0, #324	; 0x144
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();

fail:
  return false;
    1f80:	mov	r4, r3
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    DBG_FAIL_MACRO;
    1f82:	bl	1824 <dbgPrint(unsigned short)>
  oldFile.m_attributes = FILE_ATTR_FILE;
  return oldFile.remove();

fail:
  return false;
}
    1f86:	mov	r0, r4
    1f88:	add	sp, #116	; 0x74
    1f8a:	pop	{r4, r5, r6, r7, pc}
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    1f8c:	movw	r3, #2561	; 0xa01
    1f90:	mov	r0, sp
    1f92:	bl	102c <ExFatFile::open(ExFatFile*, char const*, int)>
    1f96:	mov	r4, r0
    1f98:	cbz	r0, 2000 <ExFatFile::rename(ExFatFile*, char const*)+0xc4>
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
    1f9a:	add	r7, sp, #56	; 0x38
    1f9c:	mov	r4, r5
    1f9e:	add.w	lr, r5, #48	; 0x30
    1fa2:	ldr	r0, [r4, #0]
    1fa4:	ldr	r1, [r4, #4]
    1fa6:	ldr	r2, [r4, #8]
    1fa8:	ldr	r3, [r4, #12]
    1faa:	mov	r6, r7
    1fac:	stmia	r6!, {r0, r1, r2, r3}
    1fae:	adds	r4, #16
    1fb0:	cmp	r4, lr
    1fb2:	mov	r7, r6
    1fb4:	bne.n	1fa2 <ExFatFile::rename(ExFatFile*, char const*)+0x66>
    1fb6:	ldr	r0, [r4, #0]
    1fb8:	str	r0, [r6, #0]
  m_dirPos = file.m_dirPos;
    1fba:	add	r3, sp, #36	; 0x24
    1fbc:	ldmia.w	r3, {r0, r1, r2}
    1fc0:	add.w	r3, r5, #36	; 0x24
    1fc4:	stmia.w	r3, {r0, r1, r2}
  m_setCount = file.m_setCount;
  m_flags |= FILE_FLAG_DIR_DIRTY;
    1fc8:	ldrb.w	r3, [r5, #51]	; 0x33
    DBG_FAIL_MACRO;
    goto fail;
  }
  oldFile = *this;
  m_dirPos = file.m_dirPos;
  m_setCount = file.m_setCount;
    1fcc:	ldrb.w	r2, [sp, #48]	; 0x30
    1fd0:	strb.w	r2, [r5, #48]	; 0x30
  m_flags |= FILE_FLAG_DIR_DIRTY;
    1fd4:	orn	r3, r3, #127	; 0x7f
    1fd8:	strb.w	r3, [r5, #51]	; 0x33
  if (!sync()) {
    1fdc:	mov	r0, r5
    1fde:	bl	1c44 <ExFatFile::sync()>
    1fe2:	mov	r4, r0
    1fe4:	cbz	r0, 200a <ExFatFile::rename(ExFatFile*, char const*)+0xce>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    1fe6:	movs	r1, #0
  oldFile.m_flags = FILE_FLAG_WRITE;
    1fe8:	movs	r2, #2
  oldFile.m_attributes = FILE_ATTR_FILE;
    1fea:	movs	r3, #8
  return oldFile.remove();
    1fec:	add	r0, sp, #56	; 0x38
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    1fee:	str	r1, [sp, #84]	; 0x54
  oldFile.m_flags = FILE_FLAG_WRITE;
    1ff0:	strb.w	r2, [sp, #107]	; 0x6b
  oldFile.m_attributes = FILE_ATTR_FILE;
    1ff4:	strb.w	r3, [sp, #105]	; 0x69
  return oldFile.remove();
    1ff8:	bl	1928 <ExFatFile::remove()>
    1ffc:	mov	r4, r0
    1ffe:	b.n	1f6c <ExFatFile::rename(ExFatFile*, char const*)+0x30>
  if (m_vol != dirFile->m_vol) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    DBG_FAIL_MACRO;
    2000:	mov.w	r0, #328	; 0x148
    2004:	bl	1824 <dbgPrint(unsigned short)>
    goto fail;
    2008:	b.n	1f6c <ExFatFile::rename(ExFatFile*, char const*)+0x30>
  oldFile = *this;
  m_dirPos = file.m_dirPos;
  m_setCount = file.m_setCount;
  m_flags |= FILE_FLAG_DIR_DIRTY;
  if (!sync()) {
    DBG_FAIL_MACRO;
    200a:	mov.w	r0, #336	; 0x150
    200e:	bl	1824 <dbgPrint(unsigned short)>
    goto fail;
    2012:	b.n	1f6c <ExFatFile::rename(ExFatFile*, char const*)+0x30>

00002014 <ExFatFile::truncate()>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    2014:	push	{r4, r5, r6, r7, lr}
    2016:	ldrb.w	r3, [r0, #51]	; 0x33
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    201a:	and.w	r2, r3, #2

 fail:
  return false;
}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
    201e:	sub	sp, #12
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    2020:	cmp	r2, #0
    2022:	beq.n	20ce <ExFatFile::truncate()+0xba>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
    2024:	ldr	r1, [r0, #28]
    2026:	mov	r4, r0
    2028:	cbz	r1, 208c <ExFatFile::truncate()+0x78>
      return true;
  }
  if (isContiguous()) {
    202a:	and.w	r3, r3, #64	; 0x40
    202e:	and.w	r5, r3, #255	; 0xff
    2032:	cbz	r3, 2094 <ExFatFile::truncate()+0x80>
    2034:	ldr	r0, [r0, #32]
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
    2036:	ldr	r5, [r4, #24]
  }
  if (m_firstCluster == 0) {
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    2038:	ldrb.w	r3, [r0, #1085]	; 0x43d
    203c:	ldrd	r6, r7, [r4, #8]
    2040:	adds	r3, #9
    2042:	uxtb	r3, r3
    2044:	adds.w	r6, r6, #4294967295
    2048:	rsb	lr, r3, #32
    204c:	adc.w	r7, r7, #4294967295
    2050:	lsr.w	r2, r6, r3
    2054:	lsl.w	lr, r7, lr
    2058:	subs	r3, #32
    205a:	orr.w	r2, r2, lr
    205e:	lsr.w	r3, r7, r3
    2062:	orrs	r2, r3
    2064:	adds	r2, #1
    if (m_curCluster) {
    2066:	cmp	r5, #0
    2068:	beq.n	20e0 <ExFatFile::truncate()+0xcc>
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    206a:	subs	r1, #1
    206c:	subs	r1, r1, r5
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    206e:	adds	r5, #1
      nc -= 1 + m_curCluster - m_firstCluster;
    2070:	add	r2, r1
      return true;
  }
  if (isContiguous()) {
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
    2072:	str	r5, [sp, #4]
      nc -= 1 + m_curCluster - m_firstCluster;
    } else {
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (nc && !m_vol->bitmapModify(toFree, nc, 0)) {
    2074:	cbz	r2, 20a8 <ExFatFile::truncate()+0x94>
    2076:	movs	r3, #0
    2078:	ldr	r1, [sp, #4]
    207a:	bl	1464 <ExFatPartition::bitmapModify(unsigned long, unsigned long, bool)>
    207e:	mov	r5, r0
    2080:	cbnz	r0, 20a8 <ExFatFile::truncate()+0x94>
      DBG_FAIL_MACRO;
    2082:	movw	r0, #599	; 0x257
    2086:	bl	1824 <dbgPrint(unsigned short)>
      goto fail;
    208a:	b.n	208e <ExFatFile::truncate()+0x7a>
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (m_firstCluster == 0) {
      return true;
    208c:	movs	r5, #1
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    208e:	mov	r0, r5
    2090:	add	sp, #12
    2092:	pop	{r4, r5, r6, r7, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
    2094:	ldr	r3, [r0, #24]
    2096:	cbnz	r3, 20e6 <ExFatFile::truncate()+0xd2>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
    } else {
      toFree = m_firstCluster;
    2098:	str	r1, [sp, #4]
      m_firstCluster = 0;
    209a:	str	r3, [r0, #28]
    }
    if (toFree) {
      if (!m_vol->freeChain(toFree)) {
    209c:	ldr	r0, [r4, #32]
    209e:	bl	1644 <ExFatPartition::freeChain(unsigned long)>
    20a2:	mov	r5, r0
    20a4:	cmp	r0, #0
    20a6:	beq.n	2120 <ExFatFile::truncate()+0x10c>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    20a8:	ldrd	r0, r1, [r4]
  m_validLength = m_curPosition;
  m_flags |= FILE_FLAG_DIR_DIRTY;
    20ac:	ldrb.w	r3, [r4, #51]	; 0x33
    20b0:	orn	r3, r3, #127	; 0x7f
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
  }
  m_dataLength = m_curPosition;
    20b4:	strd	r0, r1, [r4, #8]
  m_validLength = m_curPosition;
    20b8:	strd	r0, r1, [r4, #16]
  m_flags |= FILE_FLAG_DIR_DIRTY;
    20bc:	strb.w	r3, [r4, #51]	; 0x33
  return sync();
    20c0:	mov	r0, r4
    20c2:	bl	1c44 <ExFatFile::sync()>
    20c6:	mov	r5, r0

 fail:
  return false;
}
    20c8:	mov	r0, r5
    20ca:	add	sp, #12
    20cc:	pop	{r4, r5, r6, r7, pc}
//------------------------------------------------------------------------------
bool ExFatFile::truncate() {
  uint32_t toFree;
  // error if not a normal file or read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    20ce:	movw	r0, #583	; 0x247
    20d2:	and.w	r5, r2, #255	; 0xff
    20d6:	bl	1824 <dbgPrint(unsigned short)>
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return sync();

 fail:
  return false;
}
    20da:	mov	r0, r5
    20dc:	add	sp, #12
    20de:	pop	{r4, r5, r6, r7, pc}
    uint32_t nc = 1 + ((m_dataLength - 1) >> m_vol->bytesPerClusterShift());
    if (m_curCluster) {
      toFree = m_curCluster + 1;
      nc -= 1 + m_curCluster - m_firstCluster;
    } else {
      toFree = m_firstCluster;
    20e0:	str	r1, [sp, #4]
      m_firstCluster = 0;
    20e2:	str	r5, [r4, #28]
    20e4:	b.n	2074 <ExFatFile::truncate()+0x60>
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
      toFree = 0;
    20e6:	add	r2, sp, #8
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    20e8:	mov	r1, r3
      goto fail;
    }
  } else {
    // need to free chain
    if (m_curCluster) {
      toFree = 0;
    20ea:	str.w	r5, [r2, #-4]!
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
    20ee:	ldr	r0, [r0, #32]
    20f0:	bl	1560 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
    20f4:	sxtb	r0, r0
      if (fg < 0) {
    20f6:	cmp	r0, #0
    20f8:	blt.n	212a <ExFatFile::truncate()+0x116>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
    20fa:	bne.n	2104 <ExFatFile::truncate()+0xf0>
      }
    } else {
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (toFree) {
    20fc:	ldr	r1, [sp, #4]
    20fe:	cmp	r1, #0
    2100:	beq.n	20a8 <ExFatFile::truncate()+0x94>
    2102:	b.n	209c <ExFatFile::truncate()+0x88>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (fg) {
        // current cluster is end of chain
        if (!m_vol->fatPut(m_curCluster, EXFAT_EOC)) {
    2104:	mov.w	r2, #4294967295
    2108:	ldr	r1, [r4, #24]
    210a:	ldr	r0, [r4, #32]
    210c:	bl	15f4 <ExFatPartition::fatPut(unsigned long, unsigned long)>
    2110:	mov	r5, r0
    2112:	cmp	r0, #0
    2114:	bne.n	20fc <ExFatFile::truncate()+0xe8>
          DBG_FAIL_MACRO;
    2116:	movw	r0, #614	; 0x266
    211a:	bl	1824 <dbgPrint(unsigned short)>
          goto fail;
    211e:	b.n	208e <ExFatFile::truncate()+0x7a>
      toFree = m_firstCluster;
      m_firstCluster = 0;
    }
    if (toFree) {
      if (!m_vol->freeChain(toFree)) {
        DBG_FAIL_MACRO;
    2120:	mov.w	r0, #624	; 0x270
    2124:	bl	1824 <dbgPrint(unsigned short)>
        goto fail;
    2128:	b.n	208e <ExFatFile::truncate()+0x7a>
    // need to free chain
    if (m_curCluster) {
      toFree = 0;
      int8_t fg = m_vol->fatGet(m_curCluster, &toFree);
      if (fg < 0) {
        DBG_FAIL_MACRO;
    212a:	mov.w	r0, #608	; 0x260
    212e:	bl	1824 <dbgPrint(unsigned short)>
        goto fail;
    2132:	b.n	208e <ExFatFile::truncate()+0x7a>

00002134 <ExFatFile::write(void const*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    2134:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2138:	ldrb.w	r3, [r0, #51]	; 0x33
    213c:	sub	sp, #20

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    213e:	lsls	r4, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t ExFatFile::write(const void* buf, size_t nbyte) {
    2140:	mov	r6, r0
    2142:	str	r2, [sp, #4]

  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    2144:	bpl.w	238e <ExFatFile::write(void const*, unsigned int)+0x25a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    2148:	lsls	r2, r3, #28
    214a:	mov	sl, r1
    214c:	bmi.w	23bc <ExFatFile::write(void const*, unsigned int)+0x288>
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    2150:	ldr	r3, [sp, #4]
    2152:	cmp	r3, #0
    2154:	beq.w	240a <ExFatFile::write(void const*, unsigned int)+0x2d6>
    2158:	mov	r1, r6
    215a:	ldrd	r2, r3, [r1], #24
    215e:	ldr.w	r8, [sp, #4]
    2162:	str	r1, [sp, #12]
    2164:	mov	fp, r2
    clusterOffset = m_curPosition & m_vol->clusterMask();
    2166:	ldr	r0, [r6, #32]
    sectorOffset = clusterOffset & m_vol->sectorMask();
    if (clusterOffset == 0) {
      // start of new cluster
      if (m_curCluster != 0) {
    2168:	ldr	r5, [r6, #24]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    clusterOffset = m_curPosition & m_vol->clusterMask();
    216a:	ldr.w	r4, [r0, #1072]	; 0x430
    216e:	mov	r3, fp
    2170:	ands	r4, r3
    sectorOffset = clusterOffset & m_vol->sectorMask();
    2172:	ubfx	r9, r4, #0, #9
    if (clusterOffset == 0) {
    2176:	cbnz	r4, 21ce <ExFatFile::write(void const*, unsigned int)+0x9a>
      // start of new cluster
      if (m_curCluster != 0) {
    2178:	cmp	r5, #0
    217a:	beq.w	2320 <ExFatFile::write(void const*, unsigned int)+0x1ec>
        int fg;

        if (isContiguous()) {
    217e:	ldrb.w	r3, [r6, #51]	; 0x33
    2182:	lsls	r3, r3, #25
    2184:	bpl.w	2352 <ExFatFile::write(void const*, unsigned int)+0x21e>
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
    2188:	ldrd	r2, r3, [r6, #8]
    218c:	ldrb.w	r7, [r0, #1085]	; 0x43d
    2190:	adds	r7, #9
    2192:	uxtb	r7, r7
    2194:	adds.w	r2, r2, #4294967295
    2198:	adc.w	r3, r3, #4294967295
    219c:	rsb	lr, r7, #32
    21a0:	lsl.w	lr, r3, lr
    21a4:	lsr.w	r1, r2, r7
    21a8:	subs	r7, #32
    21aa:	lsr.w	r7, r3, r7
    21ae:	orr.w	r1, r1, lr
    21b2:	ldr	r3, [r6, #28]
    21b4:	orrs	r1, r7
    21b6:	add	r3, r1
    21b8:	cmp	r5, r3
    21ba:	bcc.w	234c <ExFatFile::write(void const*, unsigned int)+0x218>
            goto fail;
          }
        }
        if (fg == 0) {
          // add cluster if at end of chain
          if (!addCluster()) {
    21be:	mov	r0, r6
    21c0:	bl	1860 <ExFatFile::addCluster()>
    21c4:	cmp	r0, #0
    21c6:	beq.w	23f6 <ExFatFile::write(void const*, unsigned int)+0x2c2>
    21ca:	ldr	r0, [r6, #32]
    21cc:	ldr	r5, [r6, #24]
        }
      }
    }
    // sector for data write
    sector = m_vol->clusterStartSector(m_curCluster) +
             (clusterOffset >> m_vol->bytesPerSectorShift());
    21ce:	ldr.w	r7, [r0, #1060]	; 0x424
  bool dataCacheSync() {return m_dataCache.sync();}
  //----------------------------------------------------------------------------
  uint32_t clusterMask() {return m_clusterMask;}
  uint32_t clusterStartSector(uint32_t cluster) {
    return m_clusterHeapStartSector +
           ((cluster - 2) << m_sectorsPerClusterShift);
    21d2:	ldrb.w	lr, [r0, #1085]	; 0x43d
    21d6:	lsrs	r4, r4, #9
    21d8:	subs	r5, #2
    21da:	adds	r1, r4, r7
    21dc:	lsl.w	r5, r5, lr
    21e0:	add	r1, r5

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
    21e2:	cmp.w	r9, #0
    21e6:	bne.w	22fc <ExFatFile::write(void const*, unsigned int)+0x1c8>
    21ea:	cmp.w	r8, #512	; 0x200
    21ee:	bcs.n	22a6 <ExFatFile::write(void const*, unsigned int)+0x172>
      // lesser of space and amount to write
      if (n > toWrite) {
        n = toWrite;
      }

      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
    21f0:	ldrd	r2, r3, [r6, #16]
    21f4:	ldrd	r4, r5, [r6]
    21f8:	cmp.w	r8, #512	; 0x200
    21fc:	mov	r7, r8
    21fe:	it	cs
    2200:	movcs.w	r7, #512	; 0x200
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
    2204:	cmp	r5, r3
    2206:	it	eq
    2208:	cmpeq	r4, r2
    220a:	ite	cc
    220c:	movcc	r2, #1
    220e:	movcs	r2, #3
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    2210:	add.w	r0, r0, #524	; 0x20c
    2214:	bl	1204 <FsCache::get(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
      }
      cache = m_vol->dataCacheGet(sector, cacheOption);
      if (!cache) {
    2218:	cmp	r0, #0
    221a:	beq.n	2316 <ExFatFile::write(void const*, unsigned int)+0x1e2>
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    221c:	add	r0, r9
    221e:	mov	r2, r7
    2220:	mov	r1, sl
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    2222:	add	r9, r7
      if (!cache) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
    2224:	bl	8c24 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    2228:	cmp.w	r9, #512	; 0x200
    222c:	beq.w	2374 <ExFatFile::write(void const*, unsigned int)+0x240>
    2230:	mov	r0, r7
    2232:	movs	r1, #0
      if (!m_vol->writeSector(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    2234:	ldrd	r2, r3, [r6]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    2238:	ldrd	r4, r5, [r6, #16]
      if (!m_vol->writeSector(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    223c:	adds.w	fp, r2, r0
    2240:	adc.w	ip, r3, r1
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    2244:	cmp	r5, ip
      if (!m_vol->writeSector(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    2246:	mov	r2, fp
    2248:	mov	r3, ip
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    224a:	it	eq
    224c:	cmpeq	r4, fp
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    src += n;
    224e:	add	sl, r7
    toWrite -= n;
    2250:	rsb	r8, r7, r8
      if (!m_vol->writeSector(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    2254:	strd	r2, r3, [r6]
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
    2258:	bcs.n	226e <ExFatFile::write(void const*, unsigned int)+0x13a>
      m_flags |= FILE_FLAG_DIR_DIRTY;
    225a:	ldrb.w	r1, [r6, #51]	; 0x33
      m_validLength = m_curPosition;
    225e:	mov	r4, ip
    2260:	mov	r3, fp
    2262:	strd	r3, r4, [r6, #16]
    }
    m_curPosition += n;
    src += n;
    toWrite -= n;
    if (m_curPosition > m_validLength) {
      m_flags |= FILE_FLAG_DIR_DIRTY;
    2266:	orn	r1, r1, #127	; 0x7f
    226a:	strb.w	r1, [r6, #51]	; 0x33
    if (!seekSet(m_validLength)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  while (toWrite) {
    226e:	cmp.w	r8, #0
    2272:	bne.w	2166 <ExFatFile::write(void const*, unsigned int)+0x32>
    2276:	mov	r2, fp
    2278:	mov	r3, ip
      m_flags |= FILE_FLAG_DIR_DIRTY;
      m_validLength = m_curPosition;
    }
  }

  if (m_curPosition > m_dataLength) {
    227a:	ldrd	r0, r1, [r6, #8]
    227e:	cmp	r1, r3
    2280:	it	eq
    2282:	cmpeq	r0, r2
    2284:	bcc.w	23d4 <ExFatFile::write(void const*, unsigned int)+0x2a0>
    m_dataLength = m_curPosition;
    // update fileSize and insure sync will update dir entr
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    2288:	ldr	r3, [pc, #388]	; (2410 <ExFatFile::write(void const*, unsigned int)+0x2dc>)
    228a:	ldr	r3, [r3, #0]
    228c:	cmp	r3, #0
    228e:	beq.w	23f2 <ExFatFile::write(void const*, unsigned int)+0x2be>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    2292:	ldrb.w	r3, [r6, #51]	; 0x33
    2296:	ldr	r0, [sp, #4]
    2298:	orn	r3, r3, #127	; 0x7f
    229c:	strb.w	r3, [r6, #51]	; 0x33

fail:
  // return for write error
  m_error |= WRITE_ERROR;
  return -1;
}
    22a0:	add	sp, #20
    22a2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
    22a6:	cmp.w	r8, #1024	; 0x400
    22aa:	bcc.n	2328 <ExFatFile::write(void const*, unsigned int)+0x1f4>
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
      // Limit writes to current cluster.
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
    22ac:	movs	r3, #1
    22ae:	lsl.w	lr, r3, lr
    22b2:	rsb	lr, r4, lr
    22b6:	ldr.w	r3, [r0, #532]	; 0x214
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (toWrite >= 2*m_vol->bytesPerSector()) {
      // use multiple sector write command
      uint32_t ns = toWrite >> m_vol->bytesPerSectorShift();
    22ba:	mov.w	r4, r8, lsr #9
    22be:	cmp	r4, lr
    22c0:	it	cs
    22c2:	movcs	r4, lr
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
      // Check for cache sector in write range.
      if (sector <= m_vol->dataCacheSector()
          && m_vol->dataCacheSector() < (sector + ns)) {
    22c4:	cmp	r1, r3
      uint32_t maxNs = m_vol->sectorsPerCluster()
                       - (clusterOffset >> m_vol->bytesPerSectorShift());
      if (ns > maxNs) {
        ns = maxNs;
      }
      n = ns << m_vol->bytesPerSectorShift();
    22c6:	mov.w	r7, r4, lsl #9
      // Check for cache sector in write range.
      if (sector <= m_vol->dataCacheSector()
          && m_vol->dataCacheSector() < (sector + ns)) {
    22ca:	bhi.n	22e0 <ExFatFile::write(void const*, unsigned int)+0x1ac>
    22cc:	adds	r2, r4, r1
    22ce:	cmp	r2, r3
    22d0:	bls.n	22e0 <ExFatFile::write(void const*, unsigned int)+0x1ac>
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
    22d2:	add.w	r0, r0, #524	; 0x20c
    22d6:	str	r1, [sp, #8]
    22d8:	bl	11f8 <FsCache::invalidate()>
    22dc:	ldr	r0, [r6, #32]
    22de:	ldr	r1, [sp, #8]
    22e0:	ldr.w	r0, [r0, #1080]	; 0x438
#if USE_MULTI_SECTOR_IO
  bool readSectors(uint32_t sector, uint8_t* dst, size_t count) {
    return m_blockDev->readSectors(sector, dst, count);
  }
  bool writeSectors(uint32_t sector, const uint8_t* src, size_t count) {
    return m_blockDev->writeSectors(sector, src, count);
    22e4:	ldr	r5, [r0, #0]
    22e6:	mov	r3, r4
    22e8:	mov	r2, sl
    22ea:	ldr	r4, [r5, #28]
    22ec:	blx	r4
        // Invalidate cache if cache sector is in the range.
        m_vol->dataCacheInvalidate();
      }
      if (!m_vol->writeSectors(sector, src, ns)) {
    22ee:	cmp	r0, #0
    22f0:	bne.n	2230 <ExFatFile::write(void const*, unsigned int)+0xfc>
        DBG_FAIL_MACRO;
    22f2:	movw	r0, #758	; 0x2f6
    22f6:	bl	1824 <dbgPrint(unsigned short)>
        goto fail;
    22fa:	b.n	2396 <ExFatFile::write(void const*, unsigned int)+0x262>
             (clusterOffset >> m_vol->bytesPerSectorShift());

    if (sectorOffset != 0 || toWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    22fc:	rsb	r7, r9, #512	; 0x200
    2300:	cmp	r7, r8
      if (sectorOffset == 0 && m_curPosition >= m_validLength) {
        // start of new sector don't need to read into cache
        cacheOption = FsCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FsCache::CACHE_FOR_WRITE;
    2302:	mov.w	r2, #1
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
    2306:	add.w	r0, r0, #524	; 0x20c
    230a:	it	cs
    230c:	movcs	r7, r8
    230e:	bl	1204 <FsCache::get(unsigned long, unsigned char)>
      }
      cache = m_vol->dataCacheGet(sector, cacheOption);
      if (!cache) {
    2312:	cmp	r0, #0
    2314:	bne.n	221c <ExFatFile::write(void const*, unsigned int)+0xe8>
        DBG_FAIL_MACRO;
    2316:	mov.w	r0, #728	; 0x2d8
    231a:	bl	1824 <dbgPrint(unsigned short)>
        goto fail;
    231e:	b.n	2396 <ExFatFile::write(void const*, unsigned int)+0x262>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    2320:	ldr	r5, [r6, #28]
    2322:	cbz	r5, 2362 <ExFatFile::write(void const*, unsigned int)+0x22e>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
        } else {
          m_curCluster = m_firstCluster;
    2324:	str	r5, [r6, #24]
    2326:	b.n	21ce <ExFatFile::write(void const*, unsigned int)+0x9a>
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
      if (m_vol->dataCacheSector() == sector) {
    2328:	ldr.w	r3, [r0, #532]	; 0x214
    232c:	cmp	r1, r3
    232e:	beq.n	23ac <ExFatFile::write(void const*, unsigned int)+0x278>
    2330:	ldr.w	r0, [r0, #1080]	; 0x438
  }
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    2334:	ldr	r3, [r0, #0]
    2336:	mov	r2, sl
    2338:	ldr	r3, [r3, #24]
    233a:	blx	r3
        m_vol->dataCacheInvalidate();
      }
      if (!m_vol->writeSector(sector, src)) {
    233c:	cmp	r0, #0
    233e:	beq.n	23e8 <ExFatFile::write(void const*, unsigned int)+0x2b4>
    2340:	mov.w	r0, #512	; 0x200
    2344:	movs	r1, #0
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
    2346:	mov.w	r7, #512	; 0x200
    234a:	b.n	2234 <ExFatFile::write(void const*, unsigned int)+0x100>

        if (isContiguous()) {
          uint32_t lc = m_firstCluster;
          lc += (m_dataLength - 1) >> m_vol->bytesPerClusterShift();
          if (m_curCluster < lc) {
            m_curCluster++;
    234c:	adds	r5, #1
    234e:	str	r5, [r6, #24]
    2350:	b.n	21ce <ExFatFile::write(void const*, unsigned int)+0x9a>
            fg = 1;
          } else {
            fg = 0;
          }
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    2352:	mov	r1, r5
    2354:	ldr	r2, [sp, #12]
    2356:	bl	1560 <ExFatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
        if (fg == 0) {
    235a:	cmp	r0, #0
    235c:	bne.w	21ca <ExFatFile::write(void const*, unsigned int)+0x96>
    2360:	b.n	21be <ExFatFile::write(void const*, unsigned int)+0x8a>
          }
        }
      } else {
        if (m_firstCluster == 0) {
          // allocate first cluster of file
          if (!addCluster()) {
    2362:	mov	r0, r6
    2364:	bl	1860 <ExFatFile::addCluster()>
    2368:	cmp	r0, #0
    236a:	beq.n	2400 <ExFatFile::write(void const*, unsigned int)+0x2cc>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    236c:	ldr	r5, [r6, #24]
    236e:	str	r5, [r6, #28]
    2370:	ldr	r0, [r6, #32]
    2372:	b.n	21ce <ExFatFile::write(void const*, unsigned int)+0x9a>
  void dataCacheInvalidate() {m_dataCache.invalidate();}
  uint8_t* dataCacheGet(uint32_t sector, uint8_t option) {
    return m_dataCache.get(sector, option);
  }
  uint32_t dataCacheSector() {return m_dataCache.sector();}
  bool dataCacheSync() {return m_dataCache.sync();}
    2374:	ldr	r0, [r6, #32]
    2376:	add.w	r0, r0, #524	; 0x20c
    237a:	bl	1290 <FsCache::sync()>
      }
      uint8_t* dst = cache + sectorOffset;
      memcpy(dst, src, n);
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
        // Force write if sector is full - improves large writes.
        if (!m_vol->dataCacheSync()) {
    237e:	cmp	r0, #0
    2380:	bne.w	2230 <ExFatFile::write(void const*, unsigned int)+0xfc>
          DBG_FAIL_MACRO;
    2384:	mov.w	r0, #736	; 0x2e0
    2388:	bl	1824 <dbgPrint(unsigned short)>
          goto fail;
    238c:	b.n	2396 <ExFatFile::write(void const*, unsigned int)+0x262>
  // number of bytes left to write  -  must be before goto statements
  size_t toWrite = nbyte;
  size_t n;
  // error if not an open file or is read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    238e:	mov.w	r0, #652	; 0x28c
    2392:	bl	1824 <dbgPrint(unsigned short)>
  }
  return nbyte;

fail:
  // return for write error
  m_error |= WRITE_ERROR;
    2396:	ldrb.w	r3, [r6, #50]	; 0x32
    239a:	orr.w	r3, r3, #1
    239e:	strb.w	r3, [r6, #50]	; 0x32
  return -1;
    23a2:	mov.w	r0, #4294967295
}
    23a6:	add	sp, #20
    23a8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#else  // USE_EXFAT_BITMAP_CACHE
    return m_dataCache.sync() && syncDevice();
#endif  // USE_EXFAT_BITMAP_CACHE
  }
  void dataCacheDirty() {m_dataCache.dirty();}
  void dataCacheInvalidate() {m_dataCache.invalidate();}
    23ac:	add.w	r0, r0, #524	; 0x20c
    23b0:	str	r1, [sp, #8]
    23b2:	bl	11f8 <FsCache::invalidate()>
    23b6:	ldr	r0, [r6, #32]
    23b8:	ldr	r1, [sp, #8]
    23ba:	b.n	2330 <ExFatFile::write(void const*, unsigned int)+0x1fc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_validLength)) {
    23bc:	ldrd	r2, r3, [r0, #16]
    23c0:	bl	ae0 <ExFatFile::seekSet(unsigned long long)>
    23c4:	cmp	r0, #0
    23c6:	bne.w	2150 <ExFatFile::write(void const*, unsigned int)+0x1c>
      DBG_FAIL_MACRO;
    23ca:	movw	r0, #658	; 0x292
    23ce:	bl	1824 <dbgPrint(unsigned short)>
      goto fail;
    23d2:	b.n	2396 <ExFatFile::write(void const*, unsigned int)+0x262>
  }

  if (m_curPosition > m_dataLength) {
    m_dataLength = m_curPosition;
    // update fileSize and insure sync will update dir entr
    m_flags |= FILE_FLAG_DIR_DIRTY;
    23d4:	ldrb.w	r1, [r6, #51]	; 0x33
    23d8:	ldr	r0, [sp, #4]
    23da:	orn	r1, r1, #127	; 0x7f
      m_validLength = m_curPosition;
    }
  }

  if (m_curPosition > m_dataLength) {
    m_dataLength = m_curPosition;
    23de:	strd	r2, r3, [r6, #8]
    // update fileSize and insure sync will update dir entr
    m_flags |= FILE_FLAG_DIR_DIRTY;
    23e2:	strb.w	r1, [r6, #51]	; 0x33
    23e6:	b.n	23a6 <ExFatFile::write(void const*, unsigned int)+0x272>
      n = m_vol->bytesPerSector();
      if (m_vol->dataCacheSector() == sector) {
        m_vol->dataCacheInvalidate();
      }
      if (!m_vol->writeSector(sector, src)) {
        DBG_FAIL_MACRO;
    23e8:	movw	r0, #769	; 0x301
    23ec:	bl	1824 <dbgPrint(unsigned short)>
        goto fail;
    23f0:	b.n	2396 <ExFatFile::write(void const*, unsigned int)+0x262>
    23f2:	ldr	r0, [sp, #4]
    23f4:	b.n	23a6 <ExFatFile::write(void const*, unsigned int)+0x272>
          }
        }
        if (fg == 0) {
          // add cluster if at end of chain
          if (!addCluster()) {
            DBG_FAIL_MACRO;
    23f6:	movw	r0, #689	; 0x2b1
    23fa:	bl	1824 <dbgPrint(unsigned short)>
            goto fail;
    23fe:	b.n	2396 <ExFatFile::write(void const*, unsigned int)+0x262>
        }
      } else {
        if (m_firstCluster == 0) {
          // allocate first cluster of file
          if (!addCluster()) {
            DBG_FAIL_MACRO;
    2400:	movw	r0, #697	; 0x2b9
    2404:	bl	1824 <dbgPrint(unsigned short)>
            goto fail;
    2408:	b.n	2396 <ExFatFile::write(void const*, unsigned int)+0x262>
    240a:	ldrd	r2, r3, [r6]
    240e:	b.n	227a <ExFatFile::write(void const*, unsigned int)+0x146>
    2410:	.word	0x1fff13c8

00002414 <dbgPrint(unsigned short)>:
#if USE_DBG_MACROS
#include "Arduino.h"
#ifndef DBG_FILE
#error DBG_FILE not defined
#endif  // DBG_FILE
static void dbgPrint(uint16_t line) {
    2414:	push	{r3, r4, r5, lr}
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    2416:	movs	r1, #10
    2418:	mov	r5, r0
    241a:	ldr	r0, [pc, #40]	; (2444 <dbgPrint(unsigned short)+0x30>)
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    241c:	ldr	r4, [pc, #40]	; (2448 <dbgPrint(unsigned short)+0x34>)
    241e:	bl	8e24 <usb_serial_write>
    2422:	movs	r1, #11
    2424:	ldr	r0, [pc, #36]	; (244c <dbgPrint(unsigned short)+0x38>)
    2426:	bl	8e24 <usb_serial_write>
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    242a:	movs	r0, #46	; 0x2e
    242c:	bl	8f2c <usb_serial_putchar>
    2430:	mov	r1, r5
    2432:	mov	r0, r4
    2434:	bl	ae20 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    2438:	mov	r0, r4
  Serial.print(F("DBG_FAIL: "));
  Serial.print(F(DBG_FILE));
  Serial.write('.');
  Serial.println(line);
}
    243a:	ldmia.w	sp!, {r3, r4, r5, lr}
    243e:	b.w	ad80 <Print::println()>
    2442:	nop
    2444:	.word	0x0000c270
    2448:	.word	0x1fff099c
    244c:	.word	0x0000c2bc

00002450 <FatFile::addCluster()>:
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    2450:	mov	r2, r0
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    2452:	push	{r4, r5, r6, lr}
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
    2454:	ldr.w	r5, [r2, #16]!
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
// Add a cluster to a file.
bool FatFile::addCluster() {
    2458:	mov	r4, r0
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    245a:	mov	r1, r5
    245c:	ldr	r0, [r0, #8]
    245e:	bl	3680 <FatPartition::allocateCluster(unsigned long, unsigned long*)>
    2462:	mov	r6, r0
    2464:	cbz	r0, 2488 <FatFile::addCluster()+0x38>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    2466:	cbz	r5, 2480 <FatFile::addCluster()+0x30>
    m_flags |= FILE_FLAG_CONTIGUOUS;
  } else if (m_curCluster != (cc + 1)) {
    2468:	ldr	r3, [r4, #16]
    246a:	adds	r5, #1
    246c:	cmp	r3, r5
    m_flags &= ~FILE_FLAG_CONTIGUOUS;
    246e:	ldrb	r3, [r4, #2]
    2470:	it	ne
    2472:	andne.w	r3, r3, #191	; 0xbf
  }
  m_flags |= FILE_FLAG_DIR_DIRTY;
    2476:	orn	r3, r3, #127	; 0x7f
    247a:	strb	r3, [r4, #2]
  return false;
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
    247c:	mov	r0, r6
    247e:	pop	{r4, r5, r6, pc}
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (cc == 0) {
    m_flags |= FILE_FLAG_CONTIGUOUS;
    2480:	ldrb	r3, [r4, #2]
    2482:	orr.w	r3, r3, #64	; 0x40
    2486:	b.n	2476 <FatFile::addCluster()+0x26>
// Add a cluster to a file.
bool FatFile::addCluster() {
#if USE_FAT_FILE_FLAG_CONTIGUOUS
  uint32_t cc = m_curCluster;
  if (!m_vol->allocateCluster(m_curCluster, &m_curCluster)) {
    DBG_FAIL_MACRO;
    2488:	movs	r0, #35	; 0x23
    248a:	bl	2414 <dbgPrint(unsigned short)>
  return false;
#else  // USE_FAT_FILE_FLAG_CONTIGUOUS
  m_flags |= FILE_FLAG_DIR_DIRTY;
  return m_vol->allocateCluster(m_curCluster, &m_curCluster);
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
}
    248e:	mov	r0, r6
    2490:	pop	{r4, r5, r6, pc}
    2492:	nop

00002494 <FatFile::addDirCluster()>:
//------------------------------------------------------------------------------
// Add a cluster to a directory file and zero the cluster.
// Return with first sector of cluster in the cache.
bool FatFile::addDirCluster() {
    2494:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    2498:	ldrb	r3, [r0, #0]
    249a:	and.w	r3, r3, #32
    249e:	cmp	r3, #0
    24a0:	bne.n	2526 <FatFile::addDirCluster()+0x92>
    24a2:	and.w	r4, r3, #255	; 0xff
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    24a6:	ldr	r2, [r0, #20]
    24a8:	ldr	r3, [pc, #184]	; (2564 <FatFile::addDirCluster()+0xd0>)
    24aa:	cmp	r2, r3
    24ac:	mov	r5, r0
    24ae:	bhi.n	2518 <FatFile::addDirCluster()+0x84>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    24b0:	bl	2450 <FatFile::addCluster()>
    24b4:	mov	r8, r0
    24b6:	cmp	r0, #0
    24b8:	beq.n	2536 <FatFile::addDirCluster()+0xa2>
    DBG_FAIL_MACRO;
    goto fail;
  }
  sector = m_vol->clusterStartSector(m_curCluster);
    24ba:	ldr	r1, [r5, #16]
    24bc:	ldr	r0, [r5, #8]
    24be:	bl	3554 <FatPartition::clusterStartSector(unsigned long) const>
    24c2:	mov	r6, r0
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return m_cache.read(sector, options);
    24c4:	ldr	r0, [r5, #8]
    24c6:	mov	r1, r6
    24c8:	adds	r0, #36	; 0x24
    24ca:	movs	r2, #5
    24cc:	bl	34c8 <FatCache::read(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FatCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    24d0:	mov	r7, r0
    24d2:	cmp	r0, #0
    24d4:	beq.n	255a <FatFile::addDirCluster()+0xc6>
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
    24d6:	mov.w	r2, #512	; 0x200
    24da:	mov	r1, r4
    24dc:	bl	bb7c <memset>
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    24e0:	ldr	r3, [r5, #8]
    24e2:	ldrb	r2, [r3, #4]
    24e4:	cmp	r2, #1
    24e6:	bls.n	2542 <FatFile::addDirCluster()+0xae>
    24e8:	movs	r4, #1
    24ea:	b.n	24f4 <FatFile::addDirCluster()+0x60>
    24ec:	ldr	r3, [r5, #8]
    24ee:	ldrb	r2, [r3, #4]
    24f0:	cmp	r2, r4
    24f2:	bls.n	2542 <FatFile::addDirCluster()+0xae>
    24f4:	ldr	r0, [r3, #0]
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    24f6:	ldr	r3, [r0, #0]
    24f8:	adds	r1, r4, r6
    24fa:	ldr	r3, [r3, #24]
    24fc:	mov	r2, r7
    24fe:	blx	r3
    2500:	adds	r4, #1
    if (!m_vol->writeSector(sector + i, pc->data)) {
    2502:	mov	r3, r0
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(pc, 0, m_vol->bytesPerSector());
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    2504:	uxtb	r4, r4
    if (!m_vol->writeSector(sector + i, pc->data)) {
    2506:	cmp	r0, #0
    2508:	bne.n	24ec <FatFile::addDirCluster()+0x58>
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

fail:
  return false;
    250a:	mov	r8, r3
  }
  memset(pc, 0, m_vol->bytesPerSector());
  // zero rest of clusters
  for (uint8_t i = 1; i < m_vol->sectorsPerCluster(); i++) {
    if (!m_vol->writeSector(sector + i, pc->data)) {
      DBG_FAIL_MACRO;
    250c:	movs	r0, #83	; 0x53
    250e:	bl	2414 <dbgPrint(unsigned short)>
  m_curPosition += m_vol->bytesPerCluster();
  return true;

fail:
  return false;
}
    2512:	mov	r0, r8
    2514:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    DBG_FAIL_MACRO;
    2518:	movs	r0, #66	; 0x42
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

fail:
  return false;
    251a:	mov	r8, r4
    DBG_FAIL_MACRO;
    goto fail;
  }
  // max folder size
  if (m_curPosition >= 512UL*4095) {
    DBG_FAIL_MACRO;
    251c:	bl	2414 <dbgPrint(unsigned short)>
  m_curPosition += m_vol->bytesPerCluster();
  return true;

fail:
  return false;
}
    2520:	mov	r0, r8
    2522:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
bool FatFile::addDirCluster() {
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    DBG_FAIL_MACRO;
    2526:	movs	r0, #61	; 0x3d
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

fail:
  return false;
    2528:	mov.w	r8, #0
bool FatFile::addDirCluster() {
  uint32_t sector;
  cache_t* pc;

  if (isRootFixed()) {
    DBG_FAIL_MACRO;
    252c:	bl	2414 <dbgPrint(unsigned short)>
  m_curPosition += m_vol->bytesPerCluster();
  return true;

fail:
  return false;
}
    2530:	mov	r0, r8
    2532:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (m_curPosition >= 512UL*4095) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!addCluster()) {
    DBG_FAIL_MACRO;
    2536:	movs	r0, #70	; 0x46
    2538:	bl	2414 <dbgPrint(unsigned short)>
  m_curPosition += m_vol->bytesPerCluster();
  return true;

fail:
  return false;
}
    253c:	mov	r0, r8
    253e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
    2542:	ldrb	r3, [r3, #6]
    2544:	ldr	r1, [r5, #20]
    2546:	mov.w	r2, #512	; 0x200
    254a:	lsl.w	r3, r2, r3
    254e:	uxtah	r3, r1, r3
    2552:	str	r3, [r5, #20]
  return true;

fail:
  return false;
}
    2554:	mov	r0, r8
    2556:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    goto fail;
  }
  sector = m_vol->clusterStartSector(m_curCluster);
  pc = m_vol->cacheFetchData(sector, FatCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    DBG_FAIL_MACRO;
    255a:	movs	r0, #76	; 0x4c
  // Set position to EOF to avoid inconsistent curCluster/curPosition.
  m_curPosition += m_vol->bytesPerCluster();
  return true;

fail:
  return false;
    255c:	mov	r8, r7
    goto fail;
  }
  sector = m_vol->clusterStartSector(m_curCluster);
  pc = m_vol->cacheFetchData(sector, FatCache::CACHE_RESERVE_FOR_WRITE);
  if (!pc) {
    DBG_FAIL_MACRO;
    255e:	bl	2414 <dbgPrint(unsigned short)>
    2562:	b.n	2520 <FatFile::addDirCluster()+0x8c>
    2564:	.word	0x001ffdff

00002568 <FatFile::cacheDirEntry(unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
DirFat_t* FatFile::cacheDirEntry(uint8_t action) {
    2568:	push	{r3, r4, r5, lr}
    256a:	mov	r5, r0
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return m_cache.read(sector, options);
    256c:	ldr	r0, [r0, #8]
    256e:	mov	r2, r1
    2570:	adds	r0, #36	; 0x24
    2572:	ldr	r1, [r5, #24]
    2574:	bl	34c8 <FatCache::read(unsigned long, unsigned char)>
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirSector, action);
  if (!pc) {
    2578:	mov	r4, r0
    257a:	cbz	r0, 2588 <FatFile::cacheDirEntry(unsigned char)+0x20>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);
    257c:	ldrh	r0, [r5, #4]
    257e:	and.w	r0, r0, #15
    2582:	add.w	r0, r4, r0, lsl #5

fail:
  return nullptr;
}
    2586:	pop	{r3, r4, r5, pc}
// return pointer to cached entry or null for failure
DirFat_t* FatFile::cacheDirEntry(uint8_t action) {
  cache_t* pc;
  pc = m_vol->cacheFetchData(m_dirSector, action);
  if (!pc) {
    DBG_FAIL_MACRO;
    2588:	movs	r0, #101	; 0x65
    258a:	bl	2414 <dbgPrint(unsigned short)>
    goto fail;
  }
  return pc->dir + (m_dirIndex & 0XF);

fail:
  return nullptr;
    258e:	mov	r0, r4
    2590:	pop	{r3, r4, r5, pc}
    2592:	nop

00002594 <FatFile::sync() [clone .part.38]>:
fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    2594:	push	{r4, r5, r6, lr}
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    2596:	ldrsb.w	r3, [r0, #2]
    259a:	cmp	r3, #0
fail:
  m_curCluster = tmp;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
    259c:	sub	sp, #8
    259e:	mov	r4, r0
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    25a0:	blt.n	25de <FatFile::sync() [clone .part.38]+0x4a>
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
  }
  if (m_vol->cacheSync()) {
    25a2:	ldr	r5, [r4, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    return m_fatCache.read(sector,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    25a4:	add.w	r0, r5, #36	; 0x24
    25a8:	bl	3544 <FatCache::sync()>
    25ac:	cbnz	r0, 25c4 <FatFile::sync() [clone .part.38]+0x30>
    return true;
  }
  DBG_FAIL_MACRO;
    25ae:	movw	r0, #1150	; 0x47e
    25b2:	bl	2414 <dbgPrint(unsigned short)>

fail:
  m_error |= WRITE_ERROR;
    25b6:	ldrb	r3, [r4, #1]
    25b8:	orr.w	r3, r3, #1
    25bc:	strb	r3, [r4, #1]
  return false;
    25be:	movs	r0, #0
}
    25c0:	add	sp, #8
    25c2:	pop	{r4, r5, r6, pc}
    25c4:	add.w	r0, r5, #560	; 0x230
    25c8:	bl	3544 <FatCache::sync()>
    25cc:	cmp	r0, #0
    25ce:	beq.n	25ae <FatFile::sync() [clone .part.38]+0x1a>
    25d0:	ldr	r0, [r5, #0]
  // sector I/O functions.
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    25d2:	ldr	r3, [r0, #0]
    25d4:	ldr	r3, [r3, #20]
    25d6:	blx	r3
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    return m_fatCache.read(sector,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    25d8:	cmp	r0, #0
    25da:	beq.n	25ae <FatFile::sync() [clone .part.38]+0x1a>
    25dc:	b.n	25c0 <FatFile::sync() [clone .part.38]+0x2c>
  uint8_t ms10;
  if (!isOpen()) {
    return true;
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    DirFat_t* dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
    25de:	movs	r1, #1
    25e0:	bl	2568 <FatFile::cacheDirEntry(unsigned char)>
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
    25e4:	mov	r5, r0
    25e6:	cbz	r0, 262a <FatFile::sync() [clone .part.38]+0x96>
    25e8:	ldrb	r3, [r0, #0]
    25ea:	cmp	r3, #229	; 0xe5
    25ec:	beq.n	262a <FatFile::sync() [clone .part.38]+0x96>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    25ee:	ldrb	r3, [r4, #0]
    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    25f0:	ldr	r2, [pc, #64]	; (2634 <FatFile::sync() [clone .part.38]+0xa0>)
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // do not set filesize for dir files
    if (isFile()) {
    25f2:	lsls	r3, r3, #28
      setLe32(dir->fileSize, m_fileSize);
    25f4:	itt	mi
    25f6:	ldrmi	r3, [r4, #28]
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    25f8:	strmi	r3, [r0, #28]
    }

    // update first cluster fields
    setLe16(dir->firstClusterLow, m_firstCluster & 0XFFFF);
    25fa:	ldr	r3, [r4, #32]
    setLe16(dir->firstClusterHigh, m_firstCluster >> 16);

    // set modify time if user supplied a callback date/time function
    if (FsDateTime::callback) {
    25fc:	ldr	r6, [r2, #0]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    25fe:	strh	r3, [r0, #26]
    2600:	lsrs	r3, r3, #16
    2602:	strh	r3, [r0, #20]
    2604:	cbz	r6, 2620 <FatFile::sync() [clone .part.38]+0x8c>
      FsDateTime::callback(&date, &time, &ms10);
    2606:	add.w	r2, sp, #3
    260a:	add.w	r1, sp, #6
    260e:	add	r0, sp, #4
    2610:	blx	r6
      setLe16(dir->modifyDate, date);
    2612:	ldrh.w	r3, [sp, #4]
    2616:	ldrh.w	r2, [sp, #6]
    261a:	strh	r3, [r5, #24]
    261c:	strh	r3, [r5, #18]
    261e:	strh	r2, [r5, #22]
      setLe16(dir->accessDate, date);
      setLe16(dir->modifyTime, time);
    }
    // clear directory dirty
    m_flags &= ~FILE_FLAG_DIR_DIRTY;
    2620:	ldrb	r3, [r4, #2]
    2622:	and.w	r3, r3, #127	; 0x7f
    2626:	strb	r3, [r4, #2]
    2628:	b.n	25a2 <FatFile::sync() [clone .part.38]+0xe>
  }
  if (m_flags & FILE_FLAG_DIR_DIRTY) {
    DirFat_t* dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
    // check for deleted by another open file object
    if (!dir || dir->name[0] == FAT_NAME_DELETED) {
      DBG_FAIL_MACRO;
    262a:	movw	r0, #1125	; 0x465
    262e:	bl	2414 <dbgPrint(unsigned short)>
    2632:	b.n	25b6 <FatFile::sync() [clone .part.38]+0x22>
    2634:	.word	0x1fff13c8

00002638 <FatFile::close()>:

fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    2638:	push	{r4, lr}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    263a:	ldrb	r3, [r0, #0]

fail:
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
    263c:	mov	r4, r0
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    263e:	cbnz	r3, 264a <FatFile::close()+0x12>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    2640:	movs	r3, #0
    2642:	strb	r3, [r4, #0]
  m_flags = 0;
    2644:	strb	r3, [r4, #2]
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    return true;
    2646:	movs	r0, #1
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return rtn;
}
    2648:	pop	{r4, pc}
    264a:	bl	2594 <FatFile::sync() [clone .part.38]>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    264e:	movs	r3, #0
    2650:	strb	r3, [r4, #0]
  m_flags = 0;
    2652:	strb	r3, [r4, #2]
  return rtn;
}
    2654:	pop	{r4, pc}
    2656:	nop

00002658 <FatFile::openRoot(FatVolume*)>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
    2658:	push	{r4, r5, r6, lr}
  // error if file is already open
  if (isOpen()) {
    265a:	ldrb	r4, [r0, #0]
    265c:	cbnz	r4, 268a <FatFile::openRoot(FatVolume*)+0x32>
    265e:	mov	r5, r0
    2660:	mov	r6, r1
    DBG_FAIL_MACRO;
    goto fail;
  }
  memset(this, 0, sizeof(FatFile));
    2662:	movs	r2, #36	; 0x24
    2664:	mov	r1, r4
    2666:	bl	bb7c <memset>

  m_vol = vol;
    266a:	str	r6, [r5, #8]
  switch (vol->fatType()) {
    266c:	ldrb	r3, [r6, #7]
    266e:	cmp	r3, #16
    2670:	beq.n	2680 <FatFile::openRoot(FatVolume*)+0x28>
    2672:	cmp	r3, #32
    2674:	bne.n	2696 <FatFile::openRoot(FatVolume*)+0x3e>
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    2676:	movs	r3, #64	; 0x40
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    2678:	movs	r0, #1
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    break;

  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    267a:	strb	r3, [r5, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    267c:	strb	r0, [r5, #2]
  return true;

fail:
  return false;
}
    267e:	pop	{r4, r5, r6, pc}
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    2680:	movs	r3, #32
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    2682:	movs	r0, #1
  switch (vol->fatType()) {
#if FAT12_SUPPORT
  case 12:
#endif  // FAT12_SUPPORT
  case 16:
    m_attributes = FILE_ATTR_ROOT_FIXED;
    2684:	strb	r3, [r5, #0]
  default:
    DBG_FAIL_MACRO;
    goto fail;
  }
  // read only
  m_flags = FILE_FLAG_READ;
    2686:	strb	r0, [r5, #2]
  return true;

fail:
  return false;
}
    2688:	pop	{r4, r5, r6, pc}
}
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
  // error if file is already open
  if (isOpen()) {
    DBG_FAIL_MACRO;
    268a:	movw	r0, #606	; 0x25e
    268e:	bl	2414 <dbgPrint(unsigned short)>
  // read only
  m_flags = FILE_FLAG_READ;
  return true;

fail:
  return false;
    2692:	movs	r0, #0
//------------------------------------------------------------------------------
bool FatFile::openRoot(FatVolume* vol) {
  // error if file is already open
  if (isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
    2694:	pop	{r4, r5, r6, pc}
  case 32:
    m_attributes = FILE_ATTR_ROOT32;
    break;

  default:
    DBG_FAIL_MACRO;
    2696:	movw	r0, #625	; 0x271
    269a:	bl	2414 <dbgPrint(unsigned short)>
  // read only
  m_flags = FILE_FLAG_READ;
  return true;

fail:
  return false;
    269e:	mov	r0, r4
    26a0:	pop	{r4, r5, r6, pc}
    26a2:	nop

000026a4 <FatFile::open(FatFile*, char const*, int)>:
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    26a4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    26a8:	mov	r6, r0
    26aa:	sub	sp, #76	; 0x4c
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    26ac:	ldrb	r4, [r6, #0]
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, const char* path, oflag_t oflag) {
    26ae:	str	r2, [sp, #4]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attributes(FILE_ATTR_CLOSED), m_error(0), m_flags(0) {}
    26b0:	movs	r0, #0
    26b2:	strb.w	r0, [sp, #36]	; 0x24
    26b6:	strb.w	r0, [sp, #37]	; 0x25
    26ba:	strb.w	r0, [sp, #38]	; 0x26
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    26be:	cmp	r4, #0
    26c0:	bne.n	274c <FatFile::open(FatFile*, char const*, int)+0xa8>
    26c2:	mov	r9, r3
    26c4:	ldrb	r3, [r1, #0]
    26c6:	tst.w	r3, #112	; 0x70
    26ca:	mov	r5, r1
    26cc:	beq.n	274c <FatFile::open(FatFile*, char const*, int)+0xa8>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    26ce:	ldrb	r3, [r2, #0]
    26d0:	cmp	r3, #47	; 0x2f
    26d2:	mov	r0, r2
    26d4:	beq.n	272e <FatFile::open(FatFile*, char const*, int)+0x8a>
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    26d6:	mov.w	r8, #0
    26da:	b.n	26e8 <FatFile::open(FatFile*, char const*, int)+0x44>
    26dc:	ldr	r0, [sp, #4]
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    26de:	strb.w	r8, [r6]
  m_flags = 0;
    26e2:	strb.w	r8, [r6, #2]
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    26e6:	add	r5, sp, #36	; 0x24
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    26e8:	add	r2, sp, #4
    26ea:	add	r1, sp, #12
    26ec:	bl	3b80 <FatFile::parsePathName(char const*, fname_t*, char const**)>
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    26f0:	add	r2, sp, #12
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    26f2:	mov	r7, r0
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    26f4:	mov	r1, r5
    26f6:	movs	r3, #0
      goto fail;
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    26f8:	cmp	r0, #0
    26fa:	beq.n	275e <FatFile::open(FatFile*, char const*, int)+0xba>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    26fc:	ldr	r4, [sp, #4]
    26fe:	ldrb	r4, [r4, #0]
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    2700:	mov	r0, r6
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (*path == 0) {
    2702:	cmp	r4, #0
    2704:	beq.n	276e <FatFile::open(FatFile*, char const*, int)+0xca>
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    2706:	bl	40b4 <FatFile::open(FatFile*, fname_t*, int)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    270a:	mov	r5, r6
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    270c:	mov	r7, r0
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    270e:	add	r4, sp, #36	; 0x24
      goto fail;
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
    2710:	cmp	r0, #0
    2712:	beq.n	2784 <FatFile::open(FatFile*, char const*, int)+0xe0>
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    2714:	ldmia	r5!, {r0, r1, r2, r3}
    2716:	stmia	r4!, {r0, r1, r2, r3}
    2718:	ldmia	r5!, {r0, r1, r2, r3}
    271a:	stmia	r4!, {r0, r1, r2, r3}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    271c:	ldrb	r3, [r6, #0]
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    tmpDir = *this;
    271e:	ldr	r2, [r5, #0]
    2720:	str	r2, [r4, #0]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    2722:	cmp	r3, #0
    2724:	beq.n	26dc <FatFile::open(FatFile*, char const*, int)+0x38>
    2726:	mov	r0, r6
    2728:	bl	2594 <FatFile::sync() [clone .part.38]>
    272c:	b.n	26dc <FatFile::open(FatFile*, char const*, int)+0x38>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    272e:	adds	r0, #1
    2730:	str	r0, [sp, #4]
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    2732:	ldrb	r3, [r0, #0]
    2734:	cmp	r3, #47	; 0x2f
    2736:	beq.n	272e <FatFile::open(FatFile*, char const*, int)+0x8a>
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    2738:	ldr	r1, [r5, #8]
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
    273a:	cbz	r3, 2794 <FatFile::open(FatFile*, char const*, int)+0xf0>
      return openRoot(dirFile->m_vol);
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
    273c:	add	r0, sp, #36	; 0x24
    273e:	bl	2658 <FatFile::openRoot(FatVolume*)>
    2742:	mov	r7, r0
    2744:	cbz	r0, 279e <FatFile::open(FatFile*, char const*, int)+0xfa>
    2746:	ldr	r0, [sp, #4]
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile = &tmpDir;
    2748:	add	r5, sp, #36	; 0x24
    274a:	b.n	26d6 <FatFile::open(FatFile*, char const*, int)+0x32>
  FatFile tmpDir;
  fname_t fname;

  // error if already open
  if (isOpen() || !dirFile->isDir()) {
    DBG_FAIL_MACRO;
    274c:	mov.w	r0, #418	; 0x1a2
    2750:	bl	2414 <dbgPrint(unsigned short)>
    close();
  }
  return open(dirFile, &fname, oflag);

fail:
  return false;
    2754:	movs	r7, #0
}
    2756:	mov	r0, r7
    2758:	add	sp, #76	; 0x4c
    275a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }
    dirFile = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
    275e:	mov.w	r0, #436	; 0x1b4
    2762:	bl	2414 <dbgPrint(unsigned short)>
  }
  return open(dirFile, &fname, oflag);

fail:
  return false;
}
    2766:	mov	r0, r7
    2768:	add	sp, #76	; 0x4c
    276a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }
    tmpDir = *this;
    dirFile = &tmpDir;
    close();
  }
  return open(dirFile, &fname, oflag);
    276e:	mov	r3, r9
    2770:	add	r2, sp, #12
    2772:	mov	r1, r5
    2774:	mov	r0, r6
    2776:	bl	40b4 <FatFile::open(FatFile*, fname_t*, int)>
    277a:	mov	r7, r0

fail:
  return false;
}
    277c:	mov	r0, r7
    277e:	add	sp, #76	; 0x4c
    2780:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }
    if (*path == 0) {
      break;
    }
    if (!open(dirFile, &fname, O_RDONLY)) {
      DBG_FAIL_MACRO;
    2784:	movw	r0, #443	; 0x1bb
    2788:	bl	2414 <dbgPrint(unsigned short)>
  }
  return open(dirFile, &fname, oflag);

fail:
  return false;
}
    278c:	mov	r0, r7
    278e:	add	sp, #76	; 0x4c
    2790:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (*path == 0) {
      return openRoot(dirFile->m_vol);
    2794:	mov	r0, r6
    2796:	bl	2658 <FatFile::openRoot(FatVolume*)>
    279a:	mov	r7, r0
    279c:	b.n	2756 <FatFile::open(FatFile*, char const*, int)+0xb2>
    }
    if (!tmpDir.openRoot(dirFile->m_vol)) {
      DBG_FAIL_MACRO;
    279e:	movw	r0, #429	; 0x1ad
    27a2:	bl	2414 <dbgPrint(unsigned short)>
      goto fail;
    27a6:	b.n	2756 <FatFile::open(FatFile*, char const*, int)+0xb2>

000027a8 <FatFile::open(FatVolume*, char const*, int)>:
bool FatFile::open(const char* path, oflag_t oflag) {
  return open(FatVolume::cwv(), path, oflag);
}
//------------------------------------------------------------------------------
bool FatFile::open(FatVolume* vol, const char* path, oflag_t oflag) {
  return vol && open(vol->vwd(), path, oflag);
    27a8:	cbz	r1, 27b2 <FatFile::open(FatVolume*, char const*, int)+0xa>
    27aa:	addw	r1, r1, #1084	; 0x43c
    27ae:	b.w	26a4 <FatFile::open(FatFile*, char const*, int)>
}
    27b2:	mov	r0, r1
    27b4:	bx	lr
    27b6:	nop

000027b8 <FatFile::read(void*, unsigned int)>:
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    27b8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    27bc:	ldrb	r3, [r0, #2]
    27be:	lsls	r7, r3, #31
  m_curPosition = curPosition;
  m_curCluster = curCluster;
  return c;
}
//------------------------------------------------------------------------------
int FatFile::read(void* buf, size_t nbyte) {
    27c0:	sub	sp, #12
    27c2:	mov	r5, r0
  size_t toRead;
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    27c4:	bpl.w	2970 <FatFile::read(void*, unsigned int)+0x1b8>
    27c8:	mov	r7, r1
    27ca:	ldrb	r1, [r0, #0]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    27cc:	lsls	r6, r1, #28
    27ce:	mov	r9, r2
    27d0:	bmi.w	28e2 <FatFile::read(void*, unsigned int)+0x12a>
    uint32_t tmp32 = m_fileSize - m_curPosition;
    if (nbyte >= tmp32) {
      nbyte = tmp32;
    }
  } else if (isRootFixed()) {
    27d4:	lsls	r4, r1, #26
    27d6:	bpl.n	27ea <FatFile::read(void*, unsigned int)+0x32>
    uint16_t tmp16 = 32*m_vol->m_rootDirEntryCount - (uint16_t)m_curPosition;
    27d8:	ldr	r2, [r0, #8]
    if (nbyte > tmp16) {
    27da:	ldr	r3, [r0, #20]
    27dc:	ldrh	r2, [r2, #8]
    27de:	rsb	r3, r3, r2, lsl #5
    27e2:	uxth	r3, r3
    27e4:	cmp	r9, r3
    27e6:	it	cs
    27e8:	movcs	r9, r3
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    27ea:	cmp.w	r9, #0
    27ee:	beq.w	292c <FatFile::read(void*, unsigned int)+0x174>
    27f2:	ldr	r3, [r5, #20]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    27f4:	ldr	r2, [r5, #8]
    if (isRootFixed()) {
    27f6:	lsls	r0, r1, #26
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    27f8:	mov	r6, r9
    27fa:	mov.w	r8, #0
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    27fe:	add.w	sl, r5, #16
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    2802:	ubfx	fp, r3, #0, #9
    if (isRootFixed()) {
    2806:	bpl.n	2888 <FatFile::read(void*, unsigned int)+0xd0>
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    2808:	ldr	r1, [r2, #32]
    280a:	add.w	r1, r1, r3, lsr #9
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    280e:	cmp.w	fp, #0
    2812:	bne.n	28bc <FatFile::read(void*, unsigned int)+0x104>
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
    2814:	cmp.w	r6, #512	; 0x200
    2818:	bcc.n	28bc <FatFile::read(void*, unsigned int)+0x104>
    281a:	ldr	r3, [r2, #44]	; 0x2c
        || sector == m_vol->cacheSectorNumber()) {
    281c:	cmp	r1, r3
    281e:	beq.n	28bc <FatFile::read(void*, unsigned int)+0x104>
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
    2820:	cmp.w	r6, #1024	; 0x400
    2824:	bcc.n	28f4 <FatFile::read(void*, unsigned int)+0x13c>
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
      if (!isRootFixed()) {
    2826:	ldrb	r0, [r5, #0]
    2828:	lsls	r0, r0, #26
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
#if USE_MULTI_SECTOR_IO
    } else if (toRead >= 2*m_vol->bytesPerSector()) {
      uint32_t ns = toRead >> m_vol->bytesPerSectorShift();
    282a:	mov.w	fp, r6, lsr #9
      if (!isRootFixed()) {
    282e:	bmi.n	283c <FatFile::read(void*, unsigned int)+0x84>
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
    2830:	ldrb	r0, [r2, #4]
    2832:	rsb	r0, r8, r0
    2836:	cmp	fp, r0
    2838:	it	cs
    283a:	movcs	fp, r0
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
      // Check for cache sector in read range.
      if (sector <= m_vol->cacheSectorNumber()
          && sector < (m_vol->cacheSectorNumber() + ns)) {
    283c:	cmp	r1, r3
        uint32_t mb = m_vol->sectorsPerCluster() - sectorOfCluster;
        if (mb < ns) {
          ns = mb;
        }
      }
      n = ns << m_vol->bytesPerSectorShift();
    283e:	mov.w	r4, fp, lsl #9
      // Check for cache sector in read range.
      if (sector <= m_vol->cacheSectorNumber()
          && sector < (m_vol->cacheSectorNumber() + ns)) {
    2842:	bhi.n	285e <FatFile::read(void*, unsigned int)+0xa6>
    2844:	add	r3, fp
    2846:	cmp	r1, r3
    2848:	bcs.n	285e <FatFile::read(void*, unsigned int)+0xa6>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
    284a:	add.w	r0, r2, #36	; 0x24
    284e:	str	r1, [sp, #4]
    2850:	bl	3544 <FatCache::sync()>
        // Flush cache if a cache sector is in the range.
        if (!m_vol->cacheSyncData()) {
    2854:	cmp	r0, #0
    2856:	beq.w	295c <FatFile::read(void*, unsigned int)+0x1a4>
    285a:	ldr	r2, [r5, #8]
    285c:	ldr	r1, [sp, #4]
    285e:	ldr	r0, [r2, #0]
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
  }
#if USE_MULTI_SECTOR_IO
  bool readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    return m_blockDev->readSectors(sector, dst, ns);
    2860:	ldr	r2, [r0, #0]
    2862:	mov	r3, fp
    2864:	ldr.w	fp, [r2, #12]
    2868:	mov	r2, r7
    286a:	blx	fp
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
      if (!m_vol->readSectors(sector, dst, ns)) {
    286c:	cmp	r0, #0
    286e:	beq.n	2952 <FatFile::read(void*, unsigned int)+0x19a>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    2870:	ldr	r3, [r5, #20]
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    2872:	subs	r6, r6, r4
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    m_curPosition += n;
    2874:	add	r3, r4
      if (!m_vol->readSector(sector, dst)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    dst += n;
    2876:	add	r7, r4
    m_curPosition += n;
    2878:	str	r3, [r5, #20]
    if (nbyte > tmp16) {
      nbyte = tmp16;
    }
  }
  toRead = nbyte;
  while (toRead) {
    287a:	beq.n	292c <FatFile::read(void*, unsigned int)+0x174>
    287c:	ldrb	r1, [r5, #0]
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    287e:	ldr	r2, [r5, #8]
    if (isRootFixed()) {
    2880:	lsls	r0, r1, #26
    }
  }
  toRead = nbyte;
  while (toRead) {
    size_t n;
    offset = m_curPosition & m_vol->sectorMask();  // offset in sector
    2882:	ubfx	fp, r3, #0, #9
    if (isRootFixed()) {
    2886:	bmi.n	2808 <FatFile::read(void*, unsigned int)+0x50>
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    2888:	ldrb.w	r8, [r2, #5]
    288c:	and.w	r8, r8, r3, lsr #9
      sector = m_vol->rootDirStart()
               + (m_curPosition >> m_vol->bytesPerSectorShift());
    } else {
      sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
      if (offset == 0 && sectorOfCluster == 0) {
    2890:	cmp.w	fp, #0
    2894:	bne.n	28f0 <FatFile::read(void*, unsigned int)+0x138>
    2896:	cmp.w	r8, #0
    289a:	bne.n	28f0 <FatFile::read(void*, unsigned int)+0x138>
        // start of new cluster
        if (m_curPosition == 0) {
    289c:	cmp	r3, #0
    289e:	bne.n	2906 <FatFile::read(void*, unsigned int)+0x14e>
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    28a0:	lsls	r1, r1, #25
    28a2:	ite	mi
    28a4:	ldrmi	r1, [r2, #32]
    28a6:	ldrpl	r1, [r5, #32]
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
          m_curCluster++;
    28a8:	str	r1, [r5, #16]
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      }
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    28aa:	mov	r0, r2
    28ac:	bl	3554 <FatPartition::clusterStartSector(unsigned long) const>
    28b0:	ldr	r2, [r5, #8]
    28b2:	add.w	r1, r8, r0
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
    28b6:	cmp.w	fp, #0
    28ba:	beq.n	2814 <FatFile::read(void*, unsigned int)+0x5c>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return m_cache.read(sector, options);
    28bc:	add.w	r0, r2, #36	; 0x24
    28c0:	movs	r2, #0
    28c2:	bl	34c8 <FatCache::read(unsigned long, unsigned char)>
      if (n > toRead) {
        n = toRead;
      }
      // read sector to cache and copy data to caller
      pc = m_vol->cacheFetchData(sector, FatCache::CACHE_FOR_READ);
      if (!pc) {
    28c6:	cmp	r0, #0
    28c8:	beq.n	2938 <FatFile::read(void*, unsigned int)+0x180>
      sector = m_vol->clusterStartSector(m_curCluster) + sectorOfCluster;
    }
    if (offset != 0 || toRead < m_vol->bytesPerSector()
        || sector == m_vol->cacheSectorNumber()) {
      // amount to be read from current sector
      n = m_vol->bytesPerSector() - offset;
    28ca:	rsb	r4, fp, #512	; 0x200
    28ce:	cmp	r4, r6
    28d0:	it	cs
    28d2:	movcs	r4, r6
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* src = pc->data + offset;
      memcpy(dst, src, n);
    28d4:	add.w	r1, r0, fp
    28d8:	mov	r2, r4
    28da:	mov	r0, r7
    28dc:	bl	8c24 <memcpy>
    28e0:	b.n	2870 <FatFile::read(void*, unsigned int)+0xb8>
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (isFile()) {
    uint32_t tmp32 = m_fileSize - m_curPosition;
    28e2:	ldr	r3, [r0, #28]
    28e4:	ldr	r2, [r0, #20]
    28e6:	subs	r3, r3, r2
    28e8:	cmp	r9, r3
    28ea:	it	cs
    28ec:	movcs	r9, r3
    28ee:	b.n	27ea <FatFile::read(void*, unsigned int)+0x32>
    28f0:	ldr	r1, [r5, #16]
    28f2:	b.n	28aa <FatFile::read(void*, unsigned int)+0xf2>
    28f4:	ldr	r0, [r2, #0]
  uint32_t m_lastCluster;             // Last cluster number in FAT.
  uint32_t m_rootDirStart;            // Start sector FAT16, cluster FAT32.
  //----------------------------------------------------------------------------
  // sector I/O functions.
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
    28f6:	ldr	r3, [r0, #0]
    28f8:	mov	r2, r7
    28fa:	ldr	r3, [r3, #8]
    28fc:	blx	r3
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->readSector(sector, dst)) {
    28fe:	cbz	r0, 2966 <FatFile::read(void*, unsigned int)+0x1ae>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    2900:	mov.w	r4, #512	; 0x200
    2904:	b.n	2870 <FatFile::read(void*, unsigned int)+0xb8>
        // start of new cluster
        if (m_curPosition == 0) {
          // use first cluster in file
          m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        } else if (isFile() && isContiguous()) {
    2906:	lsls	r3, r1, #28
    2908:	bpl.n	2916 <FatFile::read(void*, unsigned int)+0x15e>
    290a:	ldrb	r3, [r5, #2]
    290c:	lsls	r4, r3, #25
    290e:	bpl.n	2916 <FatFile::read(void*, unsigned int)+0x15e>
          m_curCluster++;
    2910:	ldr	r1, [r5, #16]
    2912:	adds	r1, #1
    2914:	b.n	28a8 <FatFile::read(void*, unsigned int)+0xf0>
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    2916:	mov	r0, r2
    2918:	ldr	r1, [r5, #16]
    291a:	mov	r2, sl
    291c:	bl	3560 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    2920:	cmp	r0, #0
    2922:	blt.n	298c <FatFile::read(void*, unsigned int)+0x1d4>
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
    2924:	beq.n	297a <FatFile::read(void*, unsigned int)+0x1c2>
    2926:	ldr	r2, [r5, #8]
    2928:	ldr	r1, [r5, #16]
    292a:	b.n	28aa <FatFile::read(void*, unsigned int)+0xf2>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
    292c:	movs	r6, #0
    }
    dst += n;
    m_curPosition += n;
    toRead -= n;
  }
  return nbyte - toRead;
    292e:	rsb	r0, r6, r9

fail:
  m_error |= READ_ERROR;
  return -1;
}
    2932:	add	sp, #12
    2934:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        n = toRead;
      }
      // read sector to cache and copy data to caller
      pc = m_vol->cacheFetchData(sector, FatCache::CACHE_FOR_READ);
      if (!pc) {
        DBG_FAIL_MACRO;
    2938:	movw	r0, #717	; 0x2cd
    293c:	bl	2414 <dbgPrint(unsigned short)>
    toRead -= n;
  }
  return nbyte - toRead;

fail:
  m_error |= READ_ERROR;
    2940:	ldrb	r3, [r5, #1]
  return -1;
    2942:	mov.w	r0, #4294967295
    toRead -= n;
  }
  return nbyte - toRead;

fail:
  m_error |= READ_ERROR;
    2946:	orr.w	r3, r3, #2
    294a:	strb	r3, [r5, #1]
  return -1;
}
    294c:	add	sp, #12
    294e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
      if (!m_vol->readSectors(sector, dst, ns)) {
        DBG_FAIL_MACRO;
    2952:	movw	r0, #742	; 0x2e6
    2956:	bl	2414 <dbgPrint(unsigned short)>
        goto fail;
    295a:	b.n	2940 <FatFile::read(void*, unsigned int)+0x188>
      // Check for cache sector in read range.
      if (sector <= m_vol->cacheSectorNumber()
          && sector < (m_vol->cacheSectorNumber() + ns)) {
        // Flush cache if a cache sector is in the range.
        if (!m_vol->cacheSyncData()) {
          DBG_FAIL_MACRO;
    295c:	movw	r0, #737	; 0x2e1
    2960:	bl	2414 <dbgPrint(unsigned short)>
          goto fail;
    2964:	b.n	2940 <FatFile::read(void*, unsigned int)+0x188>
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // read single sector
      n = m_vol->bytesPerSector();
      if (!m_vol->readSector(sector, dst)) {
        DBG_FAIL_MACRO;
    2966:	movw	r0, #750	; 0x2ee
    296a:	bl	2414 <dbgPrint(unsigned short)>
        goto fail;
    296e:	b.n	2940 <FatFile::read(void*, unsigned int)+0x188>
  uint32_t sector;  // raw device sector number
  cache_t* pc;

  // error if not open for read
  if (!isReadable()) {
    DBG_FAIL_MACRO;
    2970:	mov.w	r0, #656	; 0x290
    2974:	bl	2414 <dbgPrint(unsigned short)>
    goto fail;
    2978:	b.n	2940 <FatFile::read(void*, unsigned int)+0x188>
          if (fg < 0) {
            DBG_FAIL_MACRO;
            goto fail;
          }
          if (fg == 0) {
            if (isDir()) {
    297a:	ldrb	r3, [r5, #0]
    297c:	tst.w	r3, #112	; 0x70
    2980:	bne.n	292e <FatFile::read(void*, unsigned int)+0x176>
              break;
            }
            DBG_FAIL_MACRO;
    2982:	mov.w	r0, #700	; 0x2bc
    2986:	bl	2414 <dbgPrint(unsigned short)>
            goto fail;
    298a:	b.n	2940 <FatFile::read(void*, unsigned int)+0x188>
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        } else {
          // get next cluster from FAT
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
          if (fg < 0) {
            DBG_FAIL_MACRO;
    298c:	movw	r0, #693	; 0x2b5
    2990:	bl	2414 <dbgPrint(unsigned short)>
            goto fail;
    2994:	b.n	2940 <FatFile::read(void*, unsigned int)+0x188>
    2996:	nop

00002998 <FatFile::peek()>:

fail:
  return false;
}
//------------------------------------------------------------------------------
int FatFile::peek() {
    2998:	push	{r4, r5, r6, lr}
    299a:	sub	sp, #8
   * \return For success read returns the next byte in the file as an int.
   * If an error occurs or end of file is reached -1 is returned.
   */
  int read() {
    uint8_t b;
    return read(&b, 1) == 1 ? b : -1;
    299c:	movs	r2, #1
    299e:	add.w	r1, sp, #7
    29a2:	mov	r4, r0
  uint32_t curPosition = m_curPosition;
    29a4:	ldr	r6, [r0, #20]
  uint32_t curCluster = m_curCluster;
    29a6:	ldr	r5, [r0, #16]
    29a8:	bl	27b8 <FatFile::read(void*, unsigned int)>
    29ac:	cmp	r0, #1
    29ae:	it	eq
    29b0:	ldrbeq.w	r0, [sp, #7]
  int c = read();
  m_curPosition = curPosition;
    29b4:	str	r6, [r4, #20]
    29b6:	it	ne
    29b8:	movne.w	r0, #4294967295
  m_curCluster = curCluster;
    29bc:	str	r5, [r4, #16]
  return c;
}
    29be:	add	sp, #8
    29c0:	pop	{r4, r5, r6, pc}
    29c2:	nop

000029c4 <FatFile::readDirCache(bool)>:
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    29c4:	push	{r4, r5, lr}
  uint8_t i = (m_curPosition >> 5) & 0XF;
    29c6:	ldr	r3, [r0, #20]
    29c8:	ubfx	r5, r3, #5, #4
  }
}
//------------------------------------------------------------------------------
// Read next directory entry into the cache
// Assumes file is correctly positioned
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
    29cc:	sub	sp, #12
    29ce:	mov	r4, r0
  uint8_t i = (m_curPosition >> 5) & 0XF;

  if (i == 0 || !skipReadOk) {
    29d0:	cbz	r5, 29d4 <FatFile::readDirCache(bool)+0x10>
    29d2:	cbnz	r1, 29fc <FatFile::readDirCache(bool)+0x38>
    int8_t n = read(&n, 1);
    29d4:	movs	r2, #1
    29d6:	add.w	r1, sp, #7
    29da:	mov	r0, r4
    29dc:	bl	27b8 <FatFile::read(void*, unsigned int)>
    29e0:	sxtb	r0, r0
    if  (n != 1) {
    29e2:	cmp	r0, #1
// Assumes file is correctly positioned
DirFat_t* FatFile::readDirCache(bool skipReadOk) {
  uint8_t i = (m_curPosition >> 5) & 0XF;

  if (i == 0 || !skipReadOk) {
    int8_t n = read(&n, 1);
    29e4:	strb.w	r0, [sp, #7]
    if  (n != 1) {
    29e8:	bne.n	2a02 <FatFile::readDirCache(bool)+0x3e>
      if (n != 0) {
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    m_curPosition += 31;
    29ea:	ldr	r3, [r4, #20]
    29ec:	adds	r3, #31
    29ee:	str	r3, [r4, #20]
  /** Reserve cache sector for write - do not read from sector device. */
  static const uint8_t CACHE_RESERVE_FOR_WRITE
    = CACHE_STATUS_DIRTY | CACHE_OPTION_NO_READ;
  /** \return Cache sector address. */
  cache_t* buffer() {
    return &m_buffer;
    29f0:	ldr	r0, [r4, #8]
    29f2:	adds	r0, #48	; 0x30
  } else {
    m_curPosition += 32;
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;
    29f4:	add.w	r0, r0, r5, lsl #5

fail:
  return nullptr;
}
    29f8:	add	sp, #12
    29fa:	pop	{r4, r5, pc}
      }
      goto fail;
    }
    m_curPosition += 31;
  } else {
    m_curPosition += 32;
    29fc:	adds	r3, #32
    29fe:	str	r3, [r0, #20]
    2a00:	b.n	29f0 <FatFile::readDirCache(bool)+0x2c>
  uint8_t i = (m_curPosition >> 5) & 0XF;

  if (i == 0 || !skipReadOk) {
    int8_t n = read(&n, 1);
    if  (n != 1) {
      if (n != 0) {
    2a02:	cbz	r0, 2a0c <FatFile::readDirCache(bool)+0x48>
        DBG_FAIL_MACRO;
    2a04:	movw	r0, #801	; 0x321
    2a08:	bl	2414 <dbgPrint(unsigned short)>
  }
  // return pointer to entry
  return reinterpret_cast<DirFat_t*>(m_vol->cacheAddress()) + i;

fail:
  return nullptr;
    2a0c:	movs	r0, #0
}
    2a0e:	add	sp, #12
    2a10:	pop	{r4, r5, pc}
    2a12:	nop

00002a14 <FatFile::seekSet(unsigned long)>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    2a14:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2a18:	ldrb	r3, [r0, #0]
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
    2a1a:	ldr	r7, [r0, #16]

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::seekSet(uint32_t pos) {
    2a1c:	mov	r4, r0
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    2a1e:	cmp	r3, #0
    2a20:	beq.n	2a92 <FatFile::seekSet(unsigned long)+0x7e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    2a22:	ldr	r2, [r0, #20]
    2a24:	cmp	r2, r1
    2a26:	mov	r6, r1
    2a28:	beq.n	2aba <FatFile::seekSet(unsigned long)+0xa6>
    return true;
  }
  if (pos == 0) {
    2a2a:	cbnz	r1, 2a3e <FatFile::seekSet(unsigned long)+0x2a>
    // set position to start of file
    m_curCluster = 0;
    2a2c:	str	r1, [r4, #16]
    }
  }

done:
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    2a2e:	ldrb	r3, [r4, #2]
      goto fail;
    }
  }

done:
  m_curPosition = pos;
    2a30:	str	r6, [r4, #20]
  m_flags &= ~FILE_FLAG_PREALLOCATE;
    2a32:	bic.w	r3, r3, #32
    2a36:	strb	r3, [r4, #2]
  return true;
    2a38:	movs	r0, #1
    2a3a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (pos == 0) {
    // set position to start of file
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    2a3e:	lsls	r0, r3, #28
    2a40:	bpl.n	2aa2 <FatFile::seekSet(unsigned long)+0x8e>
    if (pos > m_fileSize) {
    2a42:	ldr	r1, [r4, #28]
    2a44:	cmp	r6, r1
    2a46:	bhi.n	2ac4 <FatFile::seekSet(unsigned long)+0xb0>
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for cur and new position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());
    2a48:	ldr.w	lr, [r4, #8]
    2a4c:	ldrb.w	r5, [lr, #6]
    2a50:	adds	r5, #9
    2a52:	uxtb	r1, r5
    2a54:	subs	r0, r2, #1
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    2a56:	subs	r5, r6, #1
    }
    DBG_FAIL_MACRO;
    goto fail;
  }
  // calculate cluster index for cur and new position
  nCur = (m_curPosition - 1) >> (m_vol->bytesPerClusterShift());
    2a58:	lsrs	r0, r1
  nNew = (pos - 1) >> (m_vol->bytesPerClusterShift());
    2a5a:	lsrs	r5, r1

  if (nNew < nCur || m_curPosition == 0) {
    2a5c:	cmp	r0, r5
    2a5e:	bhi.n	2a62 <FatFile::seekSet(unsigned long)+0x4e>
    2a60:	cbnz	r2, 2ac0 <FatFile::seekSet(unsigned long)+0xac>
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
    2a62:	lsls	r3, r3, #25
    2a64:	ite	mi
    2a66:	ldrmi.w	r3, [lr, #32]
    2a6a:	ldrpl	r3, [r4, #32]
    2a6c:	str	r3, [r4, #16]
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    2a6e:	add.w	r8, r4, #16
    2a72:	mov	r2, r8
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    2a74:	cmp	r5, #0
    2a76:	beq.n	2a2e <FatFile::seekSet(unsigned long)+0x1a>
    if (m_vol->fatGet(m_curCluster, &m_curCluster) <= 0) {
    2a78:	ldr	r1, [r4, #16]
    2a7a:	ldr	r0, [r4, #8]
    2a7c:	bl	3560 <FatPartition::fatGet(unsigned long, unsigned long*)>
    2a80:	cmp	r0, #0
    2a82:	add.w	r5, r5, #4294967295
    2a86:	bgt.n	2a72 <FatFile::seekSet(unsigned long)+0x5e>
      DBG_FAIL_MACRO;
    2a88:	movw	r0, #1100	; 0x44c
    2a8c:	bl	2414 <dbgPrint(unsigned short)>
      goto fail;
    2a90:	b.n	2a9a <FatFile::seekSet(unsigned long)+0x86>
  uint32_t nCur;
  uint32_t nNew;
  uint32_t tmp = m_curCluster;
  // error if file not open
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    2a92:	movw	r0, #1063	; 0x427
    2a96:	bl	2414 <dbgPrint(unsigned short)>
  m_curPosition = pos;
  m_flags &= ~FILE_FLAG_PREALLOCATE;
  return true;

fail:
  m_curCluster = tmp;
    2a9a:	str	r7, [r4, #16]
  return false;
    2a9c:	movs	r0, #0
    2a9e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (isFile()) {
    if (pos > m_fileSize) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (isRootFixed()) {
    2aa2:	lsls	r1, r3, #26
    2aa4:	bpl.n	2a48 <FatFile::seekSet(unsigned long)+0x34>
    2aa6:	ldr	r3, [r4, #8]
    if (pos <= 32*m_vol->rootDirEntryCount()) {
    2aa8:	ldrh	r3, [r3, #8]
    2aaa:	cmp.w	r6, r3, lsl #5
    2aae:	bls.n	2a2e <FatFile::seekSet(unsigned long)+0x1a>
      goto done;
    }
    DBG_FAIL_MACRO;
    2ab0:	movw	r0, #1084	; 0x43c
    2ab4:	bl	2414 <dbgPrint(unsigned short)>
    goto fail;
    2ab8:	b.n	2a9a <FatFile::seekSet(unsigned long)+0x86>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Optimize O_APPEND writes.
  if (pos == m_curPosition) {
    return true;
    2aba:	movs	r0, #1
  return true;

fail:
  m_curCluster = tmp;
  return false;
}
    2abc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (nNew < nCur || m_curPosition == 0) {
    // must follow chain from first cluster
    m_curCluster = isRoot32() ? m_vol->rootDirStart() : m_firstCluster;
  } else {
    // advance from curPosition
    nNew -= nCur;
    2ac0:	subs	r5, r5, r0
    2ac2:	b.n	2a6e <FatFile::seekSet(unsigned long)+0x5a>
    m_curCluster = 0;
    goto done;
  }
  if (isFile()) {
    if (pos > m_fileSize) {
      DBG_FAIL_MACRO;
    2ac4:	movw	r0, #1077	; 0x435
    2ac8:	bl	2414 <dbgPrint(unsigned short)>
      goto fail;
    2acc:	b.n	2a9a <FatFile::seekSet(unsigned long)+0x86>
    2ace:	nop

00002ad0 <FatFile::rmdir()>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::rmdir() {
    2ad0:	push	{r4, lr}
  // must be open subdirectory
  if (!isSubDir() || (!USE_LONG_FILE_NAMES && isLFN())) {
    2ad2:	ldrb	r3, [r0, #0]
    2ad4:	lsls	r2, r3, #27
    2ad6:	bmi.n	2ae4 <FatFile::rmdir()+0x14>
    DBG_FAIL_MACRO;
    2ad8:	movw	r0, #943	; 0x3af
    2adc:	bl	2414 <dbgPrint(unsigned short)>
  m_flags |= FILE_FLAG_WRITE;
  return remove();

fail:
  return false;
}
    2ae0:	movs	r0, #0
    2ae2:	pop	{r4, pc}
   * \return true for success or false for failure.
   */
  bool remove(const char* path);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    2ae4:	movs	r1, #0
    2ae6:	mov	r4, r0
    2ae8:	bl	2a14 <FatFile::seekSet(unsigned long)>
  }
  rewind();

  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    2aec:	movs	r1, #1
    2aee:	mov	r0, r4
    2af0:	bl	29c4 <FatFile::readDirCache(bool)>
    if (!dir) {
    2af4:	cbz	r0, 2b14 <FatFile::rmdir()+0x44>
      }
      DBG_FAIL_MACRO;
      goto fail;
    }
    // done if past last used entry
    if (dir->name[0] == FAT_NAME_FREE) {
    2af6:	ldrb	r3, [r0, #0]
    2af8:	cbz	r3, 2b18 <FatFile::rmdir()+0x48>
      break;
    }
    // skip empty slot, '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    2afa:	cmp	r3, #229	; 0xe5
    2afc:	beq.n	2aec <FatFile::rmdir()+0x1c>
    2afe:	cmp	r3, #46	; 0x2e
    2b00:	beq.n	2aec <FatFile::rmdir()+0x1c>
      continue;
    }
    // error not empty
    if (isFileOrSubdir(dir)) {
    2b02:	ldrb	r3, [r0, #11]
    2b04:	lsls	r3, r3, #28
    2b06:	bmi.n	2aec <FatFile::rmdir()+0x1c>
      DBG_FAIL_MACRO;
    2b08:	movw	r0, #969	; 0x3c9
    2b0c:	bl	2414 <dbgPrint(unsigned short)>
  m_flags |= FILE_FLAG_WRITE;
  return remove();

fail:
  return false;
}
    2b10:	movs	r0, #0
    2b12:	pop	{r4, pc}
  // make sure directory is empty
  while (1) {
    DirFat_t* dir = readDirCache(true);
    if (!dir) {
      // EOF if no error.
      if (!getError()) {
    2b14:	ldrb	r3, [r4, #1]
    2b16:	cbnz	r3, 2b2e <FatFile::rmdir()+0x5e>
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
    2b18:	ldrb	r3, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    2b1a:	movs	r2, #8
  m_flags |= FILE_FLAG_WRITE;
    2b1c:	orr.w	r3, r3, #2
    2b20:	strb	r3, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
    2b22:	strb	r2, [r4, #0]
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    2b24:	mov	r0, r4

fail:
  return false;
}
    2b26:	ldmia.w	sp!, {r4, lr}
    }
  }
  // convert empty directory to normal file for remove
  m_attributes = FILE_ATTR_FILE;
  m_flags |= FILE_FLAG_WRITE;
  return remove();
    2b2a:	b.w	3dcc <FatFile::remove()>
    if (!dir) {
      // EOF if no error.
      if (!getError()) {
        break;
      }
      DBG_FAIL_MACRO;
    2b2e:	mov.w	r0, #956	; 0x3bc
    2b32:	bl	2414 <dbgPrint(unsigned short)>
      goto fail;
    2b36:	b.n	2ae0 <FatFile::rmdir()+0x10>

00002b38 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>:
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    2b38:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2b3c:	mov	r8, r1
    2b3e:	mov	r7, r2
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    2b40:	movs	r1, #0
    2b42:	movs	r2, #36	; 0x24
  return false;
}
//------------------------------------------------------------------------------
// open a cached directory entry.
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
    2b44:	mov	r4, r0
    2b46:	mov	r6, r3
    2b48:	ldrb.w	r5, [sp, #24]
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
    2b4c:	bl	bb7c <memset>
  // location of entry in cache
  m_vol = dirFile->m_vol;
    2b50:	ldr.w	r0, [r8, #8]
  m_dirIndex = dirIndex;
  m_dirCluster = dirFile->m_firstCluster;
    2b54:	ldr.w	r3, [r8, #32]
    2b58:	str	r3, [r4, #12]
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;
    2b5a:	and.w	r2, r7, #15
    2b5e:	add.w	r3, r0, #48	; 0x30
    2b62:	add.w	r2, r3, r2, lsl #5
                              oflag_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
  m_dirIndex = dirIndex;
    2b66:	strh	r7, [r4, #4]
bool FatFile::openCachedEntry(FatFile* dirFile, uint16_t dirIndex,
                              oflag_t oflag, uint8_t lfnOrd) {
  uint32_t firstCluster;
  memset(this, 0, sizeof(FatFile));
  // location of entry in cache
  m_vol = dirFile->m_vol;
    2b68:	str	r0, [r4, #8]
    2b6a:	ldrb	r1, [r2, #11]
  m_dirCluster = dirFile->m_firstCluster;
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;

  // Must be file or subdirectory.
  if (!isFileOrSubdir(dir)) {
    2b6c:	lsls	r7, r1, #28
    2b6e:	bmi.n	2ba8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x70>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
    2b70:	and.w	r1, r1, #23
    2b74:	strb	r1, [r4, #0]
  if (isFileDir(dir)) {
    2b76:	ldrb	r3, [r2, #11]
    m_attributes |= FILE_ATTR_FILE;
  }
  m_lfnOrd = lfnOrd;
    2b78:	strb	r5, [r4, #3]
  if (!isFileOrSubdir(dir)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    2b7a:	tst.w	r3, #24
    m_attributes |= FILE_ATTR_FILE;
    2b7e:	it	eq
    2b80:	orreq.w	r1, r1, #8
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    2b84:	and.w	r3, r6, #3
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_attributes = dir->attributes & FILE_ATTR_COPY;
  if (isFileDir(dir)) {
    m_attributes |= FILE_ATTR_FILE;
    2b88:	it	eq
    2b8a:	strbeq	r1, [r4, #0]
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    2b8c:	cmp	r3, #1
    2b8e:	beq.n	2c36 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xfe>
    2b90:	cmp	r3, #2
    2b92:	beq.n	2bba <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x82>
    2b94:	cbz	r3, 2bd8 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xa0>
    case O_WRONLY:
      m_flags = FILE_FLAG_WRITE;
      break;

    default:
      DBG_FAIL_MACRO;
    2b96:	mov.w	r0, #508	; 0x1fc
    2b9a:	bl	2414 <dbgPrint(unsigned short)>
    goto fail;
  }
  return true;

fail:
  m_attributes = FILE_ATTR_CLOSED;
    2b9e:	movs	r0, #0
    2ba0:	strb	r0, [r4, #0]
  m_flags = 0;
    2ba2:	strb	r0, [r4, #2]
  return false;
    2ba4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  DirFat_t* dir = reinterpret_cast<DirFat_t*>(m_vol->cacheAddress());
  dir += 0XF & dirIndex;

  // Must be file or subdirectory.
  if (!isFileOrSubdir(dir)) {
    DBG_FAIL_MACRO;
    2ba8:	movw	r0, #481	; 0x1e1
    2bac:	bl	2414 <dbgPrint(unsigned short)>
    goto fail;
  }
  return true;

fail:
  m_attributes = FILE_ATTR_CLOSED;
    2bb0:	movs	r0, #0
    2bb2:	strb	r0, [r4, #0]
  m_flags = 0;
    2bb4:	strb	r0, [r4, #2]
  return false;
    2bb6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    if (isSubDir() || isReadOnly()) {
    2bba:	ldrb	r3, [r4, #0]
      }
      m_flags = FILE_FLAG_READ;
      break;

    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    2bbc:	movs	r5, #3
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    if (isSubDir() || isReadOnly()) {
    2bbe:	tst.w	r3, #17
      }
      m_flags = FILE_FLAG_READ;
      break;

    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
    2bc2:	strb	r5, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    if (isSubDir() || isReadOnly()) {
    2bc4:	beq.n	2c42 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x10a>
      DBG_FAIL_MACRO;
    2bc6:	movw	r0, #514	; 0x202
    2bca:	bl	2414 <dbgPrint(unsigned short)>
    goto fail;
  }
  return true;

fail:
  m_attributes = FILE_ATTR_CLOSED;
    2bce:	movs	r0, #0
    2bd0:	strb	r0, [r4, #0]
  m_flags = 0;
    2bd2:	strb	r0, [r4, #2]
  return false;
    2bd4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    case O_RDONLY:
      if (oflag & O_TRUNC) {
    2bd8:	ands.w	lr, r6, #1024	; 0x400
    2bdc:	bne.n	2c5a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x122>
    2bde:	movs	r5, #1
    if (isSubDir() || isReadOnly()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);
    2be0:	and.w	r3, r6, #8
    2be4:	orrs	r5, r3
    2be6:	uxtb	r5, r5
    2be8:	strb	r5, [r4, #2]

  m_dirSector = m_vol->cacheSectorNumber();

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    2bea:	ldrh	r1, [r2, #20]
    2bec:	ldrh	r3, [r2, #26]
      goto fail;
    }
  }
  m_flags |= (oflag & O_APPEND ? FILE_FLAG_APPEND : 0);

  m_dirSector = m_vol->cacheSectorNumber();
    2bee:	ldr	r7, [r0, #44]	; 0x2c
    2bf0:	str	r7, [r4, #24]

  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);
    2bf2:	orr.w	r1, r3, r1, lsl #16

  if (oflag & O_TRUNC) {
    2bf6:	cmp.w	lr, #0
    2bfa:	beq.n	2c0e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xd6>
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    2bfc:	cbnz	r1, 2c4a <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x112>
      DBG_FAIL_MACRO;
      goto fail;
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    2bfe:	orn	r5, r5, #127	; 0x7f
  } else {
    m_firstCluster = firstCluster;
    m_fileSize = getLe32(dir->fileSize);
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    2c02:	lsls	r3, r6, #17
      DBG_FAIL_MACRO;
      goto fail;
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
    2c04:	strb	r5, [r4, #2]
  } else {
    m_firstCluster = firstCluster;
    m_fileSize = getLe32(dir->fileSize);
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    2c06:	bmi.n	2c18 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xe0>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return true;
    2c08:	movs	r0, #1
    2c0a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    // need to update directory entry
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else {
    m_firstCluster = firstCluster;
    2c0e:	str	r1, [r4, #32]
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    2c10:	ldr	r3, [r2, #28]
    m_fileSize = getLe32(dir->fileSize);
    2c12:	str	r3, [r4, #28]
  }
  if ((oflag & O_AT_END) && !seekSet(m_fileSize)) {
    2c14:	lsls	r3, r6, #17
    2c16:	bpl.n	2c08 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xd0>
    2c18:	ldr	r1, [r4, #28]
    2c1a:	mov	r0, r4
    2c1c:	bl	2a14 <FatFile::seekSet(unsigned long)>
    2c20:	cmp	r0, #0
    2c22:	bne.n	2c08 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xd0>
    DBG_FAIL_MACRO;
    2c24:	movw	r0, #539	; 0x21b
    2c28:	bl	2414 <dbgPrint(unsigned short)>
    goto fail;
  }
  return true;

fail:
  m_attributes = FILE_ATTR_CLOSED;
    2c2c:	movs	r0, #0
    2c2e:	strb	r0, [r4, #0]
  m_flags = 0;
    2c30:	strb	r0, [r4, #2]
  return false;
    2c32:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    if (isSubDir() || isReadOnly()) {
    2c36:	ldrb	r3, [r4, #0]
    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
      break;

    case O_WRONLY:
      m_flags = FILE_FLAG_WRITE;
    2c38:	movs	r5, #2
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    if (isSubDir() || isReadOnly()) {
    2c3a:	tst.w	r3, #17
    case O_RDWR:
      m_flags = FILE_FLAG_READ | FILE_FLAG_WRITE;
      break;

    case O_WRONLY:
      m_flags = FILE_FLAG_WRITE;
    2c3e:	strb	r5, [r4, #2]
      DBG_FAIL_MACRO;
      goto fail;
  }

  if (m_flags & FILE_FLAG_WRITE) {
    if (isSubDir() || isReadOnly()) {
    2c40:	bne.n	2bc6 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x8e>
    2c42:	sxtb	r5, r5
    2c44:	and.w	lr, r6, #1024	; 0x400
    2c48:	b.n	2be0 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xa8>
  // copy first cluster number for directory fields
  firstCluster = ((uint32_t)getLe16(dir->firstClusterHigh) << 16)
                 | getLe16(dir->firstClusterLow);

  if (oflag & O_TRUNC) {
    if (firstCluster && !m_vol->freeChain(firstCluster)) {
    2c4a:	bl	3734 <FatPartition::freeChain(unsigned long)>
    2c4e:	cbnz	r0, 2c64 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x12c>
      DBG_FAIL_MACRO;
    2c50:	mov.w	r0, #528	; 0x210
    2c54:	bl	2414 <dbgPrint(unsigned short)>
      goto fail;
    2c58:	b.n	2b9e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
  m_lfnOrd = lfnOrd;

  switch (oflag & O_ACCMODE) {
    case O_RDONLY:
      if (oflag & O_TRUNC) {
        DBG_FAIL_MACRO;
    2c5a:	movw	r0, #493	; 0x1ed
    2c5e:	bl	2414 <dbgPrint(unsigned short)>
        goto fail;
    2c62:	b.n	2b9e <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0x66>
    2c64:	ldrb	r5, [r4, #2]
    2c66:	b.n	2bfe <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)+0xc6>

00002c68 <FatFile::openNext(FatFile*, int)>:
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    2c68:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    2c6c:	ldrb	r3, [r0, #0]
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openNext(FatFile* dirFile, oflag_t oflag) {
    2c6e:	sub	sp, #12
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    2c70:	cbnz	r3, 2c7c <FatFile::openNext(FatFile*, int)+0x14>
    2c72:	ldrb	r3, [r1, #0]
    2c74:	tst.w	r3, #112	; 0x70
    2c78:	mov	r5, r1
    2c7a:	bne.n	2c8e <FatFile::openNext(FatFile*, int)+0x26>
    DBG_FAIL_MACRO;
    2c7c:	movw	r0, #558	; 0x22e
    2c80:	bl	2414 <dbgPrint(unsigned short)>
      lfnOrd = 0;
    }
  }

fail:
  return false;
    2c84:	movs	r4, #0
}
    2c86:	mov	r0, r4
    2c88:	add	sp, #12
    2c8a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    2c8e:	ldr	r6, [r1, #20]
  DirLfn_t* ldir;
  uint8_t lfnOrd = 0;
  uint16_t index;

  // Check for not open and valid directory..
  if (isOpen() || !dirFile->isDir() || (dirFile->curPosition() & 0X1F)) {
    2c90:	ands.w	r7, r6, #31
    2c94:	bne.n	2c7c <FatFile::openNext(FatFile*, int)+0x14>
    2c96:	mov	r8, r0
    2c98:	mov	r9, r2
    2c9a:	mov	sl, r7
    2c9c:	b.n	2ca2 <FatFile::openNext(FatFile*, int)+0x3a>
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
        lfnOrd = ldir->order & 0X1F;
        checksum = ldir->checksum;
      }
    } else {
      lfnOrd = 0;
    2c9e:	movs	r7, #0
    2ca0:	ldr	r6, [r5, #20]
    goto fail;
  }
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    DirFat_t* dir = dirFile->readDirCache();
    2ca2:	movs	r1, #0
    2ca4:	mov	r0, r5
    2ca6:	bl	29c4 <FatFile::readDirCache(bool)>
    if (!dir) {
    2caa:	mov	r4, r0
    2cac:	cbz	r0, 2cda <FatFile::openNext(FatFile*, int)+0x72>
        DBG_FAIL_MACRO;
      }
      goto fail;
    }
    // done if last entry
    if (dir->name[0] == FAT_NAME_FREE) {
    2cae:	ldrb	r3, [r0, #0]
    2cb0:	cmp	r3, #0
    2cb2:	beq.n	2c84 <FatFile::openNext(FatFile*, int)+0x1c>
      goto fail;
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
    2cb4:	cmp	r3, #46	; 0x2e
    2cb6:	beq.n	2c9e <FatFile::openNext(FatFile*, int)+0x36>
    2cb8:	cmp	r3, #229	; 0xe5
    2cba:	beq.n	2c9e <FatFile::openNext(FatFile*, int)+0x36>
    2cbc:	ldrb	r1, [r0, #11]
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
    2cbe:	and.w	r2, r1, #8
    2cc2:	and.w	fp, r2, #255	; 0xff
    2cc6:	cbz	r2, 2cea <FatFile::openNext(FatFile*, int)+0x82>
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      return true;
    } else if (isLongName(dir)) {
    2cc8:	cmp	r1, #15
    2cca:	bne.n	2c9e <FatFile::openNext(FatFile*, int)+0x36>
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    2ccc:	lsls	r2, r3, #25
    2cce:	bpl.n	2ca0 <FatFile::openNext(FatFile*, int)+0x38>
        lfnOrd = ldir->order & 0X1F;
    2cd0:	and.w	r7, r3, #31
        checksum = ldir->checksum;
    2cd4:	ldrb.w	sl, [r0, #13]
    2cd8:	b.n	2ca0 <FatFile::openNext(FatFile*, int)+0x38>
  while (1) {
    // read entry into cache
    index = dirFile->curPosition()/32;
    DirFat_t* dir = dirFile->readDirCache();
    if (!dir) {
      if (dirFile->getError()) {
    2cda:	ldrb	r3, [r5, #1]
    2cdc:	cmp	r3, #0
    2cde:	beq.n	2c84 <FatFile::openNext(FatFile*, int)+0x1c>
        DBG_FAIL_MACRO;
    2ce0:	movw	r0, #567	; 0x237
    2ce4:	bl	2414 <dbgPrint(unsigned short)>
    2ce8:	b.n	2c86 <FatFile::openNext(FatFile*, int)+0x1e>
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    2cea:	cbnz	r7, 2d0c <FatFile::openNext(FatFile*, int)+0xa4>
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!openCachedEntry(dirFile, index, oflag, lfnOrd)) {
    2cec:	str	r7, [sp, #0]
    2cee:	mov	r3, r9
    2cf0:	ubfx	r2, r6, #5, #16
    2cf4:	mov	r1, r5
    2cf6:	mov	r0, r8
    2cf8:	bl	2b38 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    2cfc:	mov	r4, r0
    2cfe:	cmp	r0, #0
    2d00:	bne.n	2c86 <FatFile::openNext(FatFile*, int)+0x1e>
        DBG_FAIL_MACRO;
    2d02:	mov.w	r0, #584	; 0x248
    2d06:	bl	2414 <dbgPrint(unsigned short)>
        goto fail;
    2d0a:	b.n	2c86 <FatFile::openNext(FatFile*, int)+0x1e>
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
    2d0c:	bl	39f8 <FatFile::lfnChecksum(unsigned char*)>
    2d10:	cmp	sl, r0
    2d12:	beq.n	2cec <FatFile::openNext(FatFile*, int)+0x84>
        DBG_FAIL_MACRO;
    2d14:	mov.w	r0, #580	; 0x244
      lfnOrd = 0;
    }
  }

fail:
  return false;
    2d18:	mov	r4, fp
    // skip empty slot or '.' or '..'
    if (dir->name[0] == '.' || dir->name[0] == FAT_NAME_DELETED) {
      lfnOrd = 0;
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd && checksum != lfnChecksum(dir->name)) {
        DBG_FAIL_MACRO;
    2d1a:	bl	2414 <dbgPrint(unsigned short)>
        goto fail;
    2d1e:	b.n	2c86 <FatFile::openNext(FatFile*, int)+0x1e>

00002d20 <FatFile::mkdir(FatFile*, fname_t*)>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, fname_t* fname) {
    2d20:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    2d24:	ldrb	r3, [r1, #0]
    2d26:	tst.w	r3, #112	; 0x70

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, fname_t* fname) {
    2d2a:	sub	sp, #36	; 0x24
  uint32_t sector;
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    2d2c:	beq.w	2e5e <FatFile::mkdir(FatFile*, fname_t*)+0x13e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    2d30:	movw	r3, #2562	; 0xa02
    2d34:	mov	r6, r1
    2d36:	mov	r4, r0
    2d38:	bl	40b4 <FatFile::open(FatFile*, fname_t*, int)>
    2d3c:	cmp	r0, #0
    2d3e:	beq.w	2e4e <FatFile::mkdir(FatFile*, fname_t*)+0x12e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    2d42:	movs	r2, #1
  m_attributes = FILE_ATTR_SUBDIR;
    2d44:	movs	r3, #16
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // convert file to directory
  m_flags = FILE_FLAG_READ;
    2d46:	strb	r2, [r4, #2]
  m_attributes = FILE_ATTR_SUBDIR;
    2d48:	strb	r3, [r4, #0]

  // allocate and zero first cluster
  if (!addDirCluster()) {
    2d4a:	mov	r0, r4
    2d4c:	bl	2494 <FatFile::addDirCluster()>
    2d50:	cmp	r0, #0
    2d52:	beq.w	2e84 <FatFile::mkdir(FatFile*, fname_t*)+0x164>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_firstCluster = m_curCluster;
    2d56:	ldr	r3, [r4, #16]
    2d58:	str	r3, [r4, #32]
    2d5a:	movs	r1, #0
    2d5c:	mov	r0, r4
    2d5e:	bl	2a14 <FatFile::seekSet(unsigned long)>
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    2d62:	ldrb	r3, [r4, #0]
    2d64:	cmp	r3, #0
    2d66:	bne.w	2e6e <FatFile::mkdir(FatFile*, fname_t*)+0x14e>
  if (!sync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // cache entry - should already be in cache due to sync() call
  dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
    2d6a:	movs	r1, #1
    2d6c:	mov	r0, r4
    2d6e:	bl	2568 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    2d72:	mov	r5, r0
    2d74:	cmp	r0, #0
    2d76:	beq.w	2e9e <FatFile::mkdir(FatFile*, fname_t*)+0x17e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // change directory entry  attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;
    2d7a:	movs	r3, #16
    2d7c:	strb	r3, [r0, #11]

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    2d7e:	ldr	r2, [r0, #8]
    2d80:	ldr	r1, [r5, #4]
    2d82:	ldr	r3, [r5, #12]
    2d84:	ldr	r0, [r0, #0]
    2d86:	ldrh.w	r8, [r5, #20]
    2d8a:	ldrh.w	r9, [r5, #26]
    2d8e:	mov	r7, sp
    2d90:	stmia	r7!, {r0, r1, r2, r3}
    2d92:	ldr	r1, [r5, #20]
    2d94:	ldr	r2, [r5, #24]
    2d96:	ldr	r3, [r5, #28]
    2d98:	ldr	r0, [r5, #16]
  dot.name[0] = '.';
    2d9a:	add	r5, sp, #32
  }
  // change directory entry  attribute
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
    2d9c:	stmia	r7!, {r0, r1, r2, r3}
  dot.name[0] = '.';
    2d9e:	movs	r3, #46	; 0x2e
    2da0:	strb.w	r3, [r5, #-32]!
    2da4:	add.w	r1, sp, #10
    2da8:	mov	r3, r5
  for (uint8_t i = 1; i < 11; i++) {
    dot.name[i] = ' ';
    2daa:	movs	r2, #32
    2dac:	strb.w	r2, [r3, #1]!
  dir->attributes = FAT_ATTRIB_DIRECTORY;

  // make entry for '.'
  memcpy(&dot, dir, sizeof(dot));
  dot.name[0] = '.';
  for (uint8_t i = 1; i < 11; i++) {
    2db0:	cmp	r1, r3
    2db2:	bne.n	2dac <FatFile::mkdir(FatFile*, fname_t*)+0x8c>
    dot.name[i] = ' ';
  }

  // cache sector for '.'  and '..'
  sector = m_vol->clusterStartSector(m_firstCluster);
    2db4:	ldr	r1, [r4, #32]
    2db6:	ldr	r0, [r4, #8]
    2db8:	bl	3554 <FatPartition::clusterStartSector(unsigned long) const>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return m_cache.read(sector, options);
    2dbc:	ldr	r3, [r4, #8]
    2dbe:	mov	r1, r0
    2dc0:	movs	r2, #1
    2dc2:	add.w	r0, r3, #36	; 0x24
    2dc6:	bl	34c8 <FatCache::read(unsigned long, unsigned char)>
  pc = m_vol->cacheFetchData(sector, FatCache::CACHE_FOR_WRITE);
  if (!pc) {
    2dca:	mov	lr, r0
    2dcc:	cmp	r0, #0
    2dce:	beq.n	2e94 <FatFile::mkdir(FatFile*, fname_t*)+0x174>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
    2dd0:	strh.w	r8, [sp, #20]
    2dd4:	strh.w	r9, [sp, #26]
    2dd8:	mov	r7, r5
    2dda:	ldmia	r7!, {r0, r1, r2, r3}
    2ddc:	str.w	r0, [lr]
    2de0:	str.w	r1, [lr, #4]
    2de4:	str.w	r2, [lr, #8]
    2de8:	str.w	r3, [lr, #12]
    2dec:	ldmia	r7!, {r0, r1, r2, r3}
    2dee:	str.w	r0, [lr, #16]
    2df2:	str.w	r1, [lr, #20]
    2df6:	str.w	r2, [lr, #24]
    2dfa:	str.w	r3, [lr, #28]
  // make entry for '..'
  dot.name[1] = '.';
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
    2dfe:	ldr	r3, [r6, #32]
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    2e00:	strh.w	r3, [sp, #26]
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
  // make entry for '..'
  dot.name[1] = '.';
    2e04:	movs	r2, #46	; 0x2e
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    2e06:	lsrs	r3, r3, #16
    2e08:	strh.w	r3, [sp, #20]
    goto fail;
  }
  // copy '.' to sector
  memcpy(&pc->dir[0], &dot, sizeof(dot));
  // make entry for '..'
  dot.name[1] = '.';
    2e0c:	strb.w	r2, [sp, #1]
  setLe16(dot.firstClusterLow, parent->m_firstCluster & 0XFFFF);
  setLe16(dot.firstClusterHigh, parent->m_firstCluster >> 16);
  // copy '..' to sector
  memcpy(&pc->dir[1], &dot, sizeof(dot));
    2e10:	ldmia	r5!, {r0, r1, r2, r3}
    2e12:	add.w	r6, lr, #32
    2e16:	str.w	r0, [lr, #32]
    2e1a:	str	r1, [r6, #4]
    2e1c:	str	r2, [r6, #8]
    2e1e:	str	r3, [r6, #12]
    2e20:	ldmia	r5!, {r0, r1, r2, r3}
    2e22:	str	r0, [r6, #16]
    2e24:	str	r1, [r6, #20]
    2e26:	str	r2, [r6, #24]
    2e28:	str	r3, [r6, #28]
  // write first sector
  return m_vol->cacheSync();
    2e2a:	ldr	r4, [r4, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    return m_fatCache.read(sector,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    2e2c:	add.w	r0, r4, #36	; 0x24
    2e30:	bl	3544 <FatCache::sync()>
    2e34:	cbz	r0, 2e56 <FatFile::mkdir(FatFile*, fname_t*)+0x136>
    2e36:	add.w	r0, r4, #560	; 0x230
    2e3a:	bl	3544 <FatCache::sync()>
    2e3e:	cbz	r0, 2e56 <FatFile::mkdir(FatFile*, fname_t*)+0x136>
    2e40:	ldr	r0, [r4, #0]
  // sector I/O functions.
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    2e42:	ldr	r3, [r0, #0]
    2e44:	ldr	r3, [r3, #20]

fail:
  return false;
}
    2e46:	add	sp, #36	; 0x24
    2e48:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
    2e4c:	bx	r3
    DBG_FAIL_MACRO;
    goto fail;
  }
  // create a normal file
  if (!open(parent, fname, O_CREAT | O_EXCL | O_RDWR)) {
    DBG_FAIL_MACRO;
    2e4e:	mov.w	r0, #346	; 0x15a
    2e52:	bl	2414 <dbgPrint(unsigned short)>
  // write first sector
  return m_vol->cacheSync();

fail:
  return false;
}
    2e56:	movs	r0, #0
    2e58:	add	sp, #36	; 0x24
    2e5a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  DirFat_t dot;
  DirFat_t* dir;
  cache_t* pc;

  if (!parent->isDir()) {
    DBG_FAIL_MACRO;
    2e5e:	movw	r0, #341	; 0x155
    2e62:	bl	2414 <dbgPrint(unsigned short)>
  // write first sector
  return m_vol->cacheSync();

fail:
  return false;
}
    2e66:	movs	r0, #0
    2e68:	add	sp, #36	; 0x24
    2e6a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    2e6e:	mov	r0, r4
    2e70:	bl	2594 <FatFile::sync() [clone .part.38]>
  }
  m_firstCluster = m_curCluster;
  // Set to start of dir
  rewind();
  // force entry to device
  if (!sync()) {
    2e74:	cmp	r0, #0
    2e76:	bne.w	2d6a <FatFile::mkdir(FatFile*, fname_t*)+0x4a>
    DBG_FAIL_MACRO;
    2e7a:	movw	r0, #363	; 0x16b
    2e7e:	bl	2414 <dbgPrint(unsigned short)>
    2e82:	b.n	2e56 <FatFile::mkdir(FatFile*, fname_t*)+0x136>
  m_flags = FILE_FLAG_READ;
  m_attributes = FILE_ATTR_SUBDIR;

  // allocate and zero first cluster
  if (!addDirCluster()) {
    DBG_FAIL_MACRO;
    2e84:	movw	r0, #355	; 0x163
    2e88:	bl	2414 <dbgPrint(unsigned short)>
  // write first sector
  return m_vol->cacheSync();

fail:
  return false;
}
    2e8c:	movs	r0, #0
    2e8e:	add	sp, #36	; 0x24
    2e90:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  // cache sector for '.'  and '..'
  sector = m_vol->clusterStartSector(m_firstCluster);
  pc = m_vol->cacheFetchData(sector, FatCache::CACHE_FOR_WRITE);
  if (!pc) {
    DBG_FAIL_MACRO;
    2e94:	mov.w	r0, #386	; 0x182
    2e98:	bl	2414 <dbgPrint(unsigned short)>
    2e9c:	b.n	2e56 <FatFile::mkdir(FatFile*, fname_t*)+0x136>
    goto fail;
  }
  // cache entry - should already be in cache due to sync() call
  dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
  if (!dir) {
    DBG_FAIL_MACRO;
    2e9e:	movw	r0, #369	; 0x171
    2ea2:	bl	2414 <dbgPrint(unsigned short)>
    2ea6:	b.n	2e56 <FatFile::mkdir(FatFile*, fname_t*)+0x136>

00002ea8 <FatFile::mkdir(FatFile*, char const*, bool)>:
void FatFile::fsetpos(const fspos_t* pos) {
  m_curPosition = pos->position;
  m_curCluster = pos->cluster;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    2ea8:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    2eac:	mov	r6, r0
    2eae:	sub	sp, #72	; 0x48
  fname_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    2eb0:	ldrb	r4, [r6, #0]
void FatFile::fsetpos(const fspos_t* pos) {
  m_curPosition = pos->position;
  m_curCluster = pos->cluster;
}
//------------------------------------------------------------------------------
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
    2eb2:	str	r2, [sp, #4]
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attributes(FILE_ATTR_CLOSED), m_error(0), m_flags(0) {}
    2eb4:	movs	r0, #0
    2eb6:	strb.w	r0, [sp, #36]	; 0x24
    2eba:	strb.w	r0, [sp, #37]	; 0x25
    2ebe:	strb.w	r0, [sp, #38]	; 0x26
  fname_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    2ec2:	cmp	r4, #0
    2ec4:	bne.n	2f36 <FatFile::mkdir(FatFile*, char const*, bool)+0x8e>
    2ec6:	mov	r8, r3
    2ec8:	ldrb	r3, [r1, #0]
    2eca:	tst.w	r3, #112	; 0x70
    2ece:	mov	r5, r1
    2ed0:	beq.n	2f36 <FatFile::mkdir(FatFile*, char const*, bool)+0x8e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    2ed2:	ldrb	r3, [r2, #0]
    2ed4:	cmp	r3, #47	; 0x2f
    2ed6:	mov	r0, r2
    2ed8:	beq.n	2f18 <FatFile::mkdir(FatFile*, char const*, bool)+0x70>
      goto fail;
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    2eda:	movs	r7, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    2edc:	add	r2, sp, #4
    2ede:	add	r1, sp, #12
    2ee0:	bl	3b80 <FatFile::parsePathName(char const*, fname_t*, char const**)>
      goto fail;
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    2ee4:	add	r2, sp, #12
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    2ee6:	mov	r4, r0
      goto fail;
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    2ee8:	mov	r1, r5
    2eea:	movs	r3, #0
      goto fail;
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
    2eec:	cmp	r0, #0
    2eee:	beq.n	2f7c <FatFile::mkdir(FatFile*, char const*, bool)+0xd4>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    2ef0:	ldr	r4, [sp, #4]
    2ef2:	ldrb	r4, [r4, #0]
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    2ef4:	mov	r0, r6
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!*path) {
    2ef6:	cmp	r4, #0
    2ef8:	beq.n	2f8c <FatFile::mkdir(FatFile*, char const*, bool)+0xe4>
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
    2efa:	bl	40b4 <FatFile::open(FatFile*, fname_t*, int)>
    2efe:	mov	r4, r0
    2f00:	cbnz	r0, 2f56 <FatFile::mkdir(FatFile*, char const*, bool)+0xae>
      if (!pFlag || !mkdir(parent, &fname)) {
    2f02:	cmp.w	r8, #0
    2f06:	bne.n	2f48 <FatFile::mkdir(FatFile*, char const*, bool)+0xa0>
        DBG_FAIL_MACRO;
    2f08:	mov.w	r0, #320	; 0x140
    2f0c:	bl	2414 <dbgPrint(unsigned short)>
  }
  return mkdir(parent, &fname);

fail:
  return false;
}
    2f10:	mov	r0, r4
    2f12:	add	sp, #72	; 0x48
    2f14:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    2f18:	adds	r0, #1
    2f1a:	str	r0, [sp, #4]
  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
    2f1c:	ldrb	r3, [r0, #0]
    2f1e:	cmp	r3, #47	; 0x2f
    2f20:	beq.n	2f18 <FatFile::mkdir(FatFile*, char const*, bool)+0x70>
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
    2f22:	ldr	r1, [r5, #8]
    2f24:	add	r0, sp, #36	; 0x24
    2f26:	bl	2658 <FatFile::openRoot(FatVolume*)>
    2f2a:	mov	r4, r0
    2f2c:	cmp	r0, #0
    2f2e:	beq.n	2f9a <FatFile::mkdir(FatFile*, char const*, bool)+0xf2>
    2f30:	ldr	r0, [sp, #4]
      DBG_FAIL_MACRO;
      goto fail;
    }
    parent = &tmpDir;
    2f32:	add	r5, sp, #36	; 0x24
    2f34:	b.n	2eda <FatFile::mkdir(FatFile*, char const*, bool)+0x32>
bool FatFile::mkdir(FatFile* parent, const char* path, bool pFlag) {
  fname_t fname;
  FatFile tmpDir;

  if (isOpen() || !parent->isDir()) {
    DBG_FAIL_MACRO;
    2f36:	movw	r0, #297	; 0x129
    2f3a:	bl	2414 <dbgPrint(unsigned short)>
    close();
  }
  return mkdir(parent, &fname);

fail:
  return false;
    2f3e:	movs	r4, #0
}
    2f40:	mov	r0, r4
    2f42:	add	sp, #72	; 0x48
    2f44:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    if (!*path) {
      break;
    }
    if (!open(parent, &fname, O_RDONLY)) {
      if (!pFlag || !mkdir(parent, &fname)) {
    2f48:	mov	r1, r5
    2f4a:	add	r2, sp, #12
    2f4c:	mov	r0, r6
    2f4e:	bl	2d20 <FatFile::mkdir(FatFile*, fname_t*)>
    2f52:	cmp	r0, #0
    2f54:	beq.n	2f08 <FatFile::mkdir(FatFile*, char const*, bool)+0x60>
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    2f56:	mov	r5, r6
    2f58:	ldmia	r5!, {r0, r1, r2, r3}
    2f5a:	add	r4, sp, #36	; 0x24
    2f5c:	stmia	r4!, {r0, r1, r2, r3}
    2f5e:	ldmia	r5!, {r0, r1, r2, r3}
    2f60:	stmia	r4!, {r0, r1, r2, r3}
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    2f62:	ldrb	r3, [r6, #0]
      if (!pFlag || !mkdir(parent, &fname)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    2f64:	ldr	r2, [r5, #0]
    2f66:	str	r2, [r4, #0]
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    2f68:	cbnz	r3, 2f74 <FatFile::mkdir(FatFile*, char const*, bool)+0xcc>
  return nullptr;
}
//------------------------------------------------------------------------------
bool FatFile::close() {
  bool rtn = sync();
  m_attributes = FILE_ATTR_CLOSED;
    2f6a:	strb	r7, [r6, #0]
  m_flags = 0;
    2f6c:	strb	r7, [r6, #2]
    2f6e:	ldr	r0, [sp, #4]
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    tmpDir = *this;
    parent = &tmpDir;
    2f70:	add	r5, sp, #36	; 0x24
    2f72:	b.n	2edc <FatFile::mkdir(FatFile*, char const*, bool)+0x34>
    2f74:	mov	r0, r6
    2f76:	bl	2594 <FatFile::sync() [clone .part.38]>
    2f7a:	b.n	2f6a <FatFile::mkdir(FatFile*, char const*, bool)+0xc2>
    }
    parent = &tmpDir;
  }
  while (1) {
    if (!parsePathName(path, &fname, &path)) {
      DBG_FAIL_MACRO;
    2f7c:	mov.w	r0, #312	; 0x138
    2f80:	bl	2414 <dbgPrint(unsigned short)>
  }
  return mkdir(parent, &fname);

fail:
  return false;
}
    2f84:	mov	r0, r4
    2f86:	add	sp, #72	; 0x48
    2f88:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    tmpDir = *this;
    parent = &tmpDir;
    close();
  }
  return mkdir(parent, &fname);
    2f8c:	add	r2, sp, #12
    2f8e:	mov	r1, r5
    2f90:	mov	r0, r6
    2f92:	bl	2d20 <FatFile::mkdir(FatFile*, fname_t*)>
    2f96:	mov	r4, r0
    2f98:	b.n	2f10 <FatFile::mkdir(FatFile*, char const*, bool)+0x68>
  if (isDirSeparator(*path)) {
    while (isDirSeparator(*path)) {
      path++;
    }
    if (!tmpDir.openRoot(parent->m_vol)) {
      DBG_FAIL_MACRO;
    2f9a:	movw	r0, #305	; 0x131
    2f9e:	bl	2414 <dbgPrint(unsigned short)>
      goto fail;
    2fa2:	b.n	2f10 <FatFile::mkdir(FatFile*, char const*, bool)+0x68>

00002fa4 <FatFile::rename(FatFile*, char const*)>:
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    2fa4:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    2fa8:	ldrb	r4, [r0, #0]
//------------------------------------------------------------------------------
bool FatFile::rename(const char* newPath) {
  return rename(m_vol->vwd(), newPath);
}
//------------------------------------------------------------------------------
bool FatFile::rename(FatFile* dirFile, const char* newPath) {
    2faa:	sub	sp, #104	; 0x68
    2fac:	movs	r6, #0
  FatFile oldFile;
  cache_t* pc;
  DirFat_t* dir;

  // Must be an open file or subdirectory.
  if (!(isFile() || isSubDir())) {
    2fae:	ands.w	r4, r4, #24
    2fb2:	strb.w	r6, [sp, #32]
    2fb6:	strb.w	r6, [sp, #33]	; 0x21
    2fba:	strb.w	r6, [sp, #34]	; 0x22
    2fbe:	strb.w	r6, [sp, #68]	; 0x44
    2fc2:	strb.w	r6, [sp, #69]	; 0x45
    2fc6:	strb.w	r6, [sp, #70]	; 0x46
    2fca:	bne.n	2fdc <FatFile::rename(FatFile*, char const*)+0x38>
    DBG_FAIL_MACRO;
    2fcc:	movw	r0, #842	; 0x34a
    2fd0:	bl	2414 <dbgPrint(unsigned short)>
  }
  return m_vol->cacheSync();

fail:
  return false;
}
    2fd4:	mov	r0, r4
    2fd6:	add	sp, #104	; 0x68
    2fd8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2fdc:	mov	r8, r2
  if (!USE_LONG_FILE_NAMES && isLFN()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Can't move file to new volume.
  if (m_vol != dirFile->m_vol) {
    2fde:	ldr	r3, [r1, #8]
    2fe0:	ldr	r2, [r0, #8]
    2fe2:	cmp	r2, r3
    2fe4:	mov	r5, r0
    2fe6:	mov	r7, r1
    2fe8:	beq.n	2ffc <FatFile::rename(FatFile*, char const*)+0x58>
    DBG_FAIL_MACRO;
    2fea:	mov.w	r0, #852	; 0x354
    2fee:	bl	2414 <dbgPrint(unsigned short)>
    goto fail;
  }
  return m_vol->cacheSync();

fail:
  return false;
    2ff2:	mov	r4, r6
}
    2ff4:	mov	r0, r4
    2ff6:	add	sp, #104	; 0x68
    2ff8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2ffc:	bl	2594 <FatFile::sync() [clone .part.38]>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // sync() and cache directory entry
  sync();
  oldFile = *this;
    3000:	mov	lr, r5
    3002:	ldmia.w	lr!, {r0, r1, r2, r3}
    3006:	add	r4, sp, #68	; 0x44
    3008:	stmia	r4!, {r0, r1, r2, r3}
    300a:	ldmia.w	lr!, {r0, r1, r2, r3}
    300e:	stmia	r4!, {r0, r1, r2, r3}
    3010:	ldr.w	r3, [lr]
    3014:	str	r3, [r4, #0]
  dir = cacheDirEntry(FatCache::CACHE_FOR_READ);
    3016:	mov	r1, r6
    3018:	mov	r0, r5
    301a:	bl	2568 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    301e:	mov	r4, r0
    3020:	cmp	r0, #0
    3022:	beq.w	31be <FatFile::rename(FatFile*, char const*)+0x21a>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    3026:	ldr	r1, [r4, #4]
    3028:	ldr	r2, [r4, #8]
    302a:	ldr	r3, [r4, #12]
    302c:	ldr	r0, [r0, #0]
  // make directory entry for new path
  if (isFile()) {
    302e:	ldrb.w	ip, [r5]
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    3032:	mov	lr, sp
    3034:	stmia.w	lr!, {r0, r1, r2, r3}
    3038:	ldr	r1, [r4, #20]
    303a:	ldr	r2, [r4, #24]
    303c:	ldr	r3, [r4, #28]
    303e:	ldr	r0, [r4, #16]
  // make directory entry for new path
  if (isFile()) {
    3040:	and.w	r4, ip, #8
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
    3044:	stmia.w	lr!, {r0, r1, r2, r3}
  // make directory entry for new path
  if (isFile()) {
    3048:	and.w	r3, r4, #255	; 0xff
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    304c:	mov	r2, r8
    304e:	mov	r1, r7
    goto fail;
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
  // make directory entry for new path
  if (isFile()) {
    3050:	cmp	r4, #0
    3052:	bne.w	3162 <FatFile::rename(FatFile*, char const*)+0x1be>
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else {
    // don't create missing path prefix components
    if (!file.mkdir(dirFile, newPath, false)) {
    3056:	add	r0, sp, #32
    3058:	bl	2ea8 <FatFile::mkdir(FatFile*, char const*, bool)>
    305c:	mov	r4, r0
    305e:	cmp	r0, #0
    3060:	beq.w	31aa <FatFile::rename(FatFile*, char const*)+0x206>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
    3064:	ldr	r6, [sp, #64]	; 0x40
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    3066:	ldr	r0, [sp, #56]	; 0x38
  m_dirIndex = file.m_dirIndex;
    3068:	ldrh.w	r1, [sp, #36]	; 0x24
  m_lfnOrd = file.m_lfnOrd;
    306c:	ldrb.w	r2, [sp, #35]	; 0x23
  m_dirCluster = file.m_dirCluster;
    3070:	ldr	r3, [sp, #44]	; 0x2c
    // save cluster containing new dot dot
    dirCluster = file.m_firstCluster;
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
    3072:	str	r0, [r5, #24]
  m_dirIndex = file.m_dirIndex;
    3074:	strh	r1, [r5, #4]
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    3076:	movs	r7, #0
  }
  // change to new directory entry

  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
    3078:	strb	r2, [r5, #3]
  m_dirCluster = file.m_dirCluster;
    307a:	str	r3, [r5, #12]
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
    307c:	movs	r1, #1
    307e:	mov	r0, r5
  m_dirSector = file.m_dirSector;
  m_dirIndex = file.m_dirIndex;
  m_lfnOrd = file.m_lfnOrd;
  m_dirCluster = file.m_dirCluster;
  // mark closed to avoid possible destructor close call
  file.m_attributes = FILE_ATTR_CLOSED;
    3080:	strb.w	r7, [sp, #32]
  file.m_flags = 0;
    3084:	strb.w	r7, [sp, #34]	; 0x22

  // cache new directory entry
  dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
    3088:	bl	2568 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    308c:	mov	r4, r0
    308e:	cmp	r0, #0
    3090:	beq.w	31b4 <FatFile::rename(FatFile*, char const*)+0x210>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    3094:	add	r3, sp, #104	; 0x68
  dir->attributes = entry.attributes;
    3096:	ldrb.w	r2, [sp, #11]
    DBG_FAIL_MACRO;
    goto fail;
  }
  // copy all but name and name flags to new directory entry
  memcpy(&dir->createTimeMs, &entry.createTimeMs,
         sizeof(entry) - sizeof(dir->name) - 2);
    309a:	ldr.w	r0, [r3, #-91]!
    309e:	str.w	r0, [r4, #13]
    30a2:	ldr	r0, [r3, #4]
    30a4:	str.w	r0, [r4, #17]
    30a8:	ldr	r0, [r3, #8]
    30aa:	str.w	r0, [r4, #21]
    30ae:	ldr	r0, [r3, #12]
    30b0:	str.w	r0, [r4, #25]
    30b4:	ldrh	r0, [r3, #16]
    30b6:	ldrb	r3, [r3, #18]
    30b8:	strh.w	r0, [r4, #29]
    30bc:	strb	r3, [r4, #31]
  dir->attributes = entry.attributes;
    30be:	strb	r2, [r4, #11]

  // update dot dot if directory
  if (dirCluster) {
    30c0:	cmp	r6, #0
    30c2:	beq.n	3138 <FatFile::rename(FatFile*, char const*)+0x194>
    // get new dot dot
    uint32_t sector = m_vol->clusterStartSector(dirCluster);
    30c4:	mov	r1, r6
    30c6:	ldr	r0, [r5, #8]
    30c8:	bl	3554 <FatPartition::clusterStartSector(unsigned long) const>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return m_cache.read(sector, options);
    30cc:	ldr	r3, [r5, #8]
    30ce:	mov	r1, r0
    30d0:	mov	r2, r7
    30d2:	add.w	r0, r3, #36	; 0x24
    30d6:	bl	34c8 <FatCache::read(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FatCache::CACHE_FOR_READ);
    if (!pc) {
    30da:	mov	r4, r0
    30dc:	cmp	r0, #0
    30de:	beq.n	31c8 <FatFile::rename(FatFile*, char const*)+0x224>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&entry, &pc->dir[1], sizeof(entry));
    30e0:	ldr.w	r0, [r4, #32]!
    30e4:	ldr	r1, [r4, #4]
    30e6:	ldr	r2, [r4, #8]
    30e8:	ldr	r3, [r4, #12]
    30ea:	mov	r7, sp
    30ec:	stmia	r7!, {r0, r1, r2, r3}
    30ee:	ldr	r0, [r4, #16]
    30f0:	ldr	r1, [r4, #20]
    30f2:	ldr	r2, [r4, #24]
    30f4:	ldr	r3, [r4, #28]
    30f6:	stmia	r7!, {r0, r1, r2, r3}

    // free unused cluster
    if (!m_vol->freeChain(dirCluster)) {
    30f8:	mov	r1, r6
    30fa:	ldr	r0, [r5, #8]
    30fc:	bl	3734 <FatPartition::freeChain(unsigned long)>
    3100:	mov	r4, r0
    3102:	cmp	r0, #0
    3104:	beq.n	31a0 <FatFile::rename(FatFile*, char const*)+0x1fc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // store new dot dot
    sector = m_vol->clusterStartSector(m_firstCluster);
    3106:	ldr	r1, [r5, #32]
    3108:	ldr	r0, [r5, #8]
    310a:	bl	3554 <FatPartition::clusterStartSector(unsigned long) const>
    310e:	ldr	r3, [r5, #8]
    3110:	mov	r1, r0
    3112:	movs	r2, #1
    3114:	add.w	r0, r3, #36	; 0x24
    3118:	bl	34c8 <FatCache::read(unsigned long, unsigned char)>
    pc = m_vol->cacheFetchData(sector, FatCache::CACHE_FOR_WRITE);
    if (!pc) {
    311c:	mov	r4, r0
    311e:	cmp	r0, #0
    3120:	beq.n	31d2 <FatFile::rename(FatFile*, char const*)+0x22e>
      DBG_FAIL_MACRO;
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
    3122:	mov	r6, sp
    3124:	ldmia	r6!, {r0, r1, r2, r3}
    3126:	str	r0, [r4, #32]
    3128:	str	r1, [r4, #36]	; 0x24
    312a:	str	r2, [r4, #40]	; 0x28
    312c:	str	r3, [r4, #44]	; 0x2c
    312e:	ldmia	r6!, {r0, r1, r2, r3}
    3130:	str	r0, [r4, #48]	; 0x30
    3132:	str	r1, [r4, #52]	; 0x34
    3134:	str	r2, [r4, #56]	; 0x38
    3136:	str	r3, [r4, #60]	; 0x3c
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    3138:	movs	r1, #0
  oldFile.m_flags = FILE_FLAG_WRITE;
    313a:	movs	r2, #2
  oldFile.m_attributes = FILE_ATTR_FILE;
    313c:	movs	r3, #8
  if (!oldFile.remove()) {
    313e:	add	r0, sp, #68	; 0x44
      goto fail;
    }
    memcpy(&pc->dir[1], &entry, sizeof(entry));
  }
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
    3140:	str	r1, [sp, #100]	; 0x64
  oldFile.m_flags = FILE_FLAG_WRITE;
    3142:	strb.w	r2, [sp, #70]	; 0x46
  oldFile.m_attributes = FILE_ATTR_FILE;
    3146:	strb.w	r3, [sp, #68]	; 0x44
  if (!oldFile.remove()) {
    314a:	bl	3dcc <FatFile::remove()>
    314e:	mov	r4, r0
    3150:	cbz	r0, 317e <FatFile::rename(FatFile*, char const*)+0x1da>
    DBG_FAIL_MACRO;
    goto fail;
  }
  return m_vol->cacheSync();
    3152:	ldr	r4, [r5, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    return m_fatCache.read(sector,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    3154:	add.w	r0, r4, #36	; 0x24
    3158:	bl	3544 <FatCache::sync()>
    315c:	cbnz	r0, 3188 <FatFile::rename(FatFile*, char const*)+0x1e4>
    315e:	movs	r4, #0
    3160:	b.n	2fd4 <FatFile::rename(FatFile*, char const*)+0x30>
  }
  // save directory entry
  memcpy(&entry, dir, sizeof(entry));
  // make directory entry for new path
  if (isFile()) {
    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRONLY)) {
    3162:	movw	r3, #2561	; 0xa01
    3166:	add	r0, sp, #32
    3168:	bl	26a4 <FatFile::open(FatFile*, char const*, int)>
    316c:	mov	r4, r0
    316e:	cmp	r0, #0
    3170:	bne.w	3066 <FatFile::rename(FatFile*, char const*)+0xc2>
      DBG_FAIL_MACRO;
    3174:	mov.w	r0, #868	; 0x364
    3178:	bl	2414 <dbgPrint(unsigned short)>
      goto fail;
    317c:	b.n	2fd4 <FatFile::rename(FatFile*, char const*)+0x30>
  // Remove old directory entry;
  oldFile.m_firstCluster = 0;
  oldFile.m_flags = FILE_FLAG_WRITE;
  oldFile.m_attributes = FILE_ATTR_FILE;
  if (!oldFile.remove()) {
    DBG_FAIL_MACRO;
    317e:	movw	r0, #931	; 0x3a3
    3182:	bl	2414 <dbgPrint(unsigned short)>
    goto fail;
    3186:	b.n	2fd4 <FatFile::rename(FatFile*, char const*)+0x30>
    3188:	add.w	r0, r4, #560	; 0x230
    318c:	bl	3544 <FatCache::sync()>
    3190:	cmp	r0, #0
    3192:	beq.n	315e <FatFile::rename(FatFile*, char const*)+0x1ba>
    3194:	ldr	r0, [r4, #0]
  // sector I/O functions.
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    3196:	ldr	r3, [r0, #0]
    3198:	ldr	r3, [r3, #20]
    319a:	blx	r3
    319c:	mov	r4, r0
    319e:	b.n	2fd4 <FatFile::rename(FatFile*, char const*)+0x30>
    }
    memcpy(&entry, &pc->dir[1], sizeof(entry));

    // free unused cluster
    if (!m_vol->freeChain(dirCluster)) {
      DBG_FAIL_MACRO;
    31a0:	movw	r0, #914	; 0x392
    31a4:	bl	2414 <dbgPrint(unsigned short)>
      goto fail;
    31a8:	b.n	2fd4 <FatFile::rename(FatFile*, char const*)+0x30>
      goto fail;
    }
  } else {
    // don't create missing path prefix components
    if (!file.mkdir(dirFile, newPath, false)) {
      DBG_FAIL_MACRO;
    31aa:	movw	r0, #874	; 0x36a
    31ae:	bl	2414 <dbgPrint(unsigned short)>
      goto fail;
    31b2:	b.n	2fd4 <FatFile::rename(FatFile*, char const*)+0x30>
  file.m_flags = 0;

  // cache new directory entry
  dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
  if (!dir) {
    DBG_FAIL_MACRO;
    31b4:	movw	r0, #893	; 0x37d
    31b8:	bl	2414 <dbgPrint(unsigned short)>
    goto fail;
    31bc:	b.n	2fd4 <FatFile::rename(FatFile*, char const*)+0x30>
  // sync() and cache directory entry
  sync();
  oldFile = *this;
  dir = cacheDirEntry(FatCache::CACHE_FOR_READ);
  if (!dir) {
    DBG_FAIL_MACRO;
    31be:	mov.w	r0, #860	; 0x35c
    31c2:	bl	2414 <dbgPrint(unsigned short)>
    goto fail;
    31c6:	b.n	2fd4 <FatFile::rename(FatFile*, char const*)+0x30>
  if (dirCluster) {
    // get new dot dot
    uint32_t sector = m_vol->clusterStartSector(dirCluster);
    pc = m_vol->cacheFetchData(sector, FatCache::CACHE_FOR_READ);
    if (!pc) {
      DBG_FAIL_MACRO;
    31c8:	movw	r0, #907	; 0x38b
    31cc:	bl	2414 <dbgPrint(unsigned short)>
      goto fail;
    31d0:	b.n	2fd4 <FatFile::rename(FatFile*, char const*)+0x30>
    }
    // store new dot dot
    sector = m_vol->clusterStartSector(m_firstCluster);
    pc = m_vol->cacheFetchData(sector, FatCache::CACHE_FOR_WRITE);
    if (!pc) {
      DBG_FAIL_MACRO;
    31d2:	movw	r0, #921	; 0x399
    31d6:	bl	2414 <dbgPrint(unsigned short)>
      goto fail;
    31da:	b.n	2fd4 <FatFile::rename(FatFile*, char const*)+0x30>

000031dc <FatFile::sync()>:
}
//------------------------------------------------------------------------------
bool FatFile::sync() {
  uint16_t date, time;
  uint8_t ms10;
  if (!isOpen()) {
    31dc:	ldrb	r3, [r0, #0]
    31de:	cbz	r3, 31e4 <FatFile::sync()+0x8>
    31e0:	b.w	2594 <FatFile::sync() [clone .part.38]>
  DBG_FAIL_MACRO;

fail:
  m_error |= WRITE_ERROR;
  return false;
}
    31e4:	movs	r0, #1
    31e6:	bx	lr

000031e8 <FatFile::write(void const*, unsigned int)>:

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    31e8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    31ec:	ldrb	r3, [r0, #2]
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    31ee:	lsls	r5, r3, #30

 fail:
  return false;
}
//------------------------------------------------------------------------------
size_t FatFile::write(const void* buf, size_t nbyte) {
    31f0:	mov	r4, r0
  uint8_t cacheOption;
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    31f2:	bpl.w	335e <FatFile::write(void const*, unsigned int)+0x176>
    31f6:	mov	r9, r2
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    31f8:	lsls	r2, r3, #28
    31fa:	mov	r8, r1
    31fc:	bmi.w	33b8 <FatFile::write(void const*, unsigned int)+0x1d0>
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    3200:	ldr	r2, [r4, #20]
    3202:	mvns	r3, r2
    3204:	cmp	r9, r3
    3206:	bhi.w	33ae <FatFile::write(void const*, unsigned int)+0x1c6>
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    320a:	cmp.w	r9, #0
    320e:	beq.w	33ce <FatFile::write(void const*, unsigned int)+0x1e6>
    3212:	mov	r6, r9
    m_part = vol;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    3214:	mov.w	sl, #0
    3218:	b.n	3286 <FatFile::write(void const*, unsigned int)+0x9e>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
      // start of new cluster
      if (m_curCluster != 0) {
    321a:	cmp	r1, #0
    321c:	beq.w	3322 <FatFile::write(void const*, unsigned int)+0x13a>
#if USE_FAT_FILE_FLAG_CONTIGUOUS
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
    3220:	ldrb	r3, [r4, #2]
    3222:	lsls	r3, r3, #25
    3224:	bpl.w	3332 <FatFile::write(void const*, unsigned int)+0x14a>
    3228:	ldr	r3, [r4, #28]
    322a:	cmp	r3, r2
    322c:	bls.w	3332 <FatFile::write(void const*, unsigned int)+0x14a>
          m_curCluster++;
    3230:	adds	r1, #1
    3232:	str	r1, [r4, #16]
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    3234:	bl	3554 <FatPartition::clusterStartSector(unsigned long) const>
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    3238:	cmp.w	r6, #512	; 0x200
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    323c:	mov	r1, r0
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    323e:	bcs.n	32c0 <FatFile::write(void const*, unsigned int)+0xd8>
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
    3240:	ldr	r2, [r4, #20]
    3242:	ldr	r3, [r4, #28]
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    3244:	ldr	r0, [r4, #8]
    3246:	cmp.w	r6, #512	; 0x200
    324a:	mov	r5, r6
    324c:	it	cs
    324e:	movcs.w	r5, #512	; 0x200
      // lesser of space and amount to write
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
    3252:	cmp	r2, r3
    3254:	bcc.n	3350 <FatFile::write(void const*, unsigned int)+0x168>
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FatCache::CACHE_RESERVE_FOR_WRITE;
    3256:	movs	r2, #5
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return m_cache.read(sector, options);
    3258:	adds	r0, #36	; 0x24
    325a:	bl	34c8 <FatCache::read(unsigned long, unsigned char)>
      } else {
        // rewrite part of sector
        cacheOption = FatCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(sector, cacheOption);
      if (!pc) {
    325e:	cmp	r0, #0
    3260:	beq.w	33e8 <FatFile::write(void const*, unsigned int)+0x200>
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    3264:	add	r0, r7
    3266:	mov	r2, r5
    3268:	mov	r1, r8
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    326a:	add	r7, r5
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
    326c:	bl	8c24 <memcpy>
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
    3270:	cmp.w	r7, #512	; 0x200
    3274:	beq.w	3384 <FatFile::write(void const*, unsigned int)+0x19c>
      if (!m_vol->writeSector(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    3278:	ldr	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    327a:	subs	r6, r6, r5
      if (!m_vol->writeSector(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    327c:	add	r2, r5
    src += n;
    327e:	add	r8, r5
      if (!m_vol->writeSector(sector, src)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_curPosition += n;
    3280:	str	r2, [r4, #20]
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    3282:	beq.w	33ce <FatFile::write(void const*, unsigned int)+0x1e6>
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    3286:	ldr	r0, [r4, #8]
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
      // start of new cluster
      if (m_curCluster != 0) {
    3288:	ldr	r1, [r4, #16]
  }
  //----------------------------------------------------------------------------
  bool allocateCluster(uint32_t current, uint32_t* next);
  bool allocContiguous(uint32_t count, uint32_t* firstCluster);
  uint8_t sectorOfCluster(uint32_t position) const {
    return (position >> 9) & m_clusterSectorMask;
    328a:	ldrb	r3, [r0, #5]
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    328c:	ands.w	r5, r3, r2, lsr #9
    DBG_FAIL_MACRO;
    goto fail;
  }
  while (nToWrite) {
    uint8_t sectorOfCluster = m_vol->sectorOfCluster(m_curPosition);
    uint16_t sectorOffset = m_curPosition & m_vol->sectorMask();
    3290:	ubfx	r7, r2, #0, #9
    if (sectorOfCluster == 0 && sectorOffset == 0) {
    3294:	bne.n	32b0 <FatFile::write(void const*, unsigned int)+0xc8>
    3296:	cmp	r7, #0
    3298:	beq.n	321a <FatFile::write(void const*, unsigned int)+0x32>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    329a:	bl	3554 <FatPartition::clusterStartSector(unsigned long) const>
    329e:	mov	r1, r0
                      + sectorOfCluster;

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
      // partial sector - must use cache
      // max space in sector
      n = m_vol->bytesPerSector() - sectorOffset;
    32a0:	rsb	r5, r7, #512	; 0x200
    32a4:	cmp	r5, r6
    32a6:	it	cs
    32a8:	movcs	r5, r6
    32aa:	ldr	r0, [r4, #8]
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
        // start of new sector don't need to read into cache
        cacheOption = FatCache::CACHE_RESERVE_FOR_WRITE;
      } else {
        // rewrite part of sector
        cacheOption = FatCache::CACHE_FOR_WRITE;
    32ac:	movs	r2, #1
    32ae:	b.n	3258 <FatFile::write(void const*, unsigned int)+0x70>
          m_curCluster = m_firstCluster;
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    32b0:	bl	3554 <FatPartition::clusterStartSector(unsigned long) const>
                      + sectorOfCluster;
    32b4:	adds	r1, r5, r0

    if (sectorOffset != 0 || nToWrite < m_vol->bytesPerSector()) {
    32b6:	cmp	r7, #0
    32b8:	bne.n	32a0 <FatFile::write(void const*, unsigned int)+0xb8>
    32ba:	cmp.w	r6, #512	; 0x200
    32be:	bcc.n	3240 <FatFile::write(void const*, unsigned int)+0x58>
          DBG_FAIL_MACRO;
          goto fail;
        }
      }
#if USE_MULTI_SECTOR_IO
    } else if (nToWrite >= 2*m_vol->bytesPerSector()) {
    32c0:	cmp.w	r6, #1024	; 0x400
    32c4:	ldr	r2, [r4, #8]
    32c6:	bcc.n	3308 <FatFile::write(void const*, unsigned int)+0x120>
      // use multiple sector write command
      uint32_t maxSectors = m_vol->sectorsPerCluster() - sectorOfCluster;
    32c8:	ldrb	r3, [r2, #4]
    32ca:	ldr	r7, [r2, #44]	; 0x2c
    32cc:	subs	r3, r3, r5
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
    32ce:	lsrs	r0, r6, #9
    32d0:	cmp	r3, r0
    32d2:	it	cs
    32d4:	movcs	r3, r0
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
      // Check for cache sector in write range.
      if (sector <= m_vol->cacheSectorNumber()
          && sector < (m_vol->cacheSectorNumber() + nSector)) {
    32d6:	cmp	r7, r1
      uint32_t maxSectors = m_vol->sectorsPerCluster() - sectorOfCluster;
      uint32_t nSector = nToWrite >> m_vol->bytesPerSectorShift();
      if (nSector > maxSectors) {
        nSector = maxSectors;
      }
      n = nSector << m_vol->bytesPerSectorShift();
    32d8:	mov.w	r5, r3, lsl #9
      // Check for cache sector in write range.
      if (sector <= m_vol->cacheSectorNumber()
          && sector < (m_vol->cacheSectorNumber() + nSector)) {
    32dc:	bcc.n	32f0 <FatFile::write(void const*, unsigned int)+0x108>
    32de:	add	r7, r3
    32e0:	cmp	r7, r1
    32e2:	bls.n	32f0 <FatFile::write(void const*, unsigned int)+0x108>
    m_part = vol;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    32e4:	strb.w	sl, [r2, #36]	; 0x24
    m_lbn = 0XFFFFFFFF;
    32e8:	mov.w	r0, #4294967295
    32ec:	str	r0, [r2, #44]	; 0x2c
    32ee:	ldr	r2, [r4, #8]
    32f0:	ldr	r0, [r2, #0]
#if USE_MULTI_SECTOR_IO
  bool readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    return m_blockDev->readSectors(sector, dst, ns);
  }
  bool writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    return m_blockDev->writeSectors(sector, src, ns);
    32f2:	ldr	r2, [r0, #0]
    32f4:	ldr	r7, [r2, #28]
    32f6:	mov	r2, r8
    32f8:	blx	r7
        // Invalidate cache if cache sector is in the range.
        m_vol->cacheInvalidate();
      }
      if (!m_vol->writeSectors(sector, src, nSector)) {
    32fa:	cmp	r0, #0
    32fc:	bne.n	3278 <FatFile::write(void const*, unsigned int)+0x90>
        DBG_FAIL_MACRO;
    32fe:	movw	r0, #1377	; 0x561
    3302:	bl	2414 <dbgPrint(unsigned short)>
        goto fail;
    3306:	b.n	3366 <FatFile::write(void const*, unsigned int)+0x17e>
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
      if (m_vol->cacheSectorNumber() == sector) {
    3308:	ldr	r3, [r2, #44]	; 0x2c
    330a:	cmp	r3, r1
    330c:	beq.n	3376 <FatFile::write(void const*, unsigned int)+0x18e>
    330e:	ldr	r0, [r2, #0]
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    3310:	ldr	r3, [r0, #0]
    3312:	mov	r2, r8
    3314:	ldr	r3, [r3, #24]
    3316:	blx	r3
        m_vol->cacheInvalidate();
      }
      if (!m_vol->writeSector(sector, src)) {
    3318:	cmp	r0, #0
    331a:	beq.n	3402 <FatFile::write(void const*, unsigned int)+0x21a>
        goto fail;
      }
#endif  // USE_MULTI_SECTOR_IO
    } else {
      // use single sector write command
      n = m_vol->bytesPerSector();
    331c:	mov.w	r5, #512	; 0x200
    3320:	b.n	3278 <FatFile::write(void const*, unsigned int)+0x90>
            DBG_FAIL_MACRO;
            goto fail;
          }
        }
      } else {
        if (m_firstCluster == 0) {
    3322:	ldr	r1, [r4, #32]
    3324:	cmp	r1, #0
    3326:	beq.n	339c <FatFile::write(void const*, unsigned int)+0x1b4>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
        } else {
          m_curCluster = m_firstCluster;
    3328:	str	r1, [r4, #16]
        }
      }
    }
    // sector for data write
    uint32_t sector = m_vol->clusterStartSector(m_curCluster)
    332a:	bl	3554 <FatPartition::clusterStartSector(unsigned long) const>
    332e:	mov	r1, r0
    3330:	b.n	32ba <FatFile::write(void const*, unsigned int)+0xd2>
        int8_t fg;
        if (isContiguous() && m_fileSize > m_curPosition) {
          m_curCluster++;
          fg = 1;
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
    3332:	add.w	r2, r4, #16
    3336:	bl	3560 <FatPartition::fatGet(unsigned long, unsigned long*)>
          if (fg < 0) {
    333a:	cmp	r0, #0
    333c:	blt.n	3412 <FatFile::write(void const*, unsigned int)+0x22a>
        if (fg < 0) {
          DBG_FAIL_MACRO;
          goto fail;
        }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        if (fg == 0) {
    333e:	bne.n	334a <FatFile::write(void const*, unsigned int)+0x162>
          // add cluster if at end of chain
          if (!addCluster()) {
    3340:	mov	r0, r4
    3342:	bl	2450 <FatFile::addCluster()>
    3346:	cmp	r0, #0
    3348:	beq.n	341c <FatFile::write(void const*, unsigned int)+0x234>
    334a:	ldr	r0, [r4, #8]
    334c:	ldr	r1, [r4, #16]
    334e:	b.n	332a <FatFile::write(void const*, unsigned int)+0x142>
      if (n > nToWrite) {
        n = nToWrite;
      }

      if (sectorOffset == 0 &&
         (m_curPosition >= m_fileSize || m_flags & FILE_FLAG_PREALLOCATE)) {
    3350:	ldrb	r3, [r4, #2]
        // start of new sector don't need to read into cache
        cacheOption = FatCache::CACHE_RESERVE_FOR_WRITE;
    3352:	tst.w	r3, #32
    3356:	ite	eq
    3358:	moveq	r2, #1
    335a:	movne	r2, #5
    335c:	b.n	3258 <FatFile::write(void const*, unsigned int)+0x70>
  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;
  size_t n;
  // error if not a normal file or is read-only
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    335e:	movw	r0, #1266	; 0x4f2
    3362:	bl	2414 <dbgPrint(unsigned short)>
  }
  return nbyte;

fail:
  // return for write error
  m_error |= WRITE_ERROR;
    3366:	ldrb	r3, [r4, #1]
    3368:	orr.w	r3, r3, #1
    336c:	strb	r3, [r4, #1]
  return -1;
    336e:	mov.w	r0, #4294967295
    3372:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    m_part = vol;
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    3376:	strb.w	sl, [r2, #36]	; 0x24
    m_lbn = 0XFFFFFFFF;
    337a:	mov.w	r3, #4294967295
    337e:	str	r3, [r2, #44]	; 0x2c
    3380:	ldr	r2, [r4, #8]
    3382:	b.n	330e <FatFile::write(void const*, unsigned int)+0x126>
  }
  void cacheInvalidate() {
    m_cache.invalidate();
  }
  bool cacheSyncData() {
    return m_cache.sync();
    3384:	ldr	r0, [r4, #8]
    3386:	adds	r0, #36	; 0x24
    3388:	bl	3544 <FatCache::sync()>
      }
      uint8_t* dst = pc->data + sectorOffset;
      memcpy(dst, src, n);
      if (m_vol->bytesPerSector() == (n + sectorOffset)) {
        // Force write if sector is full - improves large writes.
        if (!m_vol->cacheSyncData()) {
    338c:	cmp	r0, #0
    338e:	bne.w	3278 <FatFile::write(void const*, unsigned int)+0x90>
          DBG_FAIL_MACRO;
    3392:	movw	r0, #1357	; 0x54d
    3396:	bl	2414 <dbgPrint(unsigned short)>
          goto fail;
    339a:	b.n	3366 <FatFile::write(void const*, unsigned int)+0x17e>
          }
        }
      } else {
        if (m_firstCluster == 0) {
          // allocate first cluster of file
          if (!addCluster()) {
    339c:	mov	r0, r4
    339e:	bl	2450 <FatFile::addCluster()>
    33a2:	cmp	r0, #0
    33a4:	beq.n	3426 <FatFile::write(void const*, unsigned int)+0x23e>
            DBG_FAIL_MACRO;
            goto fail;
          }
          m_firstCluster = m_curCluster;
    33a6:	ldr	r1, [r4, #16]
    33a8:	str	r1, [r4, #32]
    33aa:	ldr	r0, [r4, #8]
    33ac:	b.n	332a <FatFile::write(void const*, unsigned int)+0x142>
      goto fail;
    }
  }
  // Don't exceed max fileSize.
  if (nbyte > (0XFFFFFFFF - m_curPosition)) {
    DBG_FAIL_MACRO;
    33ae:	movw	r0, #1278	; 0x4fe
    33b2:	bl	2414 <dbgPrint(unsigned short)>
    goto fail;
    33b6:	b.n	3366 <FatFile::write(void const*, unsigned int)+0x17e>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // seek to end of file if append flag
  if ((m_flags & FILE_FLAG_APPEND)) {
    if (!seekSet(m_fileSize)) {
    33b8:	ldr	r1, [r0, #28]
    33ba:	bl	2a14 <FatFile::seekSet(unsigned long)>
    33be:	cmp	r0, #0
    33c0:	bne.w	3200 <FatFile::write(void const*, unsigned int)+0x18>
      DBG_FAIL_MACRO;
    33c4:	mov.w	r0, #1272	; 0x4f8
    33c8:	bl	2414 <dbgPrint(unsigned short)>
      goto fail;
    33cc:	b.n	3366 <FatFile::write(void const*, unsigned int)+0x17e>
    }
    m_curPosition += n;
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    33ce:	ldr	r3, [r4, #28]
    33d0:	cmp	r3, r2
    33d2:	bcc.n	33f2 <FatFile::write(void const*, unsigned int)+0x20a>
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    m_flags |= FILE_FLAG_DIR_DIRTY;
  } else if (FsDateTime::callback) {
    33d4:	ldr	r3, [pc, #88]	; (3430 <FatFile::write(void const*, unsigned int)+0x248>)
    33d6:	ldr	r3, [r3, #0]
    33d8:	cbz	r3, 340c <FatFile::write(void const*, unsigned int)+0x224>
    // insure sync will update modified date and time
    m_flags |= FILE_FLAG_DIR_DIRTY;
    33da:	ldrb	r3, [r4, #2]
    33dc:	orn	r3, r3, #127	; 0x7f
    33e0:	strb	r3, [r4, #2]
    33e2:	mov	r0, r9
    33e4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        // rewrite part of sector
        cacheOption = FatCache::CACHE_FOR_WRITE;
      }
      pc = m_vol->cacheFetchData(sector, cacheOption);
      if (!pc) {
        DBG_FAIL_MACRO;
    33e8:	movw	r0, #1349	; 0x545
    33ec:	bl	2414 <dbgPrint(unsigned short)>
        goto fail;
    33f0:	b.n	3366 <FatFile::write(void const*, unsigned int)+0x17e>
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    m_flags |= FILE_FLAG_DIR_DIRTY;
    33f2:	ldrb	r3, [r4, #2]
    src += n;
    nToWrite -= n;
  }
  if (m_curPosition > m_fileSize) {
    // update fileSize and insure sync will update dir entry
    m_fileSize = m_curPosition;
    33f4:	str	r2, [r4, #28]
    m_flags |= FILE_FLAG_DIR_DIRTY;
    33f6:	orn	r3, r3, #127	; 0x7f
    33fa:	strb	r3, [r4, #2]
    33fc:	mov	r0, r9
    33fe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      n = m_vol->bytesPerSector();
      if (m_vol->cacheSectorNumber() == sector) {
        m_vol->cacheInvalidate();
      }
      if (!m_vol->writeSector(sector, src)) {
        DBG_FAIL_MACRO;
    3402:	movw	r0, #1388	; 0x56c
    3406:	bl	2414 <dbgPrint(unsigned short)>
        goto fail;
    340a:	b.n	3366 <FatFile::write(void const*, unsigned int)+0x17e>
    340c:	mov	r0, r9
    340e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          m_curCluster++;
          fg = 1;
        } else {
          fg = m_vol->fatGet(m_curCluster, &m_curCluster);
          if (fg < 0) {
            DBG_FAIL_MACRO;
    3412:	movw	r0, #1295	; 0x50f
    3416:	bl	2414 <dbgPrint(unsigned short)>
            goto fail;
    341a:	b.n	3366 <FatFile::write(void const*, unsigned int)+0x17e>
        }
#endif  // USE_FAT_FILE_FLAG_CONTIGUOUS
        if (fg == 0) {
          // add cluster if at end of chain
          if (!addCluster()) {
            DBG_FAIL_MACRO;
    341c:	movw	r0, #1309	; 0x51d
    3420:	bl	2414 <dbgPrint(unsigned short)>
            goto fail;
    3424:	b.n	3366 <FatFile::write(void const*, unsigned int)+0x17e>
        }
      } else {
        if (m_firstCluster == 0) {
          // allocate first cluster of file
          if (!addCluster()) {
            DBG_FAIL_MACRO;
    3426:	movw	r0, #1317	; 0x525
    342a:	bl	2414 <dbgPrint(unsigned short)>
            goto fail;
    342e:	b.n	3366 <FatFile::write(void const*, unsigned int)+0x17e>
    3430:	.word	0x1fff13c8

00003434 <dbgPrint(unsigned short)>:
#if USE_DBG_MACROS
#include "Arduino.h"
#ifndef DBG_FILE
#error DBG_FILE not defined
#endif  // DBG_FILE
static void dbgPrint(uint16_t line) {
    3434:	push	{r3, r4, r5, lr}
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    3436:	movs	r1, #10
    3438:	mov	r5, r0
    343a:	ldr	r0, [pc, #40]	; (3464 <dbgPrint(unsigned short)+0x30>)
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    343c:	ldr	r4, [pc, #40]	; (3468 <dbgPrint(unsigned short)+0x34>)
    343e:	bl	8e24 <usb_serial_write>
    3442:	movs	r1, #16
    3444:	ldr	r0, [pc, #36]	; (346c <dbgPrint(unsigned short)+0x38>)
    3446:	bl	8e24 <usb_serial_write>
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    344a:	movs	r0, #46	; 0x2e
    344c:	bl	8f2c <usb_serial_putchar>
    3450:	mov	r1, r5
    3452:	mov	r0, r4
    3454:	bl	ae20 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    3458:	mov	r0, r4
  Serial.print(F("DBG_FAIL: "));
  Serial.print(F(DBG_FILE));
  Serial.write('.');
  Serial.println(line);
}
    345a:	ldmia.w	sp!, {r3, r4, r5, lr}
    345e:	b.w	ad80 <Print::println()>
    3462:	nop
    3464:	.word	0x0000c270
    3468:	.word	0x1fff099c
    346c:	.word	0x0000c2c8

00003470 <FatCache::sync() [clone .part.8]>:
fail:

  return nullptr;
}
//------------------------------------------------------------------------------
bool FatCache::sync() {
    3470:	push	{r3, r4, r5, r6, r7, lr}
    3472:	ldr	r3, [r0, #4]
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
  }
  bool writeSector(uint32_t sector, const uint8_t* src) {
    return m_blockDev->writeSector(sector, src);
    3474:	ldr	r1, [r0, #8]
  if (m_status & CACHE_STATUS_DIRTY) {
    if (!m_part->writeSector(m_lbn, m_buffer.data)) {
    3476:	add.w	r6, r0, #12
fail:

  return nullptr;
}
//------------------------------------------------------------------------------
bool FatCache::sync() {
    347a:	mov	r4, r0
    347c:	ldr	r0, [r3, #0]
    347e:	ldr	r3, [r0, #0]
    3480:	mov	r2, r6
    3482:	ldr	r3, [r3, #24]
    3484:	blx	r3
  if (m_status & CACHE_STATUS_DIRTY) {
    if (!m_part->writeSector(m_lbn, m_buffer.data)) {
    3486:	mov	r5, r0
    3488:	cbz	r0, 34b4 <FatCache::sync() [clone .part.8]+0x44>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
    348a:	ldrb	r3, [r4, #0]
    348c:	lsls	r2, r3, #30
    348e:	bmi.n	349a <FatCache::sync() [clone .part.8]+0x2a>
      if (!m_part->writeSector(sector, m_buffer.data)) {
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status &= ~CACHE_STATUS_DIRTY;
    3490:	bic.w	r3, r3, #1
    3494:	strb	r3, [r4, #0]
  }
  return true;

fail:
  return false;
}
    3496:	mov	r0, r5
    3498:	pop	{r3, r4, r5, r6, r7, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_lbn + m_part->sectorsPerFat();
    349a:	ldr	r3, [r4, #4]
    349c:	ldr	r1, [r4, #8]
    349e:	ldr	r0, [r3, #0]
    34a0:	ldr	r7, [r3, #16]
    34a2:	ldr	r3, [r0, #0]
    34a4:	mov	r2, r6
    34a6:	ldr	r3, [r3, #24]
    34a8:	add	r1, r7
    34aa:	blx	r3
      if (!m_part->writeSector(sector, m_buffer.data)) {
    34ac:	mov	r3, r0
    34ae:	cbz	r0, 34be <FatCache::sync() [clone .part.8]+0x4e>
    34b0:	ldrb	r3, [r4, #0]
    34b2:	b.n	3490 <FatCache::sync() [clone .part.8]+0x20>
}
//------------------------------------------------------------------------------
bool FatCache::sync() {
  if (m_status & CACHE_STATUS_DIRTY) {
    if (!m_part->writeSector(m_lbn, m_buffer.data)) {
      DBG_FAIL_MACRO;
    34b4:	movs	r0, #57	; 0x39
    34b6:	bl	3434 <dbgPrint(unsigned short)>
  }
  return true;

fail:
  return false;
}
    34ba:	mov	r0, r5
    34bc:	pop	{r3, r4, r5, r6, r7, pc}
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_lbn + m_part->sectorsPerFat();
      if (!m_part->writeSector(sector, m_buffer.data)) {
        DBG_FAIL_MACRO;
    34be:	movs	r0, #64	; 0x40
    m_status &= ~CACHE_STATUS_DIRTY;
  }
  return true;

fail:
  return false;
    34c0:	mov	r5, r3
    }
    // mirror second FAT
    if (m_status & CACHE_STATUS_MIRROR_FAT) {
      uint32_t sector = m_lbn + m_part->sectorsPerFat();
      if (!m_part->writeSector(sector, m_buffer.data)) {
        DBG_FAIL_MACRO;
    34c2:	bl	3434 <dbgPrint(unsigned short)>
    34c6:	b.n	3496 <FatCache::sync() [clone .part.8]+0x26>

000034c8 <FatCache::read(unsigned long, unsigned char)>:
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatPartition.h"
//------------------------------------------------------------------------------
cache_t* FatCache::read(uint32_t sector, uint8_t option) {
  if (m_lbn != sector) {
    34c8:	ldr	r3, [r0, #8]
    34ca:	cmp	r3, r1
#define DBG_FILE "FatPartition.cpp"
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatPartition.h"
//------------------------------------------------------------------------------
cache_t* FatCache::read(uint32_t sector, uint8_t option) {
    34cc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    34d0:	mov	r6, r0
    34d2:	mov	r5, r2
  if (m_lbn != sector) {
    34d4:	beq.n	34f8 <FatCache::read(unsigned long, unsigned char)+0x30>

  return nullptr;
}
//------------------------------------------------------------------------------
bool FatCache::sync() {
  if (m_status & CACHE_STATUS_DIRTY) {
    34d6:	ldrb	r3, [r0, #0]
    34d8:	lsls	r2, r3, #31
    34da:	mov	r7, r1
    34dc:	bmi.n	3508 <FatCache::read(unsigned long, unsigned char)+0x40>
  if (m_lbn != sector) {
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
    34de:	lsls	r3, r5, #29
    34e0:	bpl.n	351e <FatCache::read(unsigned long, unsigned char)+0x56>
    34e2:	add.w	r4, r6, #12
    34e6:	movs	r3, #0
      }
    }
    m_status = 0;
    m_lbn = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    34e8:	and.w	r5, r5, #3
    34ec:	orrs	r5, r3
    34ee:	strb	r5, [r6, #0]
    34f0:	mov	r0, r4
        DBG_FAIL_MACRO;
        goto fail;
      }
    }
    m_status = 0;
    m_lbn = sector;
    34f2:	str	r7, [r6, #8]
  return &m_buffer;

fail:

  return nullptr;
}
    34f4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    34f8:	ldrsb.w	r3, [r0], #12
      }
    }
    m_status = 0;
    m_lbn = sector;
  }
  m_status |= option & CACHE_STATUS_MASK;
    34fc:	and.w	r5, r5, #3
    3500:	orrs	r5, r3
    3502:	strb	r5, [r6, #0]
  return &m_buffer;

fail:

  return nullptr;
}
    3504:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3508:	bl	3470 <FatCache::sync() [clone .part.8]>
#include "../common/FsStructs.h"
#include "FatPartition.h"
//------------------------------------------------------------------------------
cache_t* FatCache::read(uint32_t sector, uint8_t option) {
  if (m_lbn != sector) {
    if (!sync()) {
    350c:	mov	r4, r0
    350e:	cmp	r0, #0
    3510:	bne.n	34de <FatCache::read(unsigned long, unsigned char)+0x16>
      DBG_FAIL_MACRO;
    3512:	movs	r0, #34	; 0x22
    3514:	bl	3434 <dbgPrint(unsigned short)>
  m_status |= option & CACHE_STATUS_MASK;
  return &m_buffer;

fail:

  return nullptr;
    3518:	mov	r0, r4
//------------------------------------------------------------------------------
cache_t* FatCache::read(uint32_t sector, uint8_t option) {
  if (m_lbn != sector) {
    if (!sync()) {
      DBG_FAIL_MACRO;
      goto fail;
    351a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    351e:	ldr	r3, [r6, #4]
    3520:	ldr	r0, [r3, #0]
  uint32_t m_lastCluster;             // Last cluster number in FAT.
  uint32_t m_rootDirStart;            // Start sector FAT16, cluster FAT32.
  //----------------------------------------------------------------------------
  // sector I/O functions.
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
    3522:	ldr	r3, [r0, #0]
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_part->readSector(sector, m_buffer.data)) {
    3524:	add.w	r4, r6, #12
    3528:	ldr	r3, [r3, #8]
    352a:	mov	r2, r4
    352c:	mov	r1, r7
    352e:	blx	r3
    3530:	mov	r8, r0
    3532:	cmp	r0, #0
    3534:	bne.n	34e6 <FatCache::read(unsigned long, unsigned char)+0x1e>
        DBG_FAIL_MACRO;
    3536:	movs	r0, #39	; 0x27
    3538:	bl	3434 <dbgPrint(unsigned short)>
  m_status |= option & CACHE_STATUS_MASK;
  return &m_buffer;

fail:

  return nullptr;
    353c:	mov	r0, r8
      goto fail;
    }
    if (!(option & CACHE_OPTION_NO_READ)) {
      if (!m_part->readSector(sector, m_buffer.data)) {
        DBG_FAIL_MACRO;
        goto fail;
    353e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3542:	nop

00003544 <FatCache::sync()>:

  return nullptr;
}
//------------------------------------------------------------------------------
bool FatCache::sync() {
  if (m_status & CACHE_STATUS_DIRTY) {
    3544:	ldrb	r3, [r0, #0]
    3546:	lsls	r3, r3, #31
    3548:	bmi.n	354e <FatCache::sync()+0xa>
  }
  return true;

fail:
  return false;
}
    354a:	movs	r0, #1
    354c:	bx	lr
    354e:	b.w	3470 <FatCache::sync() [clone .part.8]>
    3552:	nop

00003554 <FatPartition::clusterStartSector(unsigned long) const>:
fail:
  return false;
}
//------------------------------------------------------------------------------
uint32_t FatPartition::clusterStartSector(uint32_t cluster) const {
  return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
    3554:	ldrb	r3, [r0, #6]
    3556:	ldr	r0, [r0, #20]
    3558:	subs	r1, #2
    355a:	lsls	r1, r3
}
    355c:	add	r0, r1
    355e:	bx	lr

00003560 <FatPartition::fatGet(unsigned long, unsigned long*)>:
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    3560:	cmp	r1, #1
uint32_t FatPartition::clusterStartSector(uint32_t cluster) const {
  return m_dataStartSector + ((cluster - 2) << m_sectorsPerClusterShift);
}
//------------------------------------------------------------------------------
// Fetch a FAT entry - return -1 error, 0 EOC, else 1.
int8_t FatPartition::fatGet(uint32_t cluster, uint32_t* value) {
    3562:	push	{r4, r5, r6, lr}
  uint32_t sector;
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    3564:	bls.n	35ce <FatPartition::fatGet(unsigned long, unsigned long*)+0x6e>
    3566:	ldr	r3, [r0, #28]
    3568:	cmp	r1, r3
    356a:	mov	r4, r1
    356c:	mov	r5, r0
    356e:	bhi.n	35ce <FatPartition::fatGet(unsigned long, unsigned long*)+0x6e>
    3570:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    3572:	cmp	r3, #32
    3574:	mov	r6, r2
    3576:	beq.n	35a4 <FatPartition::fatGet(unsigned long, unsigned long*)+0x44>
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe32(reinterpret_cast<uint8_t*>
                  (&pc->fat32[cluster & (m_sectorMask >> 2)]));
  } else if (fatType() == 16) {
    3578:	cmp	r3, #16
    357a:	bne.n	35c0 <FatPartition::fatGet(unsigned long, unsigned long*)+0x60>
  FatCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FatCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    return m_fatCache.read(sector,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
    357c:	ldr	r3, [r0, #24]
    357e:	ubfx	r1, r1, #8, #8
    3582:	add	r1, r3
    3584:	movs	r2, #2
    3586:	add.w	r0, r0, #560	; 0x230
    358a:	bl	34c8 <FatCache::read(unsigned long, unsigned char)>
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FatCache::CACHE_FOR_READ);
    if (!pc) {
    358e:	cbz	r0, 35da <FatPartition::fatGet(unsigned long, unsigned long*)+0x7a>
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    3590:	uxtb	r4, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    next = getLe16(reinterpret_cast<uint8_t*>
                  (&pc->fat16[cluster & (m_sectorMask >> 1)]));
    3592:	ldrh.w	r3, [r0, r4, lsl #1]
    next = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    3596:	ldr	r2, [r5, #28]
    3598:	cmp	r3, r2
    return 0;
  }
  *value = next;
  return 1;
    359a:	itte	ls
    359c:	movls	r0, #1
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
  }
  *value = next;
    359e:	strls	r3, [r6, #0]
  } else {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isEOC(next)) {
    return 0;
    35a0:	movhi	r0, #0
  *value = next;
  return 1;

fail:
  return -1;
}
    35a2:	pop	{r4, r5, r6, pc}
    35a4:	ldr	r1, [r0, #24]
    35a6:	movs	r2, #2
    35a8:	add.w	r1, r1, r4, lsr #7
    35ac:	add.w	r0, r0, #560	; 0x230
    35b0:	bl	34c8 <FatCache::read(unsigned long, unsigned char)>
  }

  if (fatType() == 32) {
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FatCache::CACHE_FOR_READ);
    if (!pc) {
    35b4:	cbz	r0, 35e6 <FatPartition::fatGet(unsigned long, unsigned long*)+0x86>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    35b6:	and.w	r4, r4, #127	; 0x7f
    35ba:	ldr.w	r3, [r0, r4, lsl #2]
    35be:	b.n	3596 <FatPartition::fatGet(unsigned long, unsigned long*)+0x36>
      index = 0;
    }
    tmp |= pc->data[index] << 8;
    next = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
  } else {
    DBG_FAIL_MACRO;
    35c0:	mov.w	r0, #260	; 0x104
    35c4:	bl	3434 <dbgPrint(unsigned short)>
  }
  *value = next;
  return 1;

fail:
  return -1;
    35c8:	mov.w	r0, #4294967295
    }
    tmp |= pc->data[index] << 8;
    next = cluster & 1 ? tmp >> 4 : tmp & 0XFFF;
  } else {
    DBG_FAIL_MACRO;
    goto fail;
    35cc:	pop	{r4, r5, r6, pc}
  uint32_t next;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    DBG_FAIL_MACRO;
    35ce:	movs	r0, #214	; 0xd6
    35d0:	bl	3434 <dbgPrint(unsigned short)>
  }
  *value = next;
  return 1;

fail:
  return -1;
    35d4:	mov.w	r0, #4294967295
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    DBG_FAIL_MACRO;
    goto fail;
    35d8:	pop	{r4, r5, r6, pc}
  } else if (fatType() == 16) {
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FatCache::CACHE_FOR_READ);
    if (!pc) {
      DBG_FAIL_MACRO;
    35da:	movs	r0, #232	; 0xe8
    35dc:	bl	3434 <dbgPrint(unsigned short)>
  }
  *value = next;
  return 1;

fail:
  return -1;
    35e0:	mov.w	r0, #4294967295
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FatCache::CACHE_FOR_READ);
    if (!pc) {
      DBG_FAIL_MACRO;
      goto fail;
    35e4:	pop	{r4, r5, r6, pc}

  if (fatType() == 32) {
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FatCache::CACHE_FOR_READ);
    if (!pc) {
      DBG_FAIL_MACRO;
    35e6:	movs	r0, #222	; 0xde
    35e8:	bl	3434 <dbgPrint(unsigned short)>
  }
  *value = next;
  return 1;

fail:
  return -1;
    35ec:	mov.w	r0, #4294967295
  if (fatType() == 32) {
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FatCache::CACHE_FOR_READ);
    if (!pc) {
      DBG_FAIL_MACRO;
      goto fail;
    35f0:	pop	{r4, r5, r6, pc}
    35f2:	nop

000035f4 <FatPartition::fatPut(unsigned long, unsigned long)>:
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    35f4:	cmp	r1, #1
fail:
  return -1;
}
//------------------------------------------------------------------------------
// Store a FAT entry
bool FatPartition::fatPut(uint32_t cluster, uint32_t value) {
    35f6:	push	{r4, r5, r6, lr}
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    35f8:	bls.n	361a <FatPartition::fatPut(unsigned long, unsigned long)+0x26>
    35fa:	ldr	r3, [r0, #28]
    35fc:	cmp	r1, r3
    35fe:	mov	r4, r1
    3600:	bhi.n	361a <FatPartition::fatPut(unsigned long, unsigned long)+0x26>
    3602:	ldrb	r3, [r0, #7]
    DBG_FAIL_MACRO;
    goto fail;
  }

  if (fatType() == 32) {
    3604:	cmp	r3, #32
    3606:	mov	r5, r2
    3608:	beq.n	3626 <FatPartition::fatPut(unsigned long, unsigned long)+0x32>
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
  }

  if (fatType() == 16) {
    360a:	cmp	r3, #16
    360c:	beq.n	3646 <FatPartition::fatPut(unsigned long, unsigned long)+0x52>
      tmp = ((pc->data[index] & 0XF0)) | tmp >> 4;
    }
    pc->data[index] = tmp;
    return true;
  } else {
    DBG_FAIL_MACRO;
    360e:	mov.w	r0, #342	; 0x156
    3612:	bl	3434 <dbgPrint(unsigned short)>
    goto fail;
  }

fail:
  return false;
    3616:	movs	r0, #0
}
    3618:	pop	{r4, r5, r6, pc}
  uint32_t sector;
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    DBG_FAIL_MACRO;
    361a:	mov.w	r0, #280	; 0x118
    361e:	bl	3434 <dbgPrint(unsigned short)>
    DBG_FAIL_MACRO;
    goto fail;
  }

fail:
  return false;
    3622:	movs	r0, #0
  cache_t* pc;

  // error if reserved cluster of beyond FAT
  if (cluster < 2 || cluster > m_lastCluster) {
    DBG_FAIL_MACRO;
    goto fail;
    3624:	pop	{r4, r5, r6, pc}
    3626:	ldr	r1, [r0, #24]
    3628:	movs	r2, #3
    362a:	add.w	r0, r0, #560	; 0x230
    362e:	add.w	r1, r1, r4, lsr #7
    3632:	bl	34c8 <FatCache::read(unsigned long, unsigned char)>
  }

  if (fatType() == 32) {
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FatCache::CACHE_FOR_WRITE);
    if (!pc) {
    3636:	mov	r6, r0
    3638:	cbz	r0, 3672 <FatPartition::fatPut(unsigned long, unsigned long)+0x7e>
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
}

inline void setLe32(uint8_t* dst, uint32_t src) {
  *reinterpret_cast<uint32_t*>(dst) = src;
    363a:	and.w	r4, r4, #127	; 0x7f
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe32(reinterpret_cast<uint8_t*>
           (&pc->fat32[cluster & (m_sectorMask >> 2)]), value);
    return true;
    363e:	movs	r0, #1
    3640:	str.w	r5, [r6, r4, lsl #2]
    3644:	pop	{r4, r5, r6, pc}
    3646:	ldr	r3, [r0, #24]
    3648:	ubfx	r1, r1, #8, #8
    364c:	add.w	r0, r0, #560	; 0x230
    3650:	add	r1, r3
    3652:	movs	r2, #3
    3654:	bl	34c8 <FatCache::read(unsigned long, unsigned char)>

  if (fatType() == 16) {
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FatCache::CACHE_FOR_WRITE);
    if (!pc) {
    3658:	mov	r6, r0
    365a:	cbz	r0, 3666 <FatPartition::fatPut(unsigned long, unsigned long)+0x72>
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    365c:	uxtb	r4, r4
      DBG_FAIL_MACRO;
      goto fail;
    }
    setLe16(reinterpret_cast<uint8_t*>
           (&pc->fat16[cluster & (m_sectorMask >> 1)]), value);
    return true;
    365e:	movs	r0, #1
    3660:	strh.w	r5, [r6, r4, lsl #1]
    3664:	pop	{r4, r5, r6, pc}
  if (fatType() == 16) {
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FatCache::CACHE_FOR_WRITE);
    if (!pc) {
      DBG_FAIL_MACRO;
    3666:	movw	r0, #301	; 0x12d
    366a:	bl	3434 <dbgPrint(unsigned short)>
    DBG_FAIL_MACRO;
    goto fail;
  }

fail:
  return false;
    366e:	mov	r0, r6
    cluster &= 0XFFFF;
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 1) );
    pc = cacheFetchFat(sector, FatCache::CACHE_FOR_WRITE);
    if (!pc) {
      DBG_FAIL_MACRO;
      goto fail;
    3670:	pop	{r4, r5, r6, pc}

  if (fatType() == 32) {
    sector = m_fatStartSector + (cluster >> (m_bytesPerSectorShift - 2));
    pc = cacheFetchFat(sector, FatCache::CACHE_FOR_WRITE);
    if (!pc) {
      DBG_FAIL_MACRO;
    3672:	mov.w	r0, #288	; 0x120
    3676:	bl	3434 <dbgPrint(unsigned short)>
    DBG_FAIL_MACRO;
    goto fail;
  }

fail:
  return false;
    367a:	mov	r0, r6
    367c:	pop	{r4, r5, r6, pc}
    367e:	nop

00003680 <FatPartition::allocateCluster(unsigned long, unsigned long*)>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    3680:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    3684:	ldr	r4, [r0, #12]
    3686:	cmp	r4, r1

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatPartition::allocateCluster(uint32_t current, uint32_t* next) {
    3688:	sub	sp, #8
    368a:	mov	r5, r0
    368c:	mov	r7, r1
    368e:	mov	r8, r2
  uint32_t find;
  bool setStart;
  if (m_allocSearchStart < current) {
    3690:	itte	cc
    3692:	movcc	r4, r1
    // Try to keep file contiguous. Start just after current cluster.
    find = current;
    setStart = false;
    3694:	movcc	r6, #0
  } else {
    find = m_allocSearchStart;
    setStart = true;
    3696:	movcs	r6, #1
    3698:	ldr	r3, [r5, #28]
  }
  while (1) {
    find++;
    369a:	adds	r4, #1
    if (find > m_lastCluster) {
    369c:	cmp	r4, r3
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    369e:	add	r2, sp, #4
    36a0:	mov	r0, r5
    36a2:	mov	r1, r4
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    36a4:	bls.n	36ba <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x3a>
      if (setStart) {
    36a6:	cbnz	r6, 3700 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x80>
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
    36a8:	ldr	r4, [r5, #12]
  } else {
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    36aa:	adds	r4, #1
    if (find > m_lastCluster) {
    36ac:	cmp	r4, r3
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
        goto fail;
      }
      find = m_allocSearchStart;
      setStart = true;
    36ae:	mov.w	r6, #1
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    36b2:	add	r2, sp, #4
    36b4:	mov	r0, r5
    36b6:	mov	r1, r4
    find = m_allocSearchStart;
    setStart = true;
  }
  while (1) {
    find++;
    if (find > m_lastCluster) {
    36b8:	bhi.n	36a6 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x26>
      }
      find = m_allocSearchStart;
      setStart = true;
      continue;
    }
    if (find == current) {
    36ba:	cmp	r7, r4
    36bc:	beq.n	36f0 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x70>
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    36be:	bl	3560 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    36c2:	cmp	r0, #0
    36c4:	blt.n	3708 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x88>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (fg && f == 0) {
    36c6:	beq.n	3698 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x18>
    36c8:	ldr	r3, [sp, #4]
    36ca:	cmp	r3, #0
    36cc:	bne.n	3698 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x18>
      break;
    }
  }
  if (setStart) {
    36ce:	cbz	r6, 36d2 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x52>
    m_allocSearchStart = find;
    36d0:	str	r4, [r5, #12]
  }
  uint32_t clusterStartSector(uint32_t cluster) const;
  int8_t fatGet(uint32_t cluster, uint32_t* value);
  bool fatPut(uint32_t cluster, uint32_t value);
  bool fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    36d2:	mvn.w	r2, #4026531840	; 0xf0000000
    36d6:	mov	r1, r4
    36d8:	mov	r0, r5
    36da:	bl	35f4 <FatPartition::fatPut(unsigned long, unsigned long)>
  }
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    36de:	mov	r6, r0
    36e0:	cbz	r0, 372a <FatPartition::allocateCluster(unsigned long, unsigned long*)+0xaa>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    36e2:	cbnz	r7, 3710 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x90>
  *next = find;
  return true;

fail:
  return false;
}
    36e4:	mov	r0, r6
      DBG_FAIL_MACRO;
      goto fail;
    }
  }
  updateFreeClusterCount(-1);
  *next = find;
    36e6:	str.w	r4, [r8]
  return true;

fail:
  return false;
}
    36ea:	add	sp, #8
    36ec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      setStart = true;
      continue;
    }
    if (find == current) {
      // Can't find space, already searched clusters after current.
      DBG_FAIL_MACRO;
    36f0:	movs	r0, #101	; 0x65
    36f2:	bl	3434 <dbgPrint(unsigned short)>
  updateFreeClusterCount(-1);
  *next = find;
  return true;

fail:
  return false;
    36f6:	movs	r6, #0
}
    36f8:	mov	r0, r6
    36fa:	add	sp, #8
    36fc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while (1) {
    find++;
    if (find > m_lastCluster) {
      if (setStart) {
        // Can't find space, checked all clusters.
        DBG_FAIL_MACRO;
    3700:	movs	r0, #92	; 0x5c
    3702:	bl	3434 <dbgPrint(unsigned short)>
        goto fail;
    3706:	b.n	36f6 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x76>
      goto fail;
    }
    uint32_t f;
    int8_t fg = fatGet(find, &f);
    if (fg < 0) {
      DBG_FAIL_MACRO;
    3708:	movs	r0, #107	; 0x6b
    370a:	bl	3434 <dbgPrint(unsigned short)>
      goto fail;
    370e:	b.n	36f6 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x76>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (current) {
    // Link clusters.
    if (!fatPut(current, find)) {
    3710:	mov	r1, r7
    3712:	mov	r0, r5
    3714:	mov	r2, r4
    3716:	bl	35f4 <FatPartition::fatPut(unsigned long, unsigned long)>
    371a:	mov	r3, r0
    371c:	cmp	r0, #0
    371e:	bne.n	36e4 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x64>
      DBG_FAIL_MACRO;
    3720:	movs	r0, #125	; 0x7d
  updateFreeClusterCount(-1);
  *next = find;
  return true;

fail:
  return false;
    3722:	mov	r6, r3
    goto fail;
  }
  if (current) {
    // Link clusters.
    if (!fatPut(current, find)) {
      DBG_FAIL_MACRO;
    3724:	bl	3434 <dbgPrint(unsigned short)>
      goto fail;
    3728:	b.n	36f8 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
  if (setStart) {
    m_allocSearchStart = find;
  }
  // Mark end of chain.
  if (!fatPutEOC(find)) {
    DBG_FAIL_MACRO;
    372a:	movs	r0, #119	; 0x77
    372c:	bl	3434 <dbgPrint(unsigned short)>
    goto fail;
    3730:	b.n	36f8 <FatPartition::allocateCluster(unsigned long, unsigned long*)+0x78>
    3732:	nop

00003734 <FatPartition::freeChain(unsigned long)>:
fail:
  return false;
}
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
    3734:	push	{r4, r5, r6, r7, lr}
    3736:	mov	r5, r0
    3738:	sub	sp, #12
    373a:	mov	r4, r1
    373c:	b.n	3756 <FatPartition::freeChain(unsigned long)+0x22>
    if (fg < 0) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    373e:	bl	35f4 <FatPartition::fatPut(unsigned long, unsigned long)>
    3742:	mov	r6, r0
    3744:	cbz	r0, 377c <FatPartition::freeChain(unsigned long)+0x48>
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Add one to count of free clusters.
    updateFreeClusterCount(1);
    if (cluster < m_allocSearchStart) {
    3746:	ldr	r3, [r5, #12]
    3748:	cmp	r4, r3
      m_allocSearchStart = cluster - 1;
    374a:	itt	cc
    374c:	addcc.w	r4, r4, #4294967295
    3750:	strcc	r4, [r5, #12]
    }
    cluster = next;
    3752:	ldr	r4, [sp, #4]
//------------------------------------------------------------------------------
// free a cluster chain
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    3754:	cbz	r7, 3776 <FatPartition::freeChain(unsigned long)+0x42>
    fg = fatGet(cluster, &next);
    3756:	add	r2, sp, #4
    3758:	mov	r1, r4
    375a:	mov	r0, r5
    375c:	bl	3560 <FatPartition::fatGet(unsigned long, unsigned long*)>
    if (fg < 0) {
    3760:	subs	r7, r0, #0
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
    3762:	mov	r1, r4
    3764:	mov.w	r2, #0
    3768:	mov	r0, r5
bool FatPartition::freeChain(uint32_t cluster) {
  uint32_t next;
  int8_t fg;
  do {
    fg = fatGet(cluster, &next);
    if (fg < 0) {
    376a:	bge.n	373e <FatPartition::freeChain(unsigned long)+0xa>
      DBG_FAIL_MACRO;
    376c:	movw	r0, #357	; 0x165
    3770:	bl	3434 <dbgPrint(unsigned short)>
  } while (fg);

  return true;

fail:
  return false;
    3774:	movs	r6, #0
}
    3776:	mov	r0, r6
    3778:	add	sp, #12
    377a:	pop	{r4, r5, r6, r7, pc}
      DBG_FAIL_MACRO;
      goto fail;
    }
    // free cluster
    if (!fatPut(cluster, 0)) {
      DBG_FAIL_MACRO;
    377c:	mov.w	r0, #362	; 0x16a
    3780:	bl	3434 <dbgPrint(unsigned short)>

  return true;

fail:
  return false;
}
    3784:	mov	r0, r6
    3786:	add	sp, #12
    3788:	pop	{r4, r5, r6, r7, pc}
    378a:	nop

0000378c <FatPartition::freeClusterCount()>:
//------------------------------------------------------------------------------
int32_t FatPartition::freeClusterCount() {
    378c:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3790:	ldrb	r3, [r0, #7]
    return m_freeClusterCount;
  }
#endif  // MAINTAIN_FREE_CLUSTER_COUNT
  uint32_t free = 0;
  uint32_t sector;
  uint32_t todo = m_lastCluster + 1;
    3792:	ldr	r2, [r0, #28]
      }
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    3794:	cmp	r3, #16

fail:
  return false;
}
//------------------------------------------------------------------------------
int32_t FatPartition::freeClusterCount() {
    3796:	mov	r6, r0
    return m_freeClusterCount;
  }
#endif  // MAINTAIN_FREE_CLUSTER_COUNT
  uint32_t free = 0;
  uint32_t sector;
  uint32_t todo = m_lastCluster + 1;
    3798:	add.w	r8, r2, #1
      }
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    379c:	beq.n	37b2 <FatPartition::freeClusterCount()+0x26>
    379e:	cmp	r3, #32
    37a0:	beq.n	37b2 <FatPartition::freeClusterCount()+0x26>
      }
      todo -= n;
    }
  } else {
    // invalid FAT type
    DBG_FAIL_MACRO;
    37a2:	movw	r0, #431	; 0x1af
    37a6:	bl	3434 <dbgPrint(unsigned short)>
  }
  setFreeClusterCount(free);
  return free;

fail:
  return -1;
    37aa:	mov.w	r0, #4294967295
      todo -= n;
    }
  } else {
    // invalid FAT type
    DBG_FAIL_MACRO;
    goto fail;
    37ae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (fg && c == 0) {
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    37b2:	ldr	r5, [r6, #24]
    while (todo) {
    37b4:	cmp.w	r8, #0
    37b8:	beq.n	3844 <FatPartition::freeClusterCount()+0xb8>
    37ba:	add.w	r7, r6, #560	; 0x230
    37be:	movs	r4, #0
  FatCache m_cache;
#if USE_SEPARATE_FAT_CACHE
  FatCache m_fatCache;
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    return m_fatCache.read(sector,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
    37c0:	mov	r1, r5
    37c2:	movs	r2, #2
    37c4:	mov	r0, r7
      cache_t* pc = cacheFetchFat(sector++, FatCache::CACHE_FOR_READ);
    37c6:	adds	r5, #1
    37c8:	bl	34c8 <FatCache::read(unsigned long, unsigned char)>
      if (!pc) {
    37cc:	cbz	r0, 3834 <FatPartition::freeClusterCount()+0xa8>
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    37ce:	ldrb	r3, [r6, #7]
    37d0:	cmp	r3, #16
    37d2:	beq.n	3802 <FatPartition::freeClusterCount()+0x76>
      if (todo < n) {
    37d4:	cmp.w	r8, #127	; 0x7f
    37d8:	bhi.n	382c <FatPartition::freeClusterCount()+0xa0>
        n = todo;
    37da:	uxth.w	r1, r8
    37de:	mov	lr, r8
    37e0:	subs	r1, #1
    37e2:	uxth	r1, r1
    37e4:	add.w	r1, r0, r1, lsl #2
    37e8:	subs	r3, r0, #4
            free++;
          }
        }
      } else {
        for (uint16_t i = 0; i < n; i++) {
          if (pc->fat32[i] == 0) {
    37ea:	ldr.w	r2, [r3, #4]!
    37ee:	cbnz	r2, 37f2 <FatPartition::freeClusterCount()+0x66>
            free++;
    37f0:	adds	r4, #1
          if (pc->fat16[i] == 0) {
            free++;
          }
        }
      } else {
        for (uint16_t i = 0; i < n; i++) {
    37f2:	cmp	r3, r1
    37f4:	bne.n	37ea <FatPartition::freeClusterCount()+0x5e>
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    37f6:	subs.w	r8, r8, lr
    37fa:	bne.n	37c0 <FatPartition::freeClusterCount()+0x34>
    37fc:	mov	r0, r4
    37fe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
    3802:	cmp.w	r8, #255	; 0xff
    3806:	bls.n	384a <FatPartition::freeClusterCount()+0xbe>
    3808:	mov.w	lr, #256	; 0x100
      cache_t* pc = cacheFetchFat(sector++, FatCache::CACHE_FOR_READ);
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    380c:	mov	r3, lr
    380e:	subs	r1, r3, #1
    3810:	uxth	r1, r1
    3812:	add.w	r1, r0, r1, lsl #1
    3816:	subs	r3, r0, #2
      if (todo < n) {
        n = todo;
      }
      if (fatType() == 16) {
        for (uint16_t i = 0; i < n; i++) {
          if (pc->fat16[i] == 0) {
    3818:	ldrh.w	r2, [r3, #2]!
    381c:	cbnz	r2, 3820 <FatPartition::freeClusterCount()+0x94>
            free++;
    381e:	adds	r4, #1
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
        n = todo;
      }
      if (fatType() == 16) {
        for (uint16_t i = 0; i < n; i++) {
    3820:	cmp	r1, r3
    3822:	bne.n	3818 <FatPartition::freeClusterCount()+0x8c>
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    3824:	subs.w	r8, r8, lr
    3828:	bne.n	37c0 <FatPartition::freeClusterCount()+0x34>
    382a:	b.n	37fc <FatPartition::freeClusterCount()+0x70>
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
    382c:	mov.w	lr, #128	; 0x80
      cache_t* pc = cacheFetchFat(sector++, FatCache::CACHE_FOR_READ);
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
    3830:	mov	r1, lr
    3832:	b.n	37e0 <FatPartition::freeClusterCount()+0x54>
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
      cache_t* pc = cacheFetchFat(sector++, FatCache::CACHE_FOR_READ);
      if (!pc) {
        DBG_FAIL_MACRO;
    3834:	movw	r0, #407	; 0x197
    3838:	bl	3434 <dbgPrint(unsigned short)>
  }
  setFreeClusterCount(free);
  return free;

fail:
  return -1;
    383c:	mov.w	r0, #4294967295
    sector = m_fatStartSector;
    while (todo) {
      cache_t* pc = cacheFetchFat(sector++, FatCache::CACHE_FOR_READ);
      if (!pc) {
        DBG_FAIL_MACRO;
        goto fail;
    3840:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        free++;
      }
    }
  } else if (fatType() == 16 || fatType() == 32) {
    sector = m_fatStartSector;
    while (todo) {
    3844:	mov	r0, r8
    // invalid FAT type
    DBG_FAIL_MACRO;
    goto fail;
  }
  setFreeClusterCount(free);
  return free;
    3846:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        DBG_FAIL_MACRO;
        goto fail;
      }
      n =  fatType() == 16 ? m_bytesPerSector/2 : m_bytesPerSector/4;
      if (todo < n) {
        n = todo;
    384a:	uxth.w	r3, r8
    384e:	mov	lr, r8
    3850:	b.n	380e <FatPartition::freeClusterCount()+0x82>
    3852:	nop

00003854 <FatPartition::init(BlockDeviceInterface*, unsigned char)>:

fail:
  return -1;
}
//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
    3854:	push	{r3, r4, r5, r6, r7, lr}
    3856:	mov	r4, r0
  m_blockDev = dev;
  pbs_t* pbs;
  BpbFat32_t* bpb;
  MbrSector_t* mbr;
  uint8_t tmp;
  m_fatType = 0;
    3858:	movs	r5, #0
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    m_lbn = 0XFFFFFFFF;
    385a:	mov.w	r3, #4294967295
  m_allocSearchStart = 1;
    385e:	movs	r0, #1
//------------------------------------------------------------------------------
bool FatPartition::init(BlockDevice* dev, uint8_t part) {
  uint32_t clusterCount;
  uint32_t totalSectors;
  uint32_t volumeStartSector = 0;
  m_blockDev = dev;
    3860:	str	r1, [r4, #0]
  }
  /** Initialize the cache.
   * \param[in] vol FatPartition that owns this FatCache.
   */
  void init(FatPartition *vol) {
    m_part = vol;
    3862:	str	r4, [r4, #40]	; 0x28
    3864:	str.w	r4, [r4, #564]	; 0x234
  pbs_t* pbs;
  BpbFat32_t* bpb;
  MbrSector_t* mbr;
  uint8_t tmp;
  m_fatType = 0;
  m_allocSearchStart = 1;
    3868:	str	r0, [r4, #12]
  m_blockDev = dev;
  pbs_t* pbs;
  BpbFat32_t* bpb;
  MbrSector_t* mbr;
  uint8_t tmp;
  m_fatType = 0;
    386a:	strb	r5, [r4, #7]
    invalidate();
  }
  /** Invalidate current cache sector. */
  void invalidate() {
    m_status = 0;
    386c:	strb.w	r5, [r4, #36]	; 0x24
    3870:	strb.w	r5, [r4, #560]	; 0x230
    m_lbn = 0XFFFFFFFF;
    3874:	str	r3, [r4, #44]	; 0x2c
    3876:	str.w	r3, [r4, #568]	; 0x238
#if USE_SEPARATE_FAT_CACHE
  m_fatCache.init(this);
#endif  // USE_SEPARATE_FAT_CACHE
  // if part == 0 assume super floppy with FAT boot sector in sector zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    387a:	mov	r6, r2
    387c:	cbz	r2, 38c2 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x6e>
    if (part > 4) {
    387e:	cmp	r2, #4
    3880:	bhi.n	38b6 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x62>
  bool cacheSync() {
    return m_cache.sync() && syncDevice();
  }
#endif  // USE_SEPARATE_FAT_CACHE
  cache_t* cacheFetchData(uint32_t sector, uint8_t options) {
    return m_cache.read(sector, options);
    3882:	add.w	r7, r4, #36	; 0x24
    3886:	mov	r2, r5
    3888:	mov	r0, r7
    388a:	mov	r1, r5
    388c:	bl	34c8 <FatCache::read(unsigned long, unsigned char)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    mbr = reinterpret_cast<MbrSector_t*>
          (cacheFetchData(0, FatCache::CACHE_FOR_READ));
    MbrPart_t *mp = mbr->part + part - 1;
    3890:	add.w	r6, r6, #268435456	; 0x10000000
    3894:	subs	r6, #1
    3896:	lsls	r6, r6, #4
    3898:	add.w	r3, r0, #446	; 0x1be
    389c:	adds	r2, r3, r6

    if (!mbr || mp->type == 0 || (mp->boot != 0 && mp->boot != 0X80)) {
    389e:	cbz	r0, 38aa <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x56>
    38a0:	ldrb	r1, [r2, #4]
    38a2:	cbz	r1, 38aa <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x56>
    38a4:	ldrb	r3, [r3, r6]
    38a6:	lsls	r3, r3, #25
    38a8:	beq.n	38e4 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x90>
      DBG_FAIL_MACRO;
    38aa:	mov.w	r0, #468	; 0x1d4
    38ae:	bl	3434 <dbgPrint(unsigned short)>
    m_fatType = 32;
  }
  return true;

fail:
  return false;
    38b2:	movs	r0, #0
          (cacheFetchData(0, FatCache::CACHE_FOR_READ));
    MbrPart_t *mp = mbr->part + part - 1;

    if (!mbr || mp->type == 0 || (mp->boot != 0 && mp->boot != 0X80)) {
      DBG_FAIL_MACRO;
      goto fail;
    38b4:	pop	{r3, r4, r5, r6, r7, pc}
#endif  // USE_SEPARATE_FAT_CACHE
  // if part == 0 assume super floppy with FAT boot sector in sector zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4) {
      DBG_FAIL_MACRO;
    38b6:	mov.w	r0, #460	; 0x1cc
    38ba:	bl	3434 <dbgPrint(unsigned short)>
    m_fatType = 32;
  }
  return true;

fail:
  return false;
    38be:	mov	r0, r5
  // if part == 0 assume super floppy with FAT boot sector in sector zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4) {
      DBG_FAIL_MACRO;
      goto fail;
    38c0:	pop	{r3, r4, r5, r6, r7, pc}
    38c2:	add.w	r7, r4, #36	; 0x24
    38c6:	mov	r0, r7
    38c8:	movs	r2, #0
    38ca:	mov	r1, r6
    38cc:	bl	34c8 <FatCache::read(unsigned long, unsigned char)>
  }
  pbs = reinterpret_cast<pbs_t*>
        (cacheFetchData(volumeStartSector, FatCache::CACHE_FOR_READ));
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);

  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    38d0:	cbz	r0, 38d8 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x84>
    38d2:	ldrb	r3, [r0, #16]
    38d4:	cmp	r3, #2
    38d6:	beq.n	38e8 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x94>
    DBG_FAIL_MACRO;
    38d8:	mov.w	r0, #478	; 0x1de
    38dc:	bl	3434 <dbgPrint(unsigned short)>
    m_fatType = 32;
  }
  return true;

fail:
  return false;
    38e0:	movs	r0, #0
        (cacheFetchData(volumeStartSector, FatCache::CACHE_FOR_READ));
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);

  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    DBG_FAIL_MACRO;
    goto fail;
    38e2:	pop	{r3, r4, r5, r6, r7, pc}
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    38e4:	ldr	r6, [r2, #8]
    38e6:	b.n	38c6 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x72>
  }
  pbs = reinterpret_cast<pbs_t*>
        (cacheFetchData(volumeStartSector, FatCache::CACHE_FOR_READ));
  bpb = reinterpret_cast<BpbFat32_t*>(pbs->bpb);

  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    38e8:	ldrh.w	r3, [r0, #11]
    38ec:	cmp.w	r3, #512	; 0x200
    38f0:	bne.n	38d8 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x84>
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
    38f2:	ldrb	r5, [r0, #13]
    38f4:	strb	r5, [r4, #4]
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    38f6:	subs	r3, r5, #1
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    38f8:	movs	r2, #0
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    38fa:	cmp	r5, #1
  if (!pbs || bpb->fatCount != 2 || getLe16(bpb->bytesPerSector) != 512) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  m_sectorsPerCluster = bpb->sectorsPerCluster;
  m_clusterSectorMask = m_sectorsPerCluster - 1;
    38fc:	strb	r3, [r4, #5]
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
    38fe:	strb	r2, [r4, #6]
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    3900:	beq.n	392a <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd6>
    3902:	movs	r2, #1
    3904:	mov	r1, r2
    3906:	b.n	390a <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb6>
    3908:	mov	r2, r3
    390a:	lsls	r1, r1, #1
    390c:	uxtb	r1, r1
    390e:	adds	r3, r2, #1
    3910:	cmp	r5, r1
    3912:	uxtb	r3, r3
    3914:	beq.n	3928 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xd4>
    if (tmp == 0) {
    3916:	cmp	r3, #9
    3918:	bne.n	3908 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xb4>
    391a:	strb	r2, [r4, #6]
      DBG_FAIL_MACRO;
    391c:	movw	r0, #487	; 0x1e7
    3920:	bl	3434 <dbgPrint(unsigned short)>
    m_fatType = 32;
  }
  return true;

fail:
  return false;
    3924:	movs	r0, #0
  // determine shift that is same as multiply by m_sectorsPerCluster
  m_sectorsPerClusterShift = 0;
  for (tmp = 1; m_sectorsPerCluster != tmp; tmp <<= 1) {
    if (tmp == 0) {
      DBG_FAIL_MACRO;
      goto fail;
    3926:	pop	{r3, r4, r5, r6, r7, pc}
    3928:	strb	r2, [r4, #6]
    }
    m_sectorsPerClusterShift++;
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
    392a:	ldrh	r1, [r0, #22]
    392c:	str	r1, [r4, #16]
  if (m_sectorsPerFat == 0) {
    392e:	cbnz	r1, 3934 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0xe0>
    3930:	ldr	r1, [r0, #36]	; 0x24
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
    3932:	str	r1, [r4, #16]
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    3934:	ldrh	r7, [r0, #14]
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    3936:	ldrh.w	r3, [r0, #17]

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);
    393a:	strh	r3, [r4, #8]
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    393c:	add	r7, r6
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    393e:	lsls	r3, r3, #5

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    3940:	add.w	r5, r7, r1, lsl #1
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    3944:	addw	r3, r3, #511	; 0x1ff
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
    3948:	ldrh.w	r1, [r0, #19]
  }
  m_sectorsPerFat = getLe16(bpb->sectorsPerFat16);
  if (m_sectorsPerFat == 0) {
    m_sectorsPerFat = getLe32(bpb->sectorsPerFat32);
  }
  m_fatStartSector = volumeStartSector + getLe16(bpb->reservedSectorCount);
    394c:	str	r7, [r4, #24]
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    394e:	add.w	r3, r5, r3, asr #9

  // count for FAT16 zero for FAT32
  m_rootDirEntryCount = getLe16(bpb->rootDirEntryCount);

  // directory start for FAT16 dataStart for FAT32
  m_rootDirStart = m_fatStartSector + 2 * m_sectorsPerFat;
    3952:	str	r5, [r4, #32]
  // data start for FAT16 and FAT32
  m_dataStartSector = m_rootDirStart +
    ((32 * m_rootDirEntryCount + m_bytesPerSector - 1)/m_bytesPerSector);
    3954:	str	r3, [r4, #20]

  // total sectors for FAT16 or FAT32
  totalSectors = getLe16(bpb->totalSectors16);
  if (totalSectors == 0) {
    3956:	cbnz	r1, 395a <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x106>
}
inline uint32_t getLe32(const uint8_t* src) {
  return *reinterpret_cast<const uint32_t*>(src);
    3958:	ldr	r1, [r0, #32]
    totalSectors = getLe32(bpb->totalSectors32);
  }
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);
    395a:	subs	r6, r6, r3
    395c:	add	r6, r1

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
    395e:	lsr.w	r2, r6, r2
  m_lastCluster = clusterCount + 1;

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    3962:	movw	r3, #4084	; 0xff4
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
  m_lastCluster = clusterCount + 1;
    3966:	adds	r1, r2, #1

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    3968:	cmp	r2, r3
  // total data sectors
  clusterCount = totalSectors - (m_dataStartSector - volumeStartSector);

  // divide by cluster size to get cluster count
  clusterCount >>= m_sectorsPerClusterShift;
  m_lastCluster = clusterCount + 1;
    396a:	str	r1, [r4, #28]

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    396c:	bls.n	3984 <FatPartition::init(BlockDeviceInterface*, unsigned char)+0x130>
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    396e:	movw	r3, #65524	; 0xfff4
    3972:	cmp	r2, r3
    3974:	ittet	hi
    3976:	ldrhi	r3, [r0, #44]	; 0x2c
    m_fatType = 16;
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    3978:	strhi	r3, [r4, #32]
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    }
  } else if (clusterCount < 65525) {
    m_fatType = 16;
    397a:	movls	r3, #16
  } else {
    m_rootDirStart = getLe32(bpb->fat32RootCluster);
    m_fatType = 32;
    397c:	movhi	r3, #32
    397e:	strb	r3, [r4, #7]
  }
  return true;
    3980:	movs	r0, #1
    3982:	pop	{r3, r4, r5, r6, r7, pc}

  // Indicate unknown number of free clusters.
  setFreeClusterCount(-1);
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    3984:	movs	r3, #12
    3986:	strb	r3, [r4, #7]
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
    3988:	movw	r0, #525	; 0x20d
    398c:	bl	3434 <dbgPrint(unsigned short)>
    m_fatType = 32;
  }
  return true;

fail:
  return false;
    3990:	movs	r0, #0
  // FAT type is determined by cluster count
  if (clusterCount < 4085) {
    m_fatType = 12;
    if (!FAT12_SUPPORT) {
      DBG_FAIL_MACRO;
      goto fail;
    3992:	pop	{r3, r4, r5, r6, r7, pc}

00003994 <lfnGetChar(DirLfn_t*, unsigned char)>:
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \return The 16-bit character.
 */
static uint16_t lfnGetChar(DirLfn_t *ldir, uint8_t i) {
  if (i < 5) {
    3994:	cmp	r1, #4
    3996:	bls.n	39b2 <lfnGetChar(DirLfn_t*, unsigned char)+0x1e>
    return getLe16(ldir->unicode1 + 2*i);
  } else if (i < 11) {
    3998:	cmp	r1, #10
    399a:	bls.n	39aa <lfnGetChar(DirLfn_t*, unsigned char)+0x16>
    return getLe16(ldir->unicode2 + 2*i - 10);
  } else if (i < 13) {
    399c:	cmp	r1, #12
void lbaToMbrChs(uint8_t* chs, uint32_t capacityMB, uint32_t lba);
//-----------------------------------------------------------------------------
#if !defined(USE_SIMPLE_LITTLE_ENDIAN) || USE_SIMPLE_LITTLE_ENDIAN
// assumes CPU is little-endian and handles alignment issues.
inline uint16_t getLe16(const uint8_t* src) {
  return *reinterpret_cast<const uint16_t*>(src);
    399e:	itte	ls
    39a0:	addls.w	r1, r0, r1, lsl #1
    39a4:	ldrhls	r0, [r1, #6]
    return getLe16(ldir->unicode3 + 2*i - 22);
  }
  return 0;
    39a6:	movhi	r0, #0
}
    39a8:	bx	lr
    39aa:	add.w	r1, r0, r1, lsl #1
    39ae:	ldrh	r0, [r1, #4]
 */
static uint16_t lfnGetChar(DirLfn_t *ldir, uint8_t i) {
  if (i < 5) {
    return getLe16(ldir->unicode1 + 2*i);
  } else if (i < 11) {
    return getLe16(ldir->unicode2 + 2*i - 10);
    39b0:	bx	lr
    39b2:	add.w	r1, r0, r1, lsl #1
    39b6:	ldrh.w	r0, [r1, #1]
 * \param[in] i Index of character.
 * \return The 16-bit character.
 */
static uint16_t lfnGetChar(DirLfn_t *ldir, uint8_t i) {
  if (i < 5) {
    return getLe16(ldir->unicode1 + 2*i);
    39ba:	bx	lr

000039bc <dbgPrint(unsigned short)>:
#if USE_DBG_MACROS
#include "Arduino.h"
#ifndef DBG_FILE
#error DBG_FILE not defined
#endif  // DBG_FILE
static void dbgPrint(uint16_t line) {
    39bc:	push	{r3, r4, r5, lr}
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    39be:	movs	r1, #10
    39c0:	mov	r5, r0
    39c2:	ldr	r0, [pc, #40]	; (39ec <dbgPrint(unsigned short)+0x30>)
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    39c4:	ldr	r4, [pc, #40]	; (39f0 <dbgPrint(unsigned short)+0x34>)
    39c6:	bl	8e24 <usb_serial_write>
    39ca:	movs	r1, #14
    39cc:	ldr	r0, [pc, #36]	; (39f4 <dbgPrint(unsigned short)+0x38>)
    39ce:	bl	8e24 <usb_serial_write>
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    39d2:	movs	r0, #46	; 0x2e
    39d4:	bl	8f2c <usb_serial_putchar>
    39d8:	mov	r1, r5
    39da:	mov	r0, r4
    39dc:	bl	ae20 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    39e0:	mov	r0, r4
  Serial.print(F("DBG_FAIL: "));
  Serial.print(F(DBG_FILE));
  Serial.write('.');
  Serial.println(line);
}
    39e2:	ldmia.w	sp!, {r3, r4, r5, lr}
    39e6:	b.w	ad80 <Print::println()>
    39ea:	nop
    39ec:	.word	0x0000c270
    39f0:	.word	0x1fff099c
    39f4:	.word	0x0000c2dc

000039f8 <FatFile::lfnChecksum(unsigned char*)>:
#include "../common/DebugMacros.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
    39f8:	push	{r4}
    39fa:	subs	r2, r0, #1
    39fc:	add.w	r4, r0, #10
  uint8_t sum = 0;
    3a00:	movs	r0, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    3a02:	ldrb.w	r1, [r2, #1]!
    3a06:	lsrs	r3, r0, #1
    3a08:	orr.w	r0, r3, r0, lsl #7
    3a0c:	uxtab	r0, r1, r0
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    3a10:	cmp	r4, r2
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    3a12:	uxtb	r0, r0
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    3a14:	bne.n	3a02 <FatFile::lfnChecksum(unsigned char*)+0xa>
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
  }
  return sum;
}
    3a16:	ldr.w	r4, [sp], #4
    3a1a:	bx	lr

00003a1c <FatFile::openCluster(FatFile*)>:
fail:
  name[0] = 0;
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
    3a1c:	push	{r3, r4, r5, lr}
  if (file->m_dirCluster == 0) {
    3a1e:	ldr	r3, [r1, #12]
    3a20:	cbz	r3, 3a40 <FatFile::openCluster(FatFile*)+0x24>
    3a22:	mov	r5, r0
    3a24:	mov	r4, r1
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
    3a26:	movs	r2, #36	; 0x24
    3a28:	movs	r1, #0
    3a2a:	bl	bb7c <memset>
  m_attributes = FILE_ATTR_SUBDIR;
    3a2e:	movs	r3, #16
  m_flags = FILE_FLAG_READ;
    3a30:	movs	r0, #1
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
    3a32:	strb	r3, [r5, #0]
  m_flags = FILE_FLAG_READ;
    3a34:	strb	r0, [r5, #2]
  m_vol = file->m_vol;
    3a36:	ldr	r2, [r4, #8]
  m_firstCluster = file->m_dirCluster;
    3a38:	ldr	r3, [r4, #12]
    3a3a:	str	r3, [r5, #32]
    return openRoot(file->m_vol);
  }
  memset(this, 0, sizeof(FatFile));
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
    3a3c:	str	r2, [r5, #8]
  m_firstCluster = file->m_dirCluster;
  return true;
}
    3a3e:	pop	{r3, r4, r5, pc}
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    3a40:	ldr	r1, [r1, #8]
  m_attributes = FILE_ATTR_SUBDIR;
  m_flags = FILE_FLAG_READ;
  m_vol = file->m_vol;
  m_firstCluster = file->m_dirCluster;
  return true;
}
    3a42:	ldmia.w	sp!, {r3, r4, r5, lr}
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::openCluster(FatFile* file) {
  if (file->m_dirCluster == 0) {
    return openRoot(file->m_vol);
    3a46:	b.w	2658 <FatFile::openRoot(FatVolume*)>
    3a4a:	nop

00003a4c <FatFile::getName(char*, unsigned int)>:
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    lfnPutChar(ldir, i, c);
  }
}
//==============================================================================
bool FatFile::getName(char* name, size_t size) {
    3a4c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3a50:	sub	sp, #52	; 0x34
  FatFile dirFile;
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    3a52:	ldrb	r3, [r0, #0]
    3a54:	movs	r4, #0
    3a56:	strb.w	r4, [sp, #12]
    3a5a:	strb.w	r4, [sp, #13]
    3a5e:	strb.w	r4, [sp, #14]
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    lfnPutChar(ldir, i, c);
  }
}
//==============================================================================
bool FatFile::getName(char* name, size_t size) {
    3a62:	mov	r9, r1
  FatFile dirFile;
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    3a64:	cbz	r3, 3a6c <FatFile::getName(char*, unsigned int)+0x20>
    3a66:	cmp	r2, #12
    3a68:	mov	r5, r2
    3a6a:	bhi.n	3a80 <FatFile::getName(char*, unsigned int)+0x34>
    DBG_FAIL_MACRO;
    3a6c:	movs	r0, #129	; 0x81
    3a6e:	bl	39bc <dbgPrint(unsigned short)>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

fail:
  name[0] = 0;
    3a72:	movs	r7, #0
    3a74:	strb.w	r7, [r9]
  return false;
}
    3a78:	mov	r0, r7
    3a7a:	add	sp, #52	; 0x34
    3a7c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  DirLfn_t* ldir;
  if (!isOpen() || size < 13) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    3a80:	ldrb	r3, [r0, #3]
    3a82:	mov	r8, r0
    3a84:	cmp	r3, #0
    3a86:	beq.n	3b46 <FatFile::getName(char*, unsigned int)+0xfa>
    return getSFN(name);
  }
  if (!dirFile.openCluster(this)) {
    3a88:	add	r0, sp, #12
    3a8a:	mov	r1, r8
    3a8c:	bl	3a1c <FatFile::openCluster(FatFile*)>
    3a90:	cmp	r0, #0
    3a92:	beq.n	3b58 <FatFile::getName(char*, unsigned int)+0x10c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    3a94:	ldrb.w	r3, [r8, #3]
    3a98:	cmp	r3, #0
    3a9a:	beq.n	3b3e <FatFile::getName(char*, unsigned int)+0xf2>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    3a9c:	str	r4, [sp, #4]
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    3a9e:	movs	r6, #1
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    3aa0:	ldrh.w	r1, [r8, #4]
    3aa4:	subs	r1, r1, r6
    3aa6:	lsls	r1, r1, #5
    3aa8:	add	r0, sp, #12
    3aaa:	bl	2a14 <FatFile::seekSet(unsigned long)>
    3aae:	mov	r7, r0
    3ab0:	cmp	r0, #0
    3ab2:	beq.n	3b60 <FatFile::getName(char*, unsigned int)+0x114>
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    3ab4:	movs	r1, #0
    3ab6:	add	r0, sp, #12
    3ab8:	bl	29c4 <FatFile::readDirCache(bool)>
    if (!ldir) {
    3abc:	mov	sl, r0
    3abe:	cmp	r0, #0
    3ac0:	beq.n	3b68 <FatFile::getName(char*, unsigned int)+0x11c>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME) {
    3ac2:	ldrb	r3, [r0, #11]
    3ac4:	cmp	r3, #15
    3ac6:	bne.n	3b70 <FatFile::getName(char*, unsigned int)+0x124>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (order != (ldir->order & 0X1F)) {
    3ac8:	ldrb	r3, [r0, #0]
    3aca:	and.w	r3, r3, #31
    3ace:	cmp	r6, r3
    3ad0:	bne.n	3b78 <FatFile::getName(char*, unsigned int)+0x12c>
  return 0;
}
//------------------------------------------------------------------------------
static bool lfnGetName(DirLfn_t *ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
    3ad2:	subs	r3, r6, #1
    3ad4:	add.w	r2, r3, r3, lsl #1
    3ad8:	add.w	r2, r3, r2, lsl #2
    3adc:	mov	r3, r2
    3ade:	add.w	r4, r9, r2
    3ae2:	add.w	fp, r2, #13
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    3ae6:	subs	r1, r3, r2
    3ae8:	uxtb	r1, r1
    3aea:	mov	r0, sl
    3aec:	bl	3994 <lfnGetChar(DirLfn_t*, unsigned char)>
    if (c == 0 || k >= n) {
    3af0:	cbz	r0, 3b54 <FatFile::getName(char*, unsigned int)+0x108>
    3af2:	cmp	r5, r3
      break;
    }
    name[k++] = c >= 0X7F ? '?' : c;
    3af4:	add.w	r3, r3, #1
static bool lfnGetName(DirLfn_t *ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= n) {
    3af8:	bls.n	3b1e <FatFile::getName(char*, unsigned int)+0xd2>
      break;
    }
    name[k++] = c >= 0X7F ? '?' : c;
    3afa:	cmp	r0, #126	; 0x7e
    3afc:	ite	ls
    3afe:	uxtbls	r0, r0
    3b00:	movhi	r0, #63	; 0x3f
}
//------------------------------------------------------------------------------
static bool lfnGetName(DirLfn_t *ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (i = 0; i < 13; i++) {
    3b02:	cmp	r3, fp
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= n) {
      break;
    }
    name[k++] = c >= 0X7F ? '?' : c;
    3b04:	strb.w	r0, [r4], #1
}
//------------------------------------------------------------------------------
static bool lfnGetName(DirLfn_t *ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (i = 0; i < 13; i++) {
    3b08:	bne.n	3ae6 <FatFile::getName(char*, unsigned int)+0x9a>
      break;
    }
    name[k++] = c >= 0X7F ? '?' : c;
  }
  // Terminate with zero byte if name fits.
  if (k < n && (ldir->order & FAT_ORDER_LAST_LONG_ENTRY)) {
    3b0a:	cmp	r5, fp
    3b0c:	bls.n	3b1e <FatFile::getName(char*, unsigned int)+0xd2>
    3b0e:	ldrb.w	r3, [sl]
    3b12:	lsls	r2, r3, #25
    name[k] = 0;
    3b14:	itt	mi
    3b16:	ldrbmi.w	r3, [sp, #4]
    3b1a:	strbmi.w	r3, [r9, fp]
  }
  // Truncate if name is too long.
  name[n - 1] = 0;
    3b1e:	add.w	r3, r9, r5
    3b22:	ldrb.w	r2, [sp, #4]
    3b26:	strb.w	r2, [r3, #-1]
    }
    if (!lfnGetName(ldir, name, size)) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
    3b2a:	ldrb.w	r3, [sl]
    3b2e:	lsls	r3, r3, #25
    3b30:	bmi.n	3a78 <FatFile::getName(char*, unsigned int)+0x2c>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    3b32:	adds	r6, #1
    3b34:	ldrb.w	r3, [r8, #3]
    3b38:	uxtb	r6, r6
    3b3a:	cmp	r3, r6
    3b3c:	bcs.n	3aa0 <FatFile::getName(char*, unsigned int)+0x54>
    if (ldir->order & FAT_ORDER_LAST_LONG_ENTRY) {
      return true;
    }
  }
  // Fall into fail.
  DBG_FAIL_MACRO;
    3b3e:	movs	r0, #166	; 0xa6
    3b40:	bl	39bc <dbgPrint(unsigned short)>
    3b44:	b.n	3a72 <FatFile::getName(char*, unsigned int)+0x26>
  if (!isOpen() || size < 13) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    return getSFN(name);
    3b46:	bl	4504 <FatFile::getSFN(char*)>
    3b4a:	mov	r7, r0
  DBG_FAIL_MACRO;

fail:
  name[0] = 0;
  return false;
}
    3b4c:	mov	r0, r7
    3b4e:	add	sp, #52	; 0x34
    3b50:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
static bool lfnGetName(DirLfn_t *ldir, char* name, size_t n) {
  uint8_t i;
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (i = 0; i < 13; i++) {
    uint16_t c = lfnGetChar(ldir, i);
    if (c == 0 || k >= n) {
    3b54:	mov	fp, r3
    3b56:	b.n	3b0a <FatFile::getName(char*, unsigned int)+0xbe>
  }
  if (!isLFN()) {
    return getSFN(name);
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    3b58:	movs	r0, #136	; 0x88
    3b5a:	bl	39bc <dbgPrint(unsigned short)>
    goto fail;
    3b5e:	b.n	3a72 <FatFile::getName(char*, unsigned int)+0x26>
  }
  for (uint8_t order = 1; order <= m_lfnOrd; order++) {
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
    3b60:	movs	r0, #141	; 0x8d
    3b62:	bl	39bc <dbgPrint(unsigned short)>
      goto fail;
    3b66:	b.n	3a72 <FatFile::getName(char*, unsigned int)+0x26>
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
    3b68:	movs	r0, #146	; 0x92
    3b6a:	bl	39bc <dbgPrint(unsigned short)>
      goto fail;
    3b6e:	b.n	3a72 <FatFile::getName(char*, unsigned int)+0x26>
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME) {
      DBG_FAIL_MACRO;
    3b70:	movs	r0, #150	; 0x96
    3b72:	bl	39bc <dbgPrint(unsigned short)>
      goto fail;
    3b76:	b.n	3a72 <FatFile::getName(char*, unsigned int)+0x26>
    }
    if (order != (ldir->order & 0X1F)) {
      DBG_FAIL_MACRO;
    3b78:	movs	r0, #154	; 0x9a
    3b7a:	bl	39bc <dbgPrint(unsigned short)>
      goto fail;
    3b7e:	b.n	3a72 <FatFile::getName(char*, unsigned int)+0x26>

00003b80 <FatFile::parsePathName(char const*, fname_t*, char const**)>:
  m_firstCluster = file->m_dirCluster;
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::parsePathName(const char* path,
                            fname_t* fname, const char** ptr) {
    3b80:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int len = 0;
  int si;
  int dot;

  // Skip leading spaces.
  while (*path == ' ') {
    3b84:	ldrb	r3, [r0, #0]
    3b86:	cmp	r3, #32
    3b88:	bne.n	3b92 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x12>
    3b8a:	ldrb.w	r3, [r0, #1]!
    3b8e:	cmp	r3, #32
    3b90:	beq.n	3b8a <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa>
    path++;
  }
  fname->lfn = path;
    3b92:	str	r0, [r1, #8]

  for (len = 0; ; len++) {
    c = path[len];
    3b94:	ldrb	r3, [r0, #0]
    if (c == 0 || isDirSeparator(c)) {
    3b96:	cmp	r3, #0
    3b98:	beq.w	3daa <FatFile::parsePathName(char const*, fname_t*, char const**)+0x22a>
    3b9c:	cmp	r3, #47	; 0x2f
    3b9e:	beq.n	3c00 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x80>
  name[n - 1] = 0;
  return true;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(char c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    3ba0:	cmp	r3, #92	; 0x5c
    3ba2:	beq.n	3bea <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    3ba4:	sub.w	r4, r3, #34	; 0x22
    3ba8:	uxtb	r4, r4
    3baa:	cmp	r4, #29
    3bac:	bls.n	3bf0 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x70>
    3bae:	ldr.w	lr, [pc, #536]	; 3dc8 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x248>
    3bb2:	adds	r6, r0, #1
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    3bb4:	movs	r4, #0
  return true;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(char c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    3bb6:	cmp	r3, #124	; 0x7c
  for (len = 0; ; len++) {
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    3bb8:	sub.w	r5, r3, #32
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    3bbc:	mov	r7, r6
  return true;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(char c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
      c == ':' || c == '<' || c == '>' || c == '?' || c == '|') {
    3bbe:	beq.n	3bea <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
  for (len = 0; ; len++) {
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
    3bc0:	cmp	r5, #94	; 0x5e
    3bc2:	bhi.n	3bea <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    c = path[len];
    3bc4:	ldrb.w	r3, [r6], #1
  name[n - 1] = 0;
  return true;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(char c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    3bc8:	sub.w	r5, r3, #34	; 0x22
    3bcc:	uxtb	r5, r5
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    3bce:	adds	r4, #1
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
    3bd0:	cmp	r3, #0
    3bd2:	beq.w	3d7c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1fc>
    3bd6:	cmp	r3, #47	; 0x2f
    3bd8:	beq.n	3c02 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x82>
  name[n - 1] = 0;
  return true;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(char c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    3bda:	cmp	r3, #92	; 0x5c
    3bdc:	lsr.w	r7, lr, r5
    3be0:	beq.n	3bea <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    3be2:	cmp	r5, #29
    3be4:	bhi.n	3bb6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x36>
    3be6:	lsls	r7, r7, #31
    3be8:	bpl.n	3bb6 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x36>
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
    3bea:	movs	r0, #0
    3bec:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  name[n - 1] = 0;
  return true;
}
//------------------------------------------------------------------------------
inline bool lfnLegalChar(char c) {
  if (c == '/' || c == '\\' || c == '"' || c == '*' ||
    3bf0:	ldr	r5, [pc, #468]	; (3dc8 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x248>)
    3bf2:	lsr.w	r4, r5, r4
    3bf6:	lsls	r4, r4, #31
    3bf8:	bpl.n	3bae <FatFile::parsePathName(char const*, fname_t*, char const**)+0x2e>
    c = path[len];
    if (c == 0 || isDirSeparator(c)) {
      break;
    }
    if (!lfnLegalChar(c)) {
      return false;
    3bfa:	movs	r0, #0
    3bfc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while (*path == ' ') {
    path++;
  }
  fname->lfn = path;

  for (len = 0; ; len++) {
    3c00:	movs	r4, #0
    3c02:	adds	r7, r0, r4
    3c04:	mov	r6, r7
    3c06:	mov	r5, r4
    3c08:	movs	r3, #47	; 0x2f
    3c0a:	b.n	3c12 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x92>
    3c0c:	ldrb.w	r3, [r6, #1]!
    if (!lfnLegalChar(c)) {
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
    3c10:	adds	r5, #1
    3c12:	cmp	r3, #32
    3c14:	beq.n	3c0c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x8c>
    3c16:	cmp	r3, #47	; 0x2f
    3c18:	beq.n	3c0c <FatFile::parsePathName(char const*, fname_t*, char const**)+0x8c>
  *ptr = &path[end];
    3c1a:	add	r5, r0
    3c1c:	str	r5, [r2, #0]

  // Back over spaces and dots.
  while (len) {
    3c1e:	cbz	r4, 3c34 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xb4>
    3c20:	mov	r2, r7
    c = path[len - 1];
    3c22:	ldrb.w	r3, [r2, #-1]!
    if (c != '.' && c != ' ') {
    3c26:	cmp	r3, #46	; 0x2e
    3c28:	beq.n	3c30 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xb0>
    3c2a:	cmp	r3, #32
    3c2c:	bne.w	3d82 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x202>
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
    3c30:	subs	r4, #1
    3c32:	bne.n	3c22 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa2>
    3c34:	mov.w	r5, #4294967295
    3c38:	mov	r3, r4
  }
  // Max length of LFN is 255.
  if (len > 255) {
    return false;
  }
  fname->len = len;
    3c3a:	str	r3, [r1, #4]
    3c3c:	add.w	r6, r1, #23
    3c40:	add.w	r3, r1, #12
  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    fname->sfn[k] = ' ';
    3c44:	movs	r2, #32
    3c46:	strb.w	r2, [r3, #1]!
  if (len > 255) {
    return false;
  }
  fname->len = len;
  // Blank file short name.
  for (uint8_t k = 0; k < 11; k++) {
    3c4a:	cmp	r3, r6
    3c4c:	bne.n	3c46 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xc6>
    3c4e:	subs	r6, r0, #1
    3c50:	movs	r2, #0
    3c52:	b.n	3c56 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd6>
    fname->sfn[k] = ' ';
  }
  // skip leading spaces and dots.
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
    3c54:	adds	r2, #1
    3c56:	ldrb.w	r3, [r6, #1]!
    3c5a:	cmp	r3, #46	; 0x2e
    3c5c:	beq.n	3c54 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd4>
    3c5e:	cmp	r3, #32
    3c60:	beq.n	3c54 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xd4>
  // Not 8.3 if leading dot or space.
  is83 = !si;
    3c62:	clz	ip, r2

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
    3c66:	adds	r6, r5, #1
    fname->sfn[k] = ' ';
  }
  // skip leading spaces and dots.
  for (si = 0; path[si] == '.' || path[si] == ' '; si++) {}
  // Not 8.3 if leading dot or space.
  is83 = !si;
    3c68:	mov.w	ip, ip, lsr #5

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
    3c6c:	beq.n	3c88 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    3c6e:	ldrb	r7, [r0, r5]
    3c70:	cmp	r7, #46	; 0x2e
    3c72:	add.w	r6, r0, r5
    3c76:	bne.n	3c82 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x102>
    3c78:	b.n	3c88 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    3c7a:	ldrb.w	r7, [r6, #-1]!
    3c7e:	cmp	r7, #46	; 0x2e
    3c80:	beq.n	3c88 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x108>
    3c82:	adds.w	r5, r5, #4294967295
    3c86:	bcs.n	3c7a <FatFile::parsePathName(char const*, fname_t*, char const**)+0xfa>
  for (; si < len; si++) {
    3c88:	cmp	r2, r4
    3c8a:	mov.w	r9, #0
    3c8e:	bge.w	3db4 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x234>
    3c92:	mov	r6, r9
    3c94:	mov	sl, r9
    3c96:	movs	r7, #7
    3c98:	mov.w	r8, #8
    3c9c:	b.n	3cea <FatFile::parsePathName(char const*, fname_t*, char const**)+0x16a>
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    3c9e:	cmp	r3, #46	; 0x2e
    3ca0:	beq.n	3d32 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b2>
  /** Check for a legal 8.3 character.
   * \param[in] c Character to be checked.
   * \return true for a legal 8.3 character.
   */
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
    3ca2:	cmp	r3, #34	; 0x22
    3ca4:	beq.n	3cbe <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    3ca6:	cmp	r3, #124	; 0x7c
    3ca8:	beq.n	3cbe <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    3caa:	sub.w	lr, r3, #42	; 0x2a
    3cae:	cmp.w	lr, #5
    3cb2:	bls.n	3d46 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1c6>
      return false;
    }
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
    3cb4:	sub.w	lr, r3, #58	; 0x3a
    3cb8:	cmp.w	lr, #5
    3cbc:	bhi.n	3d70 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1f0>
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
    3cbe:	cmp	r5, r2
    3cc0:	beq.n	3d36 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b6>
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
    3cc2:	cmp	r7, r6
    3cc4:	bcc.n	3d1a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x19a>
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
      is83 = false;
    3cc6:	mov.w	ip, #0
      c = '_';
    3cca:	movs	r3, #95	; 0x5f
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    3ccc:	add.w	lr, r6, #1
    3cd0:	add.w	fp, r1, r6
    3cd4:	uxtb.w	r6, lr
      if (i < 7) {
    3cd8:	cmp	r6, #6
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
        uc |= bit;
      }
      fname->sfn[i++] = c;
    3cda:	strb.w	r3, [fp, #13]
      if (i < 7) {
    3cde:	bhi.n	3ce2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>
        fname->seqPos = i;
    3ce0:	strb	r6, [r1, #12]
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    3ce2:	adds	r2, #1
    3ce4:	cmp	r2, r4
    3ce6:	bge.n	3cf8 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x178>
    3ce8:	ldrb	r3, [r0, r2]
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    3cea:	cmp	r3, #32
    3cec:	bne.n	3c9e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x11e>
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    3cee:	adds	r2, #1
    3cf0:	cmp	r2, r4
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
    3cf2:	mov.w	ip, #0
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    3cf6:	blt.n	3ce8 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x168>
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    3cf8:	ldrb	r3, [r1, #13]
    3cfa:	cmp	r3, #32
    3cfc:	beq.w	3bea <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    return false;
  }

  if (is83) {
    3d00:	cmp.w	ip, #0
    3d04:	beq.n	3d96 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x216>
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
    3d06:	tst.w	sl, r9
    3d0a:	it	ne
    3d0c:	movne.w	r9, #2
    3d10:	strb.w	r9, [r1]
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
    3d14:	movs	r0, #1
    3d16:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
    3d1a:	cmp	r7, #10
    3d1c:	beq.n	3d8e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
      }
      if (si != dot) {
        is83 = false;
      }
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
    3d1e:	cmp	r5, r2
    3d20:	blt.n	3d8e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
    3d22:	mov	r2, r5
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
    3d24:	movs	r7, #10
      i = 8;    // Place for extension.
    3d26:	movs	r6, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    3d28:	mov.w	r8, #16
        // Done - extension longer than three characters.
        is83 = false;
        break;
      }
      if (si != dot) {
        is83 = false;
    3d2c:	mov.w	ip, #0
    3d30:	b.n	3ce2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
    3d32:	cmp	r5, r2
    3d34:	bne.n	3cee <FatFile::parsePathName(char const*, fname_t*, char const**)+0x16e>
    if (!legal83Char(c) && si != dot) {
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
      if (in == 10) {
    3d36:	cmp	r7, #10
    3d38:	beq.n	3d8e <FatFile::parsePathName(char const*, fname_t*, char const**)+0x20e>
    3d3a:	mov	r2, r5
      // Break if no dot and base-name is longer than eight characters.
      if (si > dot) {
        break;
      }
      si = dot;
      in = 10;  // Max index for full 8.3 name.
    3d3c:	movs	r7, #10
      i = 8;    // Place for extension.
    3d3e:	movs	r6, #8
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    3d40:	mov.w	r8, #16
    3d44:	b.n	3ce2 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x162>
  static bool legal83Char(uint8_t c) {
    if (c == '"' || c == '|') {
      return false;
    }
    // *+,./
    if (0X2A <= c && c <= 0X2F && c != 0X2D) {
    3d46:	cmp	r3, #45	; 0x2d
    3d48:	bne.n	3cbe <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    c = path[si];
    if (c == ' ' || (c == '.' && dot != si)) {
      is83 = false;
      continue;
    }
    if (!legal83Char(c) && si != dot) {
    3d4a:	sub.w	lr, r3, #33	; 0x21
    3d4e:	cmp.w	lr, #93	; 0x5d
    3d52:	bhi.n	3cbe <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
      is83 = false;
      c = '_';
    }
    if (si == dot || i > in) {
    3d54:	cmp	r5, r2
    3d56:	beq.n	3d36 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1b6>
    3d58:	cmp	r7, r6
    3d5a:	bcc.n	3d1a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x19a>
      si = dot;
      in = 10;  // Max index for full 8.3 name.
      i = 8;    // Place for extension.
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
    3d5c:	sub.w	lr, r3, #97	; 0x61
    3d60:	cmp.w	lr, #25
    3d64:	bhi.n	3db8 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x238>
        c += 'A' - 'a';
    3d66:	subs	r3, #32
    3d68:	uxtb	r3, r3
        lc |= bit;
    3d6a:	orr.w	r9, r8, r9
    3d6e:	b.n	3ccc <FatFile::parsePathName(char const*, fname_t*, char const**)+0x14c>
    // :;<=>?
    if (0X3A <= c && c <= 0X3F) {
      return false;
    }
    // [\]
    if (0X5B <= c && c <= 0X5D) {
    3d70:	sub.w	lr, r3, #91	; 0x5b
    3d74:	cmp.w	lr, #2
    3d78:	bls.n	3cbe <FatFile::parsePathName(char const*, fname_t*, char const**)+0x13e>
    3d7a:	b.n	3d4a <FatFile::parsePathName(char const*, fname_t*, char const**)+0x1ca>
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    3d7c:	str	r7, [r2, #0]
    3d7e:	adds	r7, r0, r4
    3d80:	b.n	3c20 <FatFile::parsePathName(char const*, fname_t*, char const**)+0xa0>
      break;
    }
    len--;
  }
  // Max length of LFN is 255.
  if (len > 255) {
    3d82:	cmp	r4, #255	; 0xff
    3d84:	bgt.w	3bea <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>
    3d88:	subs	r5, r4, #1
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];

  // Back over spaces and dots.
  while (len) {
    c = path[len - 1];
    3d8a:	mov	r3, r4
    3d8c:	b.n	3c3a <FatFile::parsePathName(char const*, fname_t*, char const**)+0xba>
      if (i < 7) {
        fname->seqPos = i;
      }
    }
  }
  if (fname->sfn[0] == ' ') {
    3d8e:	ldrb	r3, [r1, #13]
    3d90:	cmp	r3, #32
    3d92:	beq.w	3bea <FatFile::parsePathName(char const*, fname_t*, char const**)+0x6a>

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    fname->sfn[fname->seqPos] = '~';
    3d96:	ldrb	r3, [r1, #12]
    3d98:	add	r3, r1
  }

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    3d9a:	movs	r0, #1
    fname->sfn[fname->seqPos] = '~';
    3d9c:	movs	r4, #126	; 0x7e
    fname->sfn[fname->seqPos + 1] = '1';
    3d9e:	movs	r2, #49	; 0x31
  }

  if (is83) {
    fname->flags = lc & uc ? FNAME_FLAG_MIXED_CASE : lc;
  } else {
    fname->flags = FNAME_FLAG_LOST_CHARS;
    3da0:	strb	r0, [r1, #0]
    fname->sfn[fname->seqPos] = '~';
    3da2:	strb	r4, [r3, #13]
    fname->sfn[fname->seqPos + 1] = '1';
    3da4:	strb	r2, [r3, #14]
    3da6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return false;
    }
  }
  // Advance to next path component.
  for (end = len; path[end] ==  ' ' || isDirSeparator(path[end]); end++) {}
  *ptr = &path[end];
    3daa:	str	r0, [r2, #0]
    3dac:	mov	r4, r3
    3dae:	mov.w	r5, #4294967295
    3db2:	b.n	3c3a <FatFile::parsePathName(char const*, fname_t*, char const**)+0xba>
  // Not 8.3 if leading dot or space.
  is83 = !si;

  // find last dot.
  for (dot = len - 1; dot >= 0 && path[dot] != '.'; dot--) {}
  for (; si < len; si++) {
    3db4:	mov	sl, r9
    3db6:	b.n	3cf8 <FatFile::parsePathName(char const*, fname_t*, char const**)+0x178>
      bit = FAT_CASE_LC_EXT;  // bit for extension.
    } else {
      if ('a' <= c && c <= 'z') {
        c += 'A' - 'a';
        lc |= bit;
      } else if ('A' <= c && c <= 'Z') {
    3db8:	sub.w	lr, r3, #65	; 0x41
    3dbc:	cmp.w	lr, #25
        uc |= bit;
    3dc0:	it	ls
    3dc2:	orrls.w	sl, r8, sl
    3dc6:	b.n	3ccc <FatFile::parsePathName(char const*, fname_t*, char const**)+0x14c>
    3dc8:	.word	0x35000101

00003dcc <FatFile::remove()>:

fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    3dcc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    3dd0:	ldrb	r3, [r0, #2]

fail:
  return 0;
}
//------------------------------------------------------------------------------
bool FatFile::remove() {
    3dd2:	sub	sp, #40	; 0x28
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attributes(FILE_ATTR_CLOSED), m_error(0), m_flags(0) {}
    3dd4:	movs	r2, #0
  FatFile dirFile;
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    3dd6:	and.w	r3, r3, #2
    3dda:	strb.w	r2, [sp, #4]
    3dde:	strb.w	r2, [sp, #5]
    3de2:	strb.w	r2, [sp, #6]
    3de6:	cmp	r3, #0
    3de8:	beq.n	3e64 <FatFile::remove()+0x98>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    3dea:	ldr	r1, [r0, #32]
    3dec:	mov	r6, r0
    3dee:	cbnz	r1, 3e48 <FatFile::remove()+0x7c>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
    3df0:	movs	r1, #1
    3df2:	mov	r0, r6
    3df4:	bl	2568 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    3df8:	mov	r7, r0
    3dfa:	cmp	r0, #0
    3dfc:	beq.w	3f28 <FatFile::remove()+0x15c>
    3e00:	subs	r1, r7, #1
    3e02:	add.w	r0, r7, #10
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
    3e06:	movs	r4, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    3e08:	lsrs	r2, r4, #1
    3e0a:	ldrb.w	r5, [r1, #1]!
    3e0e:	orr.w	r3, r2, r4, lsl #7
    3e12:	uxtab	r3, r5, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    3e16:	cmp	r1, r0
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    3e18:	uxtb	r4, r3
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    3e1a:	bne.n	3e08 <FatFile::remove()+0x3c>
    goto fail;
  }
  checksum = lfnChecksum(dir->name);

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;
    3e1c:	mov.w	r8, #229	; 0xe5
    3e20:	strb.w	r8, [r7]
  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
  m_flags = 0;

  // Write entry to device.
  if (!m_vol->cacheSync()) {
    3e24:	ldr	r5, [r6, #8]

  // Mark entry deleted.
  dir->name[0] = FAT_NAME_DELETED;

  // Set this file closed.
  m_attributes = FILE_ATTR_CLOSED;
    3e26:	movs	r3, #0
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    return m_fatCache.read(sector,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    3e28:	add.w	r0, r5, #36	; 0x24
    3e2c:	strb	r3, [r6, #0]
  m_flags = 0;
    3e2e:	strb	r3, [r6, #2]
    3e30:	bl	3544 <FatCache::sync()>
    3e34:	cbnz	r0, 3e78 <FatFile::remove()+0xac>

  // Write entry to device.
  if (!m_vol->cacheSync()) {
    DBG_FAIL_MACRO;
    3e36:	movw	r0, #593	; 0x251
    3e3a:	bl	39bc <dbgPrint(unsigned short)>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

fail:
  return false;
    3e3e:	movs	r5, #0
}
    3e40:	mov	r0, r5
    3e42:	add	sp, #40	; 0x28
    3e44:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Free any clusters.
  if (m_firstCluster && !m_vol->freeChain(m_firstCluster)) {
    3e48:	ldr	r0, [r0, #8]
    3e4a:	bl	3734 <FatPartition::freeChain(unsigned long)>
    3e4e:	mov	r5, r0
    3e50:	cmp	r0, #0
    3e52:	bne.n	3df0 <FatFile::remove()+0x24>
    DBG_FAIL_MACRO;
    3e54:	movw	r0, #573	; 0x23d
    3e58:	bl	39bc <dbgPrint(unsigned short)>
  // Fall into fail.
  DBG_FAIL_MACRO;

fail:
  return false;
}
    3e5c:	mov	r0, r5
    3e5e:	add	sp, #40	; 0x28
    3e60:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  DirFat_t* dir;
  DirLfn_t* ldir;

  // Cant' remove not open for write.
  if (!isWritable()) {
    DBG_FAIL_MACRO;
    3e64:	mov.w	r0, #568	; 0x238
    3e68:	and.w	r5, r3, #255	; 0xff
    3e6c:	bl	39bc <dbgPrint(unsigned short)>
  // Fall into fail.
  DBG_FAIL_MACRO;

fail:
  return false;
}
    3e70:	mov	r0, r5
    3e72:	add	sp, #40	; 0x28
    3e74:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3e78:	add.w	r0, r5, #560	; 0x230
    3e7c:	bl	3544 <FatCache::sync()>
    3e80:	cmp	r0, #0
    3e82:	beq.n	3e36 <FatFile::remove()+0x6a>
    3e84:	ldr	r0, [r5, #0]
  // sector I/O functions.
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    3e86:	ldr	r3, [r0, #0]
    3e88:	ldr	r3, [r3, #20]
    3e8a:	blx	r3
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    return m_fatCache.read(sector,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    3e8c:	mov	r5, r0
    3e8e:	cmp	r0, #0
    3e90:	beq.n	3e36 <FatFile::remove()+0x6a>
  // Write entry to device.
  if (!m_vol->cacheSync()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (!isLFN()) {
    3e92:	ldrb	r3, [r6, #3]
    3e94:	cmp	r3, #0
    3e96:	beq.n	3e40 <FatFile::remove()+0x74>
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    3e98:	add	r0, sp, #4
    3e9a:	mov	r1, r6
    3e9c:	bl	3a1c <FatFile::openCluster(FatFile*)>
    3ea0:	mov	r3, r0
    3ea2:	cmp	r0, #0
    3ea4:	beq.n	3f1c <FatFile::remove()+0x150>
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (order = 1; order <= m_lfnOrd; order++) {
    3ea6:	ldrb	r3, [r6, #3]
    3ea8:	movs	r7, #1
    3eaa:	cbnz	r3, 3ef0 <FatFile::remove()+0x124>
    3eac:	b.n	3f34 <FatFile::remove()+0x168>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    3eae:	add	r0, sp, #4
    3eb0:	bl	29c4 <FatFile::readDirCache(bool)>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (order = 1; order <= m_lfnOrd; order++) {
    3eb4:	adds	r1, r7, #1
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
    3eb6:	mov	r3, r0
    3eb8:	cmp	r0, #0
    3eba:	beq.n	3f40 <FatFile::remove()+0x174>
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    3ebc:	ldrb	r2, [r0, #11]
    3ebe:	cmp	r2, #15
    3ec0:	bne.n	3f10 <FatFile::remove()+0x144>
        order != (ldir->order & 0X1F) ||
    3ec2:	ldrb	r2, [r0, #0]
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    3ec4:	and.w	r0, r2, #31
    3ec8:	cmp	r7, r0
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (order = 1; order <= m_lfnOrd; order++) {
    3eca:	uxtb	r7, r1
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
    3ecc:	bne.n	3f10 <FatFile::remove()+0x144>
        order != (ldir->order & 0X1F) ||
    3ece:	ldrb	r1, [r3, #13]
    3ed0:	cmp	r1, r4
    3ed2:	bne.n	3f10 <FatFile::remove()+0x144>
        checksum != ldir->checksum) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    3ed4:	strb.w	r8, [r3]
    m_vol->cacheDirty();
    3ed8:	ldr	r1, [r6, #8]
  cache_t* buffer() {
    return &m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    3eda:	ldrb.w	r3, [r1, #36]	; 0x24
    3ede:	orr.w	r3, r3, #1
    3ee2:	strb.w	r3, [r1, #36]	; 0x24
    if (last) {
    3ee6:	lsls	r3, r2, #25
    3ee8:	bmi.n	3f4c <FatFile::remove()+0x180>
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (order = 1; order <= m_lfnOrd; order++) {
    3eea:	ldrb	r3, [r6, #3]
    3eec:	cmp	r3, r7
    3eee:	bcc.n	3f34 <FatFile::remove()+0x168>
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    3ef0:	ldrh	r1, [r6, #4]
    3ef2:	subs	r1, r1, r7
    3ef4:	lsls	r1, r1, #5
    3ef6:	add	r0, sp, #4
    3ef8:	bl	2a14 <FatFile::seekSet(unsigned long)>
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    3efc:	movs	r1, #0
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (order = 1; order <= m_lfnOrd; order++) {
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
    3efe:	mov	r3, r0
    3f00:	cmp	r0, #0
    3f02:	bne.n	3eae <FatFile::remove()+0xe2>
      DBG_FAIL_MACRO;
    3f04:	movw	r0, #606	; 0x25e
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

fail:
  return false;
    3f08:	mov	r5, r3
    DBG_FAIL_MACRO;
    goto fail;
  }
  for (order = 1; order <= m_lfnOrd; order++) {
    if (!dirFile.seekSet(32UL*(m_dirIndex - order))) {
      DBG_FAIL_MACRO;
    3f0a:	bl	39bc <dbgPrint(unsigned short)>
      goto fail;
    3f0e:	b.n	3e40 <FatFile::remove()+0x74>
      goto fail;
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
        order != (ldir->order & 0X1F) ||
        checksum != ldir->checksum) {
      DBG_FAIL_MACRO;
    3f10:	movw	r0, #617	; 0x269
    3f14:	bl	39bc <dbgPrint(unsigned short)>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

fail:
  return false;
    3f18:	movs	r5, #0
    }
    if (ldir->attributes != FAT_ATTRIB_LONG_NAME ||
        order != (ldir->order & 0X1F) ||
        checksum != ldir->checksum) {
      DBG_FAIL_MACRO;
      goto fail;
    3f1a:	b.n	3e40 <FatFile::remove()+0x74>
  if (!isLFN()) {
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    3f1c:	movw	r0, #601	; 0x259
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

fail:
  return false;
    3f20:	mov	r5, r3
  if (!isLFN()) {
    // Done, no LFN entries.
    return true;
  }
  if (!dirFile.openCluster(this)) {
    DBG_FAIL_MACRO;
    3f22:	bl	39bc <dbgPrint(unsigned short)>
    goto fail;
    3f26:	b.n	3e40 <FatFile::remove()+0x74>
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
  if (!dir) {
    DBG_FAIL_MACRO;
    3f28:	movw	r0, #579	; 0x243
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

fail:
  return false;
    3f2c:	mov	r5, r7
    goto fail;
  }
  // Cache directory entry.
  dir = cacheDirEntry(FatCache::CACHE_FOR_WRITE);
  if (!dir) {
    DBG_FAIL_MACRO;
    3f2e:	bl	39bc <dbgPrint(unsigned short)>
    goto fail;
    3f32:	b.n	3e40 <FatFile::remove()+0x74>
      }
      return true;
    }
  }
  // Fall into fail.
  DBG_FAIL_MACRO;
    3f34:	mov.w	r0, #632	; 0x278
    3f38:	bl	39bc <dbgPrint(unsigned short)>

fail:
  return false;
    3f3c:	movs	r5, #0
    3f3e:	b.n	3e40 <FatFile::remove()+0x74>
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
    3f40:	movw	r0, #611	; 0x263
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

fail:
  return false;
    3f44:	mov	r5, r3
      DBG_FAIL_MACRO;
      goto fail;
    }
    ldir = reinterpret_cast<DirLfn_t*>(dirFile.readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
    3f46:	bl	39bc <dbgPrint(unsigned short)>
      goto fail;
    3f4a:	b.n	3e40 <FatFile::remove()+0x74>
    }
    last = ldir->order & FAT_ORDER_LAST_LONG_ENTRY;
    ldir->order = FAT_NAME_DELETED;
    m_vol->cacheDirty();
    if (last) {
      if (!m_vol->cacheSync()) {
    3f4c:	ldr	r4, [r6, #8]
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    return m_fatCache.read(sector,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    3f4e:	add.w	r0, r4, #36	; 0x24
    3f52:	bl	3544 <FatCache::sync()>
    3f56:	cbnz	r0, 3f64 <FatFile::remove()+0x198>
        DBG_FAIL_MACRO;
    3f58:	movw	r0, #625	; 0x271
    3f5c:	bl	39bc <dbgPrint(unsigned short)>
  }
  // Fall into fail.
  DBG_FAIL_MACRO;

fail:
  return false;
    3f60:	movs	r5, #0
    ldir->order = FAT_NAME_DELETED;
    m_vol->cacheDirty();
    if (last) {
      if (!m_vol->cacheSync()) {
        DBG_FAIL_MACRO;
        goto fail;
    3f62:	b.n	3e40 <FatFile::remove()+0x74>
    3f64:	add.w	r0, r4, #560	; 0x230
    3f68:	bl	3544 <FatCache::sync()>
    3f6c:	cmp	r0, #0
    3f6e:	beq.n	3f58 <FatFile::remove()+0x18c>
    3f70:	ldr	r0, [r4, #0]
  // sector I/O functions.
  bool readSector(uint32_t sector, uint8_t* dst) {
    return m_blockDev->readSector(sector, dst);
  }
  bool syncDevice() {
    return m_blockDev->syncDevice();
    3f72:	ldr	r3, [r0, #0]
    3f74:	ldr	r3, [r3, #20]
    3f76:	blx	r3
  cache_t* cacheFetchFat(uint32_t sector, uint8_t options) {
    return m_fatCache.read(sector,
                           options | FatCache::CACHE_STATUS_MIRROR_FAT);
  }
  bool cacheSync() {
    return m_cache.sync() && m_fatCache.sync() && syncDevice();
    3f78:	cmp	r0, #0
    3f7a:	beq.n	3f58 <FatFile::remove()+0x18c>
    3f7c:	b.n	3e40 <FatFile::remove()+0x74>
    3f7e:	nop

00003f80 <FatFile::lfnUniqueSfn(fname_t*)>:

fail:
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
    3f80:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
  DirFat_t *dir;
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
    3f84:	ldrb	r3, [r1, #0]
    3f86:	lsls	r2, r3, #31
    3f88:	bpl.n	4078 <FatFile::lfnUniqueSfn(fname_t*)+0xf8>
  return false;
}
//------------------------------------------------------------------------------
bool FatFile::lfnUniqueSfn(fname_t* fname) {
  const uint8_t FIRST_HASH_SEQ = 2;  // min value is 2
  uint8_t pos = fname->seqPos;;
    3f8a:	ldrb	r7, [r1, #12]
  DirFat_t *dir;
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');
    3f8c:	adds	r3, r1, r7
    3f8e:	mov	r5, r1
    3f90:	ldrb	r2, [r3, #13]
    3f92:	cmp	r2, #126	; 0x7e
    3f94:	mov	r8, r0
    3f96:	beq.n	3fc0 <FatFile::lfnUniqueSfn(fname_t*)+0x40>
    3f98:	ldrb	r3, [r3, #14]
    3f9a:	cmp	r3, #49	; 0x31
    3f9c:	beq.n	3fc0 <FatFile::lfnUniqueSfn(fname_t*)+0x40>
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    3f9e:	movs	r1, #9
    3fa0:	ldr	r0, [pc, #260]	; (40a8 <FatFile::lfnUniqueSfn(fname_t*)+0x128>)
    3fa2:	bl	8e24 <usb_serial_write>
    3fa6:	movs	r1, #79	; 0x4f
    3fa8:	ldr	r0, [pc, #256]	; (40ac <FatFile::lfnUniqueSfn(fname_t*)+0x12c>)
    3faa:	bl	8e24 <usb_serial_write>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    3fae:	movw	r1, #645	; 0x285
    3fb2:	ldr	r0, [pc, #252]	; (40b0 <FatFile::lfnUniqueSfn(fname_t*)+0x130>)
    3fb4:	bl	ae20 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    3fb8:	ldr	r0, [pc, #244]	; (40b0 <FatFile::lfnUniqueSfn(fname_t*)+0x130>)
    3fba:	bl	ad80 <Print::println()>
    3fbe:	b.n	3fbe <FatFile::lfnUniqueSfn(fname_t*)+0x3e>
    3fc0:	movs	r6, #2
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    3fc2:	add.w	r9, r5, #13
  for (uint8_t seq = 2; seq < 100; seq++) {
    if (seq < FIRST_HASH_SEQ) {
      fname->sfn[pos + 1] = '0' + seq;
    } else {
      DBG_PRINT_IF(seq > FIRST_HASH_SEQ);
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
    3fc6:	ldr	r1, [r5, #4]
    3fc8:	ldr	r2, [r5, #8]
    3fca:	adds	r3, r6, r1
    3fcc:	uxth	r3, r3
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    3fce:	cbz	r1, 3fe2 <FatFile::lfnUniqueSfn(fname_t*)+0x62>
    3fd0:	adds	r0, r2, r1
    // hash = hash * 33 ^ str[i];
    hash = ((hash << 5) + hash) ^ str[i];
    3fd2:	ldrb.w	r1, [r2], #1
    3fd6:	add.w	r3, r3, r3, lsl #5
    3fda:	eors	r3, r1
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    3fdc:	cmp	r0, r2
    // hash = hash * 33 ^ str[i];
    hash = ((hash << 5) + hash) ^ str[i];
    3fde:	uxth	r3, r3
}
//------------------------------------------------------------------------------
// Daniel Bernstein University of Illinois at Chicago.
// Original had + instead of ^
static uint16_t Bernstein(uint16_t hash, const char *str, size_t len) {
  for (size_t i = 0; i < len; i++) {
    3fe0:	bne.n	3fd2 <FatFile::lfnUniqueSfn(fname_t*)+0x52>
    3fe2:	cmp	r7, #3
    3fe4:	it	cs
    3fe6:	movcs	r7, #3
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    3fe8:	adds	r2, r7, #4
    3fea:	uxtb	r2, r2
        uint8_t h = hex & 0XF;
    3fec:	and.w	r1, r3, #15
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    3ff0:	adds	r0, r5, r2
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    3ff2:	subs	r2, #1
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    3ff4:	cmp	r1, #9
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    3ff6:	uxtb	r2, r2
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    3ff8:	ite	ls
    3ffa:	addls	r1, #48	; 0x30
    3ffc:	addhi	r1, #55	; 0x37
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    3ffe:	cmp	r2, r7
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
    4000:	mov.w	r3, r3, lsr #4
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
    4004:	strb	r1, [r0, #13]
      hex = Bernstein(seq + fname->len, fname->lfn, fname->len);
      if (pos > 3) {
        // Make space in name for ~HHHH.
        pos = 3;
      }
      for (uint8_t i = pos + 4 ; i > pos; i--) {
    4006:	bhi.n	3fec <FatFile::lfnUniqueSfn(fname_t*)+0x6c>
        uint8_t h = hex & 0XF;
        fname->sfn[i] = h < 10 ? h + '0' : h + 'A' - 10;
        hex >>= 4;
      }
    }
    fname->sfn[pos] = '~';
    4008:	adds	r3, r5, r7
    400a:	movs	r2, #126	; 0x7e
    400c:	strb	r2, [r3, #13]
   * \return true for success or false for failure.
   */
  bool remove(const char* path);
  /** Set the file's current position to zero. */
  void rewind() {
    seekSet(0);
    400e:	movs	r1, #0
    4010:	mov	r0, r8
    4012:	bl	2a14 <FatFile::seekSet(unsigned long)>
    rewind();
    while (1) {
      dir = readDirCache(true);
    4016:	movs	r1, #1
    4018:	mov	r0, r8
    401a:	bl	29c4 <FatFile::readDirCache(bool)>
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    401e:	movs	r2, #11
    }
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
    4020:	mov	r4, r0
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    4022:	mov	r1, r0
    }
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
    4024:	cbz	r0, 404e <FatFile::lfnUniqueSfn(fname_t*)+0xce>
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    4026:	ldrb	r3, [r4, #0]
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    4028:	mov	r0, r9
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    402a:	cbz	r3, 4054 <FatFile::lfnUniqueSfn(fname_t*)+0xd4>
        goto done;
      }
      if (isFileOrSubdir(dir) && !memcmp(fname->sfn, dir->name, 11)) {
    402c:	ldrb	r3, [r4, #11]
    402e:	lsls	r3, r3, #28
    4030:	bmi.n	4016 <FatFile::lfnUniqueSfn(fname_t*)+0x96>
    4032:	bl	bb18 <memcmp>
    4036:	mov	r4, r0
    4038:	cmp	r0, #0
    403a:	bne.n	4016 <FatFile::lfnUniqueSfn(fname_t*)+0x96>
  uint16_t hex;

  DBG_HALT_IF(!(fname->flags & FNAME_FLAG_LOST_CHARS));
  DBG_HALT_IF(fname->sfn[pos] != '~' && fname->sfn[pos + 1] != '1');

  for (uint8_t seq = 2; seq < 100; seq++) {
    403c:	cmp	r6, #99	; 0x63
    403e:	bne.n	405a <FatFile::lfnUniqueSfn(fname_t*)+0xda>
        break;
      }
    }
  }
  // fall inti fail - too many tries.
  DBG_FAIL_MACRO;
    4040:	movw	r0, #685	; 0x2ad
    4044:	bl	39bc <dbgPrint(unsigned short)>

fail:
  return false;
    4048:	mov	r0, r4
    404a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    fname->sfn[pos] = '~';
    rewind();
    while (1) {
      dir = readDirCache(true);
      if (!dir) {
        if (!getError()) {
    404e:	ldrb.w	r3, [r8, #1]
    4052:	cbnz	r3, 409a <FatFile::lfnUniqueSfn(fname_t*)+0x11a>

fail:
  return false;

done:
  return true;
    4054:	movs	r0, #1
    4056:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    405a:	movs	r1, #79	; 0x4f
    405c:	ldr	r0, [pc, #76]	; (40ac <FatFile::lfnUniqueSfn(fname_t*)+0x12c>)
    405e:	bl	8e24 <usb_serial_write>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    4062:	movw	r1, #651	; 0x28b
    4066:	ldr	r0, [pc, #72]	; (40b0 <FatFile::lfnUniqueSfn(fname_t*)+0x130>)
    4068:	bl	ae20 <Print::print(long)>
    406c:	adds	r6, #1
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    406e:	ldr	r0, [pc, #64]	; (40b0 <FatFile::lfnUniqueSfn(fname_t*)+0x130>)
    4070:	bl	ad80 <Print::println()>
    4074:	uxth	r6, r6
    4076:	b.n	3fc6 <FatFile::lfnUniqueSfn(fname_t*)+0x46>
    4078:	movs	r1, #9
    407a:	ldr	r0, [pc, #44]	; (40a8 <FatFile::lfnUniqueSfn(fname_t*)+0x128>)
    407c:	bl	8e24 <usb_serial_write>
    4080:	movs	r1, #79	; 0x4f
    4082:	ldr	r0, [pc, #40]	; (40ac <FatFile::lfnUniqueSfn(fname_t*)+0x12c>)
    4084:	bl	8e24 <usb_serial_write>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    4088:	mov.w	r1, #644	; 0x284
    408c:	ldr	r0, [pc, #32]	; (40b0 <FatFile::lfnUniqueSfn(fname_t*)+0x130>)
    408e:	bl	ae20 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    4092:	ldr	r0, [pc, #28]	; (40b0 <FatFile::lfnUniqueSfn(fname_t*)+0x130>)
    4094:	bl	ad80 <Print::println()>
    4098:	b.n	4098 <FatFile::lfnUniqueSfn(fname_t*)+0x118>
      if (!dir) {
        if (!getError()) {
          // At EOF and name not found if no error.
          goto done;
        }
        DBG_FAIL_MACRO;
    409a:	mov.w	r0, #672	; 0x2a0
    409e:	bl	39bc <dbgPrint(unsigned short)>
  }
  // fall inti fail - too many tries.
  DBG_FAIL_MACRO;

fail:
  return false;
    40a2:	mov	r0, r4
        if (!getError()) {
          // At EOF and name not found if no error.
          goto done;
        }
        DBG_FAIL_MACRO;
        goto fail;
    40a4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    40a8:	.word	0x0000c2ec
    40ac:	.word	0x0000c2f8
    40b0:	.word	0x1fff099c

000040b4 <FatFile::open(FatFile*, fname_t*, int)>:
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
    40b4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    40b8:	mov	r6, r1
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
    40ba:	ldrb	r1, [r1, #0]
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
    40bc:	sub	sp, #52	; 0x34
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
    40be:	tst.w	r1, #112	; 0x70
    fname->sfn[fname->seqPos + 1] = '1';
  }
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
    40c2:	str	r0, [sp, #32]
    40c4:	str	r3, [sp, #24]
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;

  if (!dirFile->isDir() || isOpen()) {
    40c6:	beq.n	40cc <FatFile::open(FatFile*, fname_t*, int)+0x18>
    40c8:	ldrb	r3, [r0, #0]
    40ca:	cbz	r3, 40de <FatFile::open(FatFile*, fname_t*, int)+0x2a>
    DBG_FAIL_MACRO;
    40cc:	movw	r0, #313	; 0x139
    40d0:	bl	39bc <dbgPrint(unsigned short)>
    goto fail;
  }
  return true;

fail:
  return false;
    40d4:	movs	r5, #0
}
    40d6:	mov	r0, r5
    40d8:	add	sp, #52	; 0x34
    40da:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    40de:	ldrb	r3, [r2, #0]
  uint16_t curIndex;
  uint16_t date;
  uint16_t time;
  DirFat_t* dir;
  DirLfn_t* ldir;
  size_t len = fname->len;
    40e0:	ldr.w	r8, [r2, #4]
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    40e4:	lsls	r3, r3, #30
    40e6:	mov	fp, r2
    40e8:	bne.n	416c <FatFile::open(FatFile*, fname_t*, int)+0xb8>
    40ea:	movs	r7, #1
    40ec:	movs	r1, #0
    40ee:	mov	r0, r6
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
  uint8_t ms10;
  uint16_t freeIndex = 0;
    40f0:	mov	r9, r1
    40f2:	bl	2a14 <FatFile::seekSet(unsigned long)>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    40f6:	add.w	r3, fp, #13
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
  uint8_t checksum = 0;
    40fa:	str.w	r9, [sp, #28]
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
  uint8_t order = 0;
    40fe:	str.w	r9, [sp, #12]
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
  uint8_t freeNeed;
  uint8_t freeFound = 0;
    4102:	mov	r4, r9
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
  uint8_t lfnOrd = 0;
    4104:	mov	sl, r9
  }
  return true;
}
//------------------------------------------------------------------------------
bool FatFile::open(FatFile* dirFile, fname_t* fname, oflag_t oflag) {
  bool fnameFound = false;
    4106:	str.w	r9, [sp, #20]
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    410a:	str	r3, [sp, #16]
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    dir = dirFile->readDirCache(true);
    410c:	movs	r1, #1
    410e:	mov	r0, r6
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    4110:	ldr	r5, [r6, #20]
    dir = dirFile->readDirCache(true);
    4112:	bl	29c4 <FatFile::readDirCache(bool)>
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    4116:	ubfx	r5, r5, #5, #16
    dir = dirFile->readDirCache(true);
    if (!dir) {
    411a:	mov	r3, r0
    411c:	cmp	r0, #0
    411e:	beq.w	4236 <FatFile::open(FatFile*, fname_t*, int)+0x182>
        goto fail;
      }
      // At EOF
      goto create;
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
    4122:	ldrb	r2, [r0, #0]
    4124:	cmp	r2, #229	; 0xe5
    4126:	beq.n	4198 <FatFile::open(FatFile*, fname_t*, int)+0xe4>
    4128:	cmp	r2, #0
    412a:	beq.n	4198 <FatFile::open(FatFile*, fname_t*, int)+0xe4>
      if (dir->name[0] == FAT_NAME_FREE) {
        goto create;
      }
    } else {
      if (freeFound < freeNeed) {
        freeFound = 0;
    412c:	cmp	r4, r7
    412e:	it	cc
    4130:	movcc	r4, #0
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    4132:	cmp	r2, #46	; 0x2e
    4134:	beq.n	4192 <FatFile::open(FatFile*, fname_t*, int)+0xde>
    4136:	ldrb	r1, [r3, #11]
      lfnOrd = 0;
    } else if (isLongName(dir)) {
    4138:	cmp	r1, #15
    413a:	beq.n	41b4 <FatFile::open(FatFile*, fname_t*, int)+0x100>
          // Not found.
          lfnOrd = 0;
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
    413c:	and.w	r1, r1, #8
    4140:	and.w	r2, r1, #255	; 0xff
    4144:	cbnz	r1, 4192 <FatFile::open(FatFile*, fname_t*, int)+0xde>
      if (lfnOrd) {
    4146:	cmp.w	sl, #0
    414a:	bne.w	449e <FatFile::open(FatFile*, fname_t*, int)+0x3ea>
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
      }
      if (!memcmp(dir->name, fname->sfn, sizeof(fname->sfn))) {
    414e:	mov	r0, r3
    4150:	movs	r2, #11
    4152:	ldr	r1, [sp, #16]
    4154:	bl	bb18 <memcmp>
    4158:	cmp	r0, #0
    415a:	bne.n	410c <FatFile::open(FatFile*, fname_t*, int)+0x58>
        if (!(fname->flags & FNAME_FLAG_LOST_CHARS)) {
    415c:	ldrb.w	r3, [fp]
    4160:	lsls	r0, r3, #31
    4162:	bpl.w	447e <FatFile::open(FatFile*, fname_t*, int)+0x3ca>
          goto found;
        }
        fnameFound = true;
    4166:	movs	r3, #1
    4168:	str	r3, [sp, #20]
    416a:	b.n	410c <FatFile::open(FatFile*, fname_t*, int)+0x58>
  if (!dirFile->isDir() || isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;
    416c:	ldr	r7, [pc, #744]	; (4458 <FatFile::open(FatFile*, fname_t*, int)+0x3a4>)
    416e:	add.w	r3, r8, #12
    4172:	umull	r3, r7, r7, r3
    4176:	lsrs	r7, r7, #2
    4178:	adds	r7, #1
    417a:	uxtb	r7, r7
    417c:	b.n	40ec <FatFile::open(FatFile*, fname_t*, int)+0x38>
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
        checksum = ldir->checksum;
      } else if (ldir->order != --order || checksum != ldir->checksum) {
    417e:	ldr	r1, [sp, #12]
    4180:	subs	r1, #1
    4182:	uxtb	r1, r1
    4184:	cmp	r2, r1
    4186:	str	r1, [sp, #12]
    4188:	bne.n	4192 <FatFile::open(FatFile*, fname_t*, int)+0xde>
    418a:	ldrb	r2, [r3, #13]
    418c:	ldr	r1, [sp, #28]
    418e:	cmp	r1, r2
    4190:	beq.n	41ca <FatFile::open(FatFile*, fname_t*, int)+0x116>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    4192:	mov.w	sl, #0
    4196:	b.n	410c <FatFile::open(FatFile*, fname_t*, int)+0x58>
  // Number of directory entries needed.
  freeNeed = fname->flags & FNAME_FLAG_NEED_LFN ? 1 + (len + 12)/13 : 1;

  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    4198:	cmp	r4, #0
    419a:	it	eq
    419c:	moveq	r9, r5
    }
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == FAT_NAME_FREE) {
      if (freeFound == 0) {
        freeIndex = curIndex;
      }
      if (freeFound < freeNeed) {
    419e:	cmp	r4, r7
        freeFound++;
    41a0:	itt	cc
    41a2:	addcc	r4, #1
    41a4:	uxtbcc	r4, r4
      }
      if (dir->name[0] == FAT_NAME_FREE) {
    41a6:	cmp	r2, #0
    41a8:	beq.n	423e <FatFile::open(FatFile*, fname_t*, int)+0x18a>
      if (freeFound < freeNeed) {
        freeFound = 0;
      }
    }
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
    41aa:	cmp	r2, #229	; 0xe5
    41ac:	bne.n	4132 <FatFile::open(FatFile*, fname_t*, int)+0x7e>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    41ae:	mov.w	sl, #0
    41b2:	b.n	410c <FatFile::open(FatFile*, fname_t*, int)+0x58>
    // skip empty slot or '.' or '..'
    if (dir->name[0] == FAT_NAME_DELETED || dir->name[0] == '.') {
      lfnOrd = 0;
    } else if (isLongName(dir)) {
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
    41b4:	cmp.w	sl, #0
    41b8:	bne.n	417e <FatFile::open(FatFile*, fname_t*, int)+0xca>
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
    41ba:	lsls	r5, r2, #25
    41bc:	bpl.n	410c <FatFile::open(FatFile*, fname_t*, int)+0x58>
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
    41be:	and.w	sl, r2, #31
        checksum = ldir->checksum;
    41c2:	ldrb	r2, [r3, #13]
      ldir = reinterpret_cast<DirLfn_t*>(dir);
      if (!lfnOrd) {
        if ((ldir->order & FAT_ORDER_LAST_LONG_ENTRY) == 0) {
          continue;
        }
        lfnOrd = order = ldir->order & 0X1F;
    41c4:	str.w	sl, [sp, #12]
        checksum = ldir->checksum;
    41c8:	str	r2, [sp, #28]
      } else if (ldir->order != --order || checksum != ldir->checksum) {
        lfnOrd = 0;
        continue;
      }
      size_t k = 13*(order - 1);
    41ca:	ldr	r2, [sp, #12]
    41cc:	subs	r2, #1
    41ce:	add.w	r5, r2, r2, lsl #1
    41d2:	add.w	r5, r2, r5, lsl #2
      if (k >= len) {
    41d6:	cmp	r8, r5
        checksum = ldir->checksum;
      } else if (ldir->order != --order || checksum != ldir->checksum) {
        lfnOrd = 0;
        continue;
      }
      size_t k = 13*(order - 1);
    41d8:	mov	r2, r5
      if (k >= len) {
    41da:	bls.n	4192 <FatFile::open(FatFile*, fname_t*, int)+0xde>
    41dc:	add.w	r1, r5, #13
    41e0:	str.w	sl, [sp, #36]	; 0x24
    41e4:	mov	sl, r1
    41e6:	b.n	4212 <FatFile::open(FatFile*, fname_t*, int)+0x15e>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    41e8:	ldr.w	r0, [fp, #8]
    41ec:	ldrb	r2, [r0, r2]
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
    41ee:	cmp.w	ip, #25
    41f2:	it	ls
    41f4:	addls	r1, #32
    41f6:	sub.w	r0, r2, #65	; 0x41
    41fa:	it	ls
    41fc:	uxtbls	r1, r1
    41fe:	cmp	r0, #25
    4200:	itt	ls
    4202:	addls	r2, #32
    4204:	uxtbls	r2, r2
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    4206:	cmp	r2, r1
    4208:	bne.n	4192 <FatFile::open(FatFile*, fname_t*, int)+0xde>
      if (k >= len) {
        // Not found.
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
    420a:	cmp	lr, sl
    420c:	beq.w	439a <FatFile::open(FatFile*, fname_t*, int)+0x2e6>
    4210:	mov	r2, lr
        uint16_t u = lfnGetChar(ldir, i);
    4212:	subs	r1, r2, r5
    4214:	uxtb	r1, r1
    4216:	mov	r0, r3
    4218:	bl	3994 <lfnGetChar(DirLfn_t*, unsigned char)>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    421c:	uxtb	r1, r0
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
    421e:	cmp	r8, r2
}
#if USE_LONG_FILE_NAMES
//------------------------------------------------------------------------------
// Saves about 90 bytes of flash on 328 over tolower().
inline char lfnToLower(char c) {
  return 'A' <= c && c <= 'Z' ? c + 'a' - 'A' : c;
    4220:	sub.w	ip, r1, #65	; 0x41
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    4224:	add.w	lr, r2, #1
        lfnOrd = 0;
        continue;
      }
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
    4228:	beq.w	4448 <FatFile::open(FatFile*, fname_t*, int)+0x394>
            // Not found.
            lfnOrd = 0;
          }
          break;
        }
        if (u > 255 || lfnToLower(u) != lfnToLower(fname->lfn[k++])) {
    422c:	cmp	r0, #255	; 0xff
    422e:	bls.n	41e8 <FatFile::open(FatFile*, fname_t*, int)+0x134>
          goto found;
        }
        fnameFound = true;
      }
    } else {
      lfnOrd = 0;
    4230:	mov.w	sl, #0
    4234:	b.n	410c <FatFile::open(FatFile*, fname_t*, int)+0x58>
  dirFile->rewind();
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    dir = dirFile->readDirCache(true);
    if (!dir) {
      if (dirFile->getError()) {
    4236:	ldrb	r2, [r6, #1]
    4238:	cmp	r2, #0
    423a:	bne.w	43a0 <FatFile::open(FatFile*, fname_t*, int)+0x2ec>
  }
  goto open;

create:
  // don't create unless O_CREAT and write mode
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
    423e:	ldr	r2, [sp, #24]
    4240:	mov	r3, r2
    4242:	lsls	r2, r3, #22
    4244:	bpl.n	4250 <FatFile::open(FatFile*, fname_t*, int)+0x19c>
    4246:	and.w	r3, r3, #3
    424a:	subs	r3, #1
    424c:	cmp	r3, #1
    424e:	bls.n	4262 <FatFile::open(FatFile*, fname_t*, int)+0x1ae>
    DBG_FAIL_MACRO;
    4250:	mov.w	r0, #412	; 0x19c
    4254:	bl	39bc <dbgPrint(unsigned short)>
    goto fail;
  }
  return true;

fail:
  return false;
    4258:	movs	r5, #0
}
    425a:	mov	r0, r5
    425c:	add	sp, #52	; 0x34
    425e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (!(oflag & O_CREAT) || !isWriteMode(oflag)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // If at EOF start in next cluster.
  if (freeFound == 0) {
    4262:	cmp	r4, #0
    4264:	it	eq
    4266:	moveq	r9, r5
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    4268:	cmp	r4, r7
    426a:	bcc.n	4274 <FatFile::open(FatFile*, fname_t*, int)+0x1c0>
    426c:	b.n	42c0 <FatFile::open(FatFile*, fname_t*, int)+0x20c>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    426e:	uxtb	r4, r3
  // If at EOF start in next cluster.
  if (freeFound == 0) {
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    4270:	cmp	r7, r4
    4272:	bls.n	42c0 <FatFile::open(FatFile*, fname_t*, int)+0x20c>
    dir = dirFile->readDirCache();
    4274:	movs	r1, #0
    4276:	mov	r0, r6
    4278:	bl	29c4 <FatFile::readDirCache(bool)>
        goto fail;
      }
      // EOF if no error.
      break;
    }
    freeFound++;
    427c:	adds	r3, r4, #1
    freeIndex = curIndex;
  }

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
    if (!dir) {
    427e:	cmp	r0, #0
    4280:	bne.n	426e <FatFile::open(FatFile*, fname_t*, int)+0x1ba>
      if (dirFile->getError()) {
    4282:	ldrb	r2, [r6, #1]
    4284:	mov	r3, r0
    4286:	cbz	r2, 429c <FatFile::open(FatFile*, fname_t*, int)+0x1e8>
        DBG_FAIL_MACRO;
    4288:	mov.w	r0, #424	; 0x1a8
    goto fail;
  }
  return true;

fail:
  return false;
    428c:	mov	r5, r3

  while (freeFound < freeNeed) {
    dir = dirFile->readDirCache();
    if (!dir) {
      if (dirFile->getError()) {
        DBG_FAIL_MACRO;
    428e:	bl	39bc <dbgPrint(unsigned short)>
        goto fail;
    4292:	b.n	40d6 <FatFile::open(FatFile*, fname_t*, int)+0x22>
    4294:	ldr	r3, [r6, #8]
    if (!dirFile->addDirCluster()) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    // Done if more than one sector per cluster.  Max freeNeed is 21.
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
    4296:	ldrb	r3, [r3, #4]
    4298:	cmp	r3, #1
    429a:	bhi.n	42c0 <FatFile::open(FatFile*, fname_t*, int)+0x20c>
      // EOF if no error.
      break;
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    429c:	cmp	r7, r4
    429e:	bls.n	42c0 <FatFile::open(FatFile*, fname_t*, int)+0x20c>
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    42a0:	mov	r0, r6
    42a2:	bl	2494 <FatFile::addDirCluster()>
    }
    // Done if more than one sector per cluster.  Max freeNeed is 21.
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
      break;
    }
    freeFound += 16;
    42a6:	adds	r4, #16
    42a8:	uxtb	r4, r4
    }
    freeFound++;
  }
  while (freeFound < freeNeed) {
    // Will fail if FAT16 root.
    if (!dirFile->addDirCluster()) {
    42aa:	cmp	r0, #0
    42ac:	bne.n	4294 <FatFile::open(FatFile*, fname_t*, int)+0x1e0>
    42ae:	mov	r5, r0
      DBG_FAIL_MACRO;
    42b0:	movw	r0, #435	; 0x1b3
    42b4:	bl	39bc <dbgPrint(unsigned short)>
  }
  return true;

fail:
  return false;
}
    42b8:	mov	r0, r5
    42ba:	add	sp, #52	; 0x34
    42bc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (dirFile->m_vol->sectorsPerCluster() > 1) {
      break;
    }
    freeFound += 16;
  }
  if (fnameFound) {
    42c0:	ldr	r3, [sp, #20]
    42c2:	cbz	r3, 42d4 <FatFile::open(FatFile*, fname_t*, int)+0x220>
    if (!dirFile->lfnUniqueSfn(fname)) {
    42c4:	mov	r1, fp
    42c6:	mov	r0, r6
    42c8:	bl	3f80 <FatFile::lfnUniqueSfn(fname_t*)>
    42cc:	mov	r5, r0
    42ce:	cmp	r0, #0
    42d0:	beq.w	40d6 <FatFile::open(FatFile*, fname_t*, int)+0x22>
      goto fail;
    }
  }
  if (!dirFile->seekSet(32UL*freeIndex)) {
    42d4:	mov.w	r1, r9, lsl #5
    42d8:	mov	r0, r6
    42da:	bl	2a14 <FatFile::seekSet(unsigned long)>
    42de:	mov	r5, r0
    42e0:	cmp	r0, #0
    42e2:	beq.w	44b0 <FatFile::open(FatFile*, fname_t*, int)+0x3fc>
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
    42e6:	subs	r7, #1
  for (order = lfnOrd ; order ; order--) {
    42e8:	ands.w	sl, r7, #255	; 0xff
    42ec:	beq.n	43b4 <FatFile::open(FatFile*, fname_t*, int)+0x300>
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    42ee:	orr.w	r5, sl, #64	; 0x40
    42f2:	uxtb	r5, r5
  if (!dirFile->seekSet(32UL*freeIndex)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
  for (order = lfnOrd ; order ; order--) {
    42f4:	mov	r7, sl
    ldir = reinterpret_cast<DirLfn_t*>(dirFile->readDirCache());
    42f6:	mov.w	r9, #0
    42fa:	movs	r1, #0
    42fc:	mov	r0, r6
    42fe:	bl	29c4 <FatFile::readDirCache(bool)>
    if (!ldir) {
    4302:	cmp	r0, #0
    4304:	beq.w	4490 <FatFile::open(FatFile*, fname_t*, int)+0x3dc>
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    4308:	ldr	r2, [r6, #8]
  cache_t* buffer() {
    return &m_buffer;
  }
  /** Set current sector dirty. */
  void dirty() {
    m_status |= CACHE_STATUS_DIRTY;
    430a:	ldrb.w	r3, [r2, #36]	; 0x24
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    430e:	cmp	sl, r7
    4310:	orr.w	r3, r3, #1
    4314:	ite	ne
    4316:	movne	r4, r7
    4318:	moveq	r4, r5
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    431a:	movs	r1, #15
    431c:	strb.w	r3, [r2, #36]	; 0x24
    4320:	add.w	lr, fp, #23
    4324:	add.w	r3, fp, #12
    ldir->mustBeZero1 = 0;
    4328:	strb.w	r9, [r0, #12]
    if (!ldir) {
      DBG_FAIL_MACRO;
      goto fail;
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    432c:	strb	r4, [r0, #0]
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    432e:	strb	r1, [r0, #11]
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
    4330:	movs	r2, #0
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    4332:	ldrb.w	ip, [r3, #1]!
    4336:	lsrs	r1, r2, #1
    4338:	orr.w	r2, r1, r2, lsl #7
    433c:	uxtab	r2, ip, r2
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    4340:	cmp	r3, lr
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    4342:	uxtb	r2, r2
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    4344:	bne.n	4332 <FatFile::open(FatFile*, fname_t*, int)+0x27e>
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    4346:	and.w	r4, r4, #31
    434a:	subs	r4, #1
    }
    dirFile->m_vol->cacheDirty();
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    434c:	strb	r2, [r0, #13]
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    434e:	add.w	r3, r4, r4, lsl #1
    ldir->order = order == lfnOrd ? FAT_ORDER_LAST_LONG_ENTRY | order : order;
    ldir->attributes = FAT_ATTRIB_LONG_NAME;
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
    4352:	ldr.w	r2, [fp, #8]
}
inline uint64_t getLe64(const uint8_t* src) {
  return *reinterpret_cast<const uint64_t*>(src);
}
inline void setLe16(uint8_t* dst, uint16_t src) {
  *reinterpret_cast<uint16_t*>(dst) = src;
    4356:	strh.w	r9, [r0, #26]
    setLe16(ldir->unicode3 + 2*i - 22, c);
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
    435a:	add.w	r4, r4, r3, lsl #2
    435e:	adds	r0, #4
  for (uint8_t i = 0; i < 13; i++, k++) {
    4360:	movs	r3, #0
    4362:	b.n	4382 <FatFile::open(FatFile*, fname_t*, int)+0x2ce>
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t *ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    4364:	cmp	r3, #4
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    4366:	ldrb	r1, [r2, r4]
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t *ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    4368:	bls.n	4394 <FatFile::open(FatFile*, fname_t*, int)+0x2e0>
    setLe16(ldir->unicode1 + 2*i, c);
  } else if (i < 11) {
    436a:	cmp	r3, #10
    436c:	ite	ls
    436e:	strhls	r1, [r0, #0]
    4370:	strhhi	r1, [r0, #2]
  }
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    4372:	adds	r3, #1
    4374:	uxtb	r3, r3
    4376:	cmp	r3, #13
    4378:	add.w	r4, r4, #1
    437c:	add.w	r0, r0, #2
    4380:	beq.n	43ac <FatFile::open(FatFile*, fname_t*, int)+0x2f8>
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    4382:	cmp	r8, r4
    4384:	bhi.n	4364 <FatFile::open(FatFile*, fname_t*, int)+0x2b0>
    4386:	ite	ne
    4388:	movne.w	r1, #4294967295
    438c:	moveq	r1, #0
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t *ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    438e:	cmp	r3, #4
}
//------------------------------------------------------------------------------
static void lfnPutName(DirLfn_t *ldir, const char* name, size_t n) {
  size_t k = 13*((ldir->order & 0X1F) - 1);
  for (uint8_t i = 0; i < 13; i++, k++) {
    uint16_t c = k < n ? name[k] : k == n ? 0 : 0XFFFF;
    4390:	uxth	r1, r1
 * \param[in] ldir Pointer to long file name directory entry.
 * \param[in] i Index of character.
 * \param[in] c  The 16-bit character.
 */
static void lfnPutChar(DirLfn_t *ldir, uint8_t i, uint16_t c) {
  if (i < 5) {
    4392:	bhi.n	436a <FatFile::open(FatFile*, fname_t*, int)+0x2b6>
    4394:	strh.w	r1, [r0, #-3]
    4398:	b.n	4372 <FatFile::open(FatFile*, fname_t*, int)+0x2be>
    439a:	ldr.w	sl, [sp, #36]	; 0x24
    439e:	b.n	410c <FatFile::open(FatFile*, fname_t*, int)+0x58>
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    dir = dirFile->readDirCache(true);
    if (!dir) {
      if (dirFile->getError()) {
        DBG_FAIL_MACRO;
    43a0:	movw	r0, #325	; 0x145
    goto fail;
  }
  return true;

fail:
  return false;
    43a4:	mov	r5, r3
  while (1) {
    curIndex = dirFile->m_curPosition/32;
    dir = dirFile->readDirCache(true);
    if (!dir) {
      if (dirFile->getError()) {
        DBG_FAIL_MACRO;
    43a6:	bl	39bc <dbgPrint(unsigned short)>
        goto fail;
    43aa:	b.n	40d6 <FatFile::open(FatFile*, fname_t*, int)+0x22>
  if (!dirFile->seekSet(32UL*freeIndex)) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  lfnOrd = freeNeed - 1;
  for (order = lfnOrd ; order ; order--) {
    43ac:	subs	r7, #1
    43ae:	ands.w	r7, r7, #255	; 0xff
    43b2:	bne.n	42fa <FatFile::open(FatFile*, fname_t*, int)+0x246>
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
  dir = dirFile->readDirCache();
    43b4:	movs	r1, #0
    43b6:	mov	r0, r6
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
    43b8:	ldr	r5, [r6, #20]
  dir = dirFile->readDirCache();
    43ba:	bl	29c4 <FatFile::readDirCache(bool)>
    ldir->mustBeZero1 = 0;
    ldir->checksum = lfnChecksum(fname->sfn);
    setLe16(ldir->mustBeZero2, 0);
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
    43be:	ubfx	r5, r5, #5, #16
  dir = dirFile->readDirCache();
  if (!dir) {
    43c2:	mov	r4, r0
    43c4:	cmp	r0, #0
    43c6:	beq.n	44ba <FatFile::open(FatFile*, fname_t*, int)+0x406>
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
    43c8:	movs	r2, #32
    43ca:	movs	r1, #0
    43cc:	bl	bb7c <memset>
  memcpy(dir->name, fname->sfn, 11);
    43d0:	mov	r3, fp

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;

  // set timestamps
  if (FsDateTime::callback) {
    43d2:	ldr	r2, [pc, #136]	; (445c <FatFile::open(FatFile*, fname_t*, int)+0x3a8>)
    DBG_FAIL_MACRO;
    goto fail;
  }
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
  memcpy(dir->name, fname->sfn, 11);
    43d4:	ldr.w	r1, [r3, #13]!
    43d8:	ldr	r0, [r3, #4]
    43da:	str	r0, [r4, #4]
    43dc:	str	r1, [r4, #0]
    43de:	ldrh	r1, [r3, #8]
    43e0:	ldrb	r3, [r3, #10]
    43e2:	strb	r3, [r4, #10]
    43e4:	strh	r1, [r4, #8]

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    43e6:	ldrb.w	r3, [fp]

  // set timestamps
  if (FsDateTime::callback) {
    43ea:	ldr	r7, [r2, #0]
  // initialize as empty file
  memset(dir, 0, sizeof(DirFat_t));
  memcpy(dir->name, fname->sfn, 11);

  // Set base-name and extension lower case bits.
  dir->caseFlags =  (FAT_CASE_LC_BASE | FAT_CASE_LC_EXT) & fname->flags;
    43ec:	and.w	r3, r3, #24
    43f0:	strb	r3, [r4, #12]

  // set timestamps
  if (FsDateTime::callback) {
    43f2:	cbz	r7, 4418 <FatFile::open(FatFile*, fname_t*, int)+0x364>
    // call user date/time function
    FsDateTime::callback(&date, &time, &ms10);
    43f4:	add.w	r2, sp, #43	; 0x2b
    43f8:	add.w	r1, sp, #46	; 0x2e
    43fc:	add	r0, sp, #44	; 0x2c
    43fe:	blx	r7
    dir->createTimeMs = ms10;
    setLe16(dir->createDate, date);
    4400:	ldrh.w	r3, [sp, #44]	; 0x2c
    setLe16(dir->createTime, time);
    4404:	ldrh.w	r2, [sp, #46]	; 0x2e

  // set timestamps
  if (FsDateTime::callback) {
    // call user date/time function
    FsDateTime::callback(&date, &time, &ms10);
    dir->createTimeMs = ms10;
    4408:	ldrb.w	r1, [sp, #43]	; 0x2b
    440c:	strb	r1, [r4, #13]
    440e:	strh	r3, [r4, #16]
    4410:	strh	r3, [r4, #18]
    4412:	strh	r3, [r4, #24]
    4414:	strh	r2, [r4, #14]
    4416:	strh	r2, [r4, #22]
    setLe16(dir->accessDate, date);
    setLe16(dir->modifyDate, date);
    setLe16(dir->modifyTime, time);;
  }
  // Force write of entry to device.
  dirFile->m_vol->cacheDirty();
    4418:	ldr	r2, [r6, #8]
    441a:	ldrb.w	r3, [r2, #36]	; 0x24
    441e:	orr.w	r3, r3, #1
    4422:	strb.w	r3, [r2, #36]	; 0x24

open:
  // open entry in cache.
  if (!openCachedEntry(dirFile, curIndex, oflag, lfnOrd)) {
    4426:	mov	r2, r5
    4428:	str.w	sl, [sp]
    442c:	ldr	r3, [sp, #24]
    442e:	ldr	r0, [sp, #32]
    4430:	mov	r1, r6
    4432:	bl	2b38 <FatFile::openCachedEntry(FatFile*, unsigned short, int, unsigned char)>
    4436:	mov	r5, r0
    4438:	cmp	r0, #0
    443a:	bne.w	40d6 <FatFile::open(FatFile*, fname_t*, int)+0x22>
    DBG_FAIL_MACRO;
    443e:	mov.w	r0, #498	; 0x1f2
    4442:	bl	39bc <dbgPrint(unsigned short)>
    goto fail;
    4446:	b.n	40d6 <FatFile::open(FatFile*, fname_t*, int)+0x22>
      for (uint8_t i = 0; i < 13; i++) {
        uint16_t u = lfnGetChar(ldir, i);
        if (k == len) {
          if (u != 0) {
            // Not found.
            lfnOrd = 0;
    4448:	cmp	r0, #0
    444a:	ldr.w	sl, [sp, #36]	; 0x24
    444e:	it	ne
    4450:	movne.w	sl, #0
    4454:	b.n	410c <FatFile::open(FatFile*, fname_t*, int)+0x58>
    4456:	nop
    4458:	.word	0x4ec4ec4f
    445c:	.word	0x1fff13c8
    4460:	subs	r4, r3, #1
    4462:	adds	r3, #10
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    4464:	ldrb.w	r0, [r4, #1]!
    4468:	lsrs	r1, r2, #1
    446a:	orr.w	r2, r1, r2, lsl #7
    446e:	uxtab	r2, r0, r2
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    4472:	cmp	r4, r3
    sum = (((sum & 1) << 7) | ((sum & 0xfe) >> 1)) + name[i];
    4474:	uxtb	r2, r2
#include "FatVolume.h"
//------------------------------------------------------------------------------
//
uint8_t FatFile::lfnChecksum(uint8_t* name) {
  uint8_t sum = 0;
  for (uint8_t i = 0; i < 11; i++) {
    4476:	bne.n	4464 <FatFile::open(FatFile*, fname_t*, int)+0x3b0>
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd) {
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    4478:	ldr	r3, [sp, #28]
    447a:	cmp	r3, r2
    447c:	bne.n	44a4 <FatFile::open(FatFile*, fname_t*, int)+0x3f0>
    }
  }

found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    447e:	ldr	r3, [sp, #24]
    4480:	lsls	r1, r3, #20
    4482:	bpl.n	4426 <FatFile::open(FatFile*, fname_t*, int)+0x372>
    DBG_FAIL_MACRO;
    4484:	mov.w	r0, #404	; 0x194
    4488:	bl	39bc <dbgPrint(unsigned short)>
    goto fail;
  }
  return true;

fail:
  return false;
    448c:	movs	r5, #0

found:
  // Don't open if create only.
  if (oflag & O_EXCL) {
    DBG_FAIL_MACRO;
    goto fail;
    448e:	b.n	40d6 <FatFile::open(FatFile*, fname_t*, int)+0x22>
    4490:	mov	r3, r0
  }
  lfnOrd = freeNeed - 1;
  for (order = lfnOrd ; order ; order--) {
    ldir = reinterpret_cast<DirLfn_t*>(dirFile->readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
    4492:	movw	r0, #457	; 0x1c9
    goto fail;
  }
  return true;

fail:
  return false;
    4496:	mov	r5, r3
  }
  lfnOrd = freeNeed - 1;
  for (order = lfnOrd ; order ; order--) {
    ldir = reinterpret_cast<DirLfn_t*>(dirFile->readDirCache());
    if (!ldir) {
      DBG_FAIL_MACRO;
    4498:	bl	39bc <dbgPrint(unsigned short)>
      goto fail;
    449c:	b.n	40d6 <FatFile::open(FatFile*, fname_t*, int)+0x22>
          break;
        }
      }
    } else if (isFileOrSubdir(dir)) {
      if (lfnOrd) {
        if (1 == order && lfnChecksum(dir->name) == checksum) {
    449e:	ldr	r1, [sp, #12]
    44a0:	cmp	r1, #1
    44a2:	beq.n	4460 <FatFile::open(FatFile*, fname_t*, int)+0x3ac>
          goto found;
        }
        DBG_FAIL_MACRO;
    44a4:	movw	r0, #387	; 0x183
    44a8:	bl	39bc <dbgPrint(unsigned short)>
    goto fail;
  }
  return true;

fail:
  return false;
    44ac:	movs	r5, #0
      if (lfnOrd) {
        if (1 == order && lfnChecksum(dir->name) == checksum) {
          goto found;
        }
        DBG_FAIL_MACRO;
        goto fail;
    44ae:	b.n	40d6 <FatFile::open(FatFile*, fname_t*, int)+0x22>
    if (!dirFile->lfnUniqueSfn(fname)) {
      goto fail;
    }
  }
  if (!dirFile->seekSet(32UL*freeIndex)) {
    DBG_FAIL_MACRO;
    44b0:	mov.w	r0, #450	; 0x1c2
    44b4:	bl	39bc <dbgPrint(unsigned short)>
    goto fail;
    44b8:	b.n	40d6 <FatFile::open(FatFile*, fname_t*, int)+0x22>
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
  dir = dirFile->readDirCache();
  if (!dir) {
    DBG_FAIL_MACRO;
    44ba:	movw	r0, #471	; 0x1d7
    goto fail;
  }
  return true;

fail:
  return false;
    44be:	mov	r5, r4
    lfnPutName(ldir, fname->lfn, len);
  }
  curIndex = dirFile->m_curPosition/32;
  dir = dirFile->readDirCache();
  if (!dir) {
    DBG_FAIL_MACRO;
    44c0:	bl	39bc <dbgPrint(unsigned short)>
    goto fail;
    44c4:	b.n	40d6 <FatFile::open(FatFile*, fname_t*, int)+0x22>
    44c6:	nop

000044c8 <dbgPrint(unsigned short)>:
#if USE_DBG_MACROS
#include "Arduino.h"
#ifndef DBG_FILE
#error DBG_FILE not defined
#endif  // DBG_FILE
static void dbgPrint(uint16_t line) {
    44c8:	push	{r3, r4, r5, lr}
    44ca:	movs	r1, #10
    44cc:	mov	r5, r0
    44ce:	ldr	r0, [pc, #40]	; (44f8 <dbgPrint(unsigned short)+0x30>)
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    44d0:	ldr	r4, [pc, #40]	; (44fc <dbgPrint(unsigned short)+0x34>)
    44d2:	bl	8e24 <usb_serial_write>
    44d6:	movs	r1, #14
    44d8:	ldr	r0, [pc, #36]	; (4500 <dbgPrint(unsigned short)+0x38>)
    44da:	bl	8e24 <usb_serial_write>
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    44de:	movs	r0, #46	; 0x2e
    44e0:	bl	8f2c <usb_serial_putchar>
    44e4:	mov	r1, r5
    44e6:	mov	r0, r4
    44e8:	bl	ae20 <Print::print(long)>
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
	size_t println(int n)				{ return print(n) + println(); }
    44ec:	mov	r0, r4
  Serial.print(F("DBG_FAIL: "));
  Serial.print(F(DBG_FILE));
  Serial.write('.');
  Serial.println(line);
}
    44ee:	ldmia.w	sp!, {r3, r4, r5, lr}
    44f2:	b.w	ad80 <Print::println()>
    44f6:	nop
    44f8:	.word	0x0000c270
    44fc:	.word	0x1fff099c
    4500:	.word	0x0000c348

00004504 <FatFile::getSFN(char*)>:
#include "../common/DebugMacros.h"
#include "../common/FsStructs.h"
#include "FatFile.h"
#include "FatVolume.h"
//------------------------------------------------------------------------------
bool FatFile::getSFN(char* name) {
    4504:	push	{r3, r4, r5, r6, r7, lr}
    4506:	ldrb	r4, [r0, #0]
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
  DirFat_t *dir;

  if (!isOpen()) {
    4508:	cbz	r4, 4566 <FatFile::getSFN(char*)+0x62>
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    450a:	ands.w	r4, r4, #96	; 0x60
    450e:	mov	r5, r1
    4510:	beq.n	451e <FatFile::getSFN(char*)+0x1a>
    name[0] = '/';
    4512:	movs	r2, #47	; 0x2f
    name[1] = '\0';
    4514:	movs	r3, #0
  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  if (isRoot()) {
    name[0] = '/';
    4516:	strb	r2, [r1, #0]
    name[1] = '\0';
    4518:	strb	r3, [r1, #1]
    return true;
    451a:	movs	r0, #1
    451c:	pop	{r3, r4, r5, r6, r7, pc}
  }
  // cache entry
  dir = reinterpret_cast<DirFat_t*>(cacheDirEntry(FatCache::CACHE_FOR_READ));
    451e:	mov	r1, r4
    4520:	bl	2568 <FatFile::cacheDirEntry(unsigned char)>
  if (!dir) {
    4524:	mov	r6, r0
    4526:	cbz	r0, 4570 <FatFile::getSFN(char*)+0x6c>
    4528:	mov	r1, r4
    452a:	mov	r2, r4
    452c:	subs	r0, #1
    452e:	movs	r7, #8
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    4530:	mov.w	lr, #46	; 0x2e
    DBG_FAIL_MACRO;
    goto fail;
  }
  // format name
  for (uint8_t i = 0; i < 11; i++) {
    if (dir->name[i] == ' ') {
    4534:	ldrb.w	r3, [r0, #1]!
    4538:	cmp	r3, #32
    453a:	beq.n	4558 <FatFile::getSFN(char*)+0x54>
      continue;
    }
    if (i == 8) {
    453c:	cmp	r1, #8
    453e:	beq.n	457a <FatFile::getSFN(char*)+0x76>
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    }
    char c = dir->name[i];
    if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
    4540:	sub.w	r4, r3, #65	; 0x41
    4544:	cmp	r4, #25
    4546:	bhi.n	4552 <FatFile::getSFN(char*)+0x4e>
    4548:	ldrb	r4, [r6, #12]
    454a:	tst	r7, r4
      c += 'a' - 'A';
    454c:	itt	ne
    454e:	addne	r3, #32
    4550:	uxtbne	r3, r3
    }
    name[j++] = c;
    4552:	strb	r3, [r5, r2]
    4554:	adds	r2, #1
    4556:	uxtb	r2, r2
    4558:	adds	r1, #1
  if (!dir) {
    DBG_FAIL_MACRO;
    goto fail;
  }
  // format name
  for (uint8_t i = 0; i < 11; i++) {
    455a:	cmp	r1, #11
    455c:	bne.n	4534 <FatFile::getSFN(char*)+0x30>
    if ('A' <= c && c <= 'Z' && (lcBit & dir->caseFlags)) {
      c += 'a' - 'A';
    }
    name[j++] = c;
  }
  name[j] = 0;
    455e:	movs	r3, #0
    4560:	strb	r3, [r5, r2]
  return true;
    4562:	movs	r0, #1

fail:
  return false;
}
    4564:	pop	{r3, r4, r5, r6, r7, pc}
  uint8_t j = 0;
  uint8_t lcBit = FAT_CASE_LC_BASE;
  DirFat_t *dir;

  if (!isOpen()) {
    DBG_FAIL_MACRO;
    4566:	movs	r0, #37	; 0x25
    4568:	bl	44c8 <dbgPrint(unsigned short)>
  }
  name[j] = 0;
  return true;

fail:
  return false;
    456c:	mov	r0, r4
  uint8_t lcBit = FAT_CASE_LC_BASE;
  DirFat_t *dir;

  if (!isOpen()) {
    DBG_FAIL_MACRO;
    goto fail;
    456e:	pop	{r3, r4, r5, r6, r7, pc}
    return true;
  }
  // cache entry
  dir = reinterpret_cast<DirFat_t*>(cacheDirEntry(FatCache::CACHE_FOR_READ));
  if (!dir) {
    DBG_FAIL_MACRO;
    4570:	movs	r0, #48	; 0x30
    4572:	bl	44c8 <dbgPrint(unsigned short)>
  }
  name[j] = 0;
  return true;

fail:
  return false;
    4576:	mov	r0, r6
    4578:	pop	{r3, r4, r5, r6, r7, pc}
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
      name[j++] = '.';
    457a:	strb.w	lr, [r5, r2]
    457e:	adds	r2, #1
    4580:	uxtb	r2, r2
    4582:	ldrb	r3, [r0, #0]
    if (dir->name[i] == ' ') {
      continue;
    }
    if (i == 8) {
      // Position bit for extension.
      lcBit = FAT_CASE_LC_EXT;
    4584:	movs	r7, #16
    4586:	b.n	4540 <FatFile::getSFN(char*)+0x3c>

00004588 <FsBaseFile::close()>:
    *m_xFile = *from.m_xFile;
  }
  return *this;
}
//------------------------------------------------------------------------------
bool FsBaseFile::close() {
    4588:	push	{r4, lr}
    458a:	mov	r4, r0
  if (m_fFile && m_fFile->close()) {
    458c:	ldr	r0, [r0, #56]	; 0x38
    458e:	cbz	r0, 459c <FsBaseFile::close()+0x14>
    4590:	bl	2638 <FatFile::close()>
    4594:	cbz	r0, 459c <FsBaseFile::close()+0x14>
    m_fFile = nullptr;
    4596:	movs	r3, #0
    4598:	str	r3, [r4, #56]	; 0x38
    return true;
    459a:	pop	{r4, pc}
  }
  if (m_xFile && m_xFile->close()) {
    459c:	ldr	r0, [r4, #60]	; 0x3c
    459e:	cbz	r0, 45ac <FsBaseFile::close()+0x24>
    45a0:	bl	704 <ExFatFile::close()>
    45a4:	cbz	r0, 45ac <FsBaseFile::close()+0x24>
    m_xFile = nullptr;
    45a6:	movs	r3, #0
    45a8:	str	r3, [r4, #60]	; 0x3c
    45aa:	pop	{r4, pc}
    return true;
  }
  return false;
    45ac:	movs	r0, #0
}
    45ae:	pop	{r4, pc}

000045b0 <FsBaseFile::operator=(FsBaseFile const&)>:
    *m_xFile = *from.m_xFile;
  }
}
//------------------------------------------------------------------------------
FsBaseFile& FsBaseFile::operator=(const FsBaseFile& from) {
  if (this == &from) return *this;
    45b0:	cmp	r0, r1
    m_xFile = new (m_fileMem) ExFatFile;
    *m_xFile = *from.m_xFile;
  }
}
//------------------------------------------------------------------------------
FsBaseFile& FsBaseFile::operator=(const FsBaseFile& from) {
    45b2:	push	{r3, r4, r5, r6, r7, lr}
    45b4:	mov	r6, r0
  if (this == &from) return *this;
    45b6:	beq.n	45e4 <FsBaseFile::operator=(FsBaseFile const&)+0x34>
    45b8:	mov	r5, r1
  close();
    45ba:	bl	4588 <FsBaseFile::close()>
  if (from.m_fFile) {
    45be:	ldr	r4, [r5, #56]	; 0x38
    45c0:	cbz	r4, 45e8 <FsBaseFile::operator=(FsBaseFile const&)+0x38>
    m_fFile = new (m_fileMem) FatFile;
    45c2:	mov	r1, r6
    45c4:	movs	r0, #36	; 0x24
    45c6:	bl	47f8 <operator new(unsigned int, unsigned long*)>
 * \brief Basic file class.
 */
class FatFile {
 public:
  /** Create an instance. */
  FatFile() : m_attributes(FILE_ATTR_CLOSED), m_error(0), m_flags(0) {}
    45ca:	movs	r3, #0
    45cc:	strb	r3, [r0, #0]
    45ce:	strb	r3, [r0, #1]
    45d0:	strb	r3, [r0, #2]
    45d2:	str	r0, [r6, #56]	; 0x38
    *m_fFile = *from.m_fFile;
    45d4:	ldr	r5, [r5, #56]	; 0x38
//------------------------------------------------------------------------------
FsBaseFile& FsBaseFile::operator=(const FsBaseFile& from) {
  if (this == &from) return *this;
  close();
  if (from.m_fFile) {
    m_fFile = new (m_fileMem) FatFile;
    45d6:	mov	r4, r0
    *m_fFile = *from.m_fFile;
    45d8:	ldmia	r5!, {r0, r1, r2, r3}
    45da:	stmia	r4!, {r0, r1, r2, r3}
    45dc:	ldmia	r5!, {r0, r1, r2, r3}
    45de:	stmia	r4!, {r0, r1, r2, r3}
    45e0:	ldr	r3, [r5, #0]
    45e2:	str	r3, [r4, #0]
  } else if (from.m_xFile) {
    m_xFile = new (m_fileMem) ExFatFile;
    *m_xFile = *from.m_xFile;
  }
  return *this;
}
    45e4:	mov	r0, r6
    45e6:	pop	{r3, r4, r5, r6, r7, pc}
  if (this == &from) return *this;
  close();
  if (from.m_fFile) {
    m_fFile = new (m_fileMem) FatFile;
    *m_fFile = *from.m_fFile;
  } else if (from.m_xFile) {
    45e8:	ldr	r3, [r5, #60]	; 0x3c
    45ea:	cmp	r3, #0
    45ec:	beq.n	45e4 <FsBaseFile::operator=(FsBaseFile const&)+0x34>
    m_xFile = new (m_fileMem) ExFatFile;
    45ee:	mov	r1, r6
    45f0:	movs	r0, #56	; 0x38
    45f2:	bl	47f8 <operator new(unsigned int, unsigned long*)>
    45f6:	strb.w	r4, [r0, #49]	; 0x31
    45fa:	strb.w	r4, [r0, #50]	; 0x32
    45fe:	strb.w	r4, [r0, #51]	; 0x33
    4602:	str	r0, [r6, #60]	; 0x3c
    *m_xFile = *from.m_xFile;
    4604:	ldr	r3, [r5, #60]	; 0x3c
    4606:	mov	r2, r0
    4608:	add.w	r1, r3, #48	; 0x30
    460c:	ldr	r5, [r3, #0]
    460e:	ldr	r4, [r3, #4]
    4610:	ldr	r0, [r3, #8]
    4612:	ldr	r7, [r3, #12]
    4614:	str	r7, [r2, #12]
    4616:	adds	r3, #16
    4618:	cmp	r3, r1
    461a:	str	r5, [r2, #0]
    461c:	str	r4, [r2, #4]
    461e:	str	r0, [r2, #8]
    4620:	add.w	r2, r2, #16
    4624:	bne.n	460c <FsBaseFile::operator=(FsBaseFile const&)+0x5c>
    4626:	ldr	r3, [r3, #0]
    4628:	str	r3, [r2, #0]
    462a:	b.n	45e4 <FsBaseFile::operator=(FsBaseFile const&)+0x34>

0000462c <FsBaseFile::open(FsVolume*, char const*, int)>:
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    462c:	cbz	r1, 46a2 <FsBaseFile::open(FsVolume*, char const*, int)+0x76>
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
    462e:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4632:	mov	r4, r1
    4634:	mov	r5, r0
    4636:	mov	r8, r3
    4638:	mov	r7, r2
  if (!vol) {
    return false;
  }
  close();
    463a:	bl	4588 <FsBaseFile::close()>
  if (vol->m_fVol) {
    463e:	ldr.w	r6, [r4, #1144]	; 0x478
    4642:	cbz	r6, 4670 <FsBaseFile::open(FsVolume*, char const*, int)+0x44>
    m_fFile = new (m_fileMem) FatFile;
    4644:	mov	r1, r5
    4646:	movs	r0, #36	; 0x24
    4648:	bl	47f8 <operator new(unsigned int, unsigned long*)>
    464c:	movs	r1, #0
    464e:	strb	r1, [r0, #0]
    4650:	strb	r1, [r0, #1]
    4652:	strb	r1, [r0, #2]
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    4654:	ldr.w	r1, [r4, #1144]	; 0x478
  if (!vol) {
    return false;
  }
  close();
  if (vol->m_fVol) {
    m_fFile = new (m_fileMem) FatFile;
    4658:	str	r0, [r5, #56]	; 0x38
    if (m_fFile && m_fFile->open(vol->m_fVol, path, oflag)) {
    465a:	mov	r3, r8
    465c:	mov	r2, r7
    465e:	bl	27a8 <FatFile::open(FatVolume*, char const*, int)>
    4662:	cbz	r0, 466a <FsBaseFile::open(FsVolume*, char const*, int)+0x3e>
      return true;
    4664:	movs	r0, #1
    4666:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    m_fFile = nullptr;
    466a:	str	r0, [r5, #56]	; 0x38
    return false;
    466c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  } else if (vol->m_xVol) {
    4670:	ldr.w	r3, [r4, #1148]	; 0x47c
    4674:	cbz	r3, 46a6 <FsBaseFile::open(FsVolume*, char const*, int)+0x7a>
    m_xFile = new (m_fileMem) ExFatFile;
    4676:	mov	r1, r5
    4678:	movs	r0, #56	; 0x38
    467a:	bl	47f8 <operator new(unsigned int, unsigned long*)>
    467e:	strb.w	r6, [r0, #49]	; 0x31
    4682:	strb.w	r6, [r0, #50]	; 0x32
    4686:	strb.w	r6, [r0, #51]	; 0x33
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    468a:	ldr.w	r1, [r4, #1148]	; 0x47c
      return true;
    }
    m_fFile = nullptr;
    return false;
  } else if (vol->m_xVol) {
    m_xFile = new (m_fileMem) ExFatFile;
    468e:	str	r0, [r5, #60]	; 0x3c
    if (m_xFile && m_xFile->open(vol->m_xVol, path, oflag)) {
    4690:	mov	r3, r8
    4692:	mov	r2, r7
    4694:	bl	1144 <ExFatFile::open(ExFatVolume*, char const*, int)>
    4698:	cmp	r0, #0
    469a:	bne.n	4664 <FsBaseFile::open(FsVolume*, char const*, int)+0x38>
      return true;
    }
    m_xFile = nullptr;
    469c:	str	r0, [r5, #60]	; 0x3c
  }
  return false;
}
    469e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    return false;
    46a2:	movs	r0, #0
      return true;
    }
    m_xFile = nullptr;
  }
  return false;
}
    46a4:	bx	lr
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::open(FsVolume* vol, const char* path, oflag_t oflag) {
  if (!vol) {
    return false;
    46a6:	movs	r0, #0
    46a8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000046ac <FsBaseFile::openNext(FsBaseFile*, int)>:
    m_xFile = nullptr;
  }
  return false;
}
//------------------------------------------------------------------------------
bool FsBaseFile::openNext(FsBaseFile* dir, oflag_t oflag) {
    46ac:	push	{r3, r4, r5, r6, r7, lr}
    46ae:	mov	r5, r1
    46b0:	mov	r7, r2
    46b2:	mov	r4, r0
  close();
    46b4:	bl	4588 <FsBaseFile::close()>
  if (dir->m_fFile) {
    46b8:	ldr	r6, [r5, #56]	; 0x38
    46ba:	cbz	r6, 46e0 <FsBaseFile::openNext(FsBaseFile*, int)+0x34>
    m_fFile = new (m_fileMem) FatFile;
    46bc:	mov	r1, r4
    46be:	movs	r0, #36	; 0x24
    46c0:	bl	47f8 <operator new(unsigned int, unsigned long*)>
    46c4:	movs	r2, #0
    46c6:	strb	r2, [r0, #0]
    46c8:	strb	r2, [r0, #1]
    46ca:	strb	r2, [r0, #2]
    46cc:	str	r0, [r4, #56]	; 0x38
    if (m_fFile->openNext(dir->m_fFile, oflag)) {
    46ce:	mov	r2, r7
    46d0:	ldr	r1, [r5, #56]	; 0x38
    46d2:	bl	2c68 <FatFile::openNext(FatFile*, int)>
    46d6:	cbz	r0, 46dc <FsBaseFile::openNext(FsBaseFile*, int)+0x30>
      return true;
    46d8:	movs	r0, #1
    46da:	pop	{r3, r4, r5, r6, r7, pc}
    }
    m_fFile = nullptr;
    46dc:	str	r0, [r4, #56]	; 0x38
    46de:	pop	{r3, r4, r5, r6, r7, pc}
  } else if (dir->m_xFile) {
    46e0:	ldr	r0, [r5, #60]	; 0x3c
    46e2:	cbz	r0, 4708 <FsBaseFile::openNext(FsBaseFile*, int)+0x5c>
    m_xFile = new (m_fileMem) ExFatFile;
    46e4:	mov	r1, r4
    46e6:	movs	r0, #56	; 0x38
    46e8:	bl	47f8 <operator new(unsigned int, unsigned long*)>
    46ec:	strb.w	r6, [r0, #49]	; 0x31
    46f0:	strb.w	r6, [r0, #50]	; 0x32
    46f4:	strb.w	r6, [r0, #51]	; 0x33
    46f8:	str	r0, [r4, #60]	; 0x3c
    if (m_xFile->openNext(dir->m_xFile, oflag)) {
    46fa:	mov	r2, r7
    46fc:	ldr	r1, [r5, #60]	; 0x3c
    46fe:	bl	1154 <ExFatFile::openNext(ExFatFile*, int)>
    4702:	cmp	r0, #0
    4704:	bne.n	46d8 <FsBaseFile::openNext(FsBaseFile*, int)+0x2c>
      return true;
    }
    m_xFile = nullptr;
    4706:	str	r0, [r4, #60]	; 0x3c
  }
  return false;
}
    4708:	pop	{r3, r4, r5, r6, r7, pc}
    470a:	nop

0000470c <FsVolume::begin(BlockDeviceInterface*)>:
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    470c:	push	{r4, r5, r6, lr}
  m_blockDev = blockDev;
  m_fVol = nullptr;
    470e:	movs	r6, #0
 * DEALINGS IN THE SOFTWARE.
 */
#include "FsLib.h"
FsVolume* FsVolume::m_cwv = nullptr;
//------------------------------------------------------------------------------
bool FsVolume::begin(BlockDevice* blockDev) {
    4710:	mov	r5, r0
  m_blockDev = blockDev;
    4712:	str.w	r1, [r0, #1152]	; 0x480
  m_fVol = nullptr;
    4716:	str.w	r6, [r0, #1144]	; 0x478
  m_xVol = new (m_volMem) ExFatVolume;
    471a:	mov	r1, r0
    471c:	mov.w	r0, #1144	; 0x478
    4720:	bl	47f8 <operator new(unsigned int, unsigned long*)>
    4724:	mov	r4, r0
  static const uint8_t CACHE_FOR_WRITE = CACHE_STATUS_DIRTY;
  /** Reserve cache sector for write - do not read from sector device. */
  static const uint8_t CACHE_RESERVE_FOR_WRITE
    = CACHE_STATUS_DIRTY | CACHE_OPTION_NO_READ;

  FsCache() : m_blockDev(nullptr) {
    4726:	str	r6, [r0, #4]
    invalidate();
    4728:	bl	11f8 <FsCache::invalidate()>
    472c:	add.w	r0, r4, #524	; 0x20c
  static const uint8_t CACHE_FOR_WRITE = CACHE_STATUS_DIRTY;
  /** Reserve cache sector for write - do not read from sector device. */
  static const uint8_t CACHE_RESERVE_FOR_WRITE
    = CACHE_STATUS_DIRTY | CACHE_OPTION_NO_READ;

  FsCache() : m_blockDev(nullptr) {
    4730:	str.w	r6, [r4, #528]	; 0x210
    invalidate();
    4734:	bl	11f8 <FsCache::invalidate()>
 * \class ExFatPartition
 * \brief Access exFat partitions on raw file devices.
 */
class ExFatPartition {
 public:
  ExFatPartition() : m_fatType(0) {}
    4738:	strb.w	r6, [r4, #1084]	; 0x43c
    473c:	strb.w	r6, [r4, #1137]	; 0x471
    4740:	strb.w	r6, [r4, #1138]	; 0x472
    4744:	strb.w	r6, [r4, #1139]	; 0x473
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    4748:	ldr.w	r1, [r5, #1152]	; 0x480
    474c:	str.w	r4, [r5, #1148]	; 0x47c
    4750:	mov	r0, r4
    4752:	movs	r2, #1
    4754:	bl	1354 <ExFatPartition::init(BlockDeviceInterface*, unsigned char)>
    4758:	cbnz	r0, 4796 <FsVolume::begin(BlockDeviceInterface*)+0x8a>
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    475a:	movs	r6, #0
  m_fVol = new (m_volMem) FatVolume;
    475c:	mov	r1, r5
  m_fVol = nullptr;
  m_xVol = new (m_volMem) ExFatVolume;
  if (m_xVol && m_xVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_xVol = nullptr;
    475e:	str.w	r6, [r5, #1148]	; 0x47c
  m_fVol = new (m_volMem) FatVolume;
    4762:	mov.w	r0, #1120	; 0x460
    4766:	bl	47f8 <operator new(unsigned int, unsigned long*)>
 */
class FatPartition {
 public:
  /** Create an instance of FatPartition
   */
  FatPartition() : m_fatType(0) {}
    476a:	strb	r6, [r0, #7]
    476c:	strb.w	r6, [r0, #1084]	; 0x43c
    4770:	strb.w	r6, [r0, #1085]	; 0x43d
    4774:	strb.w	r6, [r0, #1086]	; 0x43e
   * \param[in] setCwv Set current working volume if true.
   * \param[in] part partition to initialize.
   * \return true for success or false for failure.
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
    4778:	movs	r2, #1
    477a:	ldr.w	r1, [r5, #1152]	; 0x480
    477e:	str.w	r0, [r5, #1144]	; 0x478
    4782:	mov	r4, r0
    4784:	bl	3854 <FatPartition::init(BlockDeviceInterface*, unsigned char)>
    4788:	cbnz	r0, 47b4 <FsVolume::begin(BlockDeviceInterface*)+0xa8>
  if (m_fVol && m_fVol->begin(m_blockDev, false)) {
    goto done;
  }
  m_cwv = nullptr;
    478a:	ldr	r3, [pc, #64]	; (47cc <FsVolume::begin(BlockDeviceInterface*)+0xc0>)
    478c:	movs	r0, #0
    478e:	str	r0, [r3, #0]
  m_fVol = nullptr;
    4790:	str.w	r0, [r5, #1144]	; 0x478
  return false;
    4794:	pop	{r4, r5, r6, pc}
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    4796:	add.w	r6, r4, #1088	; 0x440
    479a:	mov	r0, r6
    479c:	bl	704 <ExFatFile::close()>
    return m_vwd.openRoot(this);
    47a0:	mov	r1, r4
    47a2:	mov	r0, r6
    47a4:	bl	7d8 <ExFatFile::openRoot(ExFatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    47a8:	cmp	r0, #0
    47aa:	beq.n	475a <FsVolume::begin(BlockDeviceInterface*)+0x4e>

 done:
  m_cwv = this;
    47ac:	ldr	r3, [pc, #28]	; (47cc <FsVolume::begin(BlockDeviceInterface*)+0xc0>)
  return true;
    47ae:	movs	r0, #1
  m_cwv = nullptr;
  m_fVol = nullptr;
  return false;

 done:
  m_cwv = this;
    47b0:	str	r5, [r3, #0]
  return true;
    47b2:	pop	{r4, r5, r6, pc}
  /**
   * Set volume working directory to root.
   * \return true for success or false for failure.
   */
  bool chdir() {
    m_vwd.close();
    47b4:	addw	r6, r4, #1084	; 0x43c
    47b8:	mov	r0, r6
    47ba:	bl	2638 <FatFile::close()>
    return m_vwd.openRoot(this);
    47be:	mov	r1, r4
    47c0:	mov	r0, r6
    47c2:	bl	2658 <FatFile::openRoot(FatVolume*)>
   */
  bool begin(BlockDevice* dev, bool setCwv = true, uint8_t part = 1) {
    if (!init(dev, part)) {
      return false;
    }
    if (!chdir()) {
    47c6:	cmp	r0, #0
    47c8:	bne.n	47ac <FsVolume::begin(BlockDeviceInterface*)+0xa0>
    47ca:	b.n	478a <FsVolume::begin(BlockDeviceInterface*)+0x7e>
    47cc:	.word	0x1fff13cc

000047d0 <FsVolume::open(char const*, int)>:
bool FsVolume::ls(print_t* pr, const char* path, uint8_t flags) {
  FsBaseFile dir;
  return dir.open(this, path, O_RDONLY) && dir.ls(pr, flags);
}
//------------------------------------------------------------------------------
FsFile FsVolume::open(const char *path, oflag_t oflag) {
    47d0:	push	{r3, r4, r5, r6, r7, lr}
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
    47d2:	movs	r5, #0
    47d4:	mov.w	r7, #1000	; 0x3e8
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    47d8:	ldr	r6, [pc, #24]	; (47f4 <FsVolume::open(char const*, int)+0x24>)
    47da:	str	r7, [r0, #8]
    47dc:	mov	r4, r0
    47de:	strb	r5, [r0, #4]
    47e0:	strb	r5, [r0, #12]
 * \class FsBaseFile
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  FsBaseFile() : m_fFile(nullptr), m_xFile(nullptr) {}
    47e2:	str	r5, [r0, #72]	; 0x48
    47e4:	str	r5, [r0, #76]	; 0x4c
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    47e6:	str.w	r6, [r0], #16
  FsFile tmpFile;
  tmpFile.open(this, path, oflag);
    47ea:	bl	462c <FsBaseFile::open(FsVolume*, char const*, int)>
  return tmpFile;
}
    47ee:	mov	r0, r4
    47f0:	pop	{r3, r4, r5, r6, r7, pc}
    47f2:	nop
    47f4:	.word	0x0000c240

000047f8 <operator new(unsigned int, unsigned long*)>:
 */
#include "FsNew.h"
void* operator new(size_t size, newalign_t* ptr) {
  (void)size;
  return ptr;
}
    47f8:	mov	r0, r1
    47fa:	bx	lr

000047fc <SdCardInterface::status()>:
   * \return The number of 512 byte data sectors in the card
   *         or zero if an error occurs.
   */
  virtual uint32_t sectorCount() = 0;
  /** \return card status. */
  virtual uint32_t status() {return 0XFFFFFFFF;}
    47fc:	mov.w	r0, #4294967295
    4800:	bx	lr
    4802:	nop

00004804 <SdSpiCard::errorCode() const>:
  /**
   * \return code for the last error. See SdCardInfo.h for a list of error codes.
   */
  uint8_t errorCode() const {
    return m_errorCode;
  }
    4804:	ldrb	r0, [r0, #16]
    4806:	bx	lr

00004808 <SdSpiCard::errorData() const>:
  /** \return error data for last error. */
  uint32_t errorData() const {
    return m_status;
  }
    4808:	ldrb	r0, [r0, #18]
    480a:	bx	lr

0000480c <SdSpiCard::readSector(unsigned long, unsigned char*)>:
   *
   * \param[in] sector Logical sector to be read.
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
    480c:	push	{r4}
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    480e:	ldr	r4, [r0, #0]
    4810:	ldr	r4, [r4, #12]
    4812:	movs	r3, #1
    4814:	mov	ip, r4
#else  // ENABLE_DEDICATED_SPI
    return readSingle(sector, dst);
#endif  // ENABLE_DEDICATED_SPI
  }
    4816:	ldr.w	r4, [sp], #4
   * \param[out] dst Pointer to the location that will receive the data.
   * \return true for success or false for failure.
   */
  bool readSector(uint32_t sector, uint8_t* dst) {
#if ENABLE_DEDICATED_SPI
    return readSectors(sector, dst, 1);
    481a:	bx	ip

0000481c <SdSpiCard::type() const>:
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
  }
    481c:	ldrb	r0, [r0, #19]
    481e:	bx	lr

00004820 <SdSpiCard::writeSector(unsigned long, unsigned char const*)>:
   *
   * \param[in] sector Logical sector to be written.
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
    4820:	push	{r4}
#if ENABLE_DEDICATED_SPI
    return writeSectors(sector, src, 1);
    4822:	ldr	r4, [r0, #0]
    4824:	ldr	r4, [r4, #28]
    4826:	movs	r3, #1
    4828:	mov	ip, r4
#else  // ENABLE_DEDICATED_SPI
    return writeSingle(sector, src);
#endif  // ENABLE_DEDICATED_SPI
  }
    482a:	ldr.w	r4, [sp], #4
   * \param[in] src Pointer to the location of the data to be written.
   * \return true for success or false for failure.
   */
  bool writeSector(uint32_t sector, const uint8_t* src) {
#if ENABLE_DEDICATED_SPI
    return writeSectors(sector, src, 1);
    482e:	bx	ip

00004830 <SdSpiCard::~SdSpiCard()>:
/**
 * \class SdSpiCard
 * \brief Raw access to SD and SDHC flash memory cards via SPI protocol.
 */
#if HAS_SDIO_CLASS
class SdSpiCard : public SdCardInterface {
    4830:	bx	lr
    4832:	nop

00004834 <SdSpiCard::~SdSpiCard()>:
    4834:	push	{r4, lr}
    4836:	movs	r1, #20
    4838:	mov	r4, r0
    483a:	bl	ae4c <operator delete(void*, unsigned int)>
    483e:	mov	r0, r4
    4840:	pop	{r4, pc}
    4842:	nop

00004844 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
  m_curState = IDLE_STATE;
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    4844:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4848:	mov	r6, r1
  #if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    484a:	ldrb	r1, [r0, #8]
    484c:	cmp	r1, #2
  m_curState = IDLE_STATE;
#endif  // ENABLE_DEDICATED_SPI
  return true;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
    484e:	mov	r4, r0
    4850:	mov	r5, r2
    4852:	mov	r7, r3
  #if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    4854:	beq.n	4866 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x22>
    if (!syncDevice()) {
    4856:	ldr	r3, [r4, #0]
    4858:	mov	r0, r4
    485a:	ldr	r3, [r3, #20]
    485c:	blx	r3
    485e:	cbnz	r0, 4898 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x54>
      return false;
    4860:	movs	r0, #0
    4862:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return true;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeSectors(uint32_t sector, const uint8_t* src, size_t ns) {
  #if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    4866:	ldr	r3, [r0, #4]
    4868:	cmp	r3, r6
    486a:	bne.n	4856 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x12>
      return false;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    486c:	movs	r6, #0
    486e:	cbz	r7, 4888 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x44>
    if (!writeData(src)) {
    4870:	ldr	r3, [r4, #0]
    4872:	mov	r1, r5
    4874:	ldr	r3, [r3, #68]	; 0x44
    4876:	mov	r0, r4
    4878:	blx	r3
      return false;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    487a:	adds	r6, #1
    487c:	add.w	r5, r5, #512	; 0x200
    if (!writeData(src)) {
    4880:	cmp	r0, #0
    4882:	beq.n	4860 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x1c>
      return false;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
  }
  for (size_t i = 0; i < ns; i++, src += 512) {
    4884:	cmp	r7, r6
    4886:	bne.n	4870 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x2c>
    if (!writeData(src)) {
      return false;
    }
  }
  m_curSector += ns;
    4888:	ldr	r3, [r4, #4]
  return m_sharedSpi ? syncDevice() : true;
    488a:	ldrb	r2, [r4, #9]
  for (size_t i = 0; i < ns; i++, src += 512) {
    if (!writeData(src)) {
      return false;
    }
  }
  m_curSector += ns;
    488c:	add	r7, r3
    488e:	str	r7, [r4, #4]
  return m_sharedSpi ? syncDevice() : true;
    4890:	cbnz	r2, 48ae <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x6a>
    4892:	movs	r0, #1
    4894:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  #if ENABLE_DEDICATED_SPI
  if (m_curState != WRITE_STATE || m_curSector != sector) {
    if (!syncDevice()) {
      return false;
    }
    if (!writeStart(sector)) {
    4898:	ldr	r3, [r4, #0]
    489a:	mov	r1, r6
    489c:	ldr	r3, [r3, #72]	; 0x48
    489e:	mov	r0, r4
    48a0:	blx	r3
    48a2:	cmp	r0, #0
    48a4:	beq.n	4860 <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x1c>
      return false;
    }
    m_curSector = sector;
    m_curState = WRITE_STATE;
    48a6:	movs	r3, #2
      return false;
    }
    if (!writeStart(sector)) {
      return false;
    }
    m_curSector = sector;
    48a8:	str	r6, [r4, #4]
    m_curState = WRITE_STATE;
    48aa:	strb	r3, [r4, #8]
    48ac:	b.n	486c <SdSpiCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x28>
    if (!writeData(src)) {
      return false;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    48ae:	ldr	r3, [r4, #0]
    48b0:	mov	r0, r4
    48b2:	ldr	r3, [r3, #20]

 fail:
  spiStop();
  return false;
#endif  // ENABLE_DEDICATED_SPI
}
    48b4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!writeData(src)) {
      return false;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    48b8:	bx	r3
    48ba:	nop

000048bc <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]>:
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStart() {
    48bc:	push	{r3, r4, r5, lr}
    48be:	ldr	r2, [r0, #12]
    48c0:	ldr	r3, [r2, #0]
    48c2:	ldr	r1, [r2, #4]
    48c4:	mov	r4, r0

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    48c6:	ldrb	r0, [r3, #11]
    48c8:	cbz	r0, 490c <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]+0x50>
			__disable_irq();
    48ca:	cpsid	i
			if (interruptMasksUsed & 0x01) {
    48cc:	ldrb	r2, [r3, #11]
    48ce:	lsls	r0, r2, #31
    48d0:	bpl.n	48e0 <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]+0x24>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    48d2:	ldr	r0, [pc, #108]	; (4940 <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]+0x84>)
    48d4:	ldr	r2, [r3, #12]
    48d6:	ldr	r5, [r0, #0]
    48d8:	ands	r2, r5
    48da:	str	r2, [r3, #28]
				NVIC_ICER0 = interruptSave[0];
    48dc:	str	r2, [r0, #0]
    48de:	ldrb	r2, [r3, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    48e0:	lsls	r5, r2, #30
    48e2:	bpl.n	48f2 <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]+0x36>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    48e4:	ldr	r0, [pc, #92]	; (4944 <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]+0x88>)
    48e6:	ldr	r2, [r3, #16]
    48e8:	ldr	r5, [r0, #0]
    48ea:	ands	r2, r5
    48ec:	str	r2, [r3, #32]
				NVIC_ICER1 = interruptSave[1];
    48ee:	str	r2, [r0, #0]
    48f0:	ldrb	r2, [r3, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    48f2:	lsls	r0, r2, #29
    48f4:	bpl.n	4904 <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]+0x48>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    48f6:	ldr	r0, [pc, #80]	; (4948 <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]+0x8c>)
    48f8:	ldr	r2, [r3, #20]
    48fa:	ldr	r5, [r0, #0]
    48fc:	ands	r2, r5
    48fe:	str	r2, [r3, #36]	; 0x24
				NVIC_ICER2 = interruptSave[2];
    4900:	str	r2, [r0, #0]
    4902:	ldrb	r2, [r3, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    4904:	lsls	r2, r2, #28
    4906:	bmi.n	4932 <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]+0x76>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
				NVIC_ICER3 = interruptSave[3];
			}
			#endif
			__enable_irq();
    4908:	cpsie	i
    490a:	ldr	r2, [r4, #12]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    490c:	ldr	r3, [r3, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
    490e:	ldr	r0, [r3, #12]
    4910:	cmp	r0, r1
    4912:	beq.n	4924 <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]+0x68>
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
    4914:	ldr	r5, [pc, #52]	; (494c <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]+0x90>)
    4916:	str	r5, [r3, #0]
			port().CTAR0 = settings.ctar;
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    4918:	ldr	r0, [pc, #52]	; (4950 <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]+0x94>)
		}
		inTransactionFlag = 1;
		#endif
		if (port().CTAR0 != settings.ctar) {
			port().MCR = SPI_MCR_MDIS | SPI_MCR_HALT | SPI_MCR_PCSIS(0x3F);
			port().CTAR0 = settings.ctar;
    491a:	str	r1, [r3, #12]
			port().CTAR1 = settings.ctar| SPI_CTAR_FMSZ(8);
    491c:	orr.w	r5, r1, #1073741824	; 0x40000000
    4920:	str	r5, [r3, #16]
			port().MCR = SPI_MCR_MSTR | SPI_MCR_PCSIS(0x3F);
    4922:	str	r0, [r3, #0]
      m_spi->transfer(buf[i]);
    }
  }
  /** Set CS low. */
  void select() {
    digitalWrite(m_csPin, LOW);
    4924:	ldrb	r0, [r2, #8]
    4926:	movs	r1, #0
    4928:	bl	99f0 <digitalWrite>
  if (!m_spiActive) {
    spiActivate();
    spiSelect();
    m_spiActive = true;
    492c:	movs	r3, #1
    492e:	strb	r3, [r4, #17]
    4930:	pop	{r3, r4, r5, pc}
				NVIC_ICER2 = interruptSave[2];
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    4932:	ldr	r0, [pc, #32]	; (4954 <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]+0x98>)
    4934:	ldr	r2, [r3, #24]
    4936:	ldr	r5, [r0, #0]
    4938:	ands	r2, r5
    493a:	str	r2, [r3, #40]	; 0x28
				NVIC_ICER3 = interruptSave[3];
    493c:	str	r2, [r0, #0]
    493e:	b.n	4908 <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]+0x4c>
    4940:	.word	0xe000e180
    4944:	.word	0xe000e184
    4948:	.word	0xe000e188
    494c:	.word	0x003f4001
    4950:	.word	0x803f0000
    4954:	.word	0xe000e18c

00004958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>:
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
    4958:	push	{r4, lr}
    495a:	ldr	r3, [r0, #12]
    495c:	mov	r4, r0
  void setHighSpeed(SdSpiConfig spiConfig) {
    m_spiSettings = spiConfig.hsSettings;
  }
  /** Set CS high. */
  void unselect() {
    digitalWrite(m_csPin, HIGH);
    495e:	movs	r1, #1
    4960:	ldrb	r0, [r3, #8]
    4962:	bl	99f0 <digitalWrite>
    4966:	ldr	r3, [r4, #12]
    4968:	ldr	r1, [r3, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    496a:	ldr	r2, [r1, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    496c:	mov.w	r0, #2147483648	; 0x80000000
		port().PUSHR = data;
    4970:	movs	r3, #255	; 0xff
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4972:	str	r0, [r2, #44]	; 0x2c
		port().PUSHR = data;
    4974:	str	r3, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4976:	ldr	r3, [r2, #44]	; 0x2c
    4978:	cmp	r3, #0
    497a:	bge.n	4976 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]+0x1e>
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    497c:	ldrb	r3, [r1, #11]
	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
		port().PUSHR = data;
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
    497e:	ldr	r2, [r2, #56]	; 0x38
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
    4980:	cbz	r3, 49b0 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]+0x58>
			if (interruptMasksUsed & 0x01) {
    4982:	lsls	r2, r3, #31
    4984:	bpl.n	498e <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]+0x36>
				NVIC_ISER0 = interruptSave[0];
    4986:	ldr	r3, [pc, #48]	; (49b8 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]+0x60>)
    4988:	ldr	r2, [r1, #28]
    498a:	str	r2, [r3, #0]
    498c:	ldrb	r3, [r1, #11]
			}
			#if NVIC_NUM_INTERRUPTS > 32
			if (interruptMasksUsed & 0x02) {
    498e:	lsls	r0, r3, #30
    4990:	bpl.n	499a <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]+0x42>
				NVIC_ISER1 = interruptSave[1];
    4992:	ldr	r3, [pc, #40]	; (49bc <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]+0x64>)
    4994:	ldr	r2, [r1, #32]
    4996:	str	r2, [r3, #0]
    4998:	ldrb	r3, [r1, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 64 && defined(NVIC_ISER2)
			if (interruptMasksUsed & 0x04) {
    499a:	lsls	r2, r3, #29
    499c:	bpl.n	49a6 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]+0x4e>
				NVIC_ISER2 = interruptSave[2];
    499e:	ldr	r3, [pc, #32]	; (49c0 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]+0x68>)
    49a0:	ldr	r2, [r1, #36]	; 0x24
    49a2:	str	r2, [r3, #0]
    49a4:	ldrb	r3, [r1, #11]
			}
			#endif
			#if NVIC_NUM_INTERRUPTS > 96 && defined(NVIC_ISER3)
			if (interruptMasksUsed & 0x08) {
    49a6:	lsls	r3, r3, #28
    49a8:	bpl.n	49b0 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]+0x58>
				NVIC_ISER3 = interruptSave[3];
    49aa:	ldr	r3, [pc, #24]	; (49c4 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]+0x6c>)
    49ac:	ldr	r2, [r1, #40]	; 0x28
    49ae:	str	r2, [r3, #0]
  if (m_spiActive) {
    spiUnselect();
    spiSend(0XFF);
    spiDeactivate();
    m_spiActive = false;
    49b0:	movs	r3, #0
    49b2:	strb	r3, [r4, #17]
    49b4:	pop	{r4, pc}
    49b6:	nop
    49b8:	.word	0xe000e100
    49bc:	.word	0xe000e104
    49c0:	.word	0xe000e108
    49c4:	.word	0xe000e10c

000049c8 <SdSpiCard::isBusy()>:
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    49c8:	push	{r4, r5, r6, lr}
  bool rtn = true;
  bool spiActive = m_spiActive;
    49ca:	ldrb	r6, [r0, #17]
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    49cc:	mov	r5, r0
  bool rtn = true;
  bool spiActive = m_spiActive;
  if (!spiActive) {
    49ce:	cbnz	r6, 49d4 <SdSpiCard::isBusy()+0xc>
    49d0:	bl	48bc <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]>
    49d4:	ldr	r3, [r5, #12]
    49d6:	ldr	r3, [r3, #0]
    49d8:	ldr	r2, [r3, #0]
bool SdSpiCard::eraseSingleSectorEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
    49da:	movs	r1, #8
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    49dc:	mov.w	r4, #2147483648	; 0x80000000
		port().PUSHR = data;
    49e0:	movs	r0, #255	; 0xff
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    49e2:	str	r4, [r2, #44]	; 0x2c
		port().PUSHR = data;
    49e4:	str	r0, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    49e6:	ldr	r3, [r2, #44]	; 0x2c
    49e8:	cmp	r3, #0
    49ea:	bge.n	49e6 <SdSpiCard::isBusy()+0x1e>
		return port().POPR;
    49ec:	ldr	r3, [r2, #56]	; 0x38
  bool spiActive = m_spiActive;
  if (!spiActive) {
    spiStart();
  }
  for (uint8_t i = 0; i < 8; i++) {
    if (0XFF == spiReceive()) {
    49ee:	uxtb	r3, r3
    49f0:	cmp	r3, #255	; 0xff
    49f2:	beq.n	4a12 <SdSpiCard::isBusy()+0x4a>
    49f4:	subs	r3, r1, #1
  bool rtn = true;
  bool spiActive = m_spiActive;
  if (!spiActive) {
    spiStart();
  }
  for (uint8_t i = 0; i < 8; i++) {
    49f6:	ands.w	r1, r3, #255	; 0xff
    49fa:	bne.n	49e2 <SdSpiCard::isBusy()+0x1a>
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::isBusy() {
  bool rtn = true;
    49fc:	movs	r4, #1
    if (0XFF == spiReceive()) {
      rtn = false;
      break;
    }
  }
  if (!spiActive) {
    49fe:	cbnz	r6, 4a04 <SdSpiCard::isBusy()+0x3c>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4a00:	ldrb	r3, [r5, #17]
    4a02:	cbnz	r3, 4a08 <SdSpiCard::isBusy()+0x40>
  }
  if (!spiActive) {
    spiStop();
  }
  return rtn;
}
    4a04:	mov	r0, r4
    4a06:	pop	{r4, r5, r6, pc}
    4a08:	mov	r0, r5
    4a0a:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
    4a0e:	mov	r0, r4
    4a10:	pop	{r4, r5, r6, pc}
  if (!spiActive) {
    spiStart();
  }
  for (uint8_t i = 0; i < 8; i++) {
    if (0XFF == spiReceive()) {
      rtn = false;
    4a12:	movs	r4, #0
    4a14:	b.n	49fe <SdSpiCard::isBusy()+0x36>
    4a16:	nop

00004a18 <SdSpiCard::readData(unsigned char*, unsigned int)>:
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t *dst) {
  return readData(dst, 512);
}
//------------------------------------------------------------------------------
bool SdSpiCard::readData(uint8_t* dst, size_t count) {
    4a18:	push	{r4, r5, r6, r7, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4a1a:	ldr	r7, [pc, #184]	; (4ad4 <SdSpiCard::readData(unsigned char*, unsigned int)+0xbc>)
    4a1c:	ldr	r5, [r0, #12]
    4a1e:	ldr	r3, [r7, #0]
    4a20:	sub	sp, #12
    4a22:	mov	lr, r1
    4a24:	str	r3, [sp, #0]
	return ret;
    4a26:	ldr	r6, [sp, #0]
    4a28:	mov	ip, r2

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  uint16_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
    4a2a:	uxth	r6, r6
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4a2c:	mov.w	r1, #2147483648	; 0x80000000
		port().PUSHR = data;
    4a30:	movs	r2, #255	; 0xff
    4a32:	ldr	r3, [r5, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    4a34:	ldr	r4, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4a36:	str	r1, [r4, #44]	; 0x2c
		port().PUSHR = data;
    4a38:	str	r2, [r4, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4a3a:	ldr	r3, [r4, #44]	; 0x2c
    4a3c:	cmp	r3, #0
    4a3e:	bge.n	4a3a <SdSpiCard::readData(unsigned char*, unsigned int)+0x22>
		return port().POPR;
    4a40:	ldr	r3, [r4, #56]	; 0x38
    4a42:	uxtb	r3, r3
#endif  // USE_SD_CRC

  DBG_BEGIN_TIME(DBG_WAIT_READ);
  // wait for start sector token
  uint16_t t0 = SysCall::curTimeMS();
  while ((m_status = spiReceive()) == 0XFF) {
    4a44:	cmp	r3, #255	; 0xff
    4a46:	strb	r3, [r0, #18]
    4a48:	bne.n	4a6e <SdSpiCard::readData(unsigned char*, unsigned int)+0x56>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4a4a:	ldr	r3, [r7, #0]
    4a4c:	str	r3, [sp, #4]
	return ret;
    4a4e:	ldr	r3, [sp, #4]
    if (isTimedOut(t0, SD_READ_TIMEOUT)) {
    4a50:	uxth	r3, r3
    4a52:	subs	r3, r3, r6
    4a54:	cmp.w	r3, #300	; 0x12c
    4a58:	ble.n	4a32 <SdSpiCard::readData(unsigned char*, unsigned int)+0x1a>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    4a5a:	movs	r3, #29
    4a5c:	strb	r3, [r0, #16]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4a5e:	ldrb	r3, [r0, #17]
    4a60:	cbz	r3, 4a68 <SdSpiCard::readData(unsigned char*, unsigned int)+0x50>
    4a62:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
#endif  // USE_SD_CRC
  return true;

fail:
  spiStop();
  return false;
    4a66:	movs	r3, #0
}
    4a68:	mov	r0, r3
    4a6a:	add	sp, #12
    4a6c:	pop	{r4, r5, r6, r7, pc}
      error(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  DBG_END_TIME(DBG_WAIT_READ);
  if (m_status != DATA_START_SECTOR) {
    4a6e:	cmp	r3, #254	; 0xfe
    4a70:	beq.n	4a78 <SdSpiCard::readData(unsigned char*, unsigned int)+0x60>
    4a72:	movs	r3, #24
    4a74:	strb	r3, [r0, #16]
    4a76:	b.n	4a5e <SdSpiCard::readData(unsigned char*, unsigned int)+0x46>
  * \param[in] n Number of bytes to receive.
  *
  * \return Zero for no error or nonzero error code.
  */
  uint8_t receive(uint8_t* buf, size_t n) {
    for (size_t i = 0; i < n; i++) {
    4a78:	cmp.w	ip, #0
    4a7c:	beq.n	4aa0 <SdSpiCard::readData(unsigned char*, unsigned int)+0x88>
    4a7e:	add	ip, lr
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4a80:	mov.w	r4, #2147483648	; 0x80000000
		port().PUSHR = data;
    4a84:	movs	r1, #255	; 0xff
    4a86:	ldr	r3, [r5, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    4a88:	ldr	r2, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4a8a:	str	r4, [r2, #44]	; 0x2c
		port().PUSHR = data;
    4a8c:	str	r1, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4a8e:	ldr	r3, [r2, #44]	; 0x2c
    4a90:	cmp	r3, #0
    4a92:	bge.n	4a8e <SdSpiCard::readData(unsigned char*, unsigned int)+0x76>
		return port().POPR;
    4a94:	ldr	r3, [r2, #56]	; 0x38
      buf[i] = m_spi->transfer(0XFF);
    4a96:	strb.w	r3, [lr], #1
  * \param[in] n Number of bytes to receive.
  *
  * \return Zero for no error or nonzero error code.
  */
  uint8_t receive(uint8_t* buf, size_t n) {
    for (size_t i = 0; i < n; i++) {
    4a9a:	cmp	ip, lr
    4a9c:	bne.n	4a86 <SdSpiCard::readData(unsigned char*, unsigned int)+0x6e>
    4a9e:	ldr	r5, [r0, #12]
    error(SD_CARD_ERROR_READ_TOKEN);
    goto fail;
  }
  // transfer data
  if ((m_status = spiReceive(dst, count))) {
    4aa0:	movs	r3, #0
    4aa2:	strb	r3, [r0, #18]
    4aa4:	ldr	r3, [r5, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    4aa6:	ldr	r3, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4aa8:	mov.w	r1, #2147483648	; 0x80000000
		port().PUSHR = data;
    4aac:	movs	r2, #255	; 0xff
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4aae:	str	r1, [r3, #44]	; 0x2c
		port().PUSHR = data;
    4ab0:	str	r2, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4ab2:	ldr	r2, [r3, #44]	; 0x2c
    4ab4:	cmp	r2, #0
    4ab6:	bge.n	4ab2 <SdSpiCard::readData(unsigned char*, unsigned int)+0x9a>
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4ab8:	mov.w	r1, #2147483648	; 0x80000000
		port().PUSHR = data;
    4abc:	movs	r2, #255	; 0xff
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
    4abe:	ldr	r0, [r3, #56]	; 0x38
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4ac0:	str	r1, [r3, #44]	; 0x2c
		port().PUSHR = data;
    4ac2:	str	r2, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4ac4:	ldr	r2, [r3, #44]	; 0x2c
    4ac6:	cmp	r2, #0
    4ac8:	bge.n	4ac4 <SdSpiCard::readData(unsigned char*, unsigned int)+0xac>
		return port().POPR;
    4aca:	ldr	r3, [r3, #56]	; 0x38
#else  // USE_SD_CRC
  // discard crc
  spiReceive();
  spiReceive();
#endif  // USE_SD_CRC
  return true;
    4acc:	movs	r3, #1

fail:
  spiStop();
  return false;
}
    4ace:	mov	r0, r3
    4ad0:	add	sp, #12
    4ad2:	pop	{r4, r5, r6, r7, pc}
    4ad4:	.word	0x1fff1998

00004ad8 <SdSpiCard::waitNotBusy(unsigned short)>:
    m_spiActive = false;
  }
}
//------------------------------------------------------------------------------
// wait for card to go not busy
bool SdSpiCard::waitNotBusy(uint16_t timeoutMS) {
    4ad8:	push	{r4, r5, r6}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4ada:	ldr	r4, [pc, #72]	; (4b24 <SdSpiCard::waitNotBusy(unsigned short)+0x4c>)
    4adc:	ldr	r3, [r0, #12]
    4ade:	ldr	r2, [r4, #0]
    4ae0:	ldr	r3, [r3, #0]
    4ae2:	sub	sp, #12
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4ae4:	mov.w	r6, #2147483648	; 0x80000000
    4ae8:	str	r2, [sp, #0]
	return ret;
    4aea:	ldr	r0, [sp, #0]
    4aec:	ldr	r2, [r3, #0]
  }
  return false;
#else  // WDT_YIELD_TIME_MICROS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
    4aee:	uxth	r0, r0
		port().PUSHR = data;
    4af0:	movs	r5, #255	; 0xff
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4af2:	str	r6, [r2, #44]	; 0x2c
		port().PUSHR = data;
    4af4:	str	r5, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4af6:	ldr	r3, [r2, #44]	; 0x2c
    4af8:	cmp	r3, #0
    4afa:	bge.n	4af6 <SdSpiCard::waitNotBusy(unsigned short)+0x1e>
		return port().POPR;
    4afc:	ldr	r3, [r2, #56]	; 0x38
    }
  }
  return false;
#else  // WDT_YIELD_TIME_MICROS
  // Check not busy first since yield is not called in isTimedOut.
  while (spiReceive() != 0XFF) {
    4afe:	uxtb	r3, r3
    4b00:	cmp	r3, #255	; 0xff
    4b02:	beq.n	4b1a <SdSpiCard::waitNotBusy(unsigned short)+0x42>
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    4b04:	ldr	r3, [r4, #0]
    4b06:	str	r3, [sp, #4]
	return ret;
    4b08:	ldr	r3, [sp, #4]
    if (isTimedOut(t0, timeoutMS)) {
    4b0a:	uxth	r3, r3
    4b0c:	subs	r3, r3, r0
    4b0e:	cmp	r3, r1
    4b10:	ble.n	4af2 <SdSpiCard::waitNotBusy(unsigned short)+0x1a>
      return false;
    4b12:	movs	r0, #0
    }
  }
  return true;
#endif  // WDT_YIELD_TIME_MICROS
}
    4b14:	add	sp, #12
    4b16:	pop	{r4, r5, r6}
    4b18:	bx	lr
  while (spiReceive() != 0XFF) {
    if (isTimedOut(t0, timeoutMS)) {
      return false;
    }
  }
  return true;
    4b1a:	movs	r0, #1
#endif  // WDT_YIELD_TIME_MICROS
}
    4b1c:	add	sp, #12
    4b1e:	pop	{r4, r5, r6}
    4b20:	bx	lr
    4b22:	nop
    4b24:	.word	0x1fff1998

00004b28 <SdSpiCard::cardCommand(unsigned char, unsigned long)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    4b28:	push	{r4, r5, r6, r7, lr}
  // select card
  if (!m_spiActive) {
    4b2a:	ldrb	r3, [r0, #17]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t SdSpiCard::cardCommand(uint8_t cmd, uint32_t arg) {
    4b2c:	sub	sp, #12
    4b2e:	mov	r4, r0
    4b30:	mov	r6, r1
    4b32:	str	r2, [sp, #4]
  // select card
  if (!m_spiActive) {
    4b34:	cbnz	r3, 4b3a <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x12>
    4b36:	bl	48bc <SdSpiCard::spiStart() [clone .part.23] [clone .constprop.40]>
    spiStart();
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    4b3a:	cmp	r6, #0
    4b3c:	bne.n	4bcc <SdSpiCard::cardCommand(unsigned char, unsigned long)+0xa4>
    4b3e:	ldr	r5, [r4, #12]
    4b40:	ldr	r3, [r5, #0]
    4b42:	ldr	r3, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4b44:	mov.w	r1, #2147483648	; 0x80000000
		port().PUSHR = data;
    4b48:	orr.w	r2, r6, #64	; 0x40
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4b4c:	str	r1, [r3, #44]	; 0x2c
		port().PUSHR = data;
    4b4e:	str	r2, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4b50:	ldr	r2, [r3, #44]	; 0x2c
    4b52:	cmp	r2, #0
    4b54:	bge.n	4b50 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x28>
		return port().POPR;
    4b56:	ldr	r2, [r3, #56]	; 0x38
    4b58:	add	r7, sp, #4
    4b5a:	add	r1, sp, #8
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4b5c:	mov.w	r0, #2147483648	; 0x80000000
  spiSend(cmd | 0x40);

  // send argument
  uint8_t *pa = reinterpret_cast<uint8_t *>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    spiSend(pa[i]);
    4b60:	ldrb.w	r2, [r1, #-1]!
    4b64:	str	r0, [r3, #44]	; 0x2c
		port().PUSHR = data;
    4b66:	str	r2, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4b68:	ldr	r2, [r3, #44]	; 0x2c
    4b6a:	cmp	r2, #0
    4b6c:	bge.n	4b68 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x40>
  // send command
  spiSend(cmd | 0x40);

  // send argument
  uint8_t *pa = reinterpret_cast<uint8_t *>(&arg);
  for (int8_t i = 3; i >= 0; i--) {
    4b6e:	cmp	r1, r7
		return port().POPR;
    4b70:	ldr	r2, [r3, #56]	; 0x38
    4b72:	bne.n	4b60 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x38>
    spiSend(pa[i]);
  }

  // send CRC - correct for CMD0 with arg zero or CMD8 with arg 0X1AA
  spiSend(cmd == CMD0 ? 0X95 : 0X87);
    4b74:	cmp	r6, #0
    4b76:	ite	ne
    4b78:	movne	r2, #135	; 0x87
    4b7a:	moveq	r2, #149	; 0x95
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4b7c:	mov.w	r1, #2147483648	; 0x80000000
    4b80:	str	r1, [r3, #44]	; 0x2c
		port().PUSHR = data;
    4b82:	str	r2, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4b84:	ldr	r2, [r3, #44]	; 0x2c
    4b86:	cmp	r2, #0
    4b88:	bge.n	4b84 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x5c>
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4b8a:	mov.w	r1, #2147483648	; 0x80000000
		port().PUSHR = data;
    4b8e:	movs	r2, #255	; 0xff
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
    4b90:	ldr	r0, [r3, #56]	; 0x38
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4b92:	str	r1, [r3, #44]	; 0x2c
		port().PUSHR = data;
    4b94:	str	r2, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4b96:	ldr	r2, [r3, #44]	; 0x2c
    4b98:	cmp	r2, #0
    4b9a:	bge.n	4b96 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x6e>
		return port().POPR;
    4b9c:	ldr	r2, [r3, #56]	; 0x38
    4b9e:	movs	r1, #11
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4ba0:	mov.w	r7, #2147483648	; 0x80000000
		port().PUSHR = data;
    4ba4:	movs	r6, #255	; 0xff
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4ba6:	str	r7, [r3, #44]	; 0x2c
		port().PUSHR = data;
    4ba8:	str	r6, [r3, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4baa:	ldr	r2, [r3, #44]	; 0x2c
    4bac:	cmp	r2, #0
    4bae:	bge.n	4baa <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x82>
		return port().POPR;
    4bb0:	ldr	r3, [r3, #56]	; 0x38
    4bb2:	uxtb	r0, r3

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    4bb4:	lsls	r3, r3, #24
    4bb6:	strb	r0, [r4, #18]
    4bb8:	bmi.n	4bbe <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x96>
  }
  return m_status;
}
    4bba:	add	sp, #12
    4bbc:	pop	{r4, r5, r6, r7, pc}
    4bbe:	subs	r3, r1, #1

  // discard first fill byte to avoid MISO pull-up problem.
  spiReceive();

  // there are 1-8 fill bytes before response.  fill bytes should be 0XFF.
  for (uint8_t i = 0; ((m_status = spiReceive()) & 0X80) && i < 10; i++) {
    4bc0:	ands.w	r1, r3, #255	; 0xff
    4bc4:	beq.n	4bba <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x92>
    4bc6:	ldr	r3, [r5, #0]
    4bc8:	ldr	r3, [r3, #0]
    4bca:	b.n	4ba6 <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x7e>
    spiStart();
  }
  // wait if busy unless CMD0
  if (cmd != CMD0) {
    DBG_BEGIN_TIME(DBG_CMD_BUSY);
    waitNotBusy(SD_CMD_TIMEOUT);
    4bcc:	mov.w	r1, #300	; 0x12c
    4bd0:	mov	r0, r4
    4bd2:	bl	4ad8 <SdSpiCard::waitNotBusy(unsigned short)>
    4bd6:	b.n	4b3e <SdSpiCard::cardCommand(unsigned char, unsigned long)+0x16>

00004bd8 <SdSpiCard::readOCR(unsigned long*)>:
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
  uint8_t *p = reinterpret_cast<uint8_t*>(ocr);
  syncDevice();
    4bd8:	ldr	r3, [r0, #0]
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    4bda:	push	{r4, r5, r6, lr}
  uint8_t *p = reinterpret_cast<uint8_t*>(ocr);
  syncDevice();
    4bdc:	ldr	r3, [r3, #20]
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readOCR(uint32_t* ocr) {
    4bde:	mov	r4, r0
    4be0:	mov	r5, r1
  uint8_t *p = reinterpret_cast<uint8_t*>(ocr);
  syncDevice();
    4be2:	blx	r3
  if (cardCommand(CMD58, 0)) {
    4be4:	mov	r0, r4
    4be6:	movs	r2, #0
    4be8:	movs	r1, #58	; 0x3a
    4bea:	bl	4b28 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    4bee:	cbnz	r0, 4c1c <SdSpiCard::readOCR(unsigned long*)+0x44>
    4bf0:	adds	r1, r5, #4
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4bf2:	mov.w	r6, #2147483648	; 0x80000000
		port().PUSHR = data;
    4bf6:	movs	r0, #255	; 0xff
    4bf8:	ldr	r3, [r4, #12]
    4bfa:	ldr	r3, [r3, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    4bfc:	ldr	r2, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4bfe:	str	r6, [r2, #44]	; 0x2c
		port().PUSHR = data;
    4c00:	str	r0, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4c02:	ldr	r3, [r2, #44]	; 0x2c
    4c04:	cmp	r3, #0
    4c06:	bge.n	4c02 <SdSpiCard::readOCR(unsigned long*)+0x2a>
		return port().POPR;
    4c08:	ldr	r3, [r2, #56]	; 0x38
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    p[3 - i] = spiReceive();
    4c0a:	strb.w	r3, [r1, #-1]!
  syncDevice();
  if (cardCommand(CMD58, 0)) {
    error(SD_CARD_ERROR_CMD58);
    goto fail;
  }
  for (uint8_t i = 0; i < 4; i++) {
    4c0e:	cmp	r5, r1
    4c10:	bne.n	4bf8 <SdSpiCard::readOCR(unsigned long*)+0x20>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4c12:	ldrb	r5, [r4, #17]
    4c14:	cbnz	r5, 4c32 <SdSpiCard::readOCR(unsigned long*)+0x5a>
    4c16:	movs	r5, #1
  return true;

fail:
  spiStop();
  return false;
}
    4c18:	mov	r0, r5
    4c1a:	pop	{r4, r5, r6, pc}
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4c1c:	ldrb	r5, [r4, #17]
    4c1e:	movs	r3, #18
    4c20:	strb	r3, [r4, #16]
    4c22:	cmp	r5, #0
    4c24:	beq.n	4c18 <SdSpiCard::readOCR(unsigned long*)+0x40>
    4c26:	mov	r0, r4
  spiStop();
  return true;

fail:
  spiStop();
  return false;
    4c28:	movs	r5, #0
    4c2a:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
}
    4c2e:	mov	r0, r5
    4c30:	pop	{r4, r5, r6, pc}
    4c32:	mov	r0, r4
    4c34:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
    4c38:	mov	r0, r5
    4c3a:	pop	{r4, r5, r6, pc}

00004c3c <SdSpiCard::readRegister(unsigned char, void*)>:
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  syncDevice();
    4c3c:	ldr	r3, [r0, #0]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    4c3e:	push	{r4, r5, r6, lr}
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  syncDevice();
    4c40:	ldr	r3, [r3, #20]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
/** read CID or CSR register */
bool SdSpiCard::readRegister(uint8_t cmd, void* buf) {
    4c42:	mov	r4, r0
    4c44:	mov	r5, r1
    4c46:	mov	r6, r2
  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
  syncDevice();
    4c48:	blx	r3
  if (cardCommand(cmd, 0)) {
    4c4a:	mov	r1, r5
    4c4c:	mov	r0, r4
    4c4e:	movs	r2, #0
    4c50:	bl	4b28 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    4c54:	cbz	r0, 4c68 <SdSpiCard::readRegister(unsigned char, void*)+0x2c>
    4c56:	movs	r3, #27
    4c58:	strb	r3, [r4, #16]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4c5a:	ldrb	r0, [r4, #17]
    4c5c:	cbz	r0, 4c66 <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    4c5e:	mov	r0, r4
    4c60:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
  spiStop();
  return true;

fail:
  spiStop();
  return false;
    4c64:	movs	r0, #0
}
    4c66:	pop	{r4, r5, r6, pc}
  syncDevice();
  if (cardCommand(cmd, 0)) {
    error(SD_CARD_ERROR_READ_REG);
    goto fail;
  }
  if (!readData(dst, 16)) {
    4c68:	mov	r1, r6
    4c6a:	movs	r2, #16
    4c6c:	mov	r0, r4
    4c6e:	bl	4a18 <SdSpiCard::readData(unsigned char*, unsigned int)>
    4c72:	cmp	r0, #0
    4c74:	beq.n	4c5a <SdSpiCard::readRegister(unsigned char, void*)+0x1e>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4c76:	ldrb	r5, [r4, #17]
    4c78:	cmp	r5, #0
    4c7a:	beq.n	4c66 <SdSpiCard::readRegister(unsigned char, void*)+0x2a>
    4c7c:	mov	r0, r4
    4c7e:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
    4c82:	mov	r0, r5
    4c84:	pop	{r4, r5, r6, pc}
    4c86:	nop

00004c88 <SdSpiCard::readCSD(csd_t*)>:
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    4c88:	mov	r2, r1
    4c8a:	movs	r1, #9
    4c8c:	b.w	4c3c <SdSpiCard::readRegister(unsigned char, void*)>

00004c90 <SdSpiCard::readCID(CID*)>:
   * \param[out] cid pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCID(cid_t* cid) {
    return readRegister(CMD10, cid);
    4c90:	mov	r2, r1
    4c92:	movs	r1, #10
    4c94:	b.w	4c3c <SdSpiCard::readRegister(unsigned char, void*)>

00004c98 <SdSpiCard::sectorCount()>:
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    4c98:	push	{r4, r5, lr}
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    4c9a:	ldr	r3, [r0, #0]
    4c9c:	ldr	r2, [pc, #140]	; (4d2c <SdSpiCard::sectorCount()+0x94>)
    4c9e:	ldr	r3, [r3, #52]	; 0x34
    4ca0:	cmp	r3, r2
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
    4ca2:	sub	sp, #20
    4ca4:	bne.n	4d06 <SdSpiCard::sectorCount()+0x6e>
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    4ca6:	mov	r2, sp
    4ca8:	movs	r1, #9
    4caa:	bl	4c3c <SdSpiCard::readRegister(unsigned char, void*)>
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    4cae:	cbz	r0, 4cc0 <SdSpiCard::sectorCount()+0x28>
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    4cb0:	ldrb.w	r3, [sp]
    4cb4:	ands.w	r3, r3, #192	; 0xc0
    4cb8:	beq.n	4cc4 <SdSpiCard::sectorCount()+0x2c>
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    4cba:	cmp	r3, #64	; 0x40
    4cbc:	beq.n	4d0c <SdSpiCard::sectorCount()+0x74>
    4cbe:	movs	r0, #0
}
    4cc0:	add	sp, #20
    4cc2:	pop	{r4, r5, pc}
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    4cc4:	ldrb.w	r4, [sp, #9]
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    4cc8:	ldrb.w	r3, [sp, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    4ccc:	ldrb.w	r2, [sp, #7]
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    4cd0:	ldrb.w	r0, [sp, #10]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    4cd4:	ldrb.w	r1, [sp, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    4cd8:	ldrb.w	r5, [sp, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    4cdc:	and.w	r4, r4, #3
    4ce0:	lsls	r4, r4, #1
    4ce2:	lsls	r2, r2, #2
    4ce4:	and.w	r3, r3, #3
    4ce8:	orr.w	r0, r4, r0, lsr #7
    4cec:	and.w	r1, r1, #15
    4cf0:	orr.w	r3, r2, r3, lsl #10
    4cf4:	add	r0, r1
    4cf6:	orr.w	r3, r3, r5, lsr #6
    4cfa:	adds	r3, #1
    4cfc:	subs	r0, #7
    4cfe:	lsl.w	r0, r3, r0
    4d02:	add	sp, #20
    4d04:	pop	{r4, r5, pc}
  return false;
}
//------------------------------------------------------------------------------
uint32_t SdSpiCard::sectorCount() {
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
    4d06:	mov	r1, sp
    4d08:	blx	r3
    4d0a:	b.n	4cae <SdSpiCard::sectorCount()+0x16>
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    4d0c:	ldrb.w	r3, [sp, #9]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    4d10:	ldrb.w	r1, [sp, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    4d14:	ldrb.w	r0, [sp, #8]
    4d18:	adds	r2, r3, #1
    4d1a:	and.w	r3, r1, #63	; 0x3f
    4d1e:	add.w	r3, r2, r3, lsl #16
    4d22:	add.w	r0, r3, r0, lsl #8
    4d26:	lsls	r0, r0, #10
}
    4d28:	add	sp, #20
    4d2a:	pop	{r4, r5, pc}
    4d2c:	.word	0x00004c89

00004d30 <SdSpiCard::readStart(unsigned long)>:
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    4d30:	push	{r4, r5, lr}
  if (type() != SD_CARD_TYPE_SDHC) {
    4d32:	ldr	r3, [r0, #0]
    4d34:	ldr	r5, [pc, #68]	; (4d7c <SdSpiCard::readStart(unsigned long)+0x4c>)
    4d36:	ldr	r3, [r3, #64]	; 0x40
    4d38:	cmp	r3, r5
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
    4d3a:	sub	sp, #12
    4d3c:	mov	r4, r0
    4d3e:	mov	r2, r1
    4d40:	bne.n	4d72 <SdSpiCard::readStart(unsigned long)+0x42>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    4d42:	ldrb	r0, [r0, #19]
  if (type() != SD_CARD_TYPE_SDHC) {
    4d44:	cmp	r0, #3
    sector <<= 9;
    4d46:	it	ne
    4d48:	lslne	r2, r2, #9
  }
  if (cardCommand(CMD18, sector)) {
    4d4a:	movs	r1, #18
    4d4c:	mov	r0, r4
    4d4e:	bl	4b28 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    4d52:	cbz	r0, 4d6c <SdSpiCard::readStart(unsigned long)+0x3c>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4d54:	ldrb	r0, [r4, #17]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    4d56:	movs	r3, #12
    4d58:	strb	r3, [r4, #16]
    4d5a:	cbnz	r0, 4d60 <SdSpiCard::readStart(unsigned long)+0x30>
  return true;

fail:
  spiStop();
  return false;
}
    4d5c:	add	sp, #12
    4d5e:	pop	{r4, r5, pc}
    4d60:	mov	r0, r4
    4d62:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
    4d66:	movs	r0, #0
    4d68:	add	sp, #12
    4d6a:	pop	{r4, r5, pc}
  if (cardCommand(CMD18, sector)) {
    error(SD_CARD_ERROR_CMD18);
    goto fail;
  }
//  spiStop();
  return true;
    4d6c:	movs	r0, #1

fail:
  spiStop();
  return false;
}
    4d6e:	add	sp, #12
    4d70:	pop	{r4, r5, pc}
    4d72:	str	r1, [sp, #4]
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readStart(uint32_t sector) {
  if (type() != SD_CARD_TYPE_SDHC) {
    4d74:	blx	r3
    4d76:	ldr	r2, [sp, #4]
    4d78:	b.n	4d44 <SdSpiCard::readStart(unsigned long)+0x14>
    4d7a:	nop
    4d7c:	.word	0x0000481d

00004d80 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    4d80:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4d84:	mov	r5, r1
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    4d86:	ldrb	r1, [r0, #8]
    4d88:	cmp	r1, #1
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
    4d8a:	mov	r6, r0
    4d8c:	mov	r4, r2
    4d8e:	mov	r7, r3
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    4d90:	beq.n	4da2 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x22>
    if (!syncDevice()) {
    4d92:	ldr	r3, [r6, #0]
    4d94:	mov	r0, r6
    4d96:	ldr	r3, [r3, #20]
    4d98:	blx	r3
    4d9a:	cbnz	r0, 4dd6 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x56>
      return false;
    4d9c:	movs	r0, #0
    4d9e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::readSectors(uint32_t sector, uint8_t* dst, size_t ns) {
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    4da2:	ldr	r3, [r0, #4]
    4da4:	cmp	r3, r5
    4da6:	bne.n	4d92 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x12>
      return false;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    4da8:	movs	r5, #0
    4daa:	cbz	r7, 4dc6 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x46>
    if (!readData(dst, 512)) {
    4dac:	mov	r1, r4
    4dae:	mov.w	r2, #512	; 0x200
    4db2:	mov	r0, r6
    4db4:	bl	4a18 <SdSpiCard::readData(unsigned char*, unsigned int)>
      return false;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    4db8:	adds	r5, #1
    4dba:	add.w	r4, r4, #512	; 0x200
    if (!readData(dst, 512)) {
    4dbe:	cmp	r0, #0
    4dc0:	beq.n	4d9c <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x1c>
      return false;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
  }
  for (size_t i = 0; i < ns; i++, dst += 512) {
    4dc2:	cmp	r7, r5
    4dc4:	bne.n	4dac <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x2c>
    if (!readData(dst, 512)) {
      return false;
    }
  }
  m_curSector += ns;
    4dc6:	ldr	r3, [r6, #4]
  return m_sharedSpi ? syncDevice() : true;
    4dc8:	ldrb	r2, [r6, #9]
  for (size_t i = 0; i < ns; i++, dst += 512) {
    if (!readData(dst, 512)) {
      return false;
    }
  }
  m_curSector += ns;
    4dca:	add	r7, r3
    4dcc:	str	r7, [r6, #4]
  return m_sharedSpi ? syncDevice() : true;
    4dce:	cbnz	r2, 4dea <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x6a>
    4dd0:	movs	r0, #1
    4dd2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#if ENABLE_DEDICATED_SPI
  if (m_curState != READ_STATE || sector != m_curSector) {
    if (!syncDevice()) {
      return false;
    }
    if (!SdSpiCard::readStart(sector)) {
    4dd6:	mov	r1, r5
    4dd8:	mov	r0, r6
    4dda:	bl	4d30 <SdSpiCard::readStart(unsigned long)>
    4dde:	cmp	r0, #0
    4de0:	beq.n	4d9c <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x1c>
      return false;
    }
    m_curSector = sector;
    m_curState = READ_STATE;
    4de2:	movs	r3, #1
      return false;
    }
    if (!SdSpiCard::readStart(sector)) {
      return false;
    }
    m_curSector = sector;
    4de4:	str	r5, [r6, #4]
    m_curState = READ_STATE;
    4de6:	strb	r3, [r6, #8]
    4de8:	b.n	4da8 <SdSpiCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x28>
    if (!readData(dst, 512)) {
      return false;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    4dea:	ldr	r3, [r6, #0]
    4dec:	mov	r0, r6
    4dee:	ldr	r3, [r3, #20]
      return false;
    }
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
}
    4df0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    if (!readData(dst, 512)) {
      return false;
    }
  }
  m_curSector += ns;
  return m_sharedSpi ? syncDevice() : true;
    4df4:	bx	r3
    4df6:	nop

00004df8 <SdSpiCard::readStop()>:
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}

//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    4df8:	push	{r3, r4, r5, lr}
  if (cardCommand(CMD12, 0)) {
    4dfa:	movs	r2, #0
    4dfc:	movs	r1, #12
  csd_t csd;
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}

//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
    4dfe:	mov	r5, r0
  if (cardCommand(CMD12, 0)) {
    4e00:	bl	4b28 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4e04:	ldrb	r4, [r5, #17]
  return readCSD(&csd) ? sdCardCapacity(&csd) : 0;
}

//------------------------------------------------------------------------------
bool SdSpiCard::readStop() {
  if (cardCommand(CMD12, 0)) {
    4e06:	cbz	r0, 4e12 <SdSpiCard::readStop()+0x1a>
    4e08:	movs	r3, #9
    4e0a:	strb	r3, [r5, #16]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4e0c:	cbnz	r4, 4e24 <SdSpiCard::readStop()+0x2c>
  return true;

fail:
  spiStop();
  return false;
}
    4e0e:	mov	r0, r4
    4e10:	pop	{r3, r4, r5, pc}
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4e12:	cbnz	r4, 4e1a <SdSpiCard::readStop()+0x22>
  if (cardCommand(CMD12, 0)) {
    error(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  spiStop();
  return true;
    4e14:	movs	r4, #1

fail:
  spiStop();
  return false;
}
    4e16:	mov	r0, r4
    4e18:	pop	{r3, r4, r5, pc}
    4e1a:	mov	r0, r5
    4e1c:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
    4e20:	mov	r0, r4
    4e22:	pop	{r3, r4, r5, pc}
    4e24:	mov	r0, r5
    4e26:	movs	r4, #0
    4e28:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
    4e2c:	mov	r0, r4
    4e2e:	pop	{r3, r4, r5, pc}

00004e30 <SdSpiCard::writeStart(unsigned long)>:
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    4e30:	push	{r4, r5, lr}
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    4e32:	ldr	r3, [r0, #0]
    4e34:	ldr	r5, [pc, #68]	; (4e7c <SdSpiCard::writeStart(unsigned long)+0x4c>)
    4e36:	ldr	r3, [r3, #64]	; 0x40
    4e38:	cmp	r3, r5
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
    4e3a:	sub	sp, #12
    4e3c:	mov	r4, r0
    4e3e:	mov	r2, r1
    4e40:	bne.n	4e72 <SdSpiCard::writeStart(unsigned long)+0x42>
  bool syncDevice();
  /** Return the card type: SD V1, SD V2 or SDHC/SDXC
   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC/SDXC.
   */
  uint8_t type() const {
    return m_type;
    4e42:	ldrb	r0, [r0, #19]
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    4e44:	cmp	r0, #3
    sector <<= 9;
    4e46:	it	ne
    4e48:	lslne	r2, r2, #9
  }
  if (cardCommand(CMD25, sector)) {
    4e4a:	movs	r1, #25
    4e4c:	mov	r0, r4
    4e4e:	bl	4b28 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    4e52:	cbz	r0, 4e6c <SdSpiCard::writeStart(unsigned long)+0x3c>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4e54:	ldrb	r0, [r4, #17]
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    4e56:	movs	r3, #14
    4e58:	strb	r3, [r4, #16]
    4e5a:	cbnz	r0, 4e60 <SdSpiCard::writeStart(unsigned long)+0x30>
  return true;

fail:
  spiStop();
  return false;
}
    4e5c:	add	sp, #12
    4e5e:	pop	{r4, r5, pc}
    4e60:	mov	r0, r4
    4e62:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
    4e66:	movs	r0, #0
    4e68:	add	sp, #12
    4e6a:	pop	{r4, r5, pc}
  }
  if (cardCommand(CMD25, sector)) {
    error(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  return true;
    4e6c:	movs	r0, #1

fail:
  spiStop();
  return false;
}
    4e6e:	add	sp, #12
    4e70:	pop	{r4, r5, pc}
    4e72:	str	r1, [sp, #4]
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStart(uint32_t sector) {
  // use address if not SDHC card
  if (type() != SD_CARD_TYPE_SDHC) {
    4e74:	blx	r3
    4e76:	ldr	r2, [sp, #4]
    4e78:	b.n	4e44 <SdSpiCard::writeStart(unsigned long)+0x14>
    4e7a:	nop
    4e7c:	.word	0x0000481d

00004e80 <SdSpiCard::erase(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    4e80:	push	{r4, r5, r6, r7, lr}
  csd_t csd;
  if (!readCSD(&csd)) {
    4e82:	ldr	r3, [r0, #0]
    4e84:	ldr	r7, [pc, #172]	; (4f34 <SdSpiCard::erase(unsigned long, unsigned long)+0xb4>)
    4e86:	ldr	r3, [r3, #52]	; 0x34
    4e88:	cmp	r3, r7
//------------------------------------------------------------------------------
void SdSpiCard::dbgClearStats() {::dbgClearStats();}
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
    4e8a:	sub	sp, #20
    4e8c:	mov	r4, r0
    4e8e:	mov	r5, r1
    4e90:	mov	r6, r2
    4e92:	bne.n	4ef0 <SdSpiCard::erase(unsigned long, unsigned long)+0x70>
   * \param[out] csd pointer to area for returned data.
   *
   * \return true for success or false for failure.
   */
  bool readCSD(csd_t* csd) {
    return readRegister(CMD9, csd);
    4e94:	mov	r2, sp
    4e96:	movs	r1, #9
    4e98:	bl	4c3c <SdSpiCard::readRegister(unsigned char, void*)>
  csd_t csd;
  if (!readCSD(&csd)) {
    4e9c:	cbz	r0, 4ec4 <SdSpiCard::erase(unsigned long, unsigned long)+0x44>
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    4e9e:	ldrb.w	r3, [sp, #10]
    4ea2:	lsls	r2, r3, #25
    4ea4:	bpl.n	4ed4 <SdSpiCard::erase(unsigned long, unsigned long)+0x54>
      // error card can't erase specified area
      error(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    4ea6:	ldrb	r3, [r4, #19]
    4ea8:	cmp	r3, #3
    firstSector <<= 9;
    4eaa:	it	ne
    4eac:	lslne	r5, r5, #9
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
    4eae:	mov	r2, r5
    4eb0:	mov.w	r1, #32
    4eb4:	mov	r0, r4
      goto fail;
    }
  }
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
    4eb6:	it	ne
    4eb8:	lslne	r6, r6, #9
  }
  if (cardCommand(CMD32, firstSector)
    4eba:	bl	4b28 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
      || cardCommand(CMD33, lastSector)
      || cardCommand(CMD38, 0)) {
    4ebe:	cbz	r0, 4ef6 <SdSpiCard::erase(unsigned long, unsigned long)+0x76>
  /**
   *  Set SD error code.
   *  \param[in] code value for error code.
   */
  void error(uint8_t code) {
    m_errorCode = code;
    4ec0:	movs	r3, #37	; 0x25
    4ec2:	strb	r3, [r4, #16]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4ec4:	ldrb	r0, [r4, #17]
    4ec6:	cbz	r0, 4ed0 <SdSpiCard::erase(unsigned long, unsigned long)+0x50>
    4ec8:	mov	r0, r4
    4eca:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
  spiStop();
  return true;

fail:
  spiStop();
  return false;
    4ece:	movs	r0, #0
}
    4ed0:	add	sp, #20
    4ed2:	pop	{r4, r5, r6, r7, pc}
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    4ed4:	and.w	r3, r3, #63	; 0x3f
    goto fail;
  }
  // check for single sector erase
  if (!csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    4ed8:	ldrb.w	r1, [sp, #11]
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    4edc:	lsls	r3, r3, #1
    4ede:	adds	r2, r6, #1
    4ee0:	orr.w	r3, r3, r1, lsr #7
    4ee4:	orrs	r2, r5
    4ee6:	tst	r3, r2
    4ee8:	beq.n	4ea6 <SdSpiCard::erase(unsigned long, unsigned long)+0x26>
    4eea:	movs	r3, #38	; 0x26
    4eec:	strb	r3, [r4, #16]
    4eee:	b.n	4ec4 <SdSpiCard::erase(unsigned long, unsigned long)+0x44>
//------------------------------------------------------------------------------
void SdSpiCard::dbgPrintStats() {::dbgPrintStats();}
//------------------------------------------------------------------------------
bool SdSpiCard::erase(uint32_t firstSector, uint32_t lastSector) {
  csd_t csd;
  if (!readCSD(&csd)) {
    4ef0:	mov	r1, sp
    4ef2:	blx	r3
    4ef4:	b.n	4e9c <SdSpiCard::erase(unsigned long, unsigned long)+0x1c>
  if (m_type != SD_CARD_TYPE_SDHC) {
    firstSector <<= 9;
    lastSector <<= 9;
  }
  if (cardCommand(CMD32, firstSector)
      || cardCommand(CMD33, lastSector)
    4ef6:	mov	r2, r6
    4ef8:	movs	r1, #33	; 0x21
    4efa:	mov	r0, r4
    4efc:	bl	4b28 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    4f00:	cmp	r0, #0
    4f02:	bne.n	4ec0 <SdSpiCard::erase(unsigned long, unsigned long)+0x40>
      || cardCommand(CMD38, 0)) {
    4f04:	mov	r2, r0
    4f06:	movs	r1, #38	; 0x26
    4f08:	mov	r0, r4
    4f0a:	bl	4b28 <SdSpiCard::cardCommand(unsigned char, unsigned long)>
    4f0e:	cmp	r0, #0
    4f10:	bne.n	4ec0 <SdSpiCard::erase(unsigned long, unsigned long)+0x40>
    error(SD_CARD_ERROR_ERASE);
    goto fail;
  }
  DBG_BEGIN_TIME(DBG_ERASE_BUSY);
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    4f12:	movw	r1, #10000	; 0x2710
    4f16:	mov	r0, r4
    4f18:	bl	4ad8 <SdSpiCard::waitNotBusy(unsigned short)>
    4f1c:	cbnz	r0, 4f24 <SdSpiCard::erase(unsigned long, unsigned long)+0xa4>
    4f1e:	movs	r3, #39	; 0x27
    4f20:	strb	r3, [r4, #16]
    4f22:	b.n	4ec4 <SdSpiCard::erase(unsigned long, unsigned long)+0x44>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4f24:	ldrb	r5, [r4, #17]
    4f26:	cmp	r5, #0
    4f28:	beq.n	4ed0 <SdSpiCard::erase(unsigned long, unsigned long)+0x50>
    4f2a:	mov	r0, r4
    4f2c:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
    error(SD_CARD_ERROR_ERASE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_ERASE_BUSY);
  spiStop();
  return true;
    4f30:	mov	r0, r5
    4f32:	b.n	4ed0 <SdSpiCard::erase(unsigned long, unsigned long)+0x50>
    4f34:	.word	0x00004c89

00004f38 <SdSpiCard::writeStop()>:
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    4f38:	push	{r4, r5, r6, lr}
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    4f3a:	mov.w	r1, #600	; 0x258
fail:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeStop() {
    4f3e:	mov	r4, r0
  DBG_BEGIN_TIME(DBG_WRITE_STOP);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    4f40:	bl	4ad8 <SdSpiCard::waitNotBusy(unsigned short)>
    4f44:	mov	r5, r0
    4f46:	cbz	r0, 4f68 <SdSpiCard::writeStop()+0x30>
    4f48:	ldr	r3, [r4, #12]
    4f4a:	ldr	r3, [r3, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    4f4c:	ldr	r2, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4f4e:	mov.w	r1, #2147483648	; 0x80000000
		port().PUSHR = data;
    4f52:	movs	r3, #253	; 0xfd
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4f54:	str	r1, [r2, #44]	; 0x2c
		port().PUSHR = data;
    4f56:	str	r3, [r2, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4f58:	ldr	r3, [r2, #44]	; 0x2c
    4f5a:	cmp	r3, #0
    4f5c:	bge.n	4f58 <SdSpiCard::writeStop()+0x20>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4f5e:	ldrb	r6, [r4, #17]
		return port().POPR;
    4f60:	ldr	r3, [r2, #56]	; 0x38
    4f62:	cbnz	r6, 4f7c <SdSpiCard::writeStop()+0x44>

fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
}
    4f64:	mov	r0, r5
    4f66:	pop	{r4, r5, r6, pc}
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    4f68:	ldrb	r3, [r4, #17]
    4f6a:	movs	r2, #30
    4f6c:	strb	r2, [r4, #16]
    4f6e:	cmp	r3, #0
    4f70:	beq.n	4f64 <SdSpiCard::writeStop()+0x2c>
    4f72:	mov	r0, r4
    4f74:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>

fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  spiStop();
  return false;
}
    4f78:	mov	r0, r5
    4f7a:	pop	{r4, r5, r6, pc}
    4f7c:	mov	r0, r4
    4f7e:	mov	r5, r6
    4f80:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
    4f84:	mov	r0, r5
    4f86:	pop	{r4, r5, r6, pc}

00004f88 <SdSpiCard::syncDevice()>:
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
}
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
    4f88:	push	{r4, lr}
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    4f8a:	ldrb	r3, [r0, #8]
    4f8c:	cmp	r3, #1
  }
  return readStop();
#endif  // ENABLE_DEDICATED_SPI
}
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
    4f8e:	mov	r4, r0
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    4f90:	beq.n	4f9e <SdSpiCard::syncDevice()+0x16>
    if (!SdSpiCard::readStop()) {
      return false;
    }
  } else if (m_curState == WRITE_STATE) {
    4f92:	cmp	r3, #2
    4f94:	beq.n	4faa <SdSpiCard::syncDevice()+0x22>
    if (!SdSpiCard::writeStop()) {
      return false;
    }
  }
  m_curState = IDLE_STATE;
    4f96:	movs	r3, #0
    4f98:	strb	r3, [r4, #8]
#endif  // ENABLE_DEDICATED_SPI
  return true;
    4f9a:	movs	r0, #1
    4f9c:	pop	{r4, pc}
}
//------------------------------------------------------------------------------
bool SdSpiCard::syncDevice() {
#if ENABLE_DEDICATED_SPI
  if (m_curState == READ_STATE) {
    if (!SdSpiCard::readStop()) {
    4f9e:	bl	4df8 <SdSpiCard::readStop()>
    4fa2:	cmp	r0, #0
    4fa4:	bne.n	4f96 <SdSpiCard::syncDevice()+0xe>
      return false;
    4fa6:	movs	r0, #0
    4fa8:	pop	{r4, pc}
    }
  } else if (m_curState == WRITE_STATE) {
    if (!SdSpiCard::writeStop()) {
    4faa:	bl	4f38 <SdSpiCard::writeStop()>
    4fae:	cmp	r0, #0
    4fb0:	bne.n	4f96 <SdSpiCard::syncDevice()+0xe>
    4fb2:	b.n	4fa6 <SdSpiCard::syncDevice()+0x1e>

00004fb4 <SdSpiCard::writeData(unsigned char, unsigned char const*)>:
  spiStop();
  return false;
}
//------------------------------------------------------------------------------
// send one sector of data for write sector or write multiple sectors
bool SdSpiCard::writeData(uint8_t token, const uint8_t* src) {
    4fb4:	push	{r3, r4, r5, lr}
    4fb6:	ldr	r3, [r0, #12]
    4fb8:	ldr	r3, [r3, #0]
	// setCS() is a special function, not intended for use from normal Arduino
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
	KINETISK_SPI_t & port() { return *(KINETISK_SPI_t *)port_addr; }
    4fba:	ldr	r4, [r3, #0]
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4fbc:	mov.w	r3, #2147483648	; 0x80000000
    4fc0:	str	r3, [r4, #44]	; 0x2c
		port().PUSHR = data;
    4fc2:	str	r1, [r4, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4fc4:	ldr	r3, [r4, #44]	; 0x2c
    4fc6:	cmp	r3, #0
    4fc8:	bge.n	4fc4 <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x10>
		return port().POPR;
    4fca:	ldr	r3, [r4, #56]	; 0x38
    4fcc:	subs	r1, r2, #1
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4fce:	mov.w	r5, #2147483648	; 0x80000000
    4fd2:	addw	r2, r2, #511	; 0x1ff
   * \param[in] buf Buffer for data to be sent.
   * \param[in] n Number of bytes to send.
   */
  void send(const uint8_t* buf, size_t n) {
    for (size_t i = 0; i < n; i++) {
      m_spi->transfer(buf[i]);
    4fd6:	ldrb.w	r3, [r1, #1]!
    4fda:	str	r5, [r4, #44]	; 0x2c
		port().PUSHR = data;
    4fdc:	str	r3, [r4, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4fde:	ldr	r3, [r4, #44]	; 0x2c
    4fe0:	cmp	r3, #0
    4fe2:	bge.n	4fde <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x2a>
   *
   * \param[in] buf Buffer for data to be sent.
   * \param[in] n Number of bytes to send.
   */
  void send(const uint8_t* buf, size_t n) {
    for (size_t i = 0; i < n; i++) {
    4fe4:	cmp	r1, r2
		return port().POPR;
    4fe6:	ldr	r3, [r4, #56]	; 0x38
    4fe8:	bne.n	4fd6 <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x22>
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4fea:	mov.w	r2, #2147483648	; 0x80000000
		port().PUSHR = data;
    4fee:	movs	r3, #255	; 0xff
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4ff0:	str	r2, [r4, #44]	; 0x2c
		port().PUSHR = data;
    4ff2:	str	r3, [r4, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    4ff4:	ldr	r3, [r4, #44]	; 0x2c
    4ff6:	cmp	r3, #0
    4ff8:	bge.n	4ff4 <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x40>
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    4ffa:	mov.w	r2, #2147483648	; 0x80000000
		port().PUSHR = data;
    4ffe:	movs	r3, #255	; 0xff
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
    5000:	ldr	r1, [r4, #56]	; 0x38
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    5002:	str	r2, [r4, #44]	; 0x2c
		port().PUSHR = data;
    5004:	str	r3, [r4, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    5006:	ldr	r3, [r4, #44]	; 0x2c
    5008:	cmp	r3, #0
    500a:	bge.n	5006 <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x52>
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    500c:	mov.w	r2, #2147483648	; 0x80000000
		port().PUSHR = data;
    5010:	movs	r3, #255	; 0xff
		while (!(port().SR & SPI_SR_TCF)) ; // wait
		return port().POPR;
    5012:	ldr	r1, [r4, #56]	; 0x38
		}
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		port().SR = SPI_SR_TCF;
    5014:	str	r2, [r4, #44]	; 0x2c
		port().PUSHR = data;
    5016:	str	r3, [r4, #52]	; 0x34
		while (!(port().SR & SPI_SR_TCF)) ; // wait
    5018:	ldr	r3, [r4, #44]	; 0x2c
    501a:	cmp	r3, #0
    501c:	bge.n	5018 <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x64>
		return port().POPR;
    501e:	ldr	r3, [r4, #56]	; 0x38
    5020:	uxtb	r3, r3
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    5022:	and.w	r2, r3, #31
    5026:	cmp	r2, #5
  spiSend(token);
  spiSend(src, 512);
  spiSend(crc >> 8);
  spiSend(crc & 0XFF);

  m_status = spiReceive();
    5028:	strb	r3, [r0, #18]
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    502a:	beq.n	503e <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x8a>
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    502c:	ldrb	r3, [r0, #17]
    502e:	movs	r2, #31
    5030:	strb	r2, [r0, #16]
    5032:	cbz	r3, 503a <SdSpiCard::writeData(unsigned char, unsigned char const*)+0x86>
    5034:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
  }
  return true;

fail:
  spiStop();
  return false;
    5038:	movs	r3, #0
}
    503a:	mov	r0, r3
    503c:	pop	{r3, r4, r5, pc}
  m_status = spiReceive();
  if ((m_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    error(SD_CARD_ERROR_WRITE_DATA);
    goto fail;
  }
  return true;
    503e:	movs	r3, #1

fail:
  spiStop();
  return false;
}
    5040:	mov	r0, r3
    5042:	pop	{r3, r4, r5, pc}

00005044 <SdSpiCard::writeData(unsigned char const*)>:
  spiStop();
  return false;
#endif  // ENABLE_DEDICATED_SPI
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    5044:	push	{r3, r4, r5, lr}
    5046:	mov	r5, r1
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    5048:	mov.w	r1, #600	; 0x258
  spiStop();
  return false;
#endif  // ENABLE_DEDICATED_SPI
}
//------------------------------------------------------------------------------
bool SdSpiCard::writeData(const uint8_t* src) {
    504c:	mov	r4, r0
  // wait for previous write to finish
  DBG_BEGIN_TIME(DBG_WRITE_BUSY);
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    504e:	bl	4ad8 <SdSpiCard::waitNotBusy(unsigned short)>
    5052:	cbnz	r0, 5066 <SdSpiCard::writeData(unsigned char const*)+0x22>
    5054:	movs	r3, #35	; 0x23
    5056:	strb	r3, [r4, #16]
    m_spiActive = true;
  }
}
//------------------------------------------------------------------------------
void SdSpiCard::spiStop() {
  if (m_spiActive) {
    5058:	ldrb	r0, [r4, #17]
    505a:	cbz	r0, 5064 <SdSpiCard::writeData(unsigned char const*)+0x20>
    505c:	mov	r0, r4
    505e:	bl	4958 <SdSpiCard::spiStop() [clone .part.24] [clone .constprop.43]>
  }
  return true;

fail:
  spiStop();
  return false;
    5062:	movs	r0, #0
}
    5064:	pop	{r3, r4, r5, pc}
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    error(SD_CARD_ERROR_WRITE_TIMEOUT);
    goto fail;
  }
  DBG_END_TIME(DBG_WRITE_BUSY);
  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) {
    5066:	mov	r2, r5
    5068:	movs	r1, #252	; 0xfc
    506a:	mov	r0, r4
    506c:	bl	4fb4 <SdSpiCard::writeData(unsigned char, unsigned char const*)>
    5070:	cmp	r0, #0
    5072:	beq.n	5058 <SdSpiCard::writeData(unsigned char const*)+0x14>
  return true;

fail:
  spiStop();
  return false;
}
    5074:	pop	{r3, r4, r5, pc}
    5076:	nop

00005078 <sdIrs()>:
#endif  // USE_DEBUG_MODE
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
    5078:	push	{r4}
  SDHC_IRQSIGEN = 0;
    507a:	ldr	r4, [pc, #28]	; (5098 <sdIrs()+0x20>)
  m_irqstat = SDHC_IRQSTAT;
    507c:	ldr	r2, [pc, #28]	; (509c <sdIrs()+0x24>)
    507e:	ldr	r1, [pc, #32]	; (50a0 <sdIrs()+0x28>)
  SDHC_IRQSTAT = m_irqstat;
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    5080:	ldr	r0, [pc, #32]	; (50a4 <sdIrs()+0x2c>)
  return false;
}
//==============================================================================
// ISR
static void sdIrs() {
  SDHC_IRQSIGEN = 0;
    5082:	movs	r3, #0
    5084:	str	r3, [r4, #0]
  m_irqstat = SDHC_IRQSTAT;
    5086:	ldr	r4, [r2, #0]
    5088:	str	r4, [r1, #0]
  SDHC_IRQSTAT = m_irqstat;
    508a:	ldr	r1, [r1, #0]
    508c:	str	r1, [r2, #0]
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
}
    508e:	ldr.w	r4, [sp], #4
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN);
#endif
  m_dmaBusy = false;
    5092:	strb	r3, [r0, #0]
}
    5094:	bx	lr
    5096:	nop
    5098:	.word	0x400b1038
    509c:	.word	0x400b1030
    50a0:	.word	0x1fff13f4
    50a4:	.word	0x1fff140c

000050a8 <isBusyCommandComplete()>:
  }
  return !(SDHC_CMDRSP0 & CARD_STATUS_READY_FOR_DATA);
}
//------------------------------------------------------------------------------
static bool isBusyCommandComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_CMD_ERROR));
    50a8:	ldr	r3, [pc, #12]	; (50b8 <isBusyCommandComplete()+0x10>)
    50aa:	ldr	r0, [pc, #16]	; (50bc <isBusyCommandComplete()+0x14>)
    50ac:	ldr	r3, [r3, #0]
    50ae:	ands	r0, r3
}
    50b0:	clz	r0, r0
    50b4:	lsrs	r0, r0, #5
    50b6:	bx	lr
    50b8:	.word	0x400b1030
    50bc:	.word	0x000f0001

000050c0 <isBusyCommandInhibit()>:
//------------------------------------------------------------------------------
static bool isBusyCommandInhibit() {
  return SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB;
    50c0:	ldr	r3, [pc, #8]	; (50cc <isBusyCommandInhibit()+0xc>)
    50c2:	ldr	r0, [r3, #0]
}
    50c4:	and.w	r0, r0, #1
    50c8:	bx	lr
    50ca:	nop
    50cc:	.word	0x400b1024

000050d0 <isBusyDMA()>:
//------------------------------------------------------------------------------
static bool isBusyDMA() {
  return m_dmaBusy;
    50d0:	ldr	r3, [pc, #4]	; (50d8 <isBusyDMA()+0x8>)
    50d2:	ldrb	r0, [r3, #0]
}
    50d4:	bx	lr
    50d6:	nop
    50d8:	.word	0x1fff140c

000050dc <isBusyFifoRead()>:
//------------------------------------------------------------------------------
static bool isBusyFifoRead() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BREN);
    50dc:	ldr	r3, [pc, #12]	; (50ec <isBusyFifoRead()+0x10>)
    50de:	ldr	r0, [r3, #0]
    50e0:	eor.w	r0, r0, #2048	; 0x800
}
    50e4:	ubfx	r0, r0, #11, #1
    50e8:	bx	lr
    50ea:	nop
    50ec:	.word	0x400b1024

000050f0 <isBusyFifoWrite()>:
//------------------------------------------------------------------------------
static bool isBusyFifoWrite() {
  return !(SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN);
    50f0:	ldr	r3, [pc, #12]	; (5100 <isBusyFifoWrite()+0x10>)
    50f2:	ldr	r0, [r3, #0]
    50f4:	eor.w	r0, r0, #1024	; 0x400
}
    50f8:	ubfx	r0, r0, #10, #1
    50fc:	bx	lr
    50fe:	nop
    5100:	.word	0x400b1024

00005104 <isBusyTransferComplete()>:
//------------------------------------------------------------------------------
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
    5104:	ldr	r3, [pc, #12]	; (5114 <isBusyTransferComplete()+0x10>)
    5106:	ldr	r0, [pc, #16]	; (5118 <isBusyTransferComplete()+0x14>)
    5108:	ldr	r3, [r3, #0]
    510a:	ands	r0, r3
}
    510c:	clz	r0, r0
    5110:	lsrs	r0, r0, #5
    5112:	bx	lr
    5114:	.word	0x400b1030
    5118:	.word	0x117f0002

0000511c <setSdclk(unsigned long)>:
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    511c:	mov.w	r2, #1000	; 0x3e8
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    5120:	ldr	r3, [pc, #176]	; (51d4 <setSdclk(unsigned long)+0xb8>)
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
    5122:	mul.w	r0, r2, r0
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    5126:	cmp	r0, r3
  }
  d[15] = 0;
  return true;
}
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
    5128:	push	{r4, r5, r6, r7}
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    512a:	bhi.n	51c4 <setSdclk(unsigned long)+0xa8>
    512c:	ldr	r5, [pc, #168]	; (51d8 <setSdclk(unsigned long)+0xbc>)
    512e:	movs	r2, #8
    5130:	movs	r1, #1
    sdclkfs <<= 1;
    5132:	lsls	r1, r1, #1
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    5134:	lsls	r3, r1, #4
    5136:	udiv	r3, r5, r3
    513a:	cmp	r0, r3
    513c:	ldr	r4, [pc, #152]	; (51d8 <setSdclk(unsigned long)+0xbc>)
    513e:	bcs.n	51bc <setSdclk(unsigned long)+0xa0>
    5140:	subs	r2, #1
    5142:	bne.n	5132 <setSdclk(unsigned long)+0x16>
    5144:	udiv	r4, r4, r1
    5148:	lsrs	r3, r1, #1
    514a:	lsls	r7, r3, #8
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    514c:	cmp	r0, r4
    514e:	bcs.n	51cc <setSdclk(unsigned long)+0xb0>
    5150:	ldr	r6, [pc, #132]	; (51d8 <setSdclk(unsigned long)+0xbc>)
    5152:	lsls	r3, r1, #1
    5154:	movs	r2, #1
    5156:	b.n	515a <setSdclk(unsigned long)+0x3e>
    5158:	mov	r3, r4
    515a:	udiv	r4, r6, r3
    515e:	cmp	r0, r4
    dvs++;
    5160:	add.w	r5, r2, #1
    5164:	add.w	r4, r3, r1
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    5168:	bcs.n	51b8 <setSdclk(unsigned long)+0x9c>
    516a:	cmp	r5, #16
    516c:	mov	r2, r5
    516e:	bne.n	5158 <setSdclk(unsigned long)+0x3c>
    5170:	movs	r2, #240	; 0xf0
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    5172:	ldr	r6, [pc, #104]	; (51dc <setSdclk(unsigned long)+0xc0>)
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    5174:	ldr	r4, [pc, #104]	; (51e0 <setSdclk(unsigned long)+0xc4>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    5176:	ldr	r0, [pc, #96]	; (51d8 <setSdclk(unsigned long)+0xbc>)

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    5178:	ldr	r1, [pc, #104]	; (51e4 <setSdclk(unsigned long)+0xc8>)
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    dvs++;
  }
  m_sdClkKhz = base/(1000*sdclkfs*dvs);
    517a:	mov.w	r5, #1000	; 0x3e8
    517e:	mul.w	r3, r5, r3
    5182:	udiv	r3, r0, r3
    5186:	str	r3, [r6, #0]
  sdclkfs >>= 1;
  dvs--;
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Disable SDHC clock.
  SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
    5188:	ldr	r3, [r4, #0]
    518a:	bic.w	r3, r3, #8
    518e:	str	r3, [r4, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)

  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
    5190:	ldr	r0, [r4, #0]
                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    5192:	bic.w	r3, r0, #1044480	; 0xff000
    5196:	bic.w	r3, r3, #4080	; 0xff0
    519a:	orr.w	r3, r3, #917504	; 0xe0000
    519e:	orrs	r3, r7
    51a0:	orrs	r2, r3
    51a2:	str	r2, [r4, #0]

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) {
    51a4:	ldr	r3, [r1, #0]
    51a6:	lsls	r3, r3, #28
    51a8:	bpl.n	51a4 <setSdclk(unsigned long)+0x88>
  }

#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
  // Enable the SDHC clock.
  SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN;
    51aa:	ldr	r2, [pc, #52]	; (51e0 <setSdclk(unsigned long)+0xc4>)
    51ac:	ldr	r3, [r2, #0]
    51ae:	orr.w	r3, r3, #8
    51b2:	str	r3, [r2, #0]
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
    51b4:	pop	{r4, r5, r6, r7}
    51b6:	bx	lr
    51b8:	lsls	r2, r2, #4
    51ba:	b.n	5172 <setSdclk(unsigned long)+0x56>
    51bc:	udiv	r4, r4, r1
    51c0:	lsls	r7, r1, #7
    51c2:	b.n	514c <setSdclk(unsigned long)+0x30>
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000*kHzMax;
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    51c4:	ldr	r4, [pc, #16]	; (51d8 <setSdclk(unsigned long)+0xbc>)
    51c6:	movs	r7, #0
//------------------------------------------------------------------------------
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
    51c8:	movs	r1, #1
    51ca:	b.n	514c <setSdclk(unsigned long)+0x30>
  uint32_t base = baseClock();

  while ((base/(sdclkfs*DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((base/(sdclkfs*dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    51cc:	mov	r3, r1
    51ce:	movs	r2, #0
    51d0:	b.n	5172 <setSdclk(unsigned long)+0x56>
    51d2:	nop
    51d4:	.word	0x005b8d7f
    51d8:	.word	0x05b8d800
    51dc:	.word	0x1fff1410
    51e0:	.word	0x400b102c
    51e4:	.word	0x400b1024

000051e8 <SdioCard::errorCode() const>:
  }
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::errorCode() const {
  return m_errorCode;
    51e8:	ldr	r3, [pc, #4]	; (51f0 <SdioCard::errorCode() const+0x8>)
}
    51ea:	ldrb	r0, [r3, #0]
    51ec:	bx	lr
    51ee:	nop
    51f0:	.word	0x1fff0974

000051f4 <SdioCard::errorData() const>:
//------------------------------------------------------------------------------
uint32_t SdioCard::errorData() const {
  return m_irqstat;
    51f4:	ldr	r3, [pc, #4]	; (51fc <SdioCard::errorData() const+0x8>)
    51f6:	ldr	r0, [r3, #0]
}
    51f8:	bx	lr
    51fa:	nop
    51fc:	.word	0x1fff13f4

00005200 <SdioCard::readCID(CID*)>:
//------------------------------------------------------------------------------
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
    5200:	push	{r4, r5}
  memcpy(cid, &m_cid, 16);
    5202:	ldr	r4, [pc, #20]	; (5218 <SdioCard::readCID(CID*)+0x18>)
//------------------------------------------------------------------------------
uint32_t SdioCard::kHzSdClk() {
  return m_sdClkKhz;
}
//------------------------------------------------------------------------------
bool SdioCard::readCID(cid_t* cid) {
    5204:	mov	r5, r1
  memcpy(cid, &m_cid, 16);
    5206:	ldmia	r4!, {r0, r1, r2, r3}
    5208:	str	r0, [r5, #0]
    520a:	str	r1, [r5, #4]
    520c:	str	r2, [r5, #8]
    520e:	str	r3, [r5, #12]
  return true;
}
    5210:	movs	r0, #1
    5212:	pop	{r4, r5}
    5214:	bx	lr
    5216:	nop
    5218:	.word	0x1fff13d4

0000521c <SdioCard::readCSD(csd_t*)>:
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
    521c:	push	{r4, r5}
  memcpy(csd, &m_csd, 16);
    521e:	ldr	r4, [pc, #20]	; (5234 <SdioCard::readCSD(csd_t*)+0x18>)
bool SdioCard::readCID(cid_t* cid) {
  memcpy(cid, &m_cid, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readCSD(csd_t* csd) {
    5220:	mov	r5, r1
  memcpy(csd, &m_csd, 16);
    5222:	ldmia	r4!, {r0, r1, r2, r3}
    5224:	str	r0, [r5, #0]
    5226:	str	r1, [r5, #4]
    5228:	str	r2, [r5, #8]
    522a:	str	r3, [r5, #12]
  return true;
}
    522c:	movs	r0, #1
    522e:	pop	{r4, r5}
    5230:	bx	lr
    5232:	nop
    5234:	.word	0x1fff13fc

00005238 <SdioCard::readOCR(unsigned long*)>:
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
    5238:	ldr	r3, [pc, #8]	; (5244 <SdioCard::readOCR(unsigned long*)+0xc>)
    523a:	ldr	r3, [r3, #0]
    523c:	str	r3, [r1, #0]
  return true;
}
    523e:	movs	r0, #1
    5240:	bx	lr
    5242:	nop
    5244:	.word	0x1fff13ec

00005248 <SdioCard::~SdioCard()>:
//------------------------------------------------------------------------------
/**
 * \class SdioCard
 * \brief Raw SDIO access to SD and SDHC flash memory cards.
 */
class SdioCard : public SdCardInterface {
    5248:	bx	lr
    524a:	nop

0000524c <waitTimeout(bool (*)())>:
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
    524c:	push	{r3, r4, r5, r6, r7, lr}
    524e:	mov	r5, r0
  uint32_t m = micros();
    5250:	bl	9a08 <micros>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    5254:	ldr	r7, [pc, #24]	; (5270 <waitTimeout(bool (*)())+0x24>)
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
    5256:	mov	r6, r0
    5258:	b.n	5264 <waitTimeout(bool (*)())+0x18>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    525a:	bl	9a08 <micros>
    525e:	subs	r0, r0, r6
    5260:	cmp	r0, r7
    5262:	bhi.n	526c <waitTimeout(bool (*)())+0x20>
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool waitTimeout(bool (*fcn)()) {
  uint32_t m = micros();
  while (fcn()) {
    5264:	blx	r5
    5266:	mov	r4, r0
    5268:	cmp	r0, #0
    526a:	bne.n	525a <waitTimeout(bool (*)())+0xe>
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
      return true;
    }
  }
  return false;  // Caller will set errorCode.
}
    526c:	mov	r0, r4
    526e:	pop	{r3, r4, r5, r6, r7, pc}
    5270:	.word	0x000f4240

00005274 <yieldTimeout(bool (*)())>:
  SDHC_PROCTL = proctl;
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    5274:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  m_busyFcn = fcn;
    5278:	ldr.w	r8, [pc, #64]	; 52bc <yieldTimeout(bool (*)())+0x48>
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    527c:	ldr	r7, [pc, #56]	; (52b8 <yieldTimeout(bool (*)())+0x44>)
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
    527e:	str.w	r0, [r8]
  SDHC_PROCTL = proctl;
  return true;
}
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
    5282:	mov	r5, r0
  m_busyFcn = fcn;
  uint32_t m = micros();
    5284:	bl	9a08 <micros>
    5288:	mov	r6, r0
    528a:	b.n	529a <yieldTimeout(bool (*)())+0x26>
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
    528c:	bl	9a08 <micros>
    5290:	subs	r0, r0, r6
    5292:	cmp	r0, r7
    5294:	bhi.n	52ac <yieldTimeout(bool (*)())+0x38>
  Particle.process();
}
#elif defined(ARDUINO)
inline void SysCall::yield() {
  // Use the external Arduino yield() function.
  ::yield();
    5296:	bl	ac8c <yield>
//------------------------------------------------------------------------------
// Return true if timeout occurs.
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
  uint32_t m = micros();
  while (fcn()) {
    529a:	blx	r5
    529c:	mov	r4, r0
    529e:	cmp	r0, #0
    52a0:	bne.n	528c <yieldTimeout(bool (*)())+0x18>
      m_busyFcn = 0;
      return true;
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
    52a2:	str.w	r0, [r8]
  return false;  // Caller will set errorCode.
}
    52a6:	mov	r0, r4
    52a8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
static bool yieldTimeout(bool (*fcn)()) {
  m_busyFcn = fcn;
  uint32_t m = micros();
  while (fcn()) {
    if ((micros() - m) > BUSY_TIMEOUT_MICROS) {
      m_busyFcn = 0;
    52ac:	movs	r3, #0
    52ae:	str.w	r3, [r8]
    }
    SysCall::yield();
  }
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
    52b2:	mov	r0, r4
    52b4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    52b8:	.word	0x000f4240
    52bc:	.word	0x1fff13e4

000052c0 <SdioCard::~SdioCard()>:
    52c0:	push	{r4, lr}
    52c2:	movs	r1, #12
    52c4:	mov	r4, r0
    52c6:	bl	ae4c <operator delete(void*, unsigned int)>
    52ca:	mov	r0, r4
    52cc:	pop	{r4, pc}
    52ce:	nop

000052d0 <SdioCard::type() const>:
  return true;
}
//------------------------------------------------------------------------------
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
    52d0:	ldr	r3, [pc, #20]	; (52e8 <SdioCard::type() const+0x18>)
    52d2:	ldrb	r3, [r3, #0]
    52d4:	cbz	r3, 52e4 <SdioCard::type() const+0x14>
    52d6:	ldr	r3, [pc, #20]	; (52ec <SdioCard::type() const+0x1c>)
    52d8:	ldrb	r3, [r3, #0]
    52da:	cmp	r3, #0
    52dc:	ite	ne
    52de:	movne	r0, #3
    52e0:	moveq	r0, #2
    52e2:	bx	lr
    52e4:	movs	r0, #1
}
    52e6:	bx	lr
    52e8:	.word	0x1fff13d0
    52ec:	.word	0x1fff13e8

000052f0 <cardCommand(unsigned long, unsigned long)>:
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    52f0:	push	{r3, r4, r5, lr}
    52f2:	mov	r4, r0
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    52f4:	ldr	r0, [pc, #60]	; (5334 <cardCommand(unsigned long, unsigned long)+0x44>)
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
}
//------------------------------------------------------------------------------
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
    52f6:	mov	r5, r1
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    52f8:	bl	524c <waitTimeout(bool (*)())>
    52fc:	cbz	r0, 5302 <cardCommand(unsigned long, unsigned long)+0x12>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    52fe:	movs	r0, #0
    5300:	pop	{r3, r4, r5, pc}
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    5302:	ldr	r2, [pc, #52]	; (5338 <cardCommand(unsigned long, unsigned long)+0x48>)
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    5304:	ldr	r3, [pc, #52]	; (533c <cardCommand(unsigned long, unsigned long)+0x4c>)
static bool cardCommand(uint32_t xfertyp, uint32_t arg) {
  DBG_IRQSTAT();
  if (waitTimeout(isBusyCommandInhibit)) {
    return false;  // Caller will set errorCode.
  }
  SDHC_CMDARG = arg;
    5306:	str	r5, [r2, #0]
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
  if (waitTimeout(isBusyCommandComplete)) {
    5308:	ldr	r0, [pc, #52]	; (5340 <cardCommand(unsigned long, unsigned long)+0x50>)
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MASK;
    SDHC_MIX_CTRL |= xfertyp & SDHC_MIX_CTRL_MASK;
  }
  xfertyp &= ~SDHC_MIX_CTRL_MASK;
#endif  // defined(__IMXRT1062__)
  SDHC_XFERTYP = xfertyp;
    530a:	str	r4, [r3, #0]
  if (waitTimeout(isBusyCommandComplete)) {
    530c:	bl	524c <waitTimeout(bool (*)())>
    5310:	cmp	r0, #0
    5312:	bne.n	52fe <cardCommand(unsigned long, unsigned long)+0xe>
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
    5314:	ldr	r2, [pc, #44]	; (5344 <cardCommand(unsigned long, unsigned long)+0x54>)
    5316:	ldr	r3, [pc, #48]	; (5348 <cardCommand(unsigned long, unsigned long)+0x58>)
    5318:	ldr	r1, [r2, #0]
    531a:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    531c:	ldr	r1, [r3, #0]
    531e:	str	r1, [r2, #0]

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    5320:	ldr	r2, [r3, #0]
    5322:	lsls	r2, r2, #31
    5324:	bpl.n	52fe <cardCommand(unsigned long, unsigned long)+0xe>
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
    5326:	ldr	r3, [r3, #0]
    return false;  // Caller will set errorCode.
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
    5328:	tst.w	r3, #983040	; 0xf0000
    532c:	bne.n	52fe <cardCommand(unsigned long, unsigned long)+0xe>
    532e:	movs	r0, #1
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
    5330:	pop	{r3, r4, r5, pc}
    5332:	nop
    5334:	.word	0x000050c1
    5338:	.word	0x400b1008
    533c:	.word	0x400b100c
    5340:	.word	0x000050a9
    5344:	.word	0x400b1030
    5348:	.word	0x1fff13f4

0000534c <SdioCard::status()>:
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
    534c:	push	{r3, lr}
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
  }
}
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
    534e:	ldr	r3, [pc, #16]	; (5360 <SdioCard::status()+0x14>)
    5350:	ldr	r0, [pc, #16]	; (5364 <SdioCard::status()+0x18>)
    5352:	ldr	r1, [r3, #0]
    5354:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    5358:	cbz	r0, 535e <SdioCard::status()+0x12>
    535a:	ldr	r3, [pc, #12]	; (5368 <SdioCard::status()+0x1c>)
    535c:	ldr	r0, [r3, #0]
  return sdCardCapacity(&m_csd);
}
//------------------------------------------------------------------------------
uint32_t SdioCard::status() {
  return statusCMD13();
}
    535e:	pop	{r3, pc}
    5360:	.word	0x1fff13f0
    5364:	.word	0x0d1a0000
    5368:	.word	0x400b1010

0000536c <readReg16(unsigned long, void*)>:
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    536c:	push	{r4, r5, lr}
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    536e:	ldr	r3, [pc, #84]	; (53c4 <readReg16(unsigned long, void*)+0x58>)
  }
  return waitDmaStatus();
}
//------------------------------------------------------------------------------
// Read 16 byte CID or CSD register.
static bool readReg16(uint32_t xfertyp, void* data) {
    5370:	sub	sp, #20
    5372:	mov	r5, r1
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    5374:	ldr	r1, [r3, #0]
    5376:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    537a:	cbz	r0, 53be <readReg16(unsigned long, void*)+0x52>
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
    537c:	ldr	r2, [pc, #72]	; (53c8 <readReg16(unsigned long, void*)+0x5c>)
    537e:	ldr	r3, [pc, #76]	; (53cc <readReg16(unsigned long, void*)+0x60>)
    5380:	ldr	r2, [r2, #0]
    5382:	str	r2, [sp, #0]
    5384:	ldr	r1, [r3, #0]
    5386:	str	r1, [sp, #4]
    5388:	ldr	r1, [r3, #4]
    538a:	str	r1, [sp, #8]
    538c:	adds	r3, #8
    538e:	add.w	r4, r5, #15
    5392:	ldr	r3, [r3, #0]
    5394:	str	r3, [sp, #12]
  for (int i = 0; i < 15; i++) {
    5396:	movs	r3, #0
    5398:	b.n	539e <readReg16(unsigned long, void*)+0x32>
    539a:	ldr.w	r2, [r1, #-16]
    d[14 - i] = sr[i/4] >> 8*(i%4);
    539e:	and.w	r1, r3, #3
    53a2:	lsls	r1, r1, #3
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    53a4:	adds	r3, #1
    d[14 - i] = sr[i/4] >> 8*(i%4);
    53a6:	lsrs	r2, r1
    53a8:	add.w	lr, sp, #16
    53ac:	bic.w	r1, r3, #3
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    53b0:	cmp	r3, #15
    53b2:	add	r1, lr
    d[14 - i] = sr[i/4] >> 8*(i%4);
    53b4:	strb.w	r2, [r4, #-1]!
  uint8_t* d = reinterpret_cast<uint8_t*>(data);
  if (!cardCommand(xfertyp, m_rca)) {
    return false;  // Caller will set errorCode.
  }
  uint32_t sr[] = {SDHC_CMDRSP0, SDHC_CMDRSP1, SDHC_CMDRSP2, SDHC_CMDRSP3};
  for (int i = 0; i < 15; i++) {
    53b8:	bne.n	539a <readReg16(unsigned long, void*)+0x2e>
    d[14 - i] = sr[i/4] >> 8*(i%4);
  }
  d[15] = 0;
    53ba:	movs	r3, #0
    53bc:	strb	r3, [r5, #15]
  return true;
}
    53be:	add	sp, #20
    53c0:	pop	{r4, r5, pc}
    53c2:	nop
    53c4:	.word	0x1fff13f0
    53c8:	.word	0x400b1010
    53cc:	.word	0x400b1014

000053d0 <isBusyCMD13()>:
//------------------------------------------------------------------------------
static uint32_t statusCMD13() {
  return cardCommand(CMD13_XFERTYP, m_rca) ? SDHC_CMDRSP0 : 0;
}
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
    53d0:	push	{r3, lr}
  if (!cardCommand(CMD13_XFERTYP, m_rca)) {
    53d2:	ldr	r3, [pc, #28]	; (53f0 <isBusyCMD13()+0x20>)
    53d4:	ldr	r0, [pc, #28]	; (53f4 <isBusyCMD13()+0x24>)
    53d6:	ldr	r1, [r3, #0]
    53d8:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    53dc:	cbz	r0, 53ec <isBusyCMD13()+0x1c>
    // Caller will timeout.
    return true;
  }
  return !(SDHC_CMDRSP0 & CARD_STATUS_READY_FOR_DATA);
    53de:	ldr	r3, [pc, #24]	; (53f8 <isBusyCMD13()+0x28>)
    53e0:	ldr	r0, [r3, #0]
    53e2:	eor.w	r0, r0, #256	; 0x100
    53e6:	ubfx	r0, r0, #8, #1
    53ea:	pop	{r3, pc}
}
//------------------------------------------------------------------------------
static bool isBusyCMD13() {
  if (!cardCommand(CMD13_XFERTYP, m_rca)) {
    // Caller will timeout.
    return true;
    53ec:	movs	r0, #1
  }
  return !(SDHC_CMDRSP0 & CARD_STATUS_READY_FOR_DATA);
}
    53ee:	pop	{r3, pc}
    53f0:	.word	0x1fff13f0
    53f4:	.word	0x0d1a0000
    53f8:	.word	0x400b1010

000053fc <SdioCard::isBusy()>:
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    53fc:	ldr	r3, [pc, #16]	; (5410 <SdioCard::isBusy()+0x14>)
    53fe:	ldr	r3, [r3, #0]
    5400:	cbz	r3, 5404 <SdioCard::isBusy()+0x8>
    5402:	bx	r3
    5404:	ldr	r3, [pc, #12]	; (5414 <SdioCard::isBusy()+0x18>)
    5406:	ldrb	r0, [r3, #0]
    5408:	cbnz	r0, 540c <SdioCard::isBusy()+0x10>
}
    540a:	bx	lr
uint32_t SdioCard::errorLine() const {
  return m_errorLine;
}
//------------------------------------------------------------------------------
bool SdioCard::isBusy() {
  return m_busyFcn ? m_busyFcn() : m_initDone && isBusyCMD13();
    540c:	b.w	53d0 <isBusyCMD13()>
    5410:	.word	0x1fff13e4
    5414:	.word	0x1fff13f8

00005418 <waitDmaStatus() [clone .part.6]>:
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    return false;  // Caller will set errorCode.
  }
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    5418:	ldr	r3, [pc, #20]	; (5430 <waitDmaStatus() [clone .part.6]+0x18>)
    541a:	ldr	r0, [r3, #0]
    541c:	ands.w	r0, r0, #2
    5420:	beq.n	542e <waitDmaStatus() [clone .part.6]+0x16>
    5422:	ldr	r3, [r3, #0]
    5424:	ldr	r0, [pc, #12]	; (5434 <waitDmaStatus() [clone .part.6]+0x1c>)
    5426:	ands	r0, r3
    5428:	clz	r0, r0
    542c:	lsrs	r0, r0, #5
}
    542e:	bx	lr
    5430:	.word	0x1fff13f4
    5434:	.word	0x117f0000

00005438 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>:
static bool isBusyTransferComplete() {
  return !(SDHC_IRQSTAT & (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_ERROR));
}
//------------------------------------------------------------------------------
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
    5438:	push	{r3, r4, r5, r6, r7, lr}
  if ((3 & (uint32_t)buf) || n == 0) {
    543a:	lsls	r4, r2, #30
    543c:	bne.n	5440 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8>
    543e:	cbnz	r3, 5452 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x1a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5440:	ldr	r1, [pc, #124]	; (54c0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
  m_errorLine = line;
    5442:	ldr	r3, [pc, #128]	; (54c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5444:	movs	r0, #36	; 0x24
  m_errorLine = line;
    5446:	movw	r2, #467	; 0x1d3
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    544a:	strb	r0, [r1, #0]
  m_errorLine = line;
    544c:	str	r2, [r3, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    544e:	movs	r0, #0
    5450:	pop	{r3, r4, r5, r6, r7, pc}
    5452:	mov	r6, r0
static bool rdWrSectors(uint32_t xfertyp,
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    5454:	ldr	r0, [pc, #112]	; (54c8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x90>)
    5456:	mov	r4, r3
    5458:	mov	r7, r1
    545a:	mov	r5, r2
    545c:	bl	5274 <yieldTimeout(bool (*)())>
    5460:	cbnz	r0, 54aa <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x72>
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    5462:	ldr	r1, [pc, #104]	; (54cc <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x94>)
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    5464:	ldr	r2, [pc, #104]	; (54d0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x98>)
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    5466:	ldr.w	lr, [pc, #128]	; 54e8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xb0>
    546a:	mov.w	ip, #1
    546e:	strb.w	ip, [lr]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    5472:	lsls	r3, r4, #16
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    5474:	str	r0, [r1, #0]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    5476:	ldr	r4, [pc, #92]	; (54d4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x9c>)
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
    5478:	str	r5, [r2, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    547a:	ldr	r2, [pc, #92]	; (54d8 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xa0>)
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    547c:	ldr	r1, [pc, #92]	; (54dc <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xa4>)
    547e:	ldr	r0, [pc, #96]	; (54e0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xa8>)
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
    5480:	orr.w	r3, r3, #512	; 0x200
    5484:	str	r3, [r4, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    5486:	ldrb	r3, [r2, #0]
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    5488:	str	r0, [r1, #0]
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    548a:	cbnz	r3, 54ba <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x82>
    548c:	lsls	r1, r7, #9
    548e:	mov	r0, r6
    5490:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    5494:	cmp	r0, #0
    5496:	beq.n	544e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x16>
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    5498:	ldr	r0, [pc, #72]	; (54e4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0xac>)
    549a:	bl	5274 <yieldTimeout(bool (*)())>
    549e:	cmp	r0, #0
    54a0:	bne.n	544e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x16>
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    return false;
  }
  return waitDmaStatus();
}
    54a2:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    54a6:	b.w	5418 <waitDmaStatus() [clone .part.6]>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    54aa:	ldr	r1, [pc, #20]	; (54c0 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x88>)
  m_errorLine = line;
    54ac:	ldr	r3, [pc, #20]	; (54c4 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x8c>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    54ae:	movs	r0, #10
  m_errorLine = line;
    54b0:	mov.w	r2, #470	; 0x1d6
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    54b4:	strb	r0, [r1, #0]
  m_errorLine = line;
    54b6:	str	r2, [r3, #0]
                       uint32_t sector, uint8_t* buf, size_t n) {
  if ((3 & (uint32_t)buf) || n == 0) {
    return sdError(SD_CARD_ERROR_DMA);
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    54b8:	b.n	544e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x16>
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)buf;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(n) | SDHC_BLKATTR_BLKSIZE(512);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(xfertyp, m_highCapacity ? sector : 512*sector)) {
    54ba:	mov	r1, r7
    54bc:	b.n	548e <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)+0x56>
    54be:	nop
    54c0:	.word	0x1fff0974
    54c4:	.word	0x1fff1414
    54c8:	.word	0x000053d1
    54cc:	.word	0x1fff13f4
    54d0:	.word	0x400b1000
    54d4:	.word	0x400b1004
    54d8:	.word	0x1fff13e8
    54dc:	.word	0x400b1038
    54e0:	.word	0x117f0002
    54e4:	.word	0x000050d1
    54e8:	.word	0x1fff140c

000054ec <SdioCard::sectorCount()>:
//------------------------------------------------------------------------------
bool SdioCard::readStop() {
  return transferStop();
}
//------------------------------------------------------------------------------
uint32_t SdioCard::sectorCount() {
    54ec:	push	{r4, r5, r6}
  csd1_t v1;
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    54ee:	ldr	r1, [pc, #100]	; (5554 <SdioCard::sectorCount()+0x68>)
    54f0:	ldrb	r3, [r1, #0]
    54f2:	ands.w	r3, r3, #192	; 0xc0
    54f6:	beq.n	551c <SdioCard::sectorCount()+0x30>
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    54f8:	cmp	r3, #64	; 0x40
    54fa:	beq.n	5502 <SdioCard::sectorCount()+0x16>
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
  } else {
    return 0;
    54fc:	movs	r0, #0
  return sdCardCapacity(&m_csd);
}
    54fe:	pop	{r4, r5, r6}
    5500:	bx	lr
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    5502:	ldrb	r3, [r1, #9]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd->v2.csd_ver == 1) {
    return (((uint32_t)csd->v2.c_size_high << 16) +
    5504:	ldrb	r4, [r1, #7]
           ((uint16_t)csd->v2.c_size_mid << 8) + csd->v2.c_size_low + 1) << 10;
    5506:	ldrb	r0, [r1, #8]
    5508:	adds	r2, r3, #1
    550a:	and.w	r3, r4, #63	; 0x3f
    550e:	add.w	r3, r2, r3, lsl #16
    5512:	add.w	r0, r3, r0, lsl #8
    5516:	lsls	r0, r0, #10
    5518:	pop	{r4, r5, r6}
    551a:	bx	lr
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
    551c:	ldrb	r5, [r1, #9]
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    uint16_t c_size = (csd->v1.c_size_high << 10)
    551e:	ldrb	r3, [r1, #6]
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    5520:	ldrb	r2, [r1, #7]
  csd2_t v2;
};
//-----------------------------------------------------------------------------
inline uint32_t sdCardCapacity(csd_t* csd) {
  if (csd->v1.csd_ver == 0) {
    uint8_t read_bl_len = csd->v1.read_bl_len;
    5522:	ldrb	r4, [r1, #5]
    uint16_t c_size = (csd->v1.c_size_high << 10)
                      | (csd->v1.c_size_mid << 2) | csd->v1.c_size_low;
    5524:	ldrb	r6, [r1, #8]
    uint8_t c_size_mult = (csd->v1.c_size_mult_high << 1)
                          | csd->v1.c_size_mult_low;
    5526:	ldrb	r0, [r1, #10]
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
    5528:	and.w	r1, r5, #3
    552c:	lsls	r1, r1, #1
    552e:	and.w	r3, r3, #3
    5532:	lsls	r2, r2, #2
    5534:	orr.w	r0, r1, r0, lsr #7
    5538:	orr.w	r3, r2, r3, lsl #10
    553c:	and.w	r1, r4, #15
    5540:	orr.w	r3, r3, r6, lsr #6
    5544:	add	r0, r1
    5546:	subs	r0, #7
    5548:	adds	r3, #1
    554a:	lsl.w	r0, r3, r0
    554e:	pop	{r4, r5, r6}
    5550:	bx	lr
    5552:	nop
    5554:	.word	0x1fff13fc

00005558 <SdioCard::erase(unsigned long, unsigned long)>:
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    5558:	push	{r4, r5, r6, lr}
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    555a:	ldr	r6, [pc, #176]	; (560c <SdioCard::erase(unsigned long, unsigned long)+0xb4>)
    555c:	ldrb	r3, [r6, #10]
    555e:	and.w	r0, r3, #64	; 0x40
  enableGPIO(true);
  m_initDone = true;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
    5562:	mov	r5, r2
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    5564:	cbnz	r0, 557e <SdioCard::erase(unsigned long, unsigned long)+0x26>
    // erase size mask
    uint8_t m = (m_csd.v1.sector_size_high << 1) | m_csd.v1.sector_size_low;
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    5566:	and.w	r3, r3, #63	; 0x3f
//------------------------------------------------------------------------------
bool SdioCard::erase(uint32_t firstSector, uint32_t lastSector) {
  // check for single sector erase
  if (!m_csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (m_csd.v1.sector_size_high << 1) | m_csd.v1.sector_size_low;
    556a:	ldrb	r2, [r6, #11]
    556c:	and.w	r4, r0, #255	; 0xff
    if ((firstSector & m) != 0 || ((lastSector + 1) & m) != 0) {
    5570:	lsls	r3, r3, #1
    5572:	adds	r0, r5, #1
    5574:	orr.w	r3, r3, r2, lsr #7
    5578:	orrs	r0, r1
    557a:	tst	r3, r0
    557c:	bne.n	55c2 <SdioCard::erase(unsigned long, unsigned long)+0x6a>
      // error card can't erase specified area
      return sdError(SD_CARD_ERROR_ERASE_SINGLE_SECTOR);
    }
  }
  if (!m_highCapacity) {
    557e:	ldr	r3, [pc, #144]	; (5610 <SdioCard::erase(unsigned long, unsigned long)+0xb8>)
    5580:	ldrb	r3, [r3, #0]
    5582:	cbnz	r3, 5588 <SdioCard::erase(unsigned long, unsigned long)+0x30>
    firstSector <<= 9;
    5584:	lsls	r1, r1, #9
    lastSector <<= 9;
    5586:	lsls	r5, r5, #9
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    5588:	ldr	r0, [pc, #136]	; (5614 <SdioCard::erase(unsigned long, unsigned long)+0xbc>)
    558a:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    558e:	mov	r4, r0
    5590:	cbnz	r0, 55a4 <SdioCard::erase(unsigned long, unsigned long)+0x4c>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5592:	ldr	r1, [pc, #132]	; (5618 <SdioCard::erase(unsigned long, unsigned long)+0xc0>)
  m_errorLine = line;
    5594:	ldr	r3, [pc, #132]	; (561c <SdioCard::erase(unsigned long, unsigned long)+0xc4>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5596:	movs	r0, #15
  m_errorLine = line;
    5598:	movw	r2, #689	; 0x2b1
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    559c:	strb	r0, [r1, #0]
  m_errorLine = line;
    559e:	str	r2, [r3, #0]
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
  }
  return true;
}
    55a0:	mov	r0, r4
    55a2:	pop	{r4, r5, r6, pc}
    lastSector <<= 9;
  }
  if (!cardCommand(CMD32_XFERTYP, firstSector)) {
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
    55a4:	mov	r1, r5
    55a6:	ldr	r0, [pc, #120]	; (5620 <SdioCard::erase(unsigned long, unsigned long)+0xc8>)
    55a8:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    55ac:	mov	r4, r0
    55ae:	cbnz	r0, 55d4 <SdioCard::erase(unsigned long, unsigned long)+0x7c>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    55b0:	ldr	r1, [pc, #100]	; (5618 <SdioCard::erase(unsigned long, unsigned long)+0xc0>)
  m_errorLine = line;
    55b2:	ldr	r3, [pc, #104]	; (561c <SdioCard::erase(unsigned long, unsigned long)+0xc4>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    55b4:	movs	r0, #16
  m_errorLine = line;
    55b6:	mov.w	r2, #692	; 0x2b4
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    55ba:	strb	r0, [r1, #0]
  m_errorLine = line;
    55bc:	str	r2, [r3, #0]
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
  }
  return true;
}
    55be:	mov	r0, r4
    55c0:	pop	{r4, r5, r6, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    55c2:	ldr	r1, [pc, #84]	; (5618 <SdioCard::erase(unsigned long, unsigned long)+0xc0>)
  m_errorLine = line;
    55c4:	ldr	r3, [pc, #84]	; (561c <SdioCard::erase(unsigned long, unsigned long)+0xc4>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    55c6:	movs	r0, #38	; 0x26
  m_errorLine = line;
    55c8:	movw	r2, #681	; 0x2a9
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    55cc:	strb	r0, [r1, #0]
  m_errorLine = line;
    55ce:	str	r2, [r3, #0]
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
  }
  return true;
}
    55d0:	mov	r0, r4
    55d2:	pop	{r4, r5, r6, pc}
    return sdError(SD_CARD_ERROR_CMD32);
  }
  if (!cardCommand(CMD33_XFERTYP, lastSector)) {
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    55d4:	movs	r1, #0
    55d6:	ldr	r0, [pc, #76]	; (5624 <SdioCard::erase(unsigned long, unsigned long)+0xcc>)
    55d8:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    55dc:	mov	r4, r0
    55de:	cbnz	r0, 55f0 <SdioCard::erase(unsigned long, unsigned long)+0x98>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    55e0:	ldr	r1, [pc, #52]	; (5618 <SdioCard::erase(unsigned long, unsigned long)+0xc0>)
  m_errorLine = line;
    55e2:	ldr	r3, [pc, #56]	; (561c <SdioCard::erase(unsigned long, unsigned long)+0xc4>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    55e4:	movs	r0, #17
  m_errorLine = line;
    55e6:	movw	r2, #695	; 0x2b7
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    55ea:	strb	r0, [r1, #0]
  m_errorLine = line;
    55ec:	str	r2, [r3, #0]
    55ee:	b.n	55a0 <SdioCard::erase(unsigned long, unsigned long)+0x48>
     return sdError(SD_CARD_ERROR_CMD33);
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    55f0:	ldr	r0, [pc, #52]	; (5628 <SdioCard::erase(unsigned long, unsigned long)+0xd0>)
    55f2:	bl	524c <waitTimeout(bool (*)())>
    55f6:	cmp	r0, #0
    55f8:	beq.n	55a0 <SdioCard::erase(unsigned long, unsigned long)+0x48>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    55fa:	ldr	r1, [pc, #28]	; (5618 <SdioCard::erase(unsigned long, unsigned long)+0xc0>)
  m_errorLine = line;
    55fc:	ldr	r3, [pc, #28]	; (561c <SdioCard::erase(unsigned long, unsigned long)+0xc4>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    55fe:	movs	r0, #39	; 0x27
  m_errorLine = line;
    5600:	movw	r2, #698	; 0x2ba
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5604:	strb	r0, [r1, #0]
  m_errorLine = line;
    5606:	str	r2, [r3, #0]
  }
  if (!cardCommand(CMD38_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD38);
  }
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_ERASE_TIMEOUT);
    5608:	movs	r4, #0
    560a:	b.n	55a0 <SdioCard::erase(unsigned long, unsigned long)+0x48>
    560c:	.word	0x1fff13fc
    5610:	.word	0x1fff13e8
    5614:	.word	0x201a0000
    5618:	.word	0x1fff0974
    561c:	.word	0x1fff1414
    5620:	.word	0x211a0000
    5624:	.word	0x261b0000
    5628:	.word	0x000053d1

0000562c <transferStop()>:
  // Enable the SDHC clock.
  SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN;
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
}
//------------------------------------------------------------------------------
static bool transferStop() {
    562c:	push	{r4, r5, r6, lr}
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    562e:	movs	r1, #0
    5630:	ldr	r0, [pc, #84]	; (5688 <transferStop()+0x5c>)
    5632:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    5636:	mov	r4, r0
    5638:	cbnz	r0, 564c <transferStop()+0x20>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    563a:	ldr	r1, [pc, #80]	; (568c <transferStop()+0x60>)
  m_errorLine = line;
    563c:	ldr	r3, [pc, #80]	; (5690 <transferStop()+0x64>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    563e:	movs	r0, #9
  m_errorLine = line;
    5640:	movw	r2, #537	; 0x219
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5644:	strb	r0, [r1, #0]
  m_errorLine = line;
    5646:	str	r2, [r3, #0]
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
  // Restore registers.
  SDHC_IRQSTATEN = irqsststen;
  SDHC_PROCTL = proctl;
  return true;
}
    5648:	mov	r0, r4
    564a:	pop	{r4, r5, r6, pc}
//------------------------------------------------------------------------------
static bool transferStop() {
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (yieldTimeout(isBusyCMD13)) {
    564c:	ldr	r0, [pc, #68]	; (5694 <transferStop()+0x68>)
    564e:	bl	5274 <yieldTimeout(bool (*)())>
    5652:	cbnz	r0, 5672 <transferStop()+0x46>
    return sdError(SD_CARD_ERROR_CMD13);
  }
  // Save registers before reset DAT lines.
  uint32_t irqsststen = SDHC_IRQSTATEN;
    5654:	ldr	r0, [pc, #64]	; (5698 <transferStop()+0x6c>)
  uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    5656:	ldr	r1, [pc, #68]	; (569c <transferStop()+0x70>)
  // Do reset to clear CDIHB.  Should be a better way!
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    5658:	ldr	r5, [pc, #68]	; (56a0 <transferStop()+0x74>)
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  // Save registers before reset DAT lines.
  uint32_t irqsststen = SDHC_IRQSTATEN;
    565a:	ldr	r6, [r0, #0]
  uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    565c:	ldr	r3, [r1, #0]
  // Do reset to clear CDIHB.  Should be a better way!
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    565e:	ldr	r2, [r5, #0]
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  // Save registers before reset DAT lines.
  uint32_t irqsststen = SDHC_IRQSTATEN;
  uint32_t proctl = SDHC_PROCTL & ~SDHC_PROCTL_SABGREQ;
    5660:	bic.w	r3, r3, #65536	; 0x10000
  // Do reset to clear CDIHB.  Should be a better way!
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
    5664:	orr.w	r2, r2, #67108864	; 0x4000000
    5668:	str	r2, [r5, #0]
  // Restore registers.
  SDHC_IRQSTATEN = irqsststen;
    566a:	str	r6, [r0, #0]
  SDHC_PROCTL = proctl;
    566c:	str	r3, [r1, #0]
  return true;
}
    566e:	mov	r0, r4
    5670:	pop	{r4, r5, r6, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5672:	ldr	r1, [pc, #24]	; (568c <transferStop()+0x60>)
  m_errorLine = line;
    5674:	ldr	r3, [pc, #24]	; (5690 <transferStop()+0x64>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5676:	movs	r0, #10
  m_errorLine = line;
    5678:	mov.w	r2, #540	; 0x21c
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    567c:	strb	r0, [r1, #0]
static bool transferStop() {
  if (!cardCommand(CMD12_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD12);
  }
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    567e:	movs	r4, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    5680:	str	r2, [r3, #0]
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTD;
  // Restore registers.
  SDHC_IRQSTATEN = irqsststen;
  SDHC_PROCTL = proctl;
  return true;
}
    5682:	mov	r0, r4
    5684:	pop	{r4, r5, r6, pc}
    5686:	nop
    5688:	.word	0x0cdb0000
    568c:	.word	0x1fff0974
    5690:	.word	0x1fff1414
    5694:	.word	0x000053d1
    5698:	.word	0x400b1034
    569c:	.word	0x400b1028
    56a0:	.word	0x400b102c

000056a4 <SdioCard::readStop()>:
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
    56a4:	b.w	562c <transferStop()>

000056a8 <SdioCard::writeData(unsigned char const*)>:
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    56a8:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    56aa:	ldr	r3, [pc, #160]	; (574c <SdioCard::writeData(unsigned char const*)+0xa4>)
    56ac:	ldr	r3, [r3, #0]
    56ae:	lsls	r0, r3, #23
uint8_t SdioCard::type() const {
  return  m_version2 ? m_highCapacity ?
          SD_CARD_TYPE_SDHC : SD_CARD_TYPE_SD2 : SD_CARD_TYPE_SD1;
}
//------------------------------------------------------------------------------
bool SdioCard::writeData(const uint8_t* src) {
    56b0:	mov	r5, r1
  DBG_IRQSTAT();
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    56b2:	bmi.n	56c6 <SdioCard::writeData(unsigned char const*)+0x1e>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    56b4:	ldr	r3, [pc, #152]	; (5750 <SdioCard::writeData(unsigned char const*)+0xa8>)
    56b6:	ldr	r2, [r3, #0]
    56b8:	bic.w	r2, r2, #65536	; 0x10000
    56bc:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    56be:	ldr	r2, [r3, #0]
    56c0:	orr.w	r2, r2, #131072	; 0x20000
    56c4:	str	r2, [r3, #0]
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    56c6:	ldr	r2, [pc, #136]	; (5750 <SdioCard::writeData(unsigned char const*)+0xa8>)
  if (waitTimeout(isBusyFifoWrite)) {
    56c8:	ldr	r0, [pc, #136]	; (5754 <SdioCard::writeData(unsigned char const*)+0xac>)
  const uint32_t* p32 = reinterpret_cast<const uint32_t*>(src);
  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_WTA)) {
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    56ca:	ldr	r3, [r2, #0]
    56cc:	orr.w	r3, r3, #65536	; 0x10000
    56d0:	str	r3, [r2, #0]
  if (waitTimeout(isBusyFifoWrite)) {
    56d2:	bl	524c <waitTimeout(bool (*)())>
    56d6:	cmp	r0, #0
    56d8:	bne.n	5738 <SdioCard::writeData(unsigned char const*)+0x90>
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    56da:	ldr	r4, [pc, #112]	; (574c <SdioCard::writeData(unsigned char const*)+0xa4>)
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    56dc:	ldr	r0, [pc, #120]	; (5758 <SdioCard::writeData(unsigned char const*)+0xb0>)
    56de:	subs	r3, r5, #4
    56e0:	add.w	r5, r5, #508	; 0x1fc
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    56e4:	ldr	r2, [r4, #0]
    56e6:	lsls	r1, r2, #21
    56e8:	bpl.n	56e4 <SdioCard::writeData(unsigned char const*)+0x3c>
    56ea:	add.w	r1, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    56ee:	ldr.w	r2, [r3, #4]!
    56f2:	str	r2, [r0, #0]
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BWEN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    56f4:	cmp	r1, r3
    56f6:	bne.n	56ee <SdioCard::writeData(unsigned char const*)+0x46>
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    56f8:	cmp	r5, r1
    56fa:	mov	r3, r1
    56fc:	bne.n	56e4 <SdioCard::writeData(unsigned char const*)+0x3c>
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      SDHC_DATPORT = p32[i];
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    56fe:	ldr	r0, [pc, #92]	; (575c <SdioCard::writeData(unsigned char const*)+0xb4>)
    5700:	bl	524c <waitTimeout(bool (*)())>
    5704:	cbnz	r0, 5726 <SdioCard::writeData(unsigned char const*)+0x7e>
    return sdError(SD_CARD_ERROR_WRITE_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
    5706:	ldr	r2, [pc, #88]	; (5760 <SdioCard::writeData(unsigned char const*)+0xb8>)
    5708:	ldr	r3, [pc, #88]	; (5764 <SdioCard::writeData(unsigned char const*)+0xbc>)
    570a:	ldr	r1, [r2, #0]
    570c:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    570e:	ldr	r1, [r3, #0]
    5710:	str	r1, [r2, #0]
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    5712:	ldr	r2, [r3, #0]
    5714:	lsls	r2, r2, #30
    5716:	bpl.n	5748 <SdioCard::writeData(unsigned char const*)+0xa0>
    5718:	ldr	r3, [r3, #0]
    571a:	ldr	r0, [pc, #76]	; (5768 <SdioCard::writeData(unsigned char const*)+0xc0>)
    571c:	ands	r0, r3
    571e:	clz	r0, r0
    5722:	lsrs	r0, r0, #5
    5724:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5726:	ldr	r1, [pc, #68]	; (576c <SdioCard::writeData(unsigned char const*)+0xc4>)
  m_errorLine = line;
    5728:	ldr	r3, [pc, #68]	; (5770 <SdioCard::writeData(unsigned char const*)+0xc8>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    572a:	movs	r0, #35	; 0x23
  m_errorLine = line;
    572c:	movw	r2, #902	; 0x386
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5730:	strb	r0, [r1, #0]
  m_errorLine = line;
    5732:	str	r2, [r3, #0]
      SDHC_DATPORT = p32[i];
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    return sdError(SD_CARD_ERROR_WRITE_TIMEOUT);
    5734:	movs	r0, #0
    5736:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5738:	ldr	r1, [pc, #48]	; (576c <SdioCard::writeData(unsigned char const*)+0xc4>)
  m_errorLine = line;
    573a:	ldr	r3, [pc, #52]	; (5770 <SdioCard::writeData(unsigned char const*)+0xc8>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    573c:	movs	r0, #32
  m_errorLine = line;
    573e:	movw	r2, #891	; 0x37b
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5742:	strb	r0, [r1, #0]
  m_errorLine = line;
    5744:	str	r2, [r3, #0]
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
  if (waitTimeout(isBusyFifoWrite)) {
    return sdError(SD_CARD_ERROR_WRITE_FIFO);
    5746:	movs	r0, #0
    return sdError(SD_CARD_ERROR_WRITE_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
    5748:	pop	{r3, r4, r5, pc}
    574a:	nop
    574c:	.word	0x400b1024
    5750:	.word	0x400b1028
    5754:	.word	0x000050f1
    5758:	.word	0x400b1020
    575c:	.word	0x00005105
    5760:	.word	0x400b1030
    5764:	.word	0x1fff13f4
    5768:	.word	0x117f0000
    576c:	.word	0x1fff0974
    5770:	.word	0x1fff1414

00005774 <SdioCard::writeStart(unsigned long)>:
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    5774:	push	{r3, r4, r5, lr}
  if (yieldTimeout(isBusyCMD13)) {
    5776:	ldr	r0, [pc, #80]	; (57c8 <SdioCard::writeStart(unsigned long)+0x54>)
    }
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
    5778:	mov	r4, r1
  if (yieldTimeout(isBusyCMD13)) {
    577a:	bl	5274 <yieldTimeout(bool (*)())>
    577e:	cbnz	r0, 57b4 <SdioCard::writeStart(unsigned long)+0x40>
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    5780:	ldr	r2, [pc, #72]	; (57cc <SdioCard::writeStart(unsigned long)+0x58>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(0XFFFF) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    5782:	ldr	r1, [pc, #76]	; (57d0 <SdioCard::writeStart(unsigned long)+0x5c>)
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    5784:	ldr	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(0XFFFF) | SDHC_BLKATTR_BLKSIZE(512);
    5786:	ldr	r0, [pc, #76]	; (57d4 <SdioCard::writeStart(unsigned long)+0x60>)
    5788:	ldr	r5, [pc, #76]	; (57d8 <SdioCard::writeStart(unsigned long)+0x64>)
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    578a:	bic.w	r3, r3, #65536	; 0x10000
    578e:	str	r3, [r2, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(0XFFFF) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    5790:	ldrb	r3, [r1, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(0XFFFF) | SDHC_BLKATTR_BLKSIZE(512);
    5792:	str	r5, [r0, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    5794:	cbnz	r3, 57b0 <SdioCard::writeStart(unsigned long)+0x3c>
    5796:	lsls	r1, r4, #9
    5798:	ldr	r0, [pc, #64]	; (57dc <SdioCard::writeStart(unsigned long)+0x68>)
    579a:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    579e:	cbnz	r0, 57ae <SdioCard::writeStart(unsigned long)+0x3a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    57a0:	ldr	r1, [pc, #60]	; (57e0 <SdioCard::writeStart(unsigned long)+0x6c>)
  m_errorLine = line;
    57a2:	ldr	r3, [pc, #64]	; (57e4 <SdioCard::writeStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    57a4:	movs	r4, #14
  m_errorLine = line;
    57a6:	movw	r2, #987	; 0x3db
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    57aa:	strb	r4, [r1, #0]
  m_errorLine = line;
    57ac:	str	r2, [r3, #0]
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD25);
  }
  return true;
}
    57ae:	pop	{r3, r4, r5, pc}
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(0XFFFF) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)
  if (!cardCommand(CMD25_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    57b0:	mov	r1, r4
    57b2:	b.n	5798 <SdioCard::writeStart(unsigned long)+0x24>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    57b4:	ldr	r1, [pc, #40]	; (57e0 <SdioCard::writeStart(unsigned long)+0x6c>)
  m_errorLine = line;
    57b6:	ldr	r3, [pc, #44]	; (57e4 <SdioCard::writeStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    57b8:	movs	r0, #10
  m_errorLine = line;
    57ba:	movw	r2, #975	; 0x3cf
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    57be:	strb	r0, [r1, #0]
  m_errorLine = line;
    57c0:	str	r2, [r3, #0]
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStart(uint32_t sector) {
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    57c2:	movs	r0, #0
    57c4:	pop	{r3, r4, r5, pc}
    57c6:	nop
    57c8:	.word	0x000053d1
    57cc:	.word	0x400b1028
    57d0:	.word	0x1fff13e8
    57d4:	.word	0x400b1004
    57d8:	.word	0xffff0200
    57dc:	.word	0x193a0022
    57e0:	.word	0x1fff0974
    57e4:	.word	0x1fff1414

000057e8 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)>:
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    57e8:	push	{r3, r4, r5, r6, r7, lr}
    57ea:	mov	r6, r0
  if (m_sdioConfig.useDma()) {
    57ec:	ldrb	r0, [r0, #8]
    57ee:	lsls	r0, r0, #31
    m_curSector++;
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
    57f0:	mov	r4, r1
    57f2:	mov	r5, r2
    57f4:	mov	r7, r3
  if (m_sdioConfig.useDma()) {
    57f6:	bmi.n	5820 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x38>
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
      return sdError(SD_CARD_ERROR_CMD18);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    57f8:	cbz	r3, 581c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
    57fa:	add	r7, r1
    57fc:	b.n	5802 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x1a>
    57fe:	cmp	r4, r7
    5800:	beq.n	581c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
      if (!readSector(sector + i, dst + i*512UL)) {
    5802:	ldr	r3, [r6, #0]
    5804:	mov	r2, r5
    5806:	mov	r1, r4
    5808:	ldr	r3, [r3, #8]
    580a:	mov	r0, r6
    580c:	blx	r3
    580e:	adds	r4, #1
    5810:	add.w	r5, r5, #512	; 0x200
    5814:	cmp	r0, #0
    5816:	bne.n	57fe <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x16>
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
        if (!readSector(sector, dst)) {
          return false;  // readSector will set errorCode.
    5818:	movs	r0, #0
    581a:	pop	{r3, r4, r5, r6, r7, pc}
      if (!readSector(sector + i, dst + i*512UL)) {
        return false;
      }
    }
  }
  return true;
    581c:	movs	r0, #1
    581e:	pop	{r3, r4, r5, r6, r7, pc}
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
    5820:	lsls	r0, r2, #30
    5822:	beq.n	584a <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x62>
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    5824:	cmp	r3, #0
    5826:	beq.n	581c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
    5828:	add	r7, r1
    582a:	b.n	5830 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x48>
    582c:	cmp	r7, r4
    582e:	beq.n	581c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
        if (!readSector(sector, dst)) {
    5830:	ldr	r3, [r6, #0]
    5832:	mov	r2, r5
    5834:	mov	r1, r4
    5836:	ldr	r3, [r3, #8]
    5838:	mov	r0, r6
    583a:	blx	r3
}
//------------------------------------------------------------------------------
bool SdioCard::readSectors(uint32_t sector, uint8_t* dst, size_t n) {
  if (m_sdioConfig.useDma()) {
    if ((uint32_t)dst & 3) {
      for (size_t i = 0; i < n; i++, sector++, dst += 512) {
    583c:	adds	r4, #1
    583e:	add.w	r5, r5, #512	; 0x200
        if (!readSector(sector, dst)) {
    5842:	cmp	r0, #0
    5844:	bne.n	582c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x44>
          return false;  // readSector will set errorCode.
    5846:	movs	r0, #0
    5848:	pop	{r3, r4, r5, r6, r7, pc}
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD18_DMA_XFERTYP, sector, dst, n)) {
    584a:	ldr	r0, [pc, #24]	; (5864 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x7c>)
    584c:	bl	5438 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    5850:	cmp	r0, #0
    5852:	bne.n	581c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5854:	ldr	r1, [pc, #16]	; (5868 <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x80>)
  m_errorLine = line;
    5856:	ldr	r3, [pc, #20]	; (586c <SdioCard::readSectors(unsigned long, unsigned char*, unsigned int)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5858:	movs	r4, #12
  m_errorLine = line;
    585a:	movw	r2, #817	; 0x331
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    585e:	strb	r4, [r1, #0]
  m_errorLine = line;
    5860:	str	r2, [r3, #0]
    5862:	pop	{r3, r4, r5, r6, r7, pc}
    5864:	.word	0x123a0037
    5868:	.word	0x1fff0974
    586c:	.word	0x1fff1414

00005870 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)>:
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    5870:	push	{r3, r4, r5, r6, r7, lr}
    5872:	mov	r6, r0
  if (m_sdioConfig.useDma()) {
    5874:	ldrb	r0, [r0, #8]
    5876:	lsls	r0, r0, #31
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
    5878:	mov	r4, r1
    587a:	mov	r5, r2
    587c:	mov	r7, r3
  if (m_sdioConfig.useDma()) {
    587e:	bmi.n	58a8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x38>
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
      return sdError(SD_CARD_ERROR_CMD25);
    }
  } else {
    for (size_t i = 0; i < n; i++) {
    5880:	cbz	r3, 58a4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
    5882:	add	r7, r1
    5884:	b.n	588a <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x1a>
    5886:	cmp	r4, r7
    5888:	beq.n	58a4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
      if (!writeSector(sector + i, src + i*512UL)) {
    588a:	ldr	r3, [r6, #0]
    588c:	mov	r2, r5
    588e:	mov	r1, r4
    5890:	ldr	r3, [r3, #24]
    5892:	mov	r0, r6
    5894:	blx	r3
    5896:	adds	r4, #1
    5898:	add.w	r5, r5, #512	; 0x200
    589c:	cmp	r0, #0
    589e:	bne.n	5886 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x16>
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
        if (!writeSector(sector, ptr)) {
          return false;  // writeSector will set errorCode.
    58a0:	movs	r0, #0
    58a2:	pop	{r3, r4, r5, r6, r7, pc}
      if (!writeSector(sector + i, src + i*512UL)) {
        return false;
      }
    }
  }
  return true;
    58a4:	movs	r0, #1
    58a6:	pop	{r3, r4, r5, r6, r7, pc}
}
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
    58a8:	lsls	r0, r2, #30
    58aa:	beq.n	58d2 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x62>
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    58ac:	cmp	r3, #0
    58ae:	beq.n	58a4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
    58b0:	add	r7, r1
    58b2:	b.n	58b8 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x48>
    58b4:	cmp	r7, r4
    58b6:	beq.n	58a4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
        if (!writeSector(sector, ptr)) {
    58b8:	ldr	r3, [r6, #0]
    58ba:	mov	r2, r5
    58bc:	mov	r1, r4
    58be:	ldr	r3, [r3, #24]
    58c0:	mov	r0, r6
    58c2:	blx	r3
//------------------------------------------------------------------------------
bool SdioCard::writeSectors(uint32_t sector, const uint8_t* src, size_t n) {
  if (m_sdioConfig.useDma()) {
    uint8_t* ptr = const_cast<uint8_t*>(src);
    if (3 & (uint32_t)ptr) {
      for (size_t i = 0; i < n; i++, sector++, ptr += 512) {
    58c4:	adds	r4, #1
    58c6:	add.w	r5, r5, #512	; 0x200
        if (!writeSector(sector, ptr)) {
    58ca:	cmp	r0, #0
    58cc:	bne.n	58b4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x44>
          return false;  // writeSector will set errorCode.
    58ce:	movs	r0, #0
    58d0:	pop	{r3, r4, r5, r6, r7, pc}
        }
      }
      return true;
    }
    if (!rdWrSectors(CMD25_DMA_XFERTYP, sector, ptr, n)) {
    58d2:	ldr	r0, [pc, #24]	; (58ec <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x7c>)
    58d4:	bl	5438 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    58d8:	cmp	r0, #0
    58da:	bne.n	58a4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x34>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    58dc:	ldr	r1, [pc, #16]	; (58f0 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x80>)
  m_errorLine = line;
    58de:	ldr	r3, [pc, #20]	; (58f4 <SdioCard::writeSectors(unsigned long, unsigned char const*, unsigned int)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    58e0:	movs	r4, #14
  m_errorLine = line;
    58e2:	movw	r2, #961	; 0x3c1
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    58e6:	strb	r4, [r1, #0]
  m_errorLine = line;
    58e8:	str	r2, [r3, #0]
    58ea:	pop	{r3, r4, r5, r6, r7, pc}
    58ec:	.word	0x193a0027
    58f0:	.word	0x1fff0974
    58f4:	.word	0x1fff1414

000058f8 <SdioCard::writeSector(unsigned long, unsigned char const*)>:
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    58f8:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    58fa:	ldrb	r3, [r0, #8]
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    58fc:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    58fe:	lsls	r2, r3, #31
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
//------------------------------------------------------------------------------
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
    5900:	sub.w	sp, sp, #512	; 0x200
    5904:	mov	r6, r1
  if (m_sdioConfig.useDma()) {
    5906:	bpl.n	593c <SdioCard::writeSector(unsigned long, unsigned char const*)+0x44>
    uint8_t *ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
    5908:	lsls	r3, r5, #30
    590a:	beq.n	591a <SdioCard::writeSector(unsigned long, unsigned char const*)+0x22>
      ptr = aligned;
      memcpy(aligned, src, 512);
    590c:	mov	r1, r5
    590e:	mov	r0, sp
    5910:	mov.w	r2, #512	; 0x200
    5914:	bl	8c24 <memcpy>
bool SdioCard::writeSector(uint32_t sector, const uint8_t* src) {
  if (m_sdioConfig.useDma()) {
    uint8_t *ptr;
    uint8_t aligned[512];
    if (3 & (uint32_t)src) {
      ptr = aligned;
    5918:	mov	r5, sp
      memcpy(aligned, src, 512);
    } else {
      ptr = const_cast<uint8_t*>(src);
    }
  if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
    591a:	mov	r2, r5
    591c:	mov	r1, r6
    591e:	movs	r3, #1
    5920:	ldr	r0, [pc, #120]	; (599c <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa4>)
    5922:	bl	5438 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    5926:	cbnz	r0, 5936 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x3e>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5928:	ldr	r1, [pc, #116]	; (59a0 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xa8>)
  m_errorLine = line;
    592a:	ldr	r3, [pc, #120]	; (59a4 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xac>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    592c:	movs	r4, #13
  m_errorLine = line;
    592e:	mov.w	r2, #920	; 0x398
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5932:	strb	r4, [r1, #0]
  m_errorLine = line;
    5934:	str	r2, [r3, #0]
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
  }
  return true;
}
    5936:	add.w	sp, sp, #512	; 0x200
    593a:	pop	{r4, r5, r6, pc}
    }
  if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    593c:	ldrb	r3, [r0, #9]
    593e:	cmp	r3, #2
    5940:	mov	r4, r0
    5942:	beq.n	5956 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x5e>
      if (!syncDevice()) {
    5944:	ldr	r3, [r4, #0]
    5946:	mov	r0, r4
    5948:	ldr	r3, [r3, #20]
    594a:	blx	r3
    594c:	cbnz	r0, 5986 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x8e>
        return false;
    594e:	movs	r0, #0
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
  }
  return true;
}
    5950:	add.w	sp, sp, #512	; 0x200
    5954:	pop	{r4, r5, r6, pc}
    }
  if (!rdWrSectors(CMD24_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD24);
    }
  } else {
    if (m_curState != WRITE_STATE || m_curSector != sector) {
    5956:	ldr	r3, [r0, #4]
    5958:	cmp	r1, r3
    595a:	bne.n	5944 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x4c>
        return false;
      }
      m_curSector = sector;
      m_curState = WRITE_STATE;
    }
    if (!writeData(src)) {
    595c:	ldr	r3, [r4, #0]
    595e:	mov	r1, r5
    5960:	ldr	r3, [r3, #68]	; 0x44
    5962:	mov	r0, r4
    5964:	blx	r3
    5966:	cmp	r0, #0
    5968:	beq.n	594e <SdioCard::writeSector(unsigned long, unsigned char const*)+0x56>
      return false;
    }
    m_curSector++;
    596a:	ldr	r3, [r4, #4]
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    596c:	ldr	r2, [pc, #56]	; (59a8 <SdioCard::writeSector(unsigned long, unsigned char const*)+0xb0>)
      m_curState = WRITE_STATE;
    }
    if (!writeData(src)) {
      return false;
    }
    m_curSector++;
    596e:	adds	r3, #1
    5970:	str	r3, [r4, #4]
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // End transfer with CMD12 if required.
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    5972:	ldr	r3, [r2, #0]
    5974:	lsrs	r3, r3, #16
    5976:	lsls	r3, r3, #16
    5978:	cmp	r3, #0
    597a:	bne.n	5936 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x3e>
      if (!syncDevice()) {
    597c:	ldr	r3, [r4, #0]
    597e:	mov	r0, r4
    5980:	ldr	r3, [r3, #20]
    5982:	blx	r3
    5984:	b.n	5936 <SdioCard::writeSector(unsigned long, unsigned char const*)+0x3e>
  } else {
    if (m_curState != WRITE_STATE || m_curSector != sector) {
      if (!syncDevice()) {
        return false;
      }
      if (!writeStart(sector )) {
    5986:	ldr	r3, [r4, #0]
    5988:	mov	r1, r6
    598a:	ldr	r3, [r3, #72]	; 0x48
    598c:	mov	r0, r4
    598e:	blx	r3
    5990:	cmp	r0, #0
    5992:	beq.n	594e <SdioCard::writeSector(unsigned long, unsigned char const*)+0x56>
        return false;
      }
      m_curSector = sector;
      m_curState = WRITE_STATE;
    5994:	movs	r3, #2
        return false;
      }
      if (!writeStart(sector )) {
        return false;
      }
      m_curSector = sector;
    5996:	str	r6, [r4, #4]
      m_curState = WRITE_STATE;
    5998:	strb	r3, [r4, #9]
    599a:	b.n	595c <SdioCard::writeSector(unsigned long, unsigned char const*)+0x64>
    599c:	.word	0x183a0001
    59a0:	.word	0x1fff0974
    59a4:	.word	0x1fff1414
    59a8:	.word	0x400b1004

000059ac <SdioCard::syncDevice()>:
uint32_t SdioCard::status() {
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
  if (m_curState == READ_STATE) {
    59ac:	ldrb	r3, [r0, #9]
    59ae:	cmp	r3, #1
    59b0:	beq.n	59cc <SdioCard::syncDevice()+0x20>
    m_curState = IDLE_STATE;
    if (!readStop()) {
      return false;
    }
  } else if (m_curState == WRITE_STATE) {
    59b2:	cmp	r3, #2
    59b4:	beq.n	59ba <SdioCard::syncDevice()+0xe>
    if (!writeStop()) {
      return false;
    }
  }
  return true;
}
    59b6:	movs	r0, #1
    59b8:	bx	lr
    m_curState = IDLE_STATE;
    if (!readStop()) {
      return false;
    }
  } else if (m_curState == WRITE_STATE) {
    m_curState = IDLE_STATE;
    59ba:	movs	r1, #0
    if (!writeStop()) {
    59bc:	ldr	r3, [r0, #0]
    m_curState = IDLE_STATE;
    if (!readStop()) {
      return false;
    }
  } else if (m_curState == WRITE_STATE) {
    m_curState = IDLE_STATE;
    59be:	strb	r1, [r0, #9]
    if (!writeStop()) {
    59c0:	ldr	r3, [r3, #76]	; 0x4c
    59c2:	ldr	r2, [pc, #20]	; (59d8 <SdioCard::syncDevice()+0x2c>)
    59c4:	cmp	r3, r2
    59c6:	bne.n	59d4 <SdioCard::syncDevice()+0x28>
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::writeStop() {
  return transferStop();
    59c8:	b.w	562c <transferStop()>
  return statusCMD13();
}
//------------------------------------------------------------------------------
bool SdioCard::syncDevice() {
  if (m_curState == READ_STATE) {
    m_curState = IDLE_STATE;
    59cc:	movs	r3, #0
    59ce:	strb	r3, [r0, #9]
  }
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readStop() {
  return transferStop();
    59d0:	b.w	562c <transferStop()>
    if (!readStop()) {
      return false;
    }
  } else if (m_curState == WRITE_STATE) {
    m_curState = IDLE_STATE;
    if (!writeStop()) {
    59d4:	bx	r3
    59d6:	nop
    59d8:	.word	0x000056a5

000059dc <cardCMD6(unsigned long, unsigned char*)>:

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    59dc:	push	{r3, r4, r5, r6, r7, lr}
    59de:	mov	r5, r0
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    59e0:	ldr	r0, [pc, #116]	; (5a58 <cardCMD6(unsigned long, unsigned char*)+0x7c>)

  return (m_irqstat & SDHC_IRQSTAT_CC) &&
         !(m_irqstat & SDHC_IRQSTAT_CMD_ERROR);
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
    59e2:	mov	r4, r1
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    59e4:	bl	524c <waitTimeout(bool (*)())>
    59e8:	cbz	r0, 59fc <cardCMD6(unsigned long, unsigned char*)+0x20>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    59ea:	ldr	r1, [pc, #112]	; (5a5c <cardCMD6(unsigned long, unsigned char*)+0x80>)
  m_errorLine = line;
    59ec:	ldr	r3, [pc, #112]	; (5a60 <cardCMD6(unsigned long, unsigned char*)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    59ee:	movs	r0, #10
  m_errorLine = line;
    59f0:	mov.w	r2, #374	; 0x176
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    59f4:	strb	r0, [r1, #0]
  m_errorLine = line;
    59f6:	str	r2, [r3, #0]
}
//------------------------------------------------------------------------------
static bool cardCMD6(uint32_t arg, uint8_t* status) {
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    59f8:	movs	r0, #0
    59fa:	pop	{r3, r4, r5, r6, r7, pc}
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    59fc:	ldr	r2, [pc, #100]	; (5a64 <cardCMD6(unsigned long, unsigned char*)+0x88>)
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    59fe:	ldr.w	lr, [pc, #132]	; 5a84 <cardCMD6(unsigned long, unsigned char*)+0xa8>
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    5a02:	ldr	r7, [pc, #100]	; (5a68 <cardCMD6(unsigned long, unsigned char*)+0x8c>)
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    5a04:	ldr	r6, [pc, #100]	; (5a6c <cardCMD6(unsigned long, unsigned char*)+0x90>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    5a06:	ldr	r3, [pc, #104]	; (5a70 <cardCMD6(unsigned long, unsigned char*)+0x94>)
  }
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
    5a08:	mov.w	ip, #1
    5a0c:	strb.w	ip, [lr]
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    5a10:	mov	r1, r5
  return true;
}
//------------------------------------------------------------------------------
static void enableDmaIrs() {
  m_dmaBusy = true;
  m_irqstat = 0;
    5a12:	str	r0, [r2, #0]
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    5a14:	ldr	r5, [pc, #92]	; (5a74 <cardCMD6(unsigned long, unsigned char*)+0x98>)
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    5a16:	ldr	r2, [pc, #96]	; (5a78 <cardCMD6(unsigned long, unsigned char*)+0x9c>)
  // CMD6 returns 64 bytes.
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
    5a18:	str	r4, [r7, #0]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    5a1a:	ldr	r0, [pc, #96]	; (5a7c <cardCMD6(unsigned long, unsigned char*)+0xa0>)
  if (waitTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
    5a1c:	str	r5, [r6, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
    5a1e:	str	r2, [r3, #0]
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    5a20:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    5a24:	cbnz	r0, 5a36 <cardCMD6(unsigned long, unsigned char*)+0x5a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5a26:	ldr	r1, [pc, #52]	; (5a5c <cardCMD6(unsigned long, unsigned char*)+0x80>)
  m_errorLine = line;
    5a28:	ldr	r3, [pc, #52]	; (5a60 <cardCMD6(unsigned long, unsigned char*)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5a2a:	movs	r4, #4
  m_errorLine = line;
    5a2c:	movw	r2, #381	; 0x17d
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5a30:	strb	r4, [r1, #0]
  m_errorLine = line;
    5a32:	str	r2, [r3, #0]
  enableDmaIrs();
  SDHC_DSADDR  = (uint32_t)status;
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
    5a34:	pop	{r3, r4, r5, r6, r7, pc}
  m_busyFcn = 0;
  return false;  // Caller will set errorCode.
}
//------------------------------------------------------------------------------
static bool waitDmaStatus() {
  if (yieldTimeout(isBusyDMA)) {
    5a36:	ldr	r0, [pc, #72]	; (5a80 <cardCMD6(unsigned long, unsigned char*)+0xa4>)
    5a38:	bl	5274 <yieldTimeout(bool (*)())>
    5a3c:	cbnz	r0, 5a46 <cardCMD6(unsigned long, unsigned char*)+0x6a>
    5a3e:	bl	5418 <waitDmaStatus() [clone .part.6]>
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(64);
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    5a42:	cbz	r0, 5a46 <cardCMD6(unsigned long, unsigned char*)+0x6a>
    return sdError(SD_CARD_ERROR_DMA);
  }
  return true;
}
    5a44:	pop	{r3, r4, r5, r6, r7, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5a46:	ldr	r1, [pc, #20]	; (5a5c <cardCMD6(unsigned long, unsigned char*)+0x80>)
  m_errorLine = line;
    5a48:	ldr	r3, [pc, #20]	; (5a60 <cardCMD6(unsigned long, unsigned char*)+0x84>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5a4a:	movs	r0, #36	; 0x24
  m_errorLine = line;
    5a4c:	mov.w	r2, #384	; 0x180
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5a50:	strb	r0, [r1, #0]
  m_errorLine = line;
    5a52:	str	r2, [r3, #0]
  SDHC_IRQSIGEN = SDHC_IRQSIGEN_MASK;
  if (!cardCommand(CMD6_XFERTYP, arg)) {
    return sdError(SD_CARD_ERROR_CMD6);
  }
  if (!waitDmaStatus()) {
    return sdError(SD_CARD_ERROR_DMA);
    5a54:	movs	r0, #0
    5a56:	pop	{r3, r4, r5, r6, r7, pc}
    5a58:	.word	0x000053d1
    5a5c:	.word	0x1fff0974
    5a60:	.word	0x1fff1414
    5a64:	.word	0x1fff13f4
    5a68:	.word	0x400b1000
    5a6c:	.word	0x400b1004
    5a70:	.word	0x400b1038
    5a74:	.word	0x00010040
    5a78:	.word	0x117f0002
    5a7c:	.word	0x063a0011
    5a80:	.word	0x000050d1
    5a84:	.word	0x1fff140c

00005a88 <SdioCard::begin(SdioConfig)>:
  return false;  // Caller will set errorCode.
}
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    5a88:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    5a8c:	ldr	r5, [pc, #568]	; (5cc8 <SdioCard::begin(SdioConfig)+0x240>)
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    5a8e:	ldr	r4, [pc, #572]	; (5ccc <SdioCard::begin(SdioConfig)+0x244>)
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
  m_initDone = false;
    5a90:	ldr.w	r8, [pc, #684]	; 5d40 <SdioCard::begin(SdioConfig)+0x2b8>
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    5a94:	ldr	r7, [pc, #568]	; (5cd0 <SdioCard::begin(SdioConfig)+0x248>)
  m_version2 = false;
    5a96:	ldr	r6, [pc, #572]	; (5cd4 <SdioCard::begin(SdioConfig)+0x24c>)
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
    5a98:	strb	r1, [r0, #8]
  m_curState = IDLE_STATE;
    5a9a:	movs	r3, #0
  m_initDone = false;
  m_errorCode = SD_CARD_ERROR_NONE;
    5a9c:	strb	r3, [r5, #0]
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
  uint32_t kHzSdClk;
  uint32_t arg;
  m_sdioConfig = sdioConfig;
  m_curState = IDLE_STATE;
    5a9e:	strb	r3, [r0, #9]
  m_initDone = false;
    5aa0:	strb.w	r3, [r8]
  m_errorCode = SD_CARD_ERROR_NONE;
  m_highCapacity = false;
    5aa4:	strb	r3, [r7, #0]
  m_version2 = false;
    5aa6:	strb	r3, [r6, #0]
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    5aa8:	ldr	r3, [r4, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    5aaa:	ldr	r2, [pc, #556]	; (5cd8 <SdioCard::begin(SdioConfig)+0x250>)
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    5aac:	ldr	r0, [pc, #556]	; (5cdc <SdioCard::begin(SdioConfig)+0x254>)
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    5aae:	ldr	r1, [pc, #560]	; (5ce0 <SdioCard::begin(SdioConfig)+0x258>)
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    5ab0:	ldr.w	lr, [pc, #656]	; 5d44 <SdioCard::begin(SdioConfig)+0x2bc>
}
//------------------------------------------------------------------------------
static void initClock() {
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
    5ab4:	orr.w	r3, r3, #201326592	; 0xc000000
    5ab8:	str	r3, [r4, #0]
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    5aba:	ldr	r3, [r2, #0]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    5abc:	add.w	r4, r4, #260096	; 0x3f800
#ifdef HAS_KINETIS_MPU
  // Allow SDHC Bus Master access.
  MPU_RGDAAC0 |= 0x0C000000;
#endif  // HAS_KINETIS_MPU
  // Enable SDHC clock.
  SIM_SCGC3 |= SIM_SCGC3_SDHC;
    5ac0:	orr.w	r3, r3, #131072	; 0x20000
    5ac4:	str	r3, [r2, #0]
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    5ac6:	adds	r4, #12
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    5ac8:	add.w	r2, r2, #428032	; 0x68800
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    5acc:	movw	r3, #259	; 0x103
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    5ad0:	addw	r2, r2, #2044	; 0x7fc
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    5ad4:	str	r3, [r0, #0]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    5ad6:	str.w	r3, [lr]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    5ada:	str	r3, [r1, #0]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    5adc:	str	r3, [r4, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    5ade:	str	r3, [r0, #16]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    5ae0:	str	r3, [r1, #12]
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    5ae2:	ldr	r3, [r2, #0]
    5ae4:	orr.w	r3, r3, #16777216	; 0x1000000
    5ae8:	orr.w	r3, r3, #32768	; 0x8000
  return false;  // Caller will set errorCode.
}
//==============================================================================
// Start of SdioCard member functions.
//==============================================================================
bool SdioCard::begin(SdioConfig sdioConfig) {
    5aec:	sub	sp, #68	; 0x44
#if defined (__IMXRT1062__)
  SDHC_MIX_CTRL |= 0x80000000;
#endif

  // Reset SDHC. Use default Water Mark Level of 16.
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    5aee:	str	r3, [r2, #0]

  while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA) {
    5af0:	ldr	r3, [r2, #0]
    5af2:	ldr	r4, [pc, #496]	; (5ce4 <SdioCard::begin(SdioConfig)+0x25c>)
    5af4:	lsls	r1, r3, #7
    5af6:	bmi.n	5af0 <SdioCard::begin(SdioConfig)+0x68>
  }

  // Set initial SCK rate.
  setSdclk(400);
    5af8:	mov.w	r0, #400	; 0x190
    5afc:	bl	511c <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    5b00:	ldr.w	ip, [pc, #472]	; 5cdc <SdioCard::begin(SdioConfig)+0x254>
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    5b04:	ldr.w	lr, [pc, #572]	; 5d44 <SdioCard::begin(SdioConfig)+0x2bc>
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    5b08:	ldr	r1, [pc, #468]	; (5ce0 <SdioCard::begin(SdioConfig)+0x258>)
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    5b0a:	ldr	r2, [pc, #476]	; (5ce8 <SdioCard::begin(SdioConfig)+0x260>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    5b0c:	ldr	r0, [pc, #476]	; (5cec <SdioCard::begin(SdioConfig)+0x264>)
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    5b0e:	movw	r3, #1091	; 0x443
    5b12:	str.w	r3, [ip]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    5b16:	str.w	r3, [lr]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    5b1a:	mov.w	lr, #1088	; 0x440
    5b1e:	str.w	lr, [r1]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    5b22:	str	r3, [r2, #0]
  setSdclk(400);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    5b24:	add.w	r2, r2, #409600	; 0x64000
    5b28:	adds	r2, #40	; 0x28

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    5b2a:	str	r3, [r0, #0]
  setSdclk(400);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    5b2c:	ldr	r0, [pc, #448]	; (5cf0 <SdioCard::begin(SdioConfig)+0x268>)
  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    5b2e:	str	r3, [r1, #12]
  setSdclk(400);

  enableGPIO(true);

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;
    5b30:	str	r0, [r2, #0]

  attachInterruptVector(IRQ_SDHC, sdIrs);
    5b32:	ldr	r1, [pc, #448]	; (5cf4 <SdioCard::begin(SdioConfig)+0x26c>)
    5b34:	movs	r0, #81	; 0x51
    5b36:	bl	99bc <attachInterruptVector>
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    5b3a:	ldr	r3, [pc, #444]	; (5cf8 <SdioCard::begin(SdioConfig)+0x270>)

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    5b3c:	ldr	r1, [pc, #444]	; (5cfc <SdioCard::begin(SdioConfig)+0x274>)
    5b3e:	movs	r0, #96	; 0x60
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    5b40:	mov.w	r2, #131072	; 0x20000

  // Enable desired IRQSTAT bits.
  SDHC_IRQSTATEN = SDHC_IRQSTATEN_MASK;

  attachInterruptVector(IRQ_SDHC, sdIrs);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6*16);
    5b44:	strb	r0, [r1, #0]
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    5b46:	str	r2, [r3, #0]

  // Send 80 clocks to card.
  SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    5b48:	ldr	r3, [r4, #0]
    5b4a:	orr.w	r3, r3, #134217728	; 0x8000000
    5b4e:	str	r3, [r4, #0]
  while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) {
    5b50:	ldr	r1, [r4, #0]
    5b52:	ands.w	r1, r1, #134217728	; 0x8000000
    5b56:	bne.n	5b50 <SdioCard::begin(SdioConfig)+0xc8>
  m_highCapacity = false;
  m_version2 = false;

  // initialize controller.
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    5b58:	mov	r0, r1
    5b5a:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    5b5e:	mov	r4, r0
    5b60:	cmp	r0, #0
    5b62:	beq.n	5c02 <SdioCard::begin(SdioConfig)+0x17a>
    5b64:	movs	r4, #3
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
    5b66:	mov.w	r1, #426	; 0x1aa
    5b6a:	ldr	r0, [pc, #404]	; (5d00 <SdioCard::begin(SdioConfig)+0x278>)
    5b6c:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    5b70:	cmp	r0, #0
    5b72:	bne.n	5c30 <SdioCard::begin(SdioConfig)+0x1a8>
  initSDHC();
  if (!cardCommand(CMD0_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    5b74:	subs	r4, #1
    5b76:	bne.n	5b66 <SdioCard::begin(SdioConfig)+0xde>
      }
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    5b78:	ldrb	r3, [r6, #0]
    5b7a:	ldr	r6, [pc, #392]	; (5d04 <SdioCard::begin(SdioConfig)+0x27c>)
    5b7c:	cmp	r3, #0
    5b7e:	it	eq
    5b80:	moveq.w	r6, #3145728	; 0x300000
  int m = micros();
    5b84:	bl	9a08 <micros>
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    5b88:	ldr	r4, [pc, #380]	; (5d08 <SdioCard::begin(SdioConfig)+0x280>)
      m_version2 = true;
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
    5b8a:	mov	r9, r0
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    5b8c:	movs	r1, #0
    5b8e:	ldr	r0, [pc, #380]	; (5d0c <SdioCard::begin(SdioConfig)+0x284>)
    5b90:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    5b94:	cbnz	r0, 5bac <SdioCard::begin(SdioConfig)+0x124>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    5b96:	ldr	r2, [pc, #376]	; (5d10 <SdioCard::begin(SdioConfig)+0x288>)
    5b98:	movw	r1, #618	; 0x26a
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5b9c:	movs	r3, #23
  m_errorLine = line;
    5b9e:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5ba0:	strb	r3, [r5, #0]
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    5ba2:	movs	r4, #0

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    5ba4:	mov	r0, r4
    5ba6:	add	sp, #68	; 0x44
    5ba8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    5bac:	mov	r1, r6
    5bae:	ldr	r0, [pc, #356]	; (5d14 <SdioCard::begin(SdioConfig)+0x28c>)
    5bb0:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    5bb4:	cmp	r0, #0
    5bb6:	beq.n	5b96 <SdioCard::begin(SdioConfig)+0x10e>
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
    5bb8:	bl	9a08 <micros>
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    5bbc:	ldr	r3, [pc, #344]	; (5d18 <SdioCard::begin(SdioConfig)+0x290>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    5bbe:	ldr	r2, [pc, #328]	; (5d08 <SdioCard::begin(SdioConfig)+0x280>)
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
    5bc0:	rsb	r0, r9, r0
    5bc4:	cmp	r0, r3
    5bc6:	bhi.n	5b96 <SdioCard::begin(SdioConfig)+0x10e>
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
    5bc8:	ldr	r3, [r4, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
  int m = micros();
  do {
    5bca:	cmp	r3, #0
    5bcc:	bge.n	5b8c <SdioCard::begin(SdioConfig)+0x104>
    if (!cardAcmd(0, ACMD41_XFERTYP, arg) ||
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
    5bce:	ldr	r3, [pc, #332]	; (5d1c <SdioCard::begin(SdioConfig)+0x294>)
    5bd0:	ldr	r1, [r2, #0]
    5bd2:	str	r1, [r3, #0]
  if (SDHC_CMDRSP0 & 0x40000000) {
    5bd4:	ldr	r3, [r2, #0]
    // Is high capacity.
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    5bd6:	ldr	r0, [pc, #328]	; (5d20 <SdioCard::begin(SdioConfig)+0x298>)
       ((micros() - m) > BUSY_TIMEOUT_MICROS)) {
      return sdError(SD_CARD_ERROR_ACMD41);
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    5bd8:	lsls	r2, r3, #1
    // Is high capacity.
    m_highCapacity = true;
    5bda:	it	mi
    5bdc:	movmi	r3, #1
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    5bde:	mov.w	r1, #0
    }
  } while ((SDHC_CMDRSP0 & 0x80000000) == 0);
  m_ocr = SDHC_CMDRSP0;
  if (SDHC_CMDRSP0 & 0x40000000) {
    // Is high capacity.
    m_highCapacity = true;
    5be2:	it	mi
    5be4:	strbmi	r3, [r7, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    5be6:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    5bea:	mov	r4, r0
    5bec:	cbnz	r0, 5c16 <SdioCard::begin(SdioConfig)+0x18e>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    5bee:	ldr	r2, [pc, #288]	; (5d10 <SdioCard::begin(SdioConfig)+0x288>)
    5bf0:	movw	r1, #627	; 0x273
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5bf4:	movs	r3, #2

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    5bf6:	mov	r0, r4
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    5bf8:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5bfa:	strb	r3, [r5, #0]

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    5bfc:	add	sp, #68	; 0x44
    5bfe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    5c02:	ldr	r2, [pc, #268]	; (5d10 <SdioCard::begin(SdioConfig)+0x288>)
    5c04:	movw	r1, #601	; 0x259
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5c08:	movs	r3, #1

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    5c0a:	mov	r0, r4
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    5c0c:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5c0e:	strb	r3, [r5, #0]

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
  return true;
}
    5c10:	add	sp, #68	; 0x44
    5c12:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    m_highCapacity = true;
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    5c16:	movs	r1, #0
    5c18:	ldr	r0, [pc, #264]	; (5d24 <SdioCard::begin(SdioConfig)+0x29c>)
    5c1a:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    5c1e:	mov	r4, r0
    5c20:	cbnz	r0, 5c52 <SdioCard::begin(SdioConfig)+0x1ca>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    5c22:	ldr	r2, [pc, #236]	; (5d10 <SdioCard::begin(SdioConfig)+0x288>)
    5c24:	movw	r1, #630	; 0x276
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5c28:	movs	r3, #3
  m_errorLine = line;
    5c2a:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5c2c:	strb	r3, [r5, #0]
  }
  if (!cardCommand(CMD2_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
    5c2e:	b.n	5ba4 <SdioCard::begin(SdioConfig)+0x11c>
    return sdError(SD_CARD_ERROR_CMD0);
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
    5c30:	ldr	r3, [pc, #212]	; (5d08 <SdioCard::begin(SdioConfig)+0x280>)
    5c32:	ldr	r3, [r3, #0]
    5c34:	cmp.w	r3, #426	; 0x1aa
    5c38:	beq.n	5c4a <SdioCard::begin(SdioConfig)+0x1c2>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    5c3a:	ldr	r2, [pc, #212]	; (5d10 <SdioCard::begin(SdioConfig)+0x288>)
    5c3c:	movw	r1, #607	; 0x25f
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5c40:	movs	r3, #6
  m_errorLine = line;
    5c42:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5c44:	strb	r3, [r5, #0]
  }
  // Try several times for case of reset delay.
  for (uint32_t i = 0; i < CMD8_RETRIES; i++) {
    if (cardCommand(CMD8_XFERTYP, 0X1AA)) {
      if (SDHC_CMDRSP0 != 0X1AA) {
        return sdError(SD_CARD_ERROR_CMD8);
    5c46:	movs	r4, #0
    5c48:	b.n	5ba4 <SdioCard::begin(SdioConfig)+0x11c>
      }
      m_version2 = true;
    5c4a:	movs	r3, #1
    5c4c:	strb	r3, [r6, #0]
      break;
    }
  }
  arg = m_version2 ? 0X40300000 : 0x00300000;
    5c4e:	ldr	r6, [pc, #180]	; (5d04 <SdioCard::begin(SdioConfig)+0x27c>)
    5c50:	b.n	5b84 <SdioCard::begin(SdioConfig)+0xfc>
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    5c52:	ldr	r3, [pc, #180]	; (5d08 <SdioCard::begin(SdioConfig)+0x280>)
    5c54:	ldr	r6, [pc, #208]	; (5d28 <SdioCard::begin(SdioConfig)+0x2a0>)
    5c56:	ldr	r3, [r3, #0]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    5c58:	ldr	r1, [pc, #208]	; (5d2c <SdioCard::begin(SdioConfig)+0x2a4>)
    5c5a:	ldr	r0, [pc, #212]	; (5d30 <SdioCard::begin(SdioConfig)+0x2a8>)
    return sdError(SD_CARD_ERROR_CMD2);
  }
  if (!cardCommand(CMD3_XFERTYP, 0)) {
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;
    5c5c:	lsrs	r3, r3, #16
    5c5e:	lsls	r3, r3, #16
    5c60:	str	r3, [r6, #0]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    5c62:	bl	536c <readReg16(unsigned long, void*)>
    5c66:	mov	r4, r0
    5c68:	cbnz	r0, 5c78 <SdioCard::begin(SdioConfig)+0x1f0>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    5c6a:	ldr	r2, [pc, #164]	; (5d10 <SdioCard::begin(SdioConfig)+0x288>)
    5c6c:	movw	r1, #635	; 0x27b
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5c70:	movs	r3, #7
  m_errorLine = line;
    5c72:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5c74:	strb	r3, [r5, #0]
    return sdError(SD_CARD_ERROR_CMD3);
  }
  m_rca = SDHC_CMDRSP0 & 0xFFFF0000;

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
    5c76:	b.n	5ba4 <SdioCard::begin(SdioConfig)+0x11c>
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    5c78:	ldr	r1, [pc, #184]	; (5d34 <SdioCard::begin(SdioConfig)+0x2ac>)
    5c7a:	ldr	r0, [pc, #188]	; (5d38 <SdioCard::begin(SdioConfig)+0x2b0>)
    5c7c:	bl	536c <readReg16(unsigned long, void*)>
    5c80:	mov	r4, r0
    5c82:	cbnz	r0, 5c92 <SdioCard::begin(SdioConfig)+0x20a>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    5c84:	ldr	r2, [pc, #136]	; (5d10 <SdioCard::begin(SdioConfig)+0x288>)
    5c86:	movw	r1, #638	; 0x27e
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5c8a:	movs	r3, #8
  m_errorLine = line;
    5c8c:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5c8e:	strb	r3, [r5, #0]

  if (!readReg16(CMD9_XFERTYP, &m_csd)) {
    return sdError(SD_CARD_ERROR_CMD9);
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
    5c90:	b.n	5ba4 <SdioCard::begin(SdioConfig)+0x11c>
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    5c92:	ldr	r1, [r6, #0]
    5c94:	ldr	r0, [pc, #164]	; (5d3c <SdioCard::begin(SdioConfig)+0x2b4>)
    5c96:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    5c9a:	mov	r4, r0
    5c9c:	cbnz	r0, 5cac <SdioCard::begin(SdioConfig)+0x224>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    5c9e:	ldr	r2, [pc, #112]	; (5d10 <SdioCard::begin(SdioConfig)+0x288>)
    5ca0:	movw	r1, #641	; 0x281
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5ca4:	movs	r3, #5
  m_errorLine = line;
    5ca6:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5ca8:	strb	r3, [r5, #0]
  }
  if (!readReg16(CMD10_XFERTYP, &m_cid)) {
    return sdError(SD_CARD_ERROR_CMD10);
  }
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
    5caa:	b.n	5ba4 <SdioCard::begin(SdioConfig)+0x11c>
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    5cac:	ldr	r1, [r6, #0]
    5cae:	ldr	r0, [pc, #92]	; (5d0c <SdioCard::begin(SdioConfig)+0x284>)
    5cb0:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    5cb4:	cmp	r0, #0
    5cb6:	bne.n	5d48 <SdioCard::begin(SdioConfig)+0x2c0>
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    5cb8:	ldr	r2, [pc, #84]	; (5d10 <SdioCard::begin(SdioConfig)+0x288>)
    5cba:	movw	r1, #645	; 0x285
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5cbe:	movs	r3, #20
  m_errorLine = line;
    5cc0:	str	r1, [r2, #0]
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5cc2:	strb	r3, [r5, #0]
  if (!cardCommand(CMD7_XFERTYP, m_rca)) {
    return sdError(SD_CARD_ERROR_CMD7);
  }
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
    5cc4:	movs	r4, #0
    5cc6:	b.n	5ba4 <SdioCard::begin(SdioConfig)+0x11c>
    5cc8:	.word	0x1fff0974
    5ccc:	.word	0x4000d800
    5cd0:	.word	0x1fff13e8
    5cd4:	.word	0x1fff13d0
    5cd8:	.word	0x40048030
    5cdc:	.word	0x4004d000
    5ce0:	.word	0x4004d008
    5ce4:	.word	0x400b102c
    5ce8:	.word	0x4004d00c
    5cec:	.word	0x4004d010
    5cf0:	.word	0x117f000b
    5cf4:	.word	0x00005079
    5cf8:	.word	0xe000e108
    5cfc:	.word	0xe000e451
    5d00:	.word	0x081a0000
    5d04:	.word	0x40300000
    5d08:	.word	0x400b1010
    5d0c:	.word	0x371a0000
    5d10:	.word	0x1fff1414
    5d14:	.word	0x29020000
    5d18:	.word	0x000f4240
    5d1c:	.word	0x1fff13ec
    5d20:	.word	0x02090000
    5d24:	.word	0x031a0000
    5d28:	.word	0x1fff13f0
    5d2c:	.word	0x1fff13fc
    5d30:	.word	0x09090000
    5d34:	.word	0x1fff13d4
    5d38:	.word	0x0a090000
    5d3c:	.word	0x071b0000
    5d40:	.word	0x1fff13f8
    5d44:	.word	0x4004d004
}
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
//==============================================================================
// Static functions.
static bool cardAcmd(uint32_t rca, uint32_t xfertyp, uint32_t arg) {
  return cardCommand(CMD55_XFERTYP, rca) && cardCommand (xfertyp, arg);
    5d48:	movs	r1, #2
    5d4a:	ldr	r0, [pc, #168]	; (5df4 <SdioCard::begin(SdioConfig)+0x36c>)
    5d4c:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    5d50:	mov	r4, r0
    5d52:	cmp	r0, #0
    5d54:	beq.n	5cb8 <SdioCard::begin(SdioConfig)+0x230>
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    5d56:	ldr	r3, [pc, #160]	; (5df8 <SdioCard::begin(SdioConfig)+0x370>)
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    5d58:	ldr	r0, [pc, #160]	; (5dfc <SdioCard::begin(SdioConfig)+0x374>)
  // Set card to bus width four.
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    5d5a:	ldr	r2, [r3, #0]
    5d5c:	bic.w	r2, r2, #6
    5d60:	str	r2, [r3, #0]
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    5d62:	ldr	r2, [r3, #0]

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    5d64:	mov.w	r5, #1048592	; 0x100010
  if (!cardAcmd(m_rca, ACMD6_XFERTYP, 2)) {
    return sdError(SD_CARD_ERROR_ACMD6);
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    5d68:	orr.w	r2, r2, #2
    5d6c:	str	r2, [r3, #0]
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    5d6e:	mov	r1, sp
  }
  // Set SDHC to bus width four.
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);

  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);
    5d70:	str	r5, [r0, #0]

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    5d72:	mvn.w	r0, #4278190080	; 0xff000000
    5d76:	bl	59dc <cardCMD6(unsigned long, unsigned char*)>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    5d7a:	cbz	r0, 5d84 <SdioCard::begin(SdioConfig)+0x2fc>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    5d7c:	ldrb.w	r3, [sp, #13]
    5d80:	lsls	r3, r3, #30
    5d82:	bmi.n	5dd6 <SdioCard::begin(SdioConfig)+0x34e>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    kHzSdClk = 50000;
  } else {
    kHzSdClk = 25000;
    5d84:	movw	r0, #25000	; 0x61a8
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    5d88:	ldr.w	fp, [pc, #132]	; 5e10 <SdioCard::begin(SdioConfig)+0x388>
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    5d8c:	ldr.w	sl, [pc, #132]	; 5e14 <SdioCard::begin(SdioConfig)+0x38c>
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    5d90:	ldr.w	r9, [pc, #132]	; 5e18 <SdioCard::begin(SdioConfig)+0x390>
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    5d94:	ldr	r7, [pc, #104]	; (5e00 <SdioCard::begin(SdioConfig)+0x378>)
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    5d96:	ldr	r6, [pc, #108]	; (5e04 <SdioCard::begin(SdioConfig)+0x37c>)
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    5d98:	ldr	r5, [pc, #108]	; (5e08 <SdioCard::begin(SdioConfig)+0x380>)
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    5d9a:	movw	r3, #259	; 0x103
    5d9e:	str.w	r3, [fp]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    5da2:	str.w	r3, [sl]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    5da6:	str.w	r3, [r9]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    5daa:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    5dac:	str	r3, [r6, #0]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    5dae:	str	r3, [r5, #0]
  }
  // Disable GPIO.
  enableGPIO(false);

  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);
    5db0:	bl	511c <setSdclk(unsigned long)>
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    5db4:	movw	r3, #1091	; 0x443
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    5db8:	mov.w	r1, #1088	; 0x440
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    5dbc:	movs	r2, #1
static void enableGPIO(bool enable) {
  const uint32_t PORT_CLK = PORT_PCR_MUX(4) | PORT_PCR_DSE;
  const uint32_t PORT_CMD_DATA = PORT_CLK   | PORT_PCR_PE | PORT_PCR_PS;
  const uint32_t PORT_PUP = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;

  PORTE_PCR0 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D1
    5dbe:	str.w	r3, [fp]
  PORTE_PCR1 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D0
    5dc2:	str.w	r3, [sl]
  PORTE_PCR2 = enable ? PORT_CLK      : PORT_PUP;  // SDHC_CLK
    5dc6:	str.w	r1, [r9]
  PORTE_PCR3 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_CMD
    5dca:	str	r3, [r7, #0]
  PORTE_PCR4 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D3
    5dcc:	str	r3, [r6, #0]
  PORTE_PCR5 = enable ? PORT_CMD_DATA : PORT_PUP;  // SDHC_D2
    5dce:	str	r3, [r5, #0]
  // Set the SDHC SCK frequency.
  setSdclk(kHzSdClk);

  // Enable GPIO.
  enableGPIO(true);
  m_initDone = true;
    5dd0:	strb.w	r2, [r8]
  return true;
    5dd4:	b.n	5ba4 <SdioCard::begin(SdioConfig)+0x11c>

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    5dd6:	mov	r1, sp
    5dd8:	ldr	r0, [pc, #48]	; (5e0c <SdioCard::begin(SdioConfig)+0x384>)
    5dda:	bl	59dc <cardCMD6(unsigned long, unsigned char*)>
  SDHC_WML = SDHC_WML_RDWML(FIFO_WML) | SDHC_WML_WRWML(FIFO_WML);

  // Determine if High Speed mode is supported and set frequency.
  // Check status[16] for error 0XF or status[16] for new mode 0X1.
  uint8_t status[64];
  if (cardCMD6(0X00FFFFFF, status) && (2 & status[13]) &&
    5dde:	cmp	r0, #0
    5de0:	beq.n	5d84 <SdioCard::begin(SdioConfig)+0x2fc>
      cardCMD6(0X80FFFFF1, status) && (status[16] & 0XF) == 1) {
    5de2:	ldrb.w	r3, [sp, #16]
    5de6:	and.w	r3, r3, #15
    5dea:	cmp	r3, #1
    5dec:	bne.n	5d84 <SdioCard::begin(SdioConfig)+0x2fc>
    kHzSdClk = 50000;
    5dee:	movw	r0, #50000	; 0xc350
    5df2:	b.n	5d88 <SdioCard::begin(SdioConfig)+0x300>
    5df4:	.word	0x061a0000
    5df8:	.word	0x400b1028
    5dfc:	.word	0x400b1044
    5e00:	.word	0x4004d00c
    5e04:	.word	0x4004d010
    5e08:	.word	0x4004d014
    5e0c:	.word	0x80fffff1
    5e10:	.word	0x4004d000
    5e14:	.word	0x4004d004
    5e18:	.word	0x4004d008

00005e1c <SdioCard::readData(unsigned char*)>:
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t *dst) {
    5e1c:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  uint32_t *p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    5e1e:	ldr	r3, [pc, #160]	; (5ec0 <SdioCard::readData(unsigned char*)+0xa4>)
    5e20:	ldr	r3, [r3, #0]
    5e22:	lsls	r0, r3, #22
bool SdioCard::readCSD(csd_t* csd) {
  memcpy(csd, &m_csd, 16);
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readData(uint8_t *dst) {
    5e24:	mov	r5, r1
  DBG_IRQSTAT();
  uint32_t *p32 = reinterpret_cast<uint32_t*>(dst);

  if (!(SDHC_PRSSTAT & SDHC_PRSSTAT_RTA)) {
    5e26:	bmi.n	5e46 <SdioCard::readData(unsigned char*)+0x2a>
    SDHC_PROCTL &= ~SDHC_PROCTL_SABGREQ;
    5e28:	ldr	r3, [pc, #152]	; (5ec4 <SdioCard::readData(unsigned char*)+0xa8>)
    5e2a:	ldr	r2, [r3, #0]
    5e2c:	bic.w	r2, r2, #65536	; 0x10000
    5e30:	str	r2, [r3, #0]
    noInterrupts();
    5e32:	cpsid	i
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    5e34:	ldr	r2, [r3, #0]
    5e36:	orr.w	r2, r2, #131072	; 0x20000
    5e3a:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    5e3c:	ldr	r2, [r3, #0]
    5e3e:	orr.w	r2, r2, #65536	; 0x10000
    5e42:	str	r2, [r3, #0]
    interrupts();
    5e44:	cpsie	i
  }
  if (waitTimeout(isBusyFifoRead)) {
    5e46:	ldr	r0, [pc, #128]	; (5ec8 <SdioCard::readData(unsigned char*)+0xac>)
    5e48:	bl	524c <waitTimeout(bool (*)())>
    5e4c:	cmp	r0, #0
    5e4e:	bne.n	5eae <SdioCard::readData(unsigned char*)+0x92>
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    5e50:	ldr	r4, [pc, #108]	; (5ec0 <SdioCard::readData(unsigned char*)+0xa4>)
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    5e52:	ldr	r0, [pc, #120]	; (5ecc <SdioCard::readData(unsigned char*)+0xb0>)
    5e54:	subs	r3, r5, #4
    5e56:	add.w	r5, r5, #508	; 0x1fc
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    5e5a:	ldr	r2, [r4, #0]
    5e5c:	lsls	r1, r2, #20
    5e5e:	bpl.n	5e5a <SdioCard::readData(unsigned char*)+0x3e>
    5e60:	add.w	r1, r3, #64	; 0x40
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    5e64:	ldr	r2, [r0, #0]
    5e66:	str.w	r2, [r3, #4]!
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    while (0 == (SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) {
    }
    for (uint32_t i = 0; i < FIFO_WML; i++) {
    5e6a:	cmp	r1, r3
    5e6c:	bne.n	5e64 <SdioCard::readData(unsigned char*)+0x48>
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
  }
  for (uint32_t iw = 0 ; iw < 512/(4*FIFO_WML); iw++) {
    5e6e:	cmp	r5, r1
    5e70:	mov	r3, r1
    5e72:	bne.n	5e5a <SdioCard::readData(unsigned char*)+0x3e>
    for (uint32_t i = 0; i < FIFO_WML; i++) {
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    5e74:	ldr	r0, [pc, #88]	; (5ed0 <SdioCard::readData(unsigned char*)+0xb4>)
    5e76:	bl	524c <waitTimeout(bool (*)())>
    5e7a:	cbnz	r0, 5e9c <SdioCard::readData(unsigned char*)+0x80>
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
    5e7c:	ldr	r2, [pc, #84]	; (5ed4 <SdioCard::readData(unsigned char*)+0xb8>)
    5e7e:	ldr	r3, [pc, #88]	; (5ed8 <SdioCard::readData(unsigned char*)+0xbc>)
    5e80:	ldr	r1, [r2, #0]
    5e82:	str	r1, [r3, #0]
  SDHC_IRQSTAT = m_irqstat;
    5e84:	ldr	r1, [r3, #0]
    5e86:	str	r1, [r2, #0]
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
    5e88:	ldr	r2, [r3, #0]
    5e8a:	lsls	r2, r2, #30
    5e8c:	bpl.n	5ebe <SdioCard::readData(unsigned char*)+0xa2>
    5e8e:	ldr	r3, [r3, #0]
    5e90:	ldr	r0, [pc, #72]	; (5edc <SdioCard::readData(unsigned char*)+0xc0>)
    5e92:	ands	r0, r3
    5e94:	clz	r0, r0
    5e98:	lsrs	r0, r0, #5
    5e9a:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5e9c:	ldr	r1, [pc, #64]	; (5ee0 <SdioCard::readData(unsigned char*)+0xc4>)
  m_errorLine = line;
    5e9e:	ldr	r3, [pc, #68]	; (5ee4 <SdioCard::readData(unsigned char*)+0xc8>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5ea0:	movs	r0, #29
  m_errorLine = line;
    5ea2:	mov.w	r2, #756	; 0x2f4
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5ea6:	strb	r0, [r1, #0]
  m_errorLine = line;
    5ea8:	str	r2, [r3, #0]
      p32[i] = SDHC_DATPORT;
    }
    p32 += FIFO_WML;
  }
  if (waitTimeout(isBusyTransferComplete)) {
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
    5eaa:	movs	r0, #0
    5eac:	pop	{r3, r4, r5, pc}
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5eae:	ldr	r1, [pc, #48]	; (5ee0 <SdioCard::readData(unsigned char*)+0xc4>)
  m_errorLine = line;
    5eb0:	ldr	r3, [pc, #48]	; (5ee4 <SdioCard::readData(unsigned char*)+0xc8>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5eb2:	movs	r0, #26
  m_errorLine = line;
    5eb4:	movw	r2, #745	; 0x2e9
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5eb8:	strb	r0, [r1, #0]
  m_errorLine = line;
    5eba:	str	r2, [r3, #0]
    SDHC_PROCTL |= SDHC_PROCTL_CREQ;
    SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    interrupts();
  }
  if (waitTimeout(isBusyFifoRead)) {
    return sdError(SD_CARD_ERROR_READ_FIFO);
    5ebc:	movs	r0, #0
    return sdError(SD_CARD_ERROR_READ_TIMEOUT);
  }
  m_irqstat = SDHC_IRQSTAT;
  SDHC_IRQSTAT = m_irqstat;
  return (m_irqstat & SDHC_IRQSTAT_TC) && !(m_irqstat & SDHC_IRQSTAT_ERROR);
}
    5ebe:	pop	{r3, r4, r5, pc}
    5ec0:	.word	0x400b1024
    5ec4:	.word	0x400b1028
    5ec8:	.word	0x000050dd
    5ecc:	.word	0x400b1020
    5ed0:	.word	0x00005105
    5ed4:	.word	0x400b1030
    5ed8:	.word	0x1fff13f4
    5edc:	.word	0x117f0000
    5ee0:	.word	0x1fff0974
    5ee4:	.word	0x1fff1414

00005ee8 <SdioCard::readStart(unsigned long)>:
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    5ee8:	push	{r3, r4, r5, lr}
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    5eea:	ldr	r0, [pc, #80]	; (5f3c <SdioCard::readStart(unsigned long)+0x54>)
  }
  return true;
}
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
    5eec:	mov	r4, r1
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    5eee:	bl	5274 <yieldTimeout(bool (*)())>
    5ef2:	cbnz	r0, 5f28 <SdioCard::readStart(unsigned long)+0x40>
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    5ef4:	ldr	r2, [pc, #72]	; (5f40 <SdioCard::readStart(unsigned long)+0x58>)
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(0XFFFF) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    5ef6:	ldr	r1, [pc, #76]	; (5f44 <SdioCard::readStart(unsigned long)+0x5c>)
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    5ef8:	ldr	r3, [r2, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(0XFFFF) | SDHC_BLKATTR_BLKSIZE(512);
    5efa:	ldr	r0, [pc, #76]	; (5f48 <SdioCard::readStart(unsigned long)+0x60>)
    5efc:	ldr	r5, [pc, #76]	; (5f4c <SdioCard::readStart(unsigned long)+0x64>)
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
  }
  SDHC_PROCTL |= SDHC_PROCTL_SABGREQ;
    5efe:	orr.w	r3, r3, #65536	; 0x10000
    5f02:	str	r3, [r2, #0]
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(0XFFFF) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    5f04:	ldrb	r3, [r1, #0]
#if defined(__IMXRT1062__)
  // Infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKSIZE(512);
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(0XFFFF) | SDHC_BLKATTR_BLKSIZE(512);
    5f06:	str	r5, [r0, #0]
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    5f08:	cbnz	r3, 5f24 <SdioCard::readStart(unsigned long)+0x3c>
    5f0a:	lsls	r1, r4, #9
    5f0c:	ldr	r0, [pc, #64]	; (5f50 <SdioCard::readStart(unsigned long)+0x68>)
    5f0e:	bl	52f0 <cardCommand(unsigned long, unsigned long)>
    5f12:	cbnz	r0, 5f22 <SdioCard::readStart(unsigned long)+0x3a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5f14:	ldr	r1, [pc, #60]	; (5f54 <SdioCard::readStart(unsigned long)+0x6c>)
  m_errorLine = line;
    5f16:	ldr	r3, [pc, #64]	; (5f58 <SdioCard::readStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5f18:	movs	r4, #12
  m_errorLine = line;
    5f1a:	movw	r2, #845	; 0x34d
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5f1e:	strb	r4, [r1, #0]
  m_errorLine = line;
    5f20:	str	r2, [r3, #0]

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    return sdError(SD_CARD_ERROR_CMD18);
  }
  return true;
}
    5f22:	pop	{r3, r4, r5, pc}
#else  // defined(__IMXRT1062__)
  // Errata - can't do infinite transfer.
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(0XFFFF) | SDHC_BLKATTR_BLKSIZE(512);
#endif  // defined(__IMXRT1062__)

  if (!cardCommand(CMD18_PGM_XFERTYP, m_highCapacity ? sector : 512*sector)) {
    5f24:	mov	r1, r4
    5f26:	b.n	5f0c <SdioCard::readStart(unsigned long)+0x24>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5f28:	ldr	r1, [pc, #40]	; (5f54 <SdioCard::readStart(unsigned long)+0x6c>)
  m_errorLine = line;
    5f2a:	ldr	r3, [pc, #44]	; (5f58 <SdioCard::readStart(unsigned long)+0x70>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5f2c:	movs	r0, #10
  m_errorLine = line;
    5f2e:	movw	r2, #833	; 0x341
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5f32:	strb	r0, [r1, #0]
  m_errorLine = line;
    5f34:	str	r2, [r3, #0]
//------------------------------------------------------------------------------
// SDHC will do Auto CMD12 after count sectors.
bool SdioCard::readStart(uint32_t sector) {
  DBG_IRQSTAT();
  if (yieldTimeout(isBusyCMD13)) {
    return sdError(SD_CARD_ERROR_CMD13);
    5f36:	movs	r0, #0
    5f38:	pop	{r3, r4, r5, pc}
    5f3a:	nop
    5f3c:	.word	0x000053d1
    5f40:	.word	0x400b1028
    5f44:	.word	0x1fff13e8
    5f48:	.word	0x400b1004
    5f4c:	.word	0xffff0200
    5f50:	.word	0x123a0032
    5f54:	.word	0x1fff0974
    5f58:	.word	0x1fff1414

00005f5c <SdioCard::readSector(unsigned long, unsigned char*)>:
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    5f5c:	push	{r4, r5, r6, lr}
  if (m_sdioConfig.useDma()) {
    5f5e:	ldrb	r3, [r0, #8]
    5f60:	lsls	r4, r3, #31
bool SdioCard::readOCR(uint32_t* ocr) {
  *ocr = m_ocr;
  return true;
}
//------------------------------------------------------------------------------
bool SdioCard::readSector(uint32_t sector, uint8_t* dst) {
    5f62:	sub.w	sp, sp, #512	; 0x200
    5f66:	mov	r5, r2
  if (m_sdioConfig.useDma()) {
    5f68:	bpl.n	5f90 <SdioCard::readSector(unsigned long, unsigned char*)+0x34>
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;
    5f6a:	lsls	r3, r2, #30
    5f6c:	beq.n	5fae <SdioCard::readSector(unsigned long, unsigned char*)+0x52>

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    5f6e:	mov	r2, sp
    5f70:	movs	r3, #1
    5f72:	ldr	r0, [pc, #168]	; (601c <SdioCard::readSector(unsigned long, unsigned char*)+0xc0>)
    5f74:	bl	5438 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    5f78:	cbz	r0, 5fba <SdioCard::readSector(unsigned long, unsigned char*)+0x5e>
      return sdError(SD_CARD_ERROR_CMD17);
    }
    if (ptr != dst) {
      memcpy(dst, aligned, 512);
    5f7a:	mov	r1, sp
    5f7c:	mov	r0, r5
    5f7e:	mov.w	r2, #512	; 0x200
    5f82:	bl	8c24 <memcpy>
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
    5f86:	movs	r5, #1
}
    5f88:	mov	r0, r5
    5f8a:	add.w	sp, sp, #512	; 0x200
    5f8e:	pop	{r4, r5, r6, pc}
    }
    if (ptr != dst) {
      memcpy(dst, aligned, 512);
    }
  } else {
    if (m_curState != READ_STATE || sector != m_curSector) {
    5f90:	ldrb	r3, [r0, #9]
    5f92:	cmp	r3, #1
    5f94:	mov	r4, r0
    5f96:	mov	r6, r1
    5f98:	beq.n	5fd2 <SdioCard::readSector(unsigned long, unsigned char*)+0x76>
      if (!syncDevice()) {
    5f9a:	ldr	r3, [r4, #0]
    5f9c:	mov	r0, r4
    5f9e:	ldr	r3, [r3, #20]
    5fa0:	blx	r3
    5fa2:	cbnz	r0, 5ff8 <SdioCard::readSector(unsigned long, unsigned char*)+0x9c>
        return false;
    5fa4:	movs	r5, #0
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    5fa6:	mov	r0, r5
    5fa8:	add.w	sp, sp, #512	; 0x200
    5fac:	pop	{r4, r5, r6, pc}
  if (m_sdioConfig.useDma()) {
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
    5fae:	movs	r3, #1
    5fb0:	ldr	r0, [pc, #104]	; (601c <SdioCard::readSector(unsigned long, unsigned char*)+0xc0>)
    5fb2:	bl	5438 <rdWrSectors(unsigned long, unsigned long, unsigned char*, unsigned int)>
    5fb6:	cmp	r0, #0
    5fb8:	bne.n	5f86 <SdioCard::readSector(unsigned long, unsigned char*)+0x2a>
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5fba:	ldr	r1, [pc, #100]	; (6020 <SdioCard::readSector(unsigned long, unsigned char*)+0xc4>)
  m_errorLine = line;
    5fbc:	ldr	r3, [pc, #100]	; (6024 <SdioCard::readSector(unsigned long, unsigned char*)+0xc8>)
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5fbe:	movs	r0, #11
    uint8_t aligned[512];

    uint8_t* ptr = (uint32_t)dst & 3 ? aligned : dst;

    if (!rdWrSectors(CMD17_DMA_XFERTYP, sector, ptr, 1)) {
      return sdError(SD_CARD_ERROR_CMD17);
    5fc0:	movs	r5, #0
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    5fc2:	movw	r2, #775	; 0x307
#endif  // USE_DEBUG_MODE
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
    5fc6:	strb	r0, [r1, #0]
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    5fc8:	mov	r0, r5
//==============================================================================
// Error function and macro.
#define sdError(code) setSdErrorCode(code, __LINE__)
inline bool setSdErrorCode(uint8_t code, uint32_t line) {
  m_errorCode = code;
  m_errorLine = line;
    5fca:	str	r2, [r3, #0]
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
  }
  return true;
}
    5fcc:	add.w	sp, sp, #512	; 0x200
    5fd0:	pop	{r4, r5, r6, pc}
    }
    if (ptr != dst) {
      memcpy(dst, aligned, 512);
    }
  } else {
    if (m_curState != READ_STATE || sector != m_curSector) {
    5fd2:	ldr	r3, [r0, #4]
    5fd4:	cmp	r1, r3
    5fd6:	bne.n	5f9a <SdioCard::readSector(unsigned long, unsigned char*)+0x3e>
        return false;
      }
      m_curSector = sector;
      m_curState = READ_STATE;
    }
    if (!readData(dst)) {
    5fd8:	mov	r1, r5
    5fda:	mov	r0, r4
    5fdc:	bl	5e1c <SdioCard::readData(unsigned char*)>
    5fe0:	mov	r5, r0
    5fe2:	cmp	r0, #0
    5fe4:	beq.n	5fa4 <SdioCard::readSector(unsigned long, unsigned char*)+0x48>
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
    5fe6:	ldr	r3, [pc, #64]	; (6028 <SdioCard::readSector(unsigned long, unsigned char*)+0xcc>)
    5fe8:	ldr	r3, [r3, #0]
    5fea:	lsrs	r3, r3, #16
    5fec:	lsls	r3, r3, #16
    5fee:	cbz	r3, 600c <SdioCard::readSector(unsigned long, unsigned char*)+0xb0>
      if (!syncDevice()) {
        return false;
      }
    }
#endif  // defined(__MK64FX512__) || defined(__MK66FX1M0__)
    m_curSector++;
    5ff0:	ldr	r3, [r4, #4]
    5ff2:	adds	r3, #1
    5ff4:	str	r3, [r4, #4]
    5ff6:	b.n	5fa6 <SdioCard::readSector(unsigned long, unsigned char*)+0x4a>
  } else {
    if (m_curState != READ_STATE || sector != m_curSector) {
      if (!syncDevice()) {
        return false;
      }
      if (!readStart(sector)) {
    5ff8:	mov	r1, r6
    5ffa:	mov	r0, r4
    5ffc:	bl	5ee8 <SdioCard::readStart(unsigned long)>
    6000:	cmp	r0, #0
    6002:	beq.n	5fa4 <SdioCard::readSector(unsigned long, unsigned char*)+0x48>
        return false;
      }
      m_curSector = sector;
      m_curState = READ_STATE;
    6004:	movs	r3, #1
        return false;
      }
      if (!readStart(sector)) {
        return false;
      }
      m_curSector = sector;
    6006:	str	r6, [r4, #4]
      m_curState = READ_STATE;
    6008:	strb	r3, [r4, #9]
    600a:	b.n	5fd8 <SdioCard::readSector(unsigned long, unsigned char*)+0x7c>
    if (!readData(dst)) {
      return false;
    }
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    if ((SDHC_BLKATTR & 0XFFFF0000) == 0) {
      if (!syncDevice()) {
    600c:	ldr	r3, [r4, #0]
    600e:	mov	r0, r4
    6010:	ldr	r3, [r3, #20]
    6012:	blx	r3
    6014:	cmp	r0, #0
    6016:	bne.n	5ff0 <SdioCard::readSector(unsigned long, unsigned char*)+0x94>
    6018:	b.n	5fa4 <SdioCard::readSector(unsigned long, unsigned char*)+0x48>
    601a:	nop
    601c:	.word	0x113a0011
    6020:	.word	0x1fff0974
    6024:	.word	0x1fff1414
    6028:	.word	0x400b1004

0000602c <MTPStorage_SD::readonly()>:
  
    // Set Time callback
    FsDateTime::callback = dateTime;
  }

  bool MTPStorage_SD::readonly() { return false; }
    602c:	movs	r0, #0
    602e:	bx	lr

00006030 <MTPStorage_SD::has_directories()>:
  bool MTPStorage_SD::has_directories() { return true; }
    6030:	movs	r0, #1
    6032:	bx	lr

00006034 <SdFs::~SdFs()>:
//------------------------------------------------------------------------------
/**
 * \class SdFs
 * \brief SD file system class for FAT16, FAT32, and exFAT volumes.
 */
class SdFs : public SdBase<FsVolume> {
    6034:	bx	lr
    6036:	nop

00006038 <dateTime(unsigned short*, unsigned short*, unsigned char*)>:
void mtp_lock_storage(bool lock) { }

#include "TimeLib.h"
 // Call back for file timestamps.  Only called for file create and sync().
void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
{ 
    6038:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    603c:	mov	r7, r1
    603e:	mov	r6, r2
    6040:	mov	r8, r0
  // Return date using FS_DATE macro to format fields.
  *date = FS_DATE(year(), month(), day());
    6042:	bl	8c00 <year()>
    6046:	mov	r4, r0
    6048:	bl	8be0 <month()>
    604c:	mov	r5, r0
    604e:	bl	8bc0 <day()>
 * \param[in] day [1,31]
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
    6052:	subw	r3, r4, #1980	; 0x7bc
    6056:	uxth	r3, r3
  return year > 127 || month > 12 || day > 31 ? 0 :
         year << 9 | month << 5 | day;
    6058:	cmp	r3, #127	; 0x7f
    605a:	bhi.n	6062 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x2a>
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
    605c:	uxtb	r2, r5
    605e:	cmp	r2, #12
    6060:	bls.n	60ba <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x82>
         year << 9 | month << 5 | day;
    6062:	movs	r3, #0
    6064:	strh.w	r3, [r8]

  // Return time using FS_TIME macro to format fields.
  *time = FS_TIME(hour(), minute(), second());
    6068:	bl	8b60 <hour()>
    606c:	mov	r4, r0
    606e:	bl	8b80 <minute()>
    6072:	mov	r5, r0
    6074:	bl	8ba0 <second()>
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
         hour << 11 | minute << 5 | second >> 1;
    6078:	uxtb	r3, r4
    607a:	cmp	r3, #23
    607c:	bhi.n	6084 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x4c>
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
    607e:	uxtb	r3, r5
    6080:	cmp	r3, #59	; 0x3b
    6082:	bls.n	609c <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x64>
         hour << 11 | minute << 5 | second >> 1;
    6084:	movs	r3, #0
    6086:	strh	r3, [r7, #0]
  
  // Return low time bits in units of 10 ms.
  *ms10 = second() & 1 ? 100 : 0;
    6088:	bl	8ba0 <second()>
    608c:	tst.w	r0, #1
    6090:	ite	ne
    6092:	movne	r3, #100	; 0x64
    6094:	moveq	r3, #0
    6096:	strb	r3, [r6, #0]
    6098:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 * \param[in] second [0,59]
 *
 * \return Packed time for directory entry.
 */
static inline uint16_t FS_TIME(uint8_t hour, uint8_t minute, uint8_t second) {
  return hour > 23 || minute > 59 || second > 59 ? 0 :
    609c:	uxtb	r3, r0
    609e:	cmp	r3, #59	; 0x3b
    60a0:	bhi.n	6084 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x4c>
         hour << 11 | minute << 5 | second >> 1;
    60a2:	lsls	r4, r4, #11
    60a4:	lsls	r3, r5, #5
    60a6:	and.w	r4, r4, #522240	; 0x7f800
    60aa:	and.w	r3, r3, #8160	; 0x1fe0
    60ae:	orrs	r3, r4
    60b0:	ubfx	r0, r0, #1, #7
    60b4:	orrs	r3, r0
    60b6:	uxth	r3, r3
    60b8:	b.n	6086 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x4e>
#include "TimeLib.h"
 // Call back for file timestamps.  Only called for file create and sync().
void dateTime(uint16_t* date, uint16_t* time, uint8_t* ms10) 
{ 
  // Return date using FS_DATE macro to format fields.
  *date = FS_DATE(year(), month(), day());
    60ba:	uxtb	r0, r0
 *
 * \return Packed date for directory entry.
 */
static inline uint16_t FS_DATE(uint16_t year, uint8_t month, uint8_t day) {
  year -= 1980;
  return year > 127 || month > 12 || day > 31 ? 0 :
    60bc:	cmp	r0, #31
    60be:	bhi.n	6062 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x2a>
         year << 9 | month << 5 | day;
    60c0:	lsls	r5, r5, #5
    60c2:	and.w	r5, r5, #8160	; 0x1fe0
    60c6:	orrs	r0, r5
    60c8:	orr.w	r3, r0, r3, lsl #9
    60cc:	uxth	r3, r3
    60ce:	b.n	6064 <dateTime(unsigned short*, unsigned short*, unsigned char*)+0x2c>

000060d0 <MTPStorage_SD::OpenIndex() [clone .part.41] [clone .constprop.61]>:
    all_scanned_ = false;
    index_generated=false;
    open_file_ = 0xFFFFFFFEUL;
  }

  void MTPStorage_SD::OpenIndex() {
    60d0:	push	{r4, lr}
    60d2:	sub	sp, #80	; 0x50
    60d4:	mov	r4, r0
    if (index_) return;
    mtp_lock_storage(true);
    index_ = SD.open("/mtpindex.dat", FILE_WRITE);
    60d6:	movw	r3, #16898	; 0x4202
    60da:	mov	r0, sp
    60dc:	ldr	r2, [pc, #44]	; (610c <MTPStorage_SD::OpenIndex() [clone .part.41] [clone .constprop.61]+0x3c>)
    60de:	ldr	r1, [pc, #48]	; (6110 <MTPStorage_SD::OpenIndex() [clone .part.41] [clone .constprop.61]+0x40>)
    60e0:	bl	47d0 <FsVolume::open(char const*, int)>
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
    60e4:	ldrb.w	r1, [sp, #4]
#define Stream_h

#include <inttypes.h>
#include "Print.h"

class Stream : public Print
    60e8:	ldr	r2, [sp, #8]
    60ea:	ldrb.w	r3, [sp, #12]
    60ee:	strb	r1, [r4, #8]
    60f0:	str	r2, [r4, #12]
    60f2:	strb	r3, [r4, #16]
/**
 * \class StreamFile
 * \brief StreamFile class.
 */
template<class BaseFile, typename PosType>
class StreamFile : public stream_t, public BaseFile {
    60f4:	add	r1, sp, #16
    60f6:	add.w	r0, r4, #20
    60fa:	bl	45b0 <FsBaseFile::operator=(FsBaseFile const&)>
    60fe:	ldr	r3, [pc, #20]	; (6114 <MTPStorage_SD::OpenIndex() [clone .part.41] [clone .constprop.61]+0x44>)
    6100:	str	r3, [sp, #0]
 */
class FsBaseFile {
 public:
  FsBaseFile() : m_fFile(nullptr), m_xFile(nullptr) {}

  ~FsBaseFile() {close();}
    6102:	add	r0, sp, #16
    6104:	bl	4588 <FsBaseFile::close()>
    mtp_lock_storage(false);
  }
    6108:	add	sp, #80	; 0x50
    610a:	pop	{r4, pc}
    610c:	.word	0x0000c454
    6110:	.word	0x1fff1418
    6114:	.word	0x0000c21c

00006118 <MTPStorage_SD::size()>:
    FsDateTime::callback = dateTime;
  }

  bool MTPStorage_SD::readonly() { return false; }
  bool MTPStorage_SD::has_directories() { return true; }
  uint64_t MTPStorage_SD::size(){
    6118:	ldr	r2, [pc, #64]	; (615c <MTPStorage_SD::size()+0x44>)
    611a:	ldr.w	r3, [r2, #1144]	; 0x478
  /** Change global working volume to this volume. */
  void chvol() {m_cwv = this;}
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() {
    return m_fVol ? m_fVol->clusterCount() :
           m_xVol ? m_xVol->clusterCount() : 0;
    611e:	cbz	r3, 6134 <MTPStorage_SD::size()+0x1c>
    m_cache.invalidate();
    return m_cache.buffer();
  }
  /** \return The total number of clusters in the volume. */
  uint32_t clusterCount() const {
    return m_lastCluster - 1;
    6120:	ldr	r2, [r3, #28]
    6122:	ldrb	r3, [r3, #4]
    6124:	subs	r2, #1
    6126:	umull	r2, r3, r3, r2
    612a:	lsls	r1, r3, #9
    612c:	orr.w	r1, r1, r2, lsr #23
    6130:	lsls	r0, r2, #9
    6132:	bx	lr
    6134:	ldr.w	r2, [r2, #1148]	; 0x47c
    6138:	cbz	r2, 6154 <MTPStorage_SD::size()+0x3c>
    613a:	ldr.w	r3, [r2, #1064]	; 0x428
    613e:	ldrb.w	r1, [r2, #1085]	; 0x43d
    6142:	movs	r2, #1
    6144:	lsls	r2, r1
    6146:	lsls	r0, r3, #9
    6148:	umull	r0, r1, r2, r0
    614c:	lsrs	r3, r3, #23
    614e:	mla	r1, r2, r3, r1
    6152:	bx	lr
    6154:	movs	r0, #0
    6156:	movs	r1, #0
     return (uint64_t)512 * (uint64_t)SD.clusterCount() * (uint64_t)SD.sectorsPerCluster();
  }
    6158:	bx	lr
    615a:	nop
    615c:	.word	0x1fff1418

00006160 <MTPStorage_SD::free()>:

  uint64_t MTPStorage_SD::free() {
    6160:	push	{r4, lr}
    6162:	ldr	r4, [pc, #84]	; (61b8 <MTPStorage_SD::free()+0x58>)
    6164:	ldr.w	r0, [r4, #1144]	; 0x478
           m_xVol ? m_xVol->fatStartSector() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
    6168:	cbz	r0, 6180 <MTPStorage_SD::free()+0x20>
    return m_fVol ? m_fVol->fatStartSector() :
           m_xVol ? m_xVol->fatStartSector() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() {
    return m_fVol ? m_fVol->freeClusterCount() :
    616a:	bl	378c <FatPartition::freeClusterCount()>
    616e:	ldr.w	r3, [r4, #1144]	; 0x478
    6172:	ldr	r2, [pc, #68]	; (61b8 <MTPStorage_SD::free()+0x58>)
           m_xVol ? m_xVol->freeClusterCount() : 0;
  }
  /** \return The volume's cluster size in sectors. */
  uint32_t sectorsPerCluster() const {
    return m_fVol ? m_fVol->sectorsPerCluster() :
           m_xVol ? m_xVol->sectorsPerCluster() : 0;
    6174:	cbz	r3, 6194 <MTPStorage_SD::free()+0x34>
    6176:	ldrb	r2, [r3, #4]
    6178:	lsls	r2, r2, #9
    617a:	umull	r0, r1, r2, r0
    617e:	pop	{r4, pc}
           m_xVol ? m_xVol->fatStartSector() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
    6180:	ldr.w	r0, [r4, #1148]	; 0x47c
    6184:	cbz	r0, 61b0 <MTPStorage_SD::free()+0x50>
    6186:	bl	16e0 <ExFatPartition::freeClusterCount()>
    618a:	ldr.w	r3, [r4, #1144]	; 0x478
    618e:	ldr	r2, [pc, #40]	; (61b8 <MTPStorage_SD::free()+0x58>)
  }
  /** \return The volume's cluster size in sectors. */
  uint32_t sectorsPerCluster() const {
    return m_fVol ? m_fVol->sectorsPerCluster() :
           m_xVol ? m_xVol->sectorsPerCluster() : 0;
    6190:	cmp	r3, #0
    6192:	bne.n	6176 <MTPStorage_SD::free()+0x16>
    6194:	ldr.w	r3, [r2, #1148]	; 0x47c
    6198:	lsrs	r4, r0, #23
    619a:	lsls	r0, r0, #9
    619c:	cbz	r3, 61b0 <MTPStorage_SD::free()+0x50>
    619e:	ldrb.w	r2, [r3, #1085]	; 0x43d
    61a2:	movs	r3, #1
    61a4:	lsls	r3, r2
    61a6:	umull	r0, r1, r3, r0
    61aa:	mla	r1, r3, r4, r1
    61ae:	pop	{r4, pc}
           m_xVol ? m_xVol->fatStartSector() : 0;
  }
  /** \return the free cluster count. */
  uint32_t freeClusterCount() {
    return m_fVol ? m_fVol->freeClusterCount() :
           m_xVol ? m_xVol->freeClusterCount() : 0;
    61b0:	movs	r0, #0
    61b2:	movs	r1, #0
    return (uint64_t)512 * (uint64_t)SD.freeClusterCount() * (uint64_t)SD.sectorsPerCluster(); 
  }
    61b4:	pop	{r4, pc}
    61b6:	nop
    61b8:	.word	0x1fff1418

000061bc <MTPStorage_SD::write(char const*, unsigned long)>:
      OpenFileByIndex(ret, FILE_WRITE);
    }
    return ret;
  }

  void MTPStorage_SD::write(const char* data, uint32_t bytes) {
    61bc:	ldr.w	r3, [r0, #156]	; 0x9c
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
    61c0:	cbz	r3, 61c8 <MTPStorage_SD::write(char const*, unsigned long)+0xc>
    61c2:	mov	r0, r3
    61c4:	b.w	31e8 <FatFile::write(void const*, unsigned int)>
    61c8:	ldr.w	r0, [r0, #160]	; 0xa0
    61cc:	cbz	r0, 61d2 <MTPStorage_SD::write(char const*, unsigned long)+0x16>
    61ce:	b.w	2134 <ExFatFile::write(void const*, unsigned int)>
    61d2:	bx	lr

000061d4 <MTPStorage_SD::ResetIndex()>:

  uint64_t MTPStorage_SD::free() {
    return (uint64_t)512 * (uint64_t)SD.freeClusterCount() * (uint64_t)SD.sectorsPerCluster(); 
  }

  void MTPStorage_SD::ResetIndex() {
    61d4:	push	{r4, r5, r6, r7, lr}
  bool isHidden() {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() {return m_fFile || m_xFile;}
    61d6:	ldr	r3, [r0, #76]	; 0x4c
    61d8:	sub	sp, #84	; 0x54
    61da:	mov	r4, r0

    mtp_lock_storage(true);
    if(index_) index_.close();
    61dc:	add.w	r7, r0, #20
    61e0:	cmp	r3, #0
    61e2:	beq.n	628c <MTPStorage_SD::ResetIndex()+0xb8>
    61e4:	mov	r0, r7
    61e6:	bl	4588 <FsBaseFile::close()>
    61ea:	ldr	r3, [pc, #168]	; (6294 <MTPStorage_SD::ResetIndex()+0xc0>)
    61ec:	ldr.w	r5, [r3, #1144]	; 0x478
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
           m_xVol ? m_xVol->remove(path) : false;
    61f0:	cmp	r5, #0
    61f2:	beq.n	6260 <MTPStorage_SD::ResetIndex()+0x8c>
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    61f4:	mov	r1, r5
    61f6:	mov	r0, sp
    61f8:	movs	r5, #0
    61fa:	movs	r3, #1
    61fc:	ldr	r2, [pc, #152]	; (6298 <MTPStorage_SD::ResetIndex()+0xc4>)
    61fe:	strb.w	r5, [sp]
    6202:	mov	r6, sp
    6204:	strb.w	r5, [sp, #1]
    6208:	strb.w	r5, [sp, #2]
    620c:	bl	27a8 <FatFile::open(FatVolume*, char const*, int)>
    6210:	cbnz	r0, 6258 <MTPStorage_SD::ResetIndex()+0x84>
    SD.remove("/mtpindex.dat");
    index_ = SD.open("/mtpindex.dat", FILE_WRITE);
    6212:	mov	r0, r6
    6214:	movw	r3, #16898	; 0x4202
    6218:	ldr	r2, [pc, #124]	; (6298 <MTPStorage_SD::ResetIndex()+0xc4>)
    621a:	ldr	r1, [pc, #120]	; (6294 <MTPStorage_SD::ResetIndex()+0xc0>)
    621c:	bl	47d0 <FsVolume::open(char const*, int)>
    6220:	ldr	r2, [sp, #8]
    6222:	ldrb.w	r1, [sp, #4]
    6226:	ldrb.w	r3, [sp, #12]
    622a:	str	r2, [r4, #12]
    622c:	strb	r1, [r4, #8]
    622e:	strb	r3, [r4, #16]
    6230:	add	r1, sp, #16
    6232:	mov	r0, r7
    6234:	bl	45b0 <FsBaseFile::operator=(FsBaseFile const&)>
    6238:	ldr	r3, [pc, #96]	; (629c <MTPStorage_SD::ResetIndex()+0xc8>)
    623a:	str	r3, [sp, #0]
 */
class FsBaseFile {
 public:
  FsBaseFile() : m_fFile(nullptr), m_xFile(nullptr) {}

  ~FsBaseFile() {close();}
    623c:	add	r0, sp, #16
    623e:	bl	4588 <FsBaseFile::close()>
    mtp_lock_storage(false);

    all_scanned_ = false;
    6242:	movs	r3, #0
    index_generated=false;
    open_file_ = 0xFFFFFFFEUL;
    6244:	mvn.w	r2, #1
    if(index_) index_.close();
    SD.remove("/mtpindex.dat");
    index_ = SD.open("/mtpindex.dat", FILE_WRITE);
    mtp_lock_storage(false);

    all_scanned_ = false;
    6248:	strb.w	r3, [r4, #177]	; 0xb1
    index_generated=false;
    624c:	strb.w	r3, [r4, #176]	; 0xb0
    open_file_ = 0xFFFFFFFEUL;
    6250:	str.w	r2, [r4, #168]	; 0xa8
  }
    6254:	add	sp, #84	; 0x54
    6256:	pop	{r4, r5, r6, r7, pc}
    6258:	mov	r0, sp
    625a:	bl	3dcc <FatFile::remove()>
    625e:	b.n	6212 <MTPStorage_SD::ResetIndex()+0x3e>
    6260:	ldr.w	r1, [r3, #1148]	; 0x47c
   *
   * \return true for success or false for failure.
   */
  bool remove(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    6264:	mov	r6, sp
    6266:	cmp	r1, #0
    6268:	beq.n	6212 <MTPStorage_SD::ResetIndex()+0x3e>
    626a:	mov	r0, sp
    626c:	movs	r3, #1
    626e:	ldr	r2, [pc, #40]	; (6298 <MTPStorage_SD::ResetIndex()+0xc4>)
    6270:	strb.w	r5, [sp, #49]	; 0x31
    6274:	strb.w	r5, [sp, #50]	; 0x32
    6278:	strb.w	r5, [sp, #51]	; 0x33
    627c:	bl	1144 <ExFatFile::open(ExFatVolume*, char const*, int)>
    6280:	cmp	r0, #0
    6282:	beq.n	6212 <MTPStorage_SD::ResetIndex()+0x3e>
    6284:	mov	r0, sp
    6286:	bl	1928 <ExFatFile::remove()>
    628a:	b.n	6212 <MTPStorage_SD::ResetIndex()+0x3e>
  bool isHidden() {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() {return m_fFile || m_xFile;}
    628c:	ldr	r3, [r0, #80]	; 0x50
    628e:	cmp	r3, #0
    6290:	bne.n	61e4 <MTPStorage_SD::ResetIndex()+0x10>
    6292:	b.n	61ea <MTPStorage_SD::ResetIndex()+0x16>
    6294:	.word	0x1fff1418
    6298:	.word	0x0000c454
    629c:	.word	0x0000c21c

000062a0 <Print::println(__FlashStringHelper const*)>:
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    62a0:	push	{r3, r4, r5, lr}
    62a2:	mov	r4, r0
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    62a4:	mov	r0, r1
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    62a6:	mov	r5, r1
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    62a8:	bl	bd40 <strlen>
    62ac:	ldr	r3, [r4, #0]
    62ae:	mov	r2, r0
    62b0:	mov	r1, r5
    62b2:	ldr	r3, [r3, #4]
    62b4:	mov	r0, r4
    62b6:	blx	r3
    62b8:	mov	r5, r0
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }
    62ba:	mov	r0, r4
    62bc:	bl	ad80 <Print::println()>
    62c0:	add	r0, r5
    62c2:	pop	{r3, r4, r5, pc}

000062c4 <mtp_yield()>:
//   support serialflash
//   partial object fetch/receive
//   events (notify usb host when local storage changes)

// These should probably be weak.
void mtp_yield() {}
    62c4:	bx	lr
    62c6:	nop

000062c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>:
    mtp_lock_storage(true);
    index_ = SD.open("/mtpindex.dat", FILE_WRITE);
    mtp_lock_storage(false);
  }

  void MTPStorage_SD::WriteIndexRecord(uint32_t i, const Record& r) {
    62c8:	ldr	r3, [r0, #76]	; 0x4c
    62ca:	push	{r4, r5, r6, lr}
    62cc:	mov	r4, r0
    62ce:	mov	r5, r1
    62d0:	mov	r6, r2
    62d2:	cbz	r3, 6300 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x38>
    OpenIndex();
    mtp_lock_storage(true);
    index_.seek(sizeof(r) * i);
    62d4:	movs	r1, #104	; 0x68
    62d6:	mul.w	r1, r1, r5
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
    62da:	mov	r0, r3
    62dc:	bl	2a14 <FatFile::seekSet(unsigned long)>
    62e0:	ldr	r0, [r4, #76]	; 0x4c
   * for a read-only file, device is full, a corrupt file system or an
   * I/O error.
   */
  size_t write(const void* buf, size_t count) {
    return m_fFile ? m_fFile->write(buf, count) :
           m_xFile ? m_xFile->write(buf, count) : 0;
    62e2:	cbz	r0, 62f0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x28>
    62e4:	mov	r1, r6
    62e6:	movs	r2, #104	; 0x68
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }
    62e8:	ldmia.w	sp!, {r4, r5, r6, lr}
    62ec:	b.w	31e8 <FatFile::write(void const*, unsigned int)>
    62f0:	ldr	r0, [r4, #80]	; 0x50
    62f2:	cbz	r0, 632e <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x66>
    62f4:	mov	r1, r6
    62f6:	movs	r2, #104	; 0x68
    62f8:	ldmia.w	sp!, {r4, r5, r6, lr}
    62fc:	b.w	2134 <ExFatFile::write(void const*, unsigned int)>
  bool isHidden() {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() {return m_fFile || m_xFile;}
    6300:	ldr	r3, [r0, #80]	; 0x50
    6302:	cbz	r3, 6314 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x4c>
  }

  void MTPStorage_SD::WriteIndexRecord(uint32_t i, const Record& r) {
    OpenIndex();
    mtp_lock_storage(true);
    index_.seek(sizeof(r) * i);
    6304:	movs	r2, #104	; 0x68
    6306:	mul.w	r2, r2, r1
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
    630a:	mov	r0, r3
    630c:	movs	r3, #0
    630e:	bl	ae0 <ExFatFile::seekSet(unsigned long long)>
    6312:	b.n	62e0 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x18>
    6314:	bl	60d0 <MTPStorage_SD::OpenIndex() [clone .part.41] [clone .constprop.61]>
    6318:	movs	r2, #104	; 0x68
    631a:	ldr	r3, [r4, #76]	; 0x4c
    631c:	mul.w	r2, r2, r5
    6320:	mov	r1, r2
    6322:	cmp	r3, #0
    6324:	bne.n	62da <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x12>
    6326:	ldr	r3, [r4, #80]	; 0x50
    6328:	cmp	r3, #0
    632a:	bne.n	630a <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)+0x42>
    632c:	pop	{r4, r5, r6, pc}
    632e:	pop	{r4, r5, r6, pc}

00006330 <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]>:
  }

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex() {
    6330:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    6334:	ldr.w	r8, [pc, #228]	; 641c <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0xec>
    6338:	ldr.w	r5, [r8, #1144]	; 0x478
    if (index_generated) return;
    index_generated = true;
    633c:	movs	r3, #1
  }

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex() {
    633e:	sub	sp, #104	; 0x68
    6340:	mov	r4, r0
    if (index_generated) return;
    index_generated = true;
    6342:	strb.w	r3, [r0, #176]	; 0xb0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    return m_fVol ? m_fVol->exists(path) :
           m_xVol ? m_xVol->exists(path) : false;
    6346:	cbz	r5, 639a <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0x6a>
    6348:	movs	r7, #0
   *
   * \return true if the file exists else false.
   */
  bool exists(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    634a:	mov	r1, r5
    634c:	mov	r3, r7
    634e:	mov	r0, sp
    6350:	ldr	r2, [pc, #196]	; (6418 <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0xe8>)
    6352:	strb.w	r7, [sp]
    6356:	mov	r6, sp
    6358:	strb.w	r7, [sp, #1]
    635c:	strb.w	r7, [sp, #2]
    6360:	bl	27a8 <FatFile::open(FatVolume*, char const*, int)>

    mtp_lock_storage(true);
    if(SD.exists("/mtpindex.dat")) SD.remove("/mtpindex.dat");
    6364:	cbnz	r0, 63be <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0x8e>
    mtp_lock_storage(false);
    index_entries_ = 0;

    Record r;
    r.parent = 0;
    6366:	movs	r3, #0
    r.sibling = 0;
    r.child = 0;
    r.isdir = true;
    6368:	movs	r5, #1
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) {
    uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    636a:	mov	r2, r6
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) {
    uint32_t new_record = index_entries_++;
    636c:	str.w	r5, [r4, #172]	; 0xac
    WriteIndexRecord(new_record, r);
    6370:	mov	r0, r4
    6372:	mov	r1, r3
    r.parent = 0;
    r.sibling = 0;
    r.child = 0;
    r.isdir = true;
    r.scanned = false;
    r.size=0;
    6374:	movs	r6, #0
    6376:	movs	r7, #0
    strcpy(r.name, "/");
    6378:	movs	r4, #47	; 0x2f
    if(SD.exists("/mtpindex.dat")) SD.remove("/mtpindex.dat");
    mtp_lock_storage(false);
    index_entries_ = 0;

    Record r;
    r.parent = 0;
    637a:	str	r3, [sp, #0]
    r.sibling = 0;
    637c:	str	r3, [sp, #8]
    r.child = 0;
    637e:	str	r3, [sp, #4]
    r.isdir = true;
    r.scanned = false;
    6380:	strb.w	r3, [sp, #13]

    Record r;
    r.parent = 0;
    r.sibling = 0;
    r.child = 0;
    r.isdir = true;
    6384:	strb.w	r5, [sp, #12]
    r.scanned = false;
    r.size=0;
    6388:	strd	r6, r7, [sp, #16]
    strcpy(r.name, "/");
    638c:	strh.w	r4, [sp, #24]
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) {
    uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    6390:	bl	62c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    r.isdir = true;
    r.scanned = false;
    r.size=0;
    strcpy(r.name, "/");
    AppendIndexRecord(r);
  }
    6394:	add	sp, #104	; 0x68
    6396:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    639a:	ldr.w	r1, [r8, #1148]	; 0x47c
   *
   * \return true if the file exists else false.
   */
  bool exists(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_RDONLY);
    639e:	mov	r6, sp
    63a0:	cmp	r1, #0
    63a2:	beq.n	6366 <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0x36>
    63a4:	mov	r3, r5
    63a6:	mov	r0, sp
    63a8:	ldr	r2, [pc, #108]	; (6418 <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0xe8>)
    63aa:	strb.w	r5, [sp, #49]	; 0x31
    63ae:	strb.w	r5, [sp, #50]	; 0x32
    63b2:	strb.w	r5, [sp, #51]	; 0x33
    63b6:	bl	1144 <ExFatFile::open(ExFatVolume*, char const*, int)>
  void MTPStorage_SD::GenerateIndex() {
    if (index_generated) return;
    index_generated = true;

    mtp_lock_storage(true);
    if(SD.exists("/mtpindex.dat")) SD.remove("/mtpindex.dat");
    63ba:	cmp	r0, #0
    63bc:	beq.n	6366 <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0x36>
    63be:	ldr.w	r5, [r8, #1144]	; 0x478
    63c2:	ldr	r3, [pc, #88]	; (641c <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0xec>)
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
           m_xVol ? m_xVol->remove(path) : false;
    63c4:	cbz	r5, 63ec <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0xbc>
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    63c6:	mov	r1, r5
    63c8:	movs	r3, #1
    63ca:	movs	r5, #0
    63cc:	ldr	r2, [pc, #72]	; (6418 <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0xe8>)
    63ce:	strb.w	r5, [sp]
    63d2:	mov	r0, r6
    63d4:	strb.w	r5, [sp, #1]
    63d8:	strb.w	r5, [sp, #2]
    63dc:	bl	27a8 <FatFile::open(FatVolume*, char const*, int)>
    63e0:	cmp	r0, #0
    63e2:	beq.n	6366 <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0x36>
    63e4:	mov	r0, r6
    63e6:	bl	3dcc <FatFile::remove()>
    63ea:	b.n	6366 <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0x36>
    63ec:	ldr.w	r1, [r3, #1148]	; 0x47c
    63f0:	cmp	r1, #0
    63f2:	beq.n	6366 <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0x36>
   *
   * \return true for success or false for failure.
   */
  bool remove(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    63f4:	movs	r3, #1
    63f6:	ldr	r2, [pc, #32]	; (6418 <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0xe8>)
    63f8:	strb.w	r5, [sp, #49]	; 0x31
    63fc:	mov	r0, r6
    63fe:	strb.w	r5, [sp, #50]	; 0x32
    6402:	strb.w	r5, [sp, #51]	; 0x33
    6406:	bl	1144 <ExFatFile::open(ExFatVolume*, char const*, int)>
    640a:	cmp	r0, #0
    640c:	beq.n	6366 <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0x36>
    640e:	mov	r0, r6
    6410:	bl	1928 <ExFatFile::remove()>
    6414:	b.n	6366 <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]+0x36>
    6416:	nop
    6418:	.word	0x0000c454
    641c:	.word	0x1fff1418

00006420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>:
  }

  // TODO(hubbe): Cache a few records for speed.
  Record MTPStorage_SD::ReadIndexRecord(uint32_t i) {
    Record ret;
    if (i > index_entries_) {
    6420:	ldr.w	r3, [r1, #172]	; 0xac
    6424:	cmp	r3, r2
    WriteIndexRecord(new_record, r);
    return new_record;
  }

  // TODO(hubbe): Cache a few records for speed.
  Record MTPStorage_SD::ReadIndexRecord(uint32_t i) {
    6426:	push	{r4, r5, r6, lr}
    6428:	mov	r6, r0
    Record ret;
    if (i > index_entries_) {
    642a:	bcc.n	6460 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x40>
    642c:	ldr	r0, [r1, #76]	; 0x4c
    642e:	mov	r4, r1
    6430:	mov	r5, r2
  bool isHidden() {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() {return m_fFile || m_xFile;}
    6432:	cbz	r0, 646c <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x4c>
      memset(&ret, 0, sizeof(ret));
      return ret;
    }
    OpenIndex();
    mtp_lock_storage(true);
    index_.seek(sizeof(ret) * i);
    6434:	movs	r1, #104	; 0x68
    6436:	mul.w	r1, r1, r2
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
    643a:	bl	2a14 <FatFile::seekSet(unsigned long)>
    643e:	ldr	r0, [r4, #76]	; 0x4c
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
    6440:	cbz	r0, 644e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x2e>
    6442:	movs	r2, #104	; 0x68
    6444:	mov	r1, r6
    6446:	bl	27b8 <FatFile::read(void*, unsigned int)>
    index_.read(&ret, sizeof(ret));
    mtp_lock_storage(false);
    return ret;
  }
    644a:	mov	r0, r6
    644c:	pop	{r4, r5, r6, pc}
    644e:	ldr	r0, [r4, #80]	; 0x50
    6450:	cmp	r0, #0
    6452:	beq.n	644a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x2a>
    6454:	movs	r2, #104	; 0x68
    6456:	mov	r1, r6
    6458:	bl	8cc <ExFatFile::read(void*, unsigned int)>
    645c:	mov	r0, r6
    645e:	pop	{r4, r5, r6, pc}

  // TODO(hubbe): Cache a few records for speed.
  Record MTPStorage_SD::ReadIndexRecord(uint32_t i) {
    Record ret;
    if (i > index_entries_) {
      memset(&ret, 0, sizeof(ret));
    6460:	movs	r2, #104	; 0x68
    6462:	movs	r1, #0
    6464:	bl	bb7c <memset>
    mtp_lock_storage(true);
    index_.seek(sizeof(ret) * i);
    index_.read(&ret, sizeof(ret));
    mtp_lock_storage(false);
    return ret;
  }
    6468:	mov	r0, r6
    646a:	pop	{r4, r5, r6, pc}
  bool isHidden() {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() {return m_fFile || m_xFile;}
    646c:	ldr	r0, [r1, #80]	; 0x50
    646e:	cbz	r0, 647e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x5e>
      memset(&ret, 0, sizeof(ret));
      return ret;
    }
    OpenIndex();
    mtp_lock_storage(true);
    index_.seek(sizeof(ret) * i);
    6470:	movs	r2, #104	; 0x68
    6472:	mul.w	r2, r2, r5
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
    6476:	movs	r3, #0
    6478:	bl	ae0 <ExFatFile::seekSet(unsigned long long)>
    647c:	b.n	643e <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1e>
    647e:	mov	r0, r1
    6480:	bl	60d0 <MTPStorage_SD::OpenIndex() [clone .part.41] [clone .constprop.61]>
    6484:	movs	r2, #104	; 0x68
    6486:	ldr	r0, [r4, #76]	; 0x4c
    6488:	mul.w	r2, r2, r5
    648c:	mov	r1, r2
    648e:	cmp	r0, #0
    6490:	bne.n	643a <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x1a>
    6492:	ldr	r0, [r4, #80]	; 0x50
    6494:	cmp	r0, #0
    6496:	bne.n	6476 <MTPStorage_SD::ReadIndexRecord(unsigned long)+0x56>
    index_.read(&ret, sizeof(ret));
    mtp_lock_storage(false);
    return ret;
  }
    6498:	mov	r0, r6
    649a:	pop	{r4, r5, r6, pc}

0000649c <MTPStorage_SD::GetNextObjectHandle()>:
      follow_sibling_ = false;
      next_ = 1;
    }
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle() {
    649c:	push	{r4, r5, lr}
    while (true) {
      if (next_ == 0) return 0;
    649e:	ldr.w	r5, [r0, #180]	; 0xb4
      follow_sibling_ = false;
      next_ = 1;
    }
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle() {
    64a2:	sub	sp, #108	; 0x6c
    64a4:	mov	r4, r0
    while (true) {
      if (next_ == 0) return 0;
    64a6:	cbnz	r5, 64bc <MTPStorage_SD::GetNextObjectHandle()+0x20>
    64a8:	b.n	64f2 <MTPStorage_SD::GetNextObjectHandle()+0x56>

      int ret = next_;
      Record r = ReadIndexRecord(ret);
      if (follow_sibling_) {
        next_ = r.sibling;
    64aa:	ldr	r3, [sp, #8]
    64ac:	str.w	r3, [r4, #180]	; 0xb4
      } else {
        next_++;
        if (next_ >= index_entries_)
          next_ = 0;
      }
      if (r.name[0]) return ret;
    64b0:	ldrb.w	r3, [sp, #24]
    64b4:	cbnz	r3, 64ec <MTPStorage_SD::GetNextObjectHandle()+0x50>
    }
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle() {
    while (true) {
      if (next_ == 0) return 0;
    64b6:	ldr.w	r5, [r4, #180]	; 0xb4
    64ba:	cbz	r5, 64f2 <MTPStorage_SD::GetNextObjectHandle()+0x56>

      int ret = next_;
      Record r = ReadIndexRecord(ret);
    64bc:	mov	r2, r5
    64be:	mov	r1, r4
    64c0:	mov	r0, sp
    64c2:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
      if (follow_sibling_) {
    64c6:	ldrb.w	r2, [r4, #184]	; 0xb8
    64ca:	cmp	r2, #0
    64cc:	bne.n	64aa <MTPStorage_SD::GetNextObjectHandle()+0xe>
        next_ = r.sibling;
      } else {
        next_++;
    64ce:	ldr.w	r3, [r4, #180]	; 0xb4
        if (next_ >= index_entries_)
    64d2:	ldr.w	r1, [r4, #172]	; 0xac
      int ret = next_;
      Record r = ReadIndexRecord(ret);
      if (follow_sibling_) {
        next_ = r.sibling;
      } else {
        next_++;
    64d6:	adds	r3, #1
    64d8:	str.w	r3, [r4, #180]	; 0xb4
        if (next_ >= index_entries_)
    64dc:	cmp	r3, r1
          next_ = 0;
      }
      if (r.name[0]) return ret;
    64de:	ldrb.w	r3, [sp, #24]
      if (follow_sibling_) {
        next_ = r.sibling;
      } else {
        next_++;
        if (next_ >= index_entries_)
          next_ = 0;
    64e2:	it	cs
    64e4:	strcs.w	r2, [r4, #180]	; 0xb4
      }
      if (r.name[0]) return ret;
    64e8:	cmp	r3, #0
    64ea:	beq.n	64b6 <MTPStorage_SD::GetNextObjectHandle()+0x1a>
    }
  }
    64ec:	mov	r0, r5
    64ee:	add	sp, #108	; 0x6c
    64f0:	pop	{r4, r5, pc}
    }
  }

  uint32_t MTPStorage_SD::GetNextObjectHandle() {
    while (true) {
      if (next_ == 0) return 0;
    64f2:	movs	r5, #0
        if (next_ >= index_entries_)
          next_ = 0;
      }
      if (r.name[0]) return ret;
    }
  }
    64f4:	mov	r0, r5
    64f6:	add	sp, #108	; 0x6c
    64f8:	pop	{r4, r5, pc}
    64fa:	nop

000064fc <MTPStorage_SD::GetObjectInfo(unsigned long, char*, unsigned long*, unsigned long*, unsigned long*)>:

  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t *dir, uint32_t* size, uint32_t* parent) {
    64fc:	push	{r4, r5, r6, r7, lr}
    64fe:	sub	sp, #108	; 0x6c
    6500:	mov	r7, r2
    Record r = ReadIndexRecord(handle);
    6502:	mov	r2, r1
    6504:	mov	r1, r0
    6506:	mov	r0, sp
      }
      if (r.name[0]) return ret;
    }
  }

  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t *dir, uint32_t* size, uint32_t* parent) {
    6508:	mov	r4, r3
    650a:	ldr	r5, [sp, #128]	; 0x80
    650c:	ldr	r6, [sp, #132]	; 0x84
    Record r = ReadIndexRecord(handle);
    650e:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    strcpy(name, r.name);
    6512:	add	r1, sp, #24
    6514:	mov	r0, r7
    6516:	bl	bc84 <strcpy>
    *parent = r.parent;
    651a:	ldr	r1, [sp, #0]
    //*size = r.isdir ? 0xFFFFFFFFUL : r.size;
    *size = r.size;
    651c:	ldr	r2, [sp, #16]
    *dir = r.isdir;
    651e:	ldrb.w	r3, [sp, #12]
  }

  void MTPStorage_SD::GetObjectInfo(uint32_t handle, char* name, uint32_t *dir, uint32_t* size, uint32_t* parent) {
    Record r = ReadIndexRecord(handle);
    strcpy(name, r.name);
    *parent = r.parent;
    6522:	str	r1, [r6, #0]
    //*size = r.isdir ? 0xFFFFFFFFUL : r.size;
    *size = r.size;
    6524:	str	r2, [r5, #0]
    *dir = r.isdir;
    6526:	str	r3, [r4, #0]
  }
    6528:	add	sp, #108	; 0x6c
    652a:	pop	{r4, r5, r6, r7, pc}

0000652c <MTPStorage_SD::SetObjectInfo(unsigned long, char*, unsigned long, unsigned long, unsigned long)>:

  void MTPStorage_SD::SetObjectInfo(uint32_t handle, char* name, uint32_t dir, uint32_t size, uint32_t parent) {
    652c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6530:	mov	r5, r1
    6532:	sub	sp, #108	; 0x6c
    6534:	mov	r4, r0
    6536:	mov	r9, r2
    Record r = ReadIndexRecord(handle);
    6538:	mov	r1, r0
    653a:	mov	r2, r5
    653c:	mov	r0, sp
    //*size = r.isdir ? 0xFFFFFFFFUL : r.size;
    *size = r.size;
    *dir = r.isdir;
  }

  void MTPStorage_SD::SetObjectInfo(uint32_t handle, char* name, uint32_t dir, uint32_t size, uint32_t parent) {
    653e:	mov	r8, r3
    6540:	ldr	r6, [sp, #136]	; 0x88
    6542:	ldr	r7, [sp, #140]	; 0x8c
    Record r = ReadIndexRecord(handle);
    6544:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    strcpy(r.name,name);
    6548:	mov	r1, r9
    654a:	add	r0, sp, #24
    654c:	bl	bc84 <strcpy>
    r.parent = parent;
    //*size = r.isdir ? 0xFFFFFFFFUL : r.size;
    r.size = size;
    r.isdir = dir;
    WriteIndexRecord(handle, r);
    6550:	mov	r0, r4
    6552:	mov	r2, sp
    6554:	mov	r1, r5
  void MTPStorage_SD::SetObjectInfo(uint32_t handle, char* name, uint32_t dir, uint32_t size, uint32_t parent) {
    Record r = ReadIndexRecord(handle);
    strcpy(r.name,name);
    r.parent = parent;
    //*size = r.isdir ? 0xFFFFFFFFUL : r.size;
    r.size = size;
    6556:	movs	r4, #0
  }

  void MTPStorage_SD::SetObjectInfo(uint32_t handle, char* name, uint32_t dir, uint32_t size, uint32_t parent) {
    Record r = ReadIndexRecord(handle);
    strcpy(r.name,name);
    r.parent = parent;
    6558:	str	r7, [sp, #0]
    //*size = r.isdir ? 0xFFFFFFFFUL : r.size;
    r.size = size;
    655a:	str	r6, [sp, #16]
    r.isdir = dir;
    655c:	strb.w	r8, [sp, #12]
  void MTPStorage_SD::SetObjectInfo(uint32_t handle, char* name, uint32_t dir, uint32_t size, uint32_t parent) {
    Record r = ReadIndexRecord(handle);
    strcpy(r.name,name);
    r.parent = parent;
    //*size = r.isdir ? 0xFFFFFFFFUL : r.size;
    r.size = size;
    6560:	str	r4, [sp, #20]
    r.isdir = dir;
    WriteIndexRecord(handle, r);
    6562:	bl	62c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
  }
    6566:	add	sp, #108	; 0x6c
    6568:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0000656c <MTPStorage_SD::GetSize(unsigned long)>:

  uint64_t MTPStorage_SD::GetSize(uint32_t handle) {
    656c:	push	{lr}
    656e:	sub	sp, #108	; 0x6c
    return ReadIndexRecord(handle).size;
    6570:	mov	r2, r1
    6572:	mov	r1, r0
    6574:	mov	r0, sp
    6576:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
  }
    657a:	ldrd	r0, r1, [sp, #16]
    657e:	add	sp, #108	; 0x6c
    6580:	ldr.w	pc, [sp], #4

00006584 <MTPStorage_SD::close()>:
    mtp_lock_storage(true);
    f_.write(data, bytes);
    mtp_lock_storage(false);
  }

  void MTPStorage_SD::close() {
    6584:	push	{r4, r6, r7, lr}
    6586:	mov	r4, r0
    6588:	ldr.w	r0, [r0, #156]	; 0x9c
    658c:	sub	sp, #104	; 0x68
   *
   * \return true for success or false for failure.
   */
  bool sync() {
    return m_fFile ? m_fFile->sync() :
           m_xFile ? m_xFile->sync() : false;
    658e:	cbz	r0, 65d8 <MTPStorage_SD::close()+0x54>
    6590:	bl	31dc <FatFile::sync()>
    6594:	ldr.w	r3, [r4, #156]	; 0x9c
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
    6598:	cbz	r3, 65ea <MTPStorage_SD::close()+0x66>
    659a:	ldr	r6, [r3, #28]
    659c:	movs	r7, #0
    mtp_lock_storage(true);
    f_.sync();
    uint64_t size = f_.size();
    f_.close();
    659e:	add.w	r0, r4, #100	; 0x64
    65a2:	bl	4588 <FsBaseFile::close()>
    mtp_lock_storage(false);
    //
    Record r = ReadIndexRecord(open_file_);
    65a6:	mov	r0, sp
    65a8:	ldr.w	r2, [r4, #168]	; 0xa8
    65ac:	mov	r1, r4
    65ae:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    if(!r.isdir) r.child=1;
    65b2:	ldrb.w	r3, [sp, #12]
    65b6:	cbnz	r3, 65bc <MTPStorage_SD::close()+0x38>
    65b8:	movs	r3, #1
    65ba:	str	r3, [sp, #4]
    r.size = (uint32_t) size;
    WriteIndexRecord(open_file_, r);
    65bc:	mov	r2, sp
    65be:	ldr.w	r1, [r4, #168]	; 0xa8
    65c2:	mov	r0, r4
    f_.close();
    mtp_lock_storage(false);
    //
    Record r = ReadIndexRecord(open_file_);
    if(!r.isdir) r.child=1;
    r.size = (uint32_t) size;
    65c4:	strd	r6, r7, [sp, #16]
    WriteIndexRecord(open_file_, r);
    65c8:	bl	62c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    open_file_ = 0xFFFFFFFEUL;
    65cc:	mvn.w	r3, #1
    65d0:	str.w	r3, [r4, #168]	; 0xa8
  }
    65d4:	add	sp, #104	; 0x68
    65d6:	pop	{r4, r6, r7, pc}
   *
   * \return true for success or false for failure.
   */
  bool sync() {
    return m_fFile ? m_fFile->sync() :
           m_xFile ? m_xFile->sync() : false;
    65d8:	ldr.w	r0, [r4, #160]	; 0xa0
    65dc:	cbz	r0, 65e4 <MTPStorage_SD::close()+0x60>
    65de:	bl	1c44 <ExFatFile::sync()>
    65e2:	b.n	6594 <MTPStorage_SD::close()+0x10>
    65e4:	movs	r6, #0
    65e6:	movs	r7, #0
    65e8:	b.n	659e <MTPStorage_SD::close()+0x1a>
    65ea:	ldr.w	r3, [r4, #160]	; 0xa0
           m_xFile ? m_xFile->fgets(str, num, delim) : -1;
  }
  /** \return The total number of bytes in a file. */
  uint64_t fileSize() {
    return m_fFile ? m_fFile->fileSize() :
           m_xFile ? m_xFile->fileSize() : 0;
    65ee:	cmp	r3, #0
    65f0:	beq.n	65e4 <MTPStorage_SD::close()+0x60>
    65f2:	ldrd	r6, r7, [r3, #16]
    65f6:	movs	r7, #0
    65f8:	b.n	659e <MTPStorage_SD::close()+0x1a>
    65fa:	nop

000065fc <MTPStorage_SD::ConstructFilename(int, char*)>:
    mtp_lock_storage(false);
    return ret;
  }

  void MTPStorage_SD::ConstructFilename(int i, char* out) {
    if (i == 0) {
    65fc:	cbz	r1, 663c <MTPStorage_SD::ConstructFilename(int, char*)+0x40>
    index_.read(&ret, sizeof(ret));
    mtp_lock_storage(false);
    return ret;
  }

  void MTPStorage_SD::ConstructFilename(int i, char* out) {
    65fe:	push	{r4, r5, lr}
    6600:	sub	sp, #108	; 0x6c
    6602:	mov	r4, r2
    6604:	mov	r5, r0
    if (i == 0) {
      strcpy(out, "/");
    } else {
      Record tmp = ReadIndexRecord(i);
    6606:	mov	r2, r1
    6608:	mov	r1, r0
    660a:	mov	r0, sp
    660c:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
      ConstructFilename(tmp.parent, out);
    6610:	mov	r2, r4
    6612:	mov	r0, r5
    6614:	ldr	r1, [sp, #0]
    6616:	bl	65fc <MTPStorage_SD::ConstructFilename(int, char*)>
      if (out[strlen(out)-1] != '/')
    661a:	mov	r0, r4
    661c:	bl	bd40 <strlen>
    6620:	adds	r3, r4, r0
    6622:	ldrb.w	r3, [r3, #-1]
    6626:	cmp	r3, #47	; 0x2f
    6628:	beq.n	6630 <MTPStorage_SD::ConstructFilename(int, char*)+0x34>
        strcat(out, "/");
    662a:	ldr	r3, [pc, #24]	; (6644 <MTPStorage_SD::ConstructFilename(int, char*)+0x48>)
    662c:	ldrh	r3, [r3, #0]
    662e:	strh	r3, [r4, r0]
      strcat(out, tmp.name);
    6630:	mov	r0, r4
    6632:	add	r1, sp, #24
    6634:	bl	bc44 <strcat>
    }
  }
    6638:	add	sp, #108	; 0x6c
    663a:	pop	{r4, r5, pc}
    return ret;
  }

  void MTPStorage_SD::ConstructFilename(int i, char* out) {
    if (i == 0) {
      strcpy(out, "/");
    663c:	ldr	r3, [pc, #4]	; (6644 <MTPStorage_SD::ConstructFilename(int, char*)+0x48>)
    663e:	ldrh	r3, [r3, #0]
    6640:	strh	r3, [r2, #0]
    6642:	bx	lr
    6644:	.word	0x0000c464

00006648 <MTPStorage_SD::DeleteObject(unsigned long)>:
    f_.seek(pos);
    f_.read(out, bytes);
    mtp_lock_storage(false);
  }

  bool MTPStorage_SD::DeleteObject(uint32_t object) {
    6648:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    664c:	adds	r2, r1, #1
    664e:	sub.w	sp, sp, #568	; 0x238
    6652:	mov	r6, r1
    6654:	mov	r4, r0
    6656:	ite	ne
    6658:	movne	r5, r1
    665a:	moveq	r5, #0
    665c:	b.n	666e <MTPStorage_SD::DeleteObject(unsigned long)+0x26>
    char filename[256];
    Record r;
    while (true) {
      r = ReadIndexRecord(object == 0xFFFFFFFFUL ? 0 : object);
      if (!r.isdir) break;  // found a file
      if (!r.child) break;  // empty directory
    665e:	ldr	r3, [sp, #108]	; 0x6c
      if (!DeleteObject(r.child)) // recursive call until no more files can be deleted
    6660:	mov	r1, r3
    char filename[256];
    Record r;
    while (true) {
      r = ReadIndexRecord(object == 0xFFFFFFFFUL ? 0 : object);
      if (!r.isdir) break;  // found a file
      if (!r.child) break;  // empty directory
    6662:	cbz	r3, 668e <MTPStorage_SD::DeleteObject(unsigned long)+0x46>
      if (!DeleteObject(r.child)) // recursive call until no more files can be deleted
    6664:	ldr	r3, [r4, #0]
    6666:	ldr	r3, [r3, #52]	; 0x34
    6668:	blx	r3
    666a:	cmp	r0, #0
    666c:	beq.n	673a <MTPStorage_SD::DeleteObject(unsigned long)+0xf2>

  bool MTPStorage_SD::DeleteObject(uint32_t object) {
    char filename[256];
    Record r;
    while (true) {
      r = ReadIndexRecord(object == 0xFFFFFFFFUL ? 0 : object);
    666e:	mov	r2, r5
    6670:	mov	r1, r4
    6672:	mov	r0, sp
    6674:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    6678:	movs	r2, #104	; 0x68
    667a:	mov	r1, sp
    667c:	add.w	r0, sp, r2
    6680:	bl	8c24 <memcpy>
      if (!r.isdir) break;  // found a file
    6684:	ldrb.w	r3, [sp, #116]	; 0x74
      if (!r.child) break;  // empty directory
      if (!DeleteObject(r.child)) // recursive call until no more files can be deleted
    6688:	mov	r0, r4
  bool MTPStorage_SD::DeleteObject(uint32_t object) {
    char filename[256];
    Record r;
    while (true) {
      r = ReadIndexRecord(object == 0xFFFFFFFFUL ? 0 : object);
      if (!r.isdir) break;  // found a file
    668a:	cmp	r3, #0
    668c:	bne.n	665e <MTPStorage_SD::DeleteObject(unsigned long)+0x16>
        return false;
    }

    // We can't actually delete the root folder,
    // but if we deleted everything else, return true.
    if (object == 0xFFFFFFFFUL) return true;
    668e:	adds	r3, r6, #1
    6690:	beq.n	6752 <MTPStorage_SD::DeleteObject(unsigned long)+0x10a>

    ConstructFilename(object, filename);
    6692:	add	r2, sp, #312	; 0x138
    6694:	mov	r1, r6
    6696:	mov	r0, r4
    6698:	bl	65fc <MTPStorage_SD::ConstructFilename(int, char*)>
    bool success;
    mtp_lock_storage(true);
    if (r.isdir) {
    669c:	ldrb.w	r7, [sp, #116]	; 0x74
    66a0:	ldr	r3, [pc, #296]	; (67cc <MTPStorage_SD::DeleteObject(unsigned long)+0x184>)
    66a2:	cmp	r7, #0
    66a4:	beq.n	675c <MTPStorage_SD::DeleteObject(unsigned long)+0x114>
    66a6:	ldr.w	r7, [r3, #1144]	; 0x478
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char *path) {
    return m_fVol ? m_fVol->rmdir(path) :
           m_xVol ? m_xVol->rmdir(path) : false;
    66aa:	cbz	r7, 6718 <MTPStorage_SD::DeleteObject(unsigned long)+0xd0>
    66ac:	add	r5, sp, #208	; 0xd0
    66ae:	mov.w	lr, #0
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const char* path) {
    FatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    66b2:	add	r2, sp, #312	; 0x138
    66b4:	mov	r1, r7
    66b6:	mov	r0, r5
    66b8:	mov	r3, lr
    66ba:	strb.w	lr, [r5]
    66be:	strb.w	lr, [r5, #1]
    66c2:	strb.w	lr, [r5, #2]
    66c6:	bl	27a8 <FatFile::open(FatVolume*, char const*, int)>
    66ca:	cbz	r0, 673a <MTPStorage_SD::DeleteObject(unsigned long)+0xf2>
    66cc:	mov	r0, r5
    66ce:	bl	2ad0 <FatFile::rmdir()>
      success = SD.rmdir(filename);
    } else {
      success = SD.remove(filename);
    }
    mtp_lock_storage(false);
    if (!success) return false;
    66d2:	cbz	r0, 673a <MTPStorage_SD::DeleteObject(unsigned long)+0xf2>
    // object is deleted on disk
    // remove object from database
    r.name[0] = 0;
    int p = r.parent;
    66d4:	ldr.w	r8, [sp, #104]	; 0x68
    }
    mtp_lock_storage(false);
    if (!success) return false;
    // object is deleted on disk
    // remove object from database
    r.name[0] = 0;
    66d8:	movs	r3, #0
    int p = r.parent;
    WriteIndexRecord(object, r);
    66da:	add	r2, sp, #104	; 0x68
    66dc:	mov	r1, r6
    66de:	mov	r0, r4
    }
    mtp_lock_storage(false);
    if (!success) return false;
    // object is deleted on disk
    // remove object from database
    r.name[0] = 0;
    66e0:	strb.w	r3, [sp, #128]	; 0x80
    int p = r.parent;
    WriteIndexRecord(object, r);
    66e4:	bl	62c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    Record tmp = ReadIndexRecord(p);  // get parent object (directory)
    66e8:	mov	r2, r8
    66ea:	mov	r1, r4
    66ec:	mov	r0, r5
    66ee:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    if (tmp.child == object) {        // are we first object in directory (youngest child)
    66f2:	ldr	r7, [r5, #4]
    66f4:	cmp	r6, r7
    66f6:	beq.n	6744 <MTPStorage_SD::DeleteObject(unsigned long)+0xfc>
      tmp.child = r.sibling;
      WriteIndexRecord(p, tmp);
    } else {                          // search younger siblings
      int c = tmp.child;              // youngest sibling in directory
      while (c) {
    66f8:	cbz	r7, 6752 <MTPStorage_SD::DeleteObject(unsigned long)+0x10a>
        tmp = ReadIndexRecord(c);
    66fa:	mov	r2, r7
    66fc:	mov	r1, r4
    66fe:	mov	r0, sp
    6700:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    6704:	movs	r2, #104	; 0x68
    6706:	mov	r1, sp
    6708:	mov	r0, r5
    670a:	bl	8c24 <memcpy>
        if (tmp.sibling == object) {  // found next youngest sibling
    670e:	ldr	r3, [r5, #8]
    6710:	cmp	r6, r3
    6712:	beq.n	67b2 <MTPStorage_SD::DeleteObject(unsigned long)+0x16a>
    if (tmp.child == object) {        // are we first object in directory (youngest child)
      tmp.child = r.sibling;
      WriteIndexRecord(p, tmp);
    } else {                          // search younger siblings
      int c = tmp.child;              // youngest sibling in directory
      while (c) {
    6714:	mov	r7, r3
    6716:	b.n	66f8 <MTPStorage_SD::DeleteObject(unsigned long)+0xb0>
    6718:	ldr.w	r1, [r3, #1148]	; 0x47c
    671c:	cbz	r1, 673a <MTPStorage_SD::DeleteObject(unsigned long)+0xf2>
    671e:	add	r5, sp, #208	; 0xd0
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const ExChar_t* path) {
    ExFatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    6720:	add	r2, sp, #312	; 0x138
    6722:	mov	r3, r7
    6724:	mov	r0, r5
    6726:	strb.w	r7, [r5, #49]	; 0x31
    672a:	strb.w	r7, [r5, #50]	; 0x32
    672e:	strb.w	r7, [r5, #51]	; 0x33
    6732:	bl	1144 <ExFatFile::open(ExFatVolume*, char const*, int)>
    6736:	cmp	r0, #0
    6738:	bne.n	67c4 <MTPStorage_SD::DeleteObject(unsigned long)+0x17c>
    while (true) {
      r = ReadIndexRecord(object == 0xFFFFFFFFUL ? 0 : object);
      if (!r.isdir) break;  // found a file
      if (!r.child) break;  // empty directory
      if (!DeleteObject(r.child)) // recursive call until no more files can be deleted
        return false;
    673a:	movs	r0, #0
          c = tmp.sibling;            // move to next sibling in directory
        }
      }
    }
    return true;
  }
    673c:	add.w	sp, sp, #568	; 0x238
    6740:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    r.name[0] = 0;
    int p = r.parent;
    WriteIndexRecord(object, r);
    Record tmp = ReadIndexRecord(p);  // get parent object (directory)
    if (tmp.child == object) {        // are we first object in directory (youngest child)
      tmp.child = r.sibling;
    6744:	ldr	r3, [sp, #112]	; 0x70
    6746:	str	r3, [r5, #4]
      WriteIndexRecord(p, tmp);
    6748:	mov	r2, r5
    674a:	mov	r1, r8
    674c:	mov	r0, r4
    674e:	bl	62c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
        } else {
          c = tmp.sibling;            // move to next sibling in directory
        }
      }
    }
    return true;
    6752:	movs	r0, #1
  }
    6754:	add.w	sp, sp, #568	; 0x238
    6758:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    675c:	ldr.w	lr, [r3, #1144]	; 0x478
  *
   * \return true for success or false for failure.
  */
  bool remove(const char *path) {
    return m_fVol ? m_fVol->remove(path) :
           m_xVol ? m_xVol->remove(path) : false;
    6760:	cmp.w	lr, #0
    6764:	beq.n	6786 <MTPStorage_SD::DeleteObject(unsigned long)+0x13e>
    6766:	add	r5, sp, #208	; 0xd0
   *
   * \return true for success or false for failure.
   */
  bool remove(const char* path) {
    FatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    6768:	add	r2, sp, #312	; 0x138
    676a:	mov	r1, lr
    676c:	mov	r0, r5
    676e:	movs	r3, #1
    6770:	strb	r7, [r5, #0]
    6772:	strb	r7, [r5, #1]
    6774:	strb	r7, [r5, #2]
    6776:	bl	27a8 <FatFile::open(FatVolume*, char const*, int)>
    677a:	cmp	r0, #0
    677c:	beq.n	673a <MTPStorage_SD::DeleteObject(unsigned long)+0xf2>
    677e:	mov	r0, r5
    6780:	bl	3dcc <FatFile::remove()>
    6784:	b.n	66d2 <MTPStorage_SD::DeleteObject(unsigned long)+0x8a>
    6786:	ldr.w	r1, [r3, #1148]	; 0x47c
    678a:	cmp	r1, #0
    678c:	beq.n	673a <MTPStorage_SD::DeleteObject(unsigned long)+0xf2>
    678e:	add	r5, sp, #208	; 0xd0
   *
   * \return true for success or false for failure.
   */
  bool remove(const ExChar_t* path) {
    ExFatFile tmp;
    return tmp.open(this, path, O_WRONLY) && tmp.remove();
    6790:	add	r2, sp, #312	; 0x138
    6792:	mov	r0, r5
    6794:	movs	r3, #1
    6796:	strb.w	lr, [r5, #49]	; 0x31
    679a:	strb.w	lr, [r5, #50]	; 0x32
    679e:	strb.w	lr, [r5, #51]	; 0x33
    67a2:	bl	1144 <ExFatFile::open(ExFatVolume*, char const*, int)>
    67a6:	cmp	r0, #0
    67a8:	beq.n	673a <MTPStorage_SD::DeleteObject(unsigned long)+0xf2>
    67aa:	mov	r0, r5
    67ac:	bl	1928 <ExFatFile::remove()>
    67b0:	b.n	66d2 <MTPStorage_SD::DeleteObject(unsigned long)+0x8a>
    } else {                          // search younger siblings
      int c = tmp.child;              // youngest sibling in directory
      while (c) {
        tmp = ReadIndexRecord(c);
        if (tmp.sibling == object) {  // found next youngest sibling
          tmp.sibling = r.sibling;    // link to next older sibling; is zero of actual object is oldest child
    67b2:	ldr	r3, [sp, #112]	; 0x70
    67b4:	str	r3, [r5, #8]
          WriteIndexRecord(c, tmp);
    67b6:	mov	r0, r4
    67b8:	mov	r2, r5
    67ba:	mov	r1, r7
    67bc:	bl	62c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
        } else {
          c = tmp.sibling;            // move to next sibling in directory
        }
      }
    }
    return true;
    67c0:	movs	r0, #1
      while (c) {
        tmp = ReadIndexRecord(c);
        if (tmp.sibling == object) {  // found next youngest sibling
          tmp.sibling = r.sibling;    // link to next older sibling; is zero of actual object is oldest child
          WriteIndexRecord(c, tmp);
          break;
    67c2:	b.n	673c <MTPStorage_SD::DeleteObject(unsigned long)+0xf4>
   *
   * \return true for success or false for failure.
   */
  bool rmdir(const ExChar_t* path) {
    ExFatFile sub;
    return sub.open(this, path, O_RDONLY) && sub.rmdir();
    67c4:	mov	r0, r5
    67c6:	bl	1a50 <ExFatFile::rmdir()>
    67ca:	b.n	66d2 <MTPStorage_SD::DeleteObject(unsigned long)+0x8a>
    67cc:	.word	0x1fff1418

000067d0 <MTPStorage_SD::rename(unsigned long, char const*)>:
    r.size = (uint32_t) size;
    WriteIndexRecord(open_file_, r);
    open_file_ = 0xFFFFFFFEUL;
  }
  void MTPStorage_SD::rename(uint32_t handle, const char* name) 
  { char oldName[256];
    67d0:	push	{r4, r5, r6, lr}
    67d2:	sub.w	sp, sp, #672	; 0x2a0
    67d6:	mov	r4, r0
    67d8:	mov	r5, r1
    67da:	mov	r6, r2
    char newName[256];

    ConstructFilename(handle, oldName);
    67dc:	add	r2, sp, #160	; 0xa0
    67de:	bl	65fc <MTPStorage_SD::ConstructFilename(int, char*)>
    Record p1 = ReadIndexRecord(handle);
    67e2:	mov	r2, r5
    67e4:	mov	r1, r4
    67e6:	add	r0, sp, #56	; 0x38
    67e8:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    strcpy(p1.name,name);
    67ec:	mov	r1, r6
    67ee:	add	r0, sp, #80	; 0x50
    67f0:	bl	bc84 <strcpy>
    WriteIndexRecord(handle, p1);
    67f4:	mov	r0, r4
    67f6:	add	r2, sp, #56	; 0x38
    67f8:	mov	r1, r5
    67fa:	bl	62c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    ConstructFilename(handle, newName);
    67fe:	mov	r0, r4
    6800:	mov	r1, r5
    6802:	add	r2, sp, #416	; 0x1a0
    6804:	bl	65fc <MTPStorage_SD::ConstructFilename(int, char*)>
    6808:	ldr	r3, [pc, #116]	; (6880 <MTPStorage_SD::rename(unsigned long, char const*)+0xb0>)
    680a:	ldr.w	r4, [r3, #1144]	; 0x478
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    return m_fVol ? m_fVol->rename(oldPath, newPath) :
           m_xVol ? m_xVol->rename(oldPath, newPath) : false;
    680e:	cbz	r4, 6846 <MTPStorage_SD::rename(unsigned long, char const*)+0x76>
    6810:	movs	r5, #0
    return open(path.c_str(), oflag );
  }
#endif  // ENABLE_ARDUINO_STRING

 private:
  FatFile* vwd() {return &m_vwd;}
    6812:	addw	r4, r4, #1084	; 0x43c
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    FatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    6816:	add	r2, sp, #160	; 0xa0
    6818:	mov	r1, r4
    681a:	mov	r0, sp
    681c:	mov	r3, r5
    681e:	strb.w	r5, [sp]
    6822:	strb.w	r5, [sp, #1]
    6826:	strb.w	r5, [sp, #2]
    682a:	bl	26a4 <FatFile::open(FatFile*, char const*, int)>
    682e:	cbnz	r0, 6836 <MTPStorage_SD::rename(unsigned long, char const*)+0x66>

    SD.rename(oldName,newName);
  }
    6830:	add.w	sp, sp, #672	; 0x2a0
    6834:	pop	{r4, r5, r6, pc}
    6836:	add	r2, sp, #416	; 0x1a0
    6838:	mov	r1, r4
    683a:	mov	r0, sp
    683c:	bl	2fa4 <FatFile::rename(FatFile*, char const*)>
    6840:	add.w	sp, sp, #672	; 0x2a0
    6844:	pop	{r4, r5, r6, pc}
    6846:	ldr.w	r1, [r3, #1148]	; 0x47c
    684a:	cmp	r1, #0
    684c:	beq.n	6830 <MTPStorage_SD::rename(unsigned long, char const*)+0x60>
  bool rmdir(const char* path);
#endif  //  USE_UNICODE_NAMES

 private:
  friend ExFatFile;
  ExFatFile* vwd() {return &m_vwd;}
    684e:	add.w	r5, r1, #1088	; 0x440
   *
   * \return true for success or false for failure.
   */
  bool rename(const ExChar_t* oldPath, const ExChar_t* newPath) {
    ExFatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    6852:	add	r2, sp, #160	; 0xa0
    6854:	mov	r1, r5
    6856:	mov	r3, r4
    6858:	mov	r0, sp
    685a:	strb.w	r4, [sp, #49]	; 0x31
    685e:	strb.w	r4, [sp, #50]	; 0x32
    6862:	strb.w	r4, [sp, #51]	; 0x33
    6866:	bl	102c <ExFatFile::open(ExFatFile*, char const*, int)>
    686a:	cmp	r0, #0
    686c:	beq.n	6830 <MTPStorage_SD::rename(unsigned long, char const*)+0x60>
    686e:	add	r2, sp, #416	; 0x1a0
    6870:	mov	r1, r5
    6872:	mov	r0, sp
    6874:	bl	1f3c <ExFatFile::rename(ExFatFile*, char const*)>
    6878:	add.w	sp, sp, #672	; 0x2a0
    687c:	pop	{r4, r5, r6, pc}
    687e:	nop
    6880:	.word	0x1fff1418

00006884 <MTPStorage_SD::move(unsigned long, unsigned long)>:

  void MTPStorage_SD::move(uint32_t handle, uint32_t newParent ) 
  { char oldName[256];
    6884:	push	{r4, r5, r6, lr}
    6886:	sub.w	sp, sp, #776	; 0x308
    688a:	mov	r4, r2
    688c:	mov	r5, r0
    688e:	mov	r6, r1
    char newName[256];

    ConstructFilename(handle, oldName);
    6890:	add	r2, sp, #264	; 0x108
    6892:	bl	65fc <MTPStorage_SD::ConstructFilename(int, char*)>
    Record p1 = ReadIndexRecord(handle);
    6896:	mov	r2, r6
    6898:	mov	r1, r5
    689a:	add	r0, sp, #56	; 0x38
    689c:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>

    if (newParent == 0xFFFFFFFFUL) newParent = 0;
    68a0:	adds	r3, r4, #1
    68a2:	it	eq
    68a4:	moveq	r4, #0
    Record p2 = ReadIndexRecord(newParent); // is pointing to last object in directory
    68a6:	mov	r2, r4
    68a8:	mov	r1, r5
    68aa:	add	r0, sp, #160	; 0xa0
    68ac:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>

    p1.sibling = p2.child;
    68b0:	ldr	r3, [sp, #164]	; 0xa4
    68b2:	str	r3, [sp, #64]	; 0x40
    p1.parent = newParent;

    p2.child = handle; 
    WriteIndexRecord(handle, p1);
    68b4:	add	r2, sp, #56	; 0x38
    68b6:	mov	r1, r6
    68b8:	mov	r0, r5

    if (newParent == 0xFFFFFFFFUL) newParent = 0;
    Record p2 = ReadIndexRecord(newParent); // is pointing to last object in directory

    p1.sibling = p2.child;
    p1.parent = newParent;
    68ba:	str	r4, [sp, #56]	; 0x38

    p2.child = handle; 
    68bc:	str	r6, [sp, #164]	; 0xa4
    WriteIndexRecord(handle, p1);
    68be:	bl	62c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    WriteIndexRecord(newParent, p2);
    68c2:	mov	r1, r4
    68c4:	add	r2, sp, #160	; 0xa0
    68c6:	mov	r0, r5
    68c8:	bl	62c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>

    ConstructFilename(handle, newName);
    68cc:	mov	r1, r6
    68ce:	mov	r0, r5
    68d0:	add	r2, sp, #520	; 0x208
    68d2:	bl	65fc <MTPStorage_SD::ConstructFilename(int, char*)>
    68d6:	ldr	r3, [pc, #116]	; (694c <MTPStorage_SD::move(unsigned long, unsigned long)+0xc8>)
    68d8:	ldr.w	r4, [r3, #1144]	; 0x478
    68dc:	cbz	r4, 6914 <MTPStorage_SD::move(unsigned long, unsigned long)+0x90>
    68de:	movs	r5, #0
    return open(path.c_str(), oflag );
  }
#endif  // ENABLE_ARDUINO_STRING

 private:
  FatFile* vwd() {return &m_vwd;}
    68e0:	addw	r4, r4, #1084	; 0x43c
   *
   * \return true for success or false for failure.
   */
  bool rename(const char *oldPath, const char *newPath) {
    FatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    68e4:	add	r2, sp, #264	; 0x108
    68e6:	mov	r1, r4
    68e8:	mov	r0, sp
    68ea:	mov	r3, r5
    68ec:	strb.w	r5, [sp]
    68f0:	strb.w	r5, [sp, #1]
    68f4:	strb.w	r5, [sp, #2]
    68f8:	bl	26a4 <FatFile::open(FatFile*, char const*, int)>
    68fc:	cbnz	r0, 6904 <MTPStorage_SD::move(unsigned long, unsigned long)+0x80>
    SD.rename(oldName,newName);
  }
    68fe:	add.w	sp, sp, #776	; 0x308
    6902:	pop	{r4, r5, r6, pc}
    6904:	add	r2, sp, #520	; 0x208
    6906:	mov	r1, r4
    6908:	mov	r0, sp
    690a:	bl	2fa4 <FatFile::rename(FatFile*, char const*)>
    690e:	add.w	sp, sp, #776	; 0x308
    6912:	pop	{r4, r5, r6, pc}
    6914:	ldr.w	r1, [r3, #1148]	; 0x47c
    6918:	cmp	r1, #0
    691a:	beq.n	68fe <MTPStorage_SD::move(unsigned long, unsigned long)+0x7a>
  bool rmdir(const char* path);
#endif  //  USE_UNICODE_NAMES

 private:
  friend ExFatFile;
  ExFatFile* vwd() {return &m_vwd;}
    691c:	add.w	r5, r1, #1088	; 0x440
   *
   * \return true for success or false for failure.
   */
  bool rename(const ExChar_t* oldPath, const ExChar_t* newPath) {
    ExFatFile file;
    return file.open(vwd(), oldPath, O_RDONLY) && file.rename(vwd(), newPath);
    6920:	add	r2, sp, #264	; 0x108
    6922:	mov	r1, r5
    6924:	mov	r3, r4
    6926:	mov	r0, sp
    6928:	strb.w	r4, [sp, #49]	; 0x31
    692c:	strb.w	r4, [sp, #50]	; 0x32
    6930:	strb.w	r4, [sp, #51]	; 0x33
    6934:	bl	102c <ExFatFile::open(ExFatFile*, char const*, int)>
    6938:	cmp	r0, #0
    693a:	beq.n	68fe <MTPStorage_SD::move(unsigned long, unsigned long)+0x7a>
    693c:	add	r2, sp, #520	; 0x208
    693e:	mov	r1, r5
    6940:	mov	r0, sp
    6942:	bl	1f3c <ExFatFile::rename(ExFatFile*, char const*)>
    6946:	add.w	sp, sp, #776	; 0x308
    694a:	pop	{r4, r5, r6, pc}
    694c:	.word	0x1fff1418

00006950 <MTPStorage_SD::OpenFileByIndex(unsigned long, int)>:
        strcat(out, "/");
      strcat(out, tmp.name);
    }
  }

  void MTPStorage_SD::OpenFileByIndex(uint32_t i, oflag_t mode) {
    6950:	push	{r4, r5, r6, r7, lr}
    if (open_file_ == i && mode_ == mode)
    6952:	ldr.w	r3, [r0, #168]	; 0xa8
    6956:	cmp	r3, r1
        strcat(out, "/");
      strcat(out, tmp.name);
    }
  }

  void MTPStorage_SD::OpenFileByIndex(uint32_t i, oflag_t mode) {
    6958:	sub	sp, #340	; 0x154
    if (open_file_ == i && mode_ == mode)
    695a:	beq.n	69b6 <MTPStorage_SD::OpenFileByIndex(unsigned long, int)+0x66>
    695c:	mov	r4, r0
    695e:	mov	r6, r2
      return;
    char filename[256];
    ConstructFilename(i, filename);
    6960:	add	r2, sp, #80	; 0x50
    6962:	mov	r5, r1
    6964:	bl	65fc <MTPStorage_SD::ConstructFilename(int, char*)>
  bool isHidden() {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() {return m_fFile || m_xFile;}
    6968:	ldr.w	r3, [r4, #156]	; 0x9c
    mtp_lock_storage(true);
    if(f_ && f_.isOpen()) f_.close();
    696c:	add.w	r7, r4, #100	; 0x64
    6970:	cbz	r3, 69c0 <MTPStorage_SD::OpenFileByIndex(unsigned long, int)+0x70>
    6972:	mov	r0, r7
    6974:	bl	4588 <FsBaseFile::close()>
    f_ = SD.open(filename, mode);
    6978:	add	r2, sp, #80	; 0x50
    697a:	mov	r0, sp
    697c:	mov	r3, r6
    697e:	ldr	r1, [pc, #76]	; (69cc <MTPStorage_SD::OpenFileByIndex(unsigned long, int)+0x7c>)
    6980:	bl	47d0 <FsVolume::open(char const*, int)>
//#define BYTE 0
//#endif

class __FlashStringHelper;

class Print
    6984:	ldrb.w	r1, [sp, #4]
    6988:	ldr	r2, [sp, #8]
    698a:	ldrb.w	r3, [sp, #12]
    698e:	strb.w	r1, [r4, #88]	; 0x58
    6992:	str	r2, [r4, #92]	; 0x5c
    6994:	strb.w	r3, [r4, #96]	; 0x60
    6998:	add	r1, sp, #16
    699a:	mov	r0, r7
    699c:	bl	45b0 <FsBaseFile::operator=(FsBaseFile const&)>
    69a0:	ldr	r3, [pc, #44]	; (69d0 <MTPStorage_SD::OpenFileByIndex(unsigned long, int)+0x80>)
    69a2:	str	r3, [sp, #0]
 */
class FsBaseFile {
 public:
  FsBaseFile() : m_fFile(nullptr), m_xFile(nullptr) {}

  ~FsBaseFile() {close();}
    69a4:	add	r0, sp, #16
    69a6:	bl	4588 <FsBaseFile::close()>
    open_file_ = i;
    69aa:	str.w	r5, [r4, #168]	; 0xa8
    mode_ = mode;
    69ae:	strh.w	r6, [r4, #164]	; 0xa4
    mtp_lock_storage(false);
  }
    69b2:	add	sp, #340	; 0x154
    69b4:	pop	{r4, r5, r6, r7, pc}
      strcat(out, tmp.name);
    }
  }

  void MTPStorage_SD::OpenFileByIndex(uint32_t i, oflag_t mode) {
    if (open_file_ == i && mode_ == mode)
    69b6:	ldrh.w	r3, [r0, #164]	; 0xa4
    69ba:	cmp	r3, r2
    69bc:	bne.n	695c <MTPStorage_SD::OpenFileByIndex(unsigned long, int)+0xc>
    69be:	b.n	69b2 <MTPStorage_SD::OpenFileByIndex(unsigned long, int)+0x62>
  bool isHidden() {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() {return m_fFile || m_xFile;}
    69c0:	ldr.w	r3, [r4, #160]	; 0xa0
    69c4:	cmp	r3, #0
    69c6:	bne.n	6972 <MTPStorage_SD::OpenFileByIndex(unsigned long, int)+0x22>
    69c8:	b.n	6978 <MTPStorage_SD::OpenFileByIndex(unsigned long, int)+0x28>
    69ca:	nop
    69cc:	.word	0x1fff1418
    69d0:	.word	0x0000c21c

000069d4 <MTPStorage_SD::Create(unsigned long, bool, char const*)>:
      }
    }
    return true;
  }

  uint32_t MTPStorage_SD::Create(uint32_t parent, bool folder, const char* filename) {
    69d4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = 0;
    69d8:	cmp.w	r1, #4294967295
    69dc:	ite	ne
    69de:	movne	r6, r1
    69e0:	moveq	r6, #0
      }
    }
    return true;
  }

  uint32_t MTPStorage_SD::Create(uint32_t parent, bool folder, const char* filename) {
    69e2:	sub.w	sp, sp, #520	; 0x208
    69e6:	mov	r5, r3
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = 0;
    Record p = ReadIndexRecord(parent);
    69e8:	mov	r1, r0
      }
    }
    return true;
  }

  uint32_t MTPStorage_SD::Create(uint32_t parent, bool folder, const char* filename) {
    69ea:	mov	r4, r0
    69ec:	mov	r7, r2
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = 0;
    Record p = ReadIndexRecord(parent);
    69ee:	add	r0, sp, #56	; 0x38
    69f0:	mov	r2, r6
    69f2:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    Record r;
    if (strlen(filename) > 62) return 0;
    69f6:	mov	r0, r5
    69f8:	bl	bd40 <strlen>
    69fc:	cmp	r0, #62	; 0x3e
    69fe:	bls.n	6a0c <MTPStorage_SD::Create(unsigned long, bool, char const*)+0x38>
    6a00:	movs	r5, #0
      mtp_lock_storage(false);
    } else {
      OpenFileByIndex(ret, FILE_WRITE);
    }
    return ret;
  }
    6a02:	mov	r0, r5
    6a04:	add.w	sp, sp, #520	; 0x208
    6a08:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    uint32_t ret;
    if (parent == 0xFFFFFFFFUL) parent = 0;
    Record p = ReadIndexRecord(parent);
    Record r;
    if (strlen(filename) > 62) return 0;
    strcpy(r.name, filename);
    6a0c:	adds	r2, r0, #1
    6a0e:	mov	r1, r5
    6a10:	add	r0, sp, #184	; 0xb8
    6a12:	bl	8c24 <memcpy>
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) {
    uint32_t new_record = index_entries_++;
    6a16:	ldr.w	r5, [r4, #172]	; 0xac
    Record r;
    if (strlen(filename) > 62) return 0;
    strcpy(r.name, filename);
    r.parent = parent;
    r.child = 0;
    r.sibling = p.child;
    6a1a:	ldr	r3, [sp, #60]	; 0x3c
    6a1c:	str	r3, [sp, #168]	; 0xa8
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) {
    uint32_t new_record = index_entries_++;
    6a1e:	adds	r2, r5, #1
    strcpy(r.name, filename);
    r.parent = parent;
    r.child = 0;
    r.sibling = p.child;
    r.isdir = folder;
    r.size=0;
    6a20:	mov.w	r8, #0
    6a24:	mov.w	r9, #0
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) {
    uint32_t new_record = index_entries_++;
    6a28:	str.w	r2, [r4, #172]	; 0xac
    WriteIndexRecord(new_record, r);
    6a2c:	mov	r1, r5
    6a2e:	add	r2, sp, #160	; 0xa0
    strcpy(r.name, filename);
    r.parent = parent;
    r.child = 0;
    r.sibling = p.child;
    r.isdir = folder;
    r.size=0;
    6a30:	strd	r8, r9, [sp, #176]	; 0xb0
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) {
    uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    6a34:	mov	r0, r4
    Record p = ReadIndexRecord(parent);
    Record r;
    if (strlen(filename) > 62) return 0;
    strcpy(r.name, filename);
    r.parent = parent;
    r.child = 0;
    6a36:	mov.w	sl, #0
    r.sibling = p.child;
    r.isdir = folder;
    r.size=0;
    // New folder is empty, scanned = true.
    r.scanned = 1;
    6a3a:	mov.w	r8, #1
    if (parent == 0xFFFFFFFFUL) parent = 0;
    Record p = ReadIndexRecord(parent);
    Record r;
    if (strlen(filename) > 62) return 0;
    strcpy(r.name, filename);
    r.parent = parent;
    6a3e:	str	r6, [sp, #160]	; 0xa0
    r.child = 0;
    r.sibling = p.child;
    r.isdir = folder;
    6a40:	strb.w	r7, [sp, #172]	; 0xac
    Record p = ReadIndexRecord(parent);
    Record r;
    if (strlen(filename) > 62) return 0;
    strcpy(r.name, filename);
    r.parent = parent;
    r.child = 0;
    6a44:	str.w	sl, [sp, #164]	; 0xa4
    r.sibling = p.child;
    r.isdir = folder;
    r.size=0;
    // New folder is empty, scanned = true.
    r.scanned = 1;
    6a48:	strb.w	r8, [sp, #173]	; 0xad
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) {
    uint32_t new_record = index_entries_++;
    WriteIndexRecord(new_record, r);
    6a4c:	bl	62c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    r.isdir = folder;
    r.size=0;
    // New folder is empty, scanned = true.
    r.scanned = 1;
    ret = p.child = AppendIndexRecord(r); 
    WriteIndexRecord(parent, p);
    6a50:	mov	r0, r4
    6a52:	add	r2, sp, #56	; 0x38
    6a54:	mov	r1, r6
    r.sibling = p.child;
    r.isdir = folder;
    r.size=0;
    // New folder is empty, scanned = true.
    r.scanned = 1;
    ret = p.child = AppendIndexRecord(r); 
    6a56:	str	r5, [sp, #60]	; 0x3c
    WriteIndexRecord(parent, p);
    6a58:	bl	62c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    //
    if (folder) {
      char filename[256];
      ConstructFilename(ret, filename);
    6a5c:	mov	r0, r4
    // New folder is empty, scanned = true.
    r.scanned = 1;
    ret = p.child = AppendIndexRecord(r); 
    WriteIndexRecord(parent, p);
    //
    if (folder) {
    6a5e:	cbnz	r7, 6a74 <MTPStorage_SD::Create(unsigned long, bool, char const*)+0xa0>
      ConstructFilename(ret, filename);
      mtp_lock_storage(true);
      SD.mkdir(filename);
      mtp_lock_storage(false);
    } else {
      OpenFileByIndex(ret, FILE_WRITE);
    6a60:	movw	r2, #16898	; 0x4202
    6a64:	mov	r1, r5
    6a66:	bl	6950 <MTPStorage_SD::OpenFileByIndex(unsigned long, int)>
    }
    return ret;
  }
    6a6a:	mov	r0, r5
    6a6c:	add.w	sp, sp, #520	; 0x208
    6a70:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ret = p.child = AppendIndexRecord(r); 
    WriteIndexRecord(parent, p);
    //
    if (folder) {
      char filename[256];
      ConstructFilename(ret, filename);
    6a74:	add	r2, sp, #264	; 0x108
    6a76:	mov	r1, r5
    6a78:	bl	65fc <MTPStorage_SD::ConstructFilename(int, char*)>
    6a7c:	ldr	r3, [pc, #68]	; (6ac4 <MTPStorage_SD::Create(unsigned long, bool, char const*)+0xf0>)
    6a7e:	ldr.w	r4, [r3, #1144]	; 0x478
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char *path, bool pFlag = true) {
    return m_fVol ? m_fVol->mkdir(path, pFlag) :
           m_xVol ? m_xVol->mkdir(path, pFlag) : false;
    6a82:	cbz	r4, 6aa0 <MTPStorage_SD::Create(unsigned long, bool, char const*)+0xcc>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const char* path, bool pFlag = true) {
    FatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    6a84:	mov	r3, r8
    6a86:	add	r2, sp, #264	; 0x108
    6a88:	addw	r1, r4, #1084	; 0x43c
    6a8c:	mov	r0, sp
    6a8e:	strb.w	sl, [sp]
    6a92:	strb.w	sl, [sp, #1]
    6a96:	strb.w	sl, [sp, #2]
    6a9a:	bl	2ea8 <FatFile::mkdir(FatFile*, char const*, bool)>
    6a9e:	b.n	6a02 <MTPStorage_SD::Create(unsigned long, bool, char const*)+0x2e>
    6aa0:	ldr.w	r1, [r3, #1148]	; 0x47c
    6aa4:	cmp	r1, #0
    6aa6:	beq.n	6a02 <MTPStorage_SD::Create(unsigned long, bool, char const*)+0x2e>
   *
   * \return true for success or false for failure.
   */
  bool mkdir(const ExChar_t* path, bool pFlag = true) {
    ExFatFile sub;
    return sub.mkdir(vwd(), path, pFlag);
    6aa8:	mov	r3, r8
    6aaa:	add	r2, sp, #264	; 0x108
    6aac:	add.w	r1, r1, #1088	; 0x440
    6ab0:	mov	r0, sp
    6ab2:	strb.w	r4, [sp, #49]	; 0x31
    6ab6:	strb.w	r4, [sp, #50]	; 0x32
    6aba:	strb.w	r4, [sp, #51]	; 0x33
    6abe:	bl	1e34 <ExFatFile::mkdir(ExFatFile*, char const*, bool)>
    6ac2:	b.n	6a02 <MTPStorage_SD::Create(unsigned long, bool, char const*)+0x2e>
    6ac4:	.word	0x1fff1418

00006ac8 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)>:

  uint64_t MTPStorage_SD::GetSize(uint32_t handle) {
    return ReadIndexRecord(handle).size;
  }

  void MTPStorage_SD::read(uint32_t handle, uint32_t pos, char* out, uint32_t bytes) {
    6ac8:	push	{r3, r4, r5, r6, r7, lr}
    6aca:	mov	r4, r0
    6acc:	mov	r7, r2
    OpenFileByIndex(handle);
    6ace:	movs	r2, #0

  uint64_t MTPStorage_SD::GetSize(uint32_t handle) {
    return ReadIndexRecord(handle).size;
  }

  void MTPStorage_SD::read(uint32_t handle, uint32_t pos, char* out, uint32_t bytes) {
    6ad0:	mov	r5, r3
    6ad2:	ldr	r6, [sp, #24]
    OpenFileByIndex(handle);
    6ad4:	bl	6950 <MTPStorage_SD::OpenFileByIndex(unsigned long, int)>
    6ad8:	ldr.w	r0, [r4, #156]	; 0x9c
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
    6adc:	cbz	r0, 6b08 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x40>
   * \param[in] pos The new position in bytes from the beginning of the file.
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
    6ade:	mov	r1, r7
    6ae0:	bl	2a14 <FatFile::seekSet(unsigned long)>
    6ae4:	ldr.w	r0, [r4, #156]	; 0x9c
   * read() called before a file has been opened, corrupt file system
   * or an I/O error occurred.
   */
  int read(void* buf, size_t count) {
    return m_fFile ? m_fFile->read(buf, count) :
           m_xFile ? m_xFile->read(buf, count) : -1;
    6ae8:	cbz	r0, 6af6 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x2e>
    6aea:	mov	r2, r6
    6aec:	mov	r1, r5
    mtp_lock_storage(true);
    f_.seek(pos);
    f_.read(out, bytes);
    mtp_lock_storage(false);
  }
    6aee:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    6af2:	b.w	27b8 <FatFile::read(void*, unsigned int)>
    6af6:	ldr.w	r0, [r4, #160]	; 0xa0
    6afa:	cbz	r0, 6b1c <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x54>
    6afc:	mov	r2, r6
    6afe:	mov	r1, r5
    6b00:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    6b04:	b.w	8cc <ExFatFile::read(void*, unsigned int)>
   *
   * \return true for success or false for failure.
   */
  bool seekSet(uint64_t pos) {
    return m_fFile ? pos < (1ULL << 32) && m_fFile->seekSet(pos) :
           m_xFile ? m_xFile->seekSet(pos) : false;
    6b08:	ldr.w	r1, [r4, #160]	; 0xa0
    6b0c:	cbz	r1, 6b1a <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x52>
    6b0e:	mov	r3, r0
    6b10:	mov	r2, r7
    6b12:	mov	r0, r1
    6b14:	bl	ae0 <ExFatFile::seekSet(unsigned long long)>
    6b18:	b.n	6ae4 <MTPStorage_SD::read(unsigned long, unsigned long, char*, unsigned long)+0x1c>
    6b1a:	pop	{r3, r4, r5, r6, r7, pc}
    6b1c:	pop	{r3, r4, r5, r6, r7, pc}
    6b1e:	nop

00006b20 <MTPStorage_SD::ScanDir(unsigned long)>:
    r.size=0;
    strcpy(r.name, "/");
    AppendIndexRecord(r);
  }

  void MTPStorage_SD::ScanDir(uint32_t i) {
    6b20:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6b24:	sub	sp, #292	; 0x124
    Record record = ReadIndexRecord(i);
    6b26:	mov	r2, r1
    r.size=0;
    strcpy(r.name, "/");
    AppendIndexRecord(r);
  }

  void MTPStorage_SD::ScanDir(uint32_t i) {
    6b28:	mov	r5, r0
    6b2a:	mov	r6, r1
    Record record = ReadIndexRecord(i);
    6b2c:	mov	r1, r0
    6b2e:	add	r0, sp, #80	; 0x50
    6b30:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>

    if (record.isdir && !record.scanned) {
    6b34:	ldrb.w	r3, [sp, #92]	; 0x5c
    6b38:	cbz	r3, 6b40 <MTPStorage_SD::ScanDir(unsigned long)+0x20>
    6b3a:	ldrb.w	r2, [sp, #93]	; 0x5d
    6b3e:	cbz	r2, 6b46 <MTPStorage_SD::ScanDir(unsigned long)+0x26>
      }
      record.scanned = true;
      record.child = sibling; // this is the last object in directory
      WriteIndexRecord(i, record);
    }
  }
    6b40:	add	sp, #292	; 0x124
    6b42:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  void MTPStorage_SD::ScanDir(uint32_t i) {
    Record record = ReadIndexRecord(i);

    if (record.isdir && !record.scanned) {
      OpenFileByIndex(i);
    6b46:	mov	r1, r6
    6b48:	mov	r0, r5
    6b4a:	bl	6950 <MTPStorage_SD::OpenFileByIndex(unsigned long, int)>
  bool isHidden() {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() {return m_fFile || m_xFile;}
    6b4e:	ldr.w	r3, [r5, #156]	; 0x9c
    6b52:	cmp	r3, #0
    6b54:	beq.n	6c3e <MTPStorage_SD::ScanDir(unsigned long)+0x11e>
    r.size=0;
    strcpy(r.name, "/");
    AppendIndexRecord(r);
  }

  void MTPStorage_SD::ScanDir(uint32_t i) {
    6b56:	mov.w	fp, #0
{
  public:
	constexpr Print() : write_error(0) {}
    6b5a:	mov	r4, fp
    6b5c:	add.w	r9, r5, #100	; 0x64
    6b60:	ldr.w	sl, [pc, #264]	; 6c6c <MTPStorage_SD::ScanDir(unsigned long)+0x14c>
    6b64:	b.n	6bc2 <MTPStorage_SD::ScanDir(unsigned long)+0xa2>
        mtp_lock_storage(false);

        if (!child) break;

        Record r;
        r.parent = i;
    6b66:	str	r6, [sp, #184]	; 0xb8
        r.sibling = sibling;
    6b68:	str.w	fp, [sp, #192]	; 0xc0
    6b6c:	ldrb.w	lr, [r3]
        r.isdir = child.isDirectory();
        r.child = r.isdir ? 0 : 1;
        r.scanned = false;
        r.size=child.size();
    6b70:	ldr	r3, [r3, #28]
    6b72:	str	r3, [sp, #200]	; 0xc8
    6b74:	and.w	r3, lr, #112	; 0x70
        if (!child) break;

        Record r;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child.isDirectory();
    6b78:	cmp	r3, #0
    6b7a:	iteet	ne
    6b7c:	movne.w	lr, #1
    6b80:	moveq.w	lr, #0
        r.child = r.isdir ? 0 : 1;
    6b84:	moveq	r3, #1
    6b86:	movne	r3, #0
        r.scanned = false;
    6b88:	strb.w	r4, [sp, #197]	; 0xc5
        r.size=child.size();
    6b8c:	str	r4, [sp, #204]	; 0xcc
   *             must be at least 13 bytes long.  The file's name will be
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
    6b8e:	strb.w	r4, [sp, #208]	; 0xd0
        if (!child) break;

        Record r;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child.isDirectory();
    6b92:	strb.w	lr, [sp, #196]	; 0xc4
        r.child = r.isdir ? 0 : 1;
    6b96:	str	r3, [sp, #188]	; 0xbc
    return m_fFile ? m_fFile->getName(name, len) :
    6b98:	bl	3a4c <FatFile::getName(char*, unsigned int)>
    index_.write((char*)&r, sizeof(r));
    mtp_lock_storage(false);
  }

  uint32_t MTPStorage_SD::AppendIndexRecord(const Record& r) {
    uint32_t new_record = index_entries_++;
    6b9c:	ldr.w	fp, [r5, #172]	; 0xac
    6ba0:	add.w	r3, fp, #1
    6ba4:	str.w	r3, [r5, #172]	; 0xac
    WriteIndexRecord(new_record, r);
    6ba8:	mov	r1, fp
    6baa:	add	r2, sp, #184	; 0xb8
    6bac:	mov	r0, r5
    6bae:	bl	62c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
        r.child = r.isdir ? 0 : 1;
        r.scanned = false;
        r.size=child.size();
        child.getName(r.name, 64);
        sibling = AppendIndexRecord(r);
        child.close();
    6bb2:	add	r0, sp, #16
    6bb4:	bl	4588 <FsBaseFile::close()>
 */
class FsBaseFile {
 public:
  FsBaseFile() : m_fFile(nullptr), m_xFile(nullptr) {}

  ~FsBaseFile() {close();}
    6bb8:	add	r0, sp, #16
    6bba:	str.w	sl, [sp]
    6bbe:	bl	4588 <FsBaseFile::close()>
{
  public:
	constexpr Stream() : _timeout(1000), read_error(0) {}
    6bc2:	mov.w	r3, #1000	; 0x3e8
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
    6bc6:	movs	r2, #0
    6bc8:	mov	r1, r9
    6bca:	str	r3, [sp, #8]
    6bcc:	add	r0, sp, #16
};
/**
 * \class FsFile
 * \brief FsBaseFile file with Arduino Stream.
 */
class FsFile : public StreamFile<FsBaseFile, uint64_t> {
    6bce:	ldr	r3, [pc, #152]	; (6c68 <MTPStorage_SD::ScanDir(unsigned long)+0x148>)
    6bd0:	str	r3, [sp, #0]
    6bd2:	strb.w	r4, [sp, #4]
    6bd6:	strb.w	r4, [sp, #12]
 * \class FsBaseFile
 * \brief FsBaseFile class.
 */
class FsBaseFile {
 public:
  FsBaseFile() : m_fFile(nullptr), m_xFile(nullptr) {}
    6bda:	str	r4, [sp, #72]	; 0x48
    6bdc:	str	r4, [sp, #76]	; 0x4c
   * \param[in] oflag open flags.
   * \return a FatStream object.
   */
  FsFile openNextFile(oflag_t oflag = O_RDONLY) {
    FsFile tmpFile;
    tmpFile.openNext(this, oflag);
    6bde:	bl	46ac <FsBaseFile::openNext(FsBaseFile*, int)>
    6be2:	ldr	r3, [sp, #72]	; 0x48
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
    return m_fFile ? m_fFile->getName(name, len) :
    6be4:	movs	r2, #64	; 0x40
    6be6:	add	r1, sp, #208	; 0xd0
    6be8:	mov	r0, r3
  bool isHidden() {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() {return m_fFile || m_xFile;}
    6bea:	cmp	r3, #0
    6bec:	bne.n	6b66 <MTPStorage_SD::ScanDir(unsigned long)+0x46>
    6bee:	ldr.w	ip, [sp, #76]	; 0x4c
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
    return m_fFile ? m_fFile->getName(name, len) :
           m_xFile ? m_xFile->getName(name, len) : 0;
    6bf2:	mov	r0, ip
  bool isHidden() {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() {return m_fFile || m_xFile;}
    6bf4:	cmp.w	ip, #0
    6bf8:	beq.n	6c48 <MTPStorage_SD::ScanDir(unsigned long)+0x128>
    6bfa:	ldrb.w	lr, [ip, #49]	; 0x31
        mtp_lock_storage(false);

        if (!child) break;

        Record r;
        r.parent = i;
    6bfe:	str	r6, [sp, #184]	; 0xb8
    6c00:	and.w	lr, lr, #80	; 0x50
        r.sibling = sibling;
        r.isdir = child.isDirectory();
    6c04:	cmp.w	lr, #0
    6c08:	ldrd	r7, r8, [ip, #16]
    6c0c:	ite	ne
    6c0e:	movne.w	lr, #1
    6c12:	moveq.w	lr, #0
    6c16:	strb.w	lr, [sp, #196]	; 0xc4
        r.child = r.isdir ? 0 : 1;
    6c1a:	ite	eq
    6c1c:	moveq.w	lr, #1
    6c20:	movne.w	lr, #0
    6c24:	strd	r7, r8, [sp, #200]	; 0xc8

        if (!child) break;

        Record r;
        r.parent = i;
        r.sibling = sibling;
    6c28:	str.w	fp, [sp, #192]	; 0xc0
        r.isdir = child.isDirectory();
        r.child = r.isdir ? 0 : 1;
        r.scanned = false;
    6c2c:	strb.w	r3, [sp, #197]	; 0xc5

        Record r;
        r.parent = i;
        r.sibling = sibling;
        r.isdir = child.isDirectory();
        r.child = r.isdir ? 0 : 1;
    6c30:	str.w	lr, [sp, #188]	; 0xbc
   *             must be at least 13 bytes long.  The file's name will be
   *             truncated if the file's name is too long.
   * \return The length of the returned string.
   */
  size_t getName(char* name, size_t len) {
    *name = 0;
    6c34:	strb.w	r3, [sp, #208]	; 0xd0
    return m_fFile ? m_fFile->getName(name, len) :
           m_xFile ? m_xFile->getName(name, len) : 0;
    6c38:	bl	718 <ExFatFile::getName(char*, unsigned int)>
    6c3c:	b.n	6b9c <MTPStorage_SD::ScanDir(unsigned long)+0x7c>
  bool isHidden() {
    return m_fFile ? m_fFile->isHidden() :
           m_xFile ? m_xFile->isHidden() : false;
  }
  /** \return True if this is an open file/directory else false. */
  bool isOpen() {return m_fFile || m_xFile;}
    6c3e:	ldr.w	r3, [r5, #160]	; 0xa0
    6c42:	cmp	r3, #0
    6c44:	bne.n	6b56 <MTPStorage_SD::ScanDir(unsigned long)+0x36>
    6c46:	b.n	6b40 <MTPStorage_SD::ScanDir(unsigned long)+0x20>
 */
class FsBaseFile {
 public:
  FsBaseFile() : m_fFile(nullptr), m_xFile(nullptr) {}

  ~FsBaseFile() {close();}
    6c48:	add	r0, sp, #16
    6c4a:	str.w	sl, [sp]
    6c4e:	bl	4588 <FsBaseFile::close()>
        r.size=child.size();
        child.getName(r.name, 64);
        sibling = AppendIndexRecord(r);
        child.close();
      }
      record.scanned = true;
    6c52:	movs	r3, #1
      record.child = sibling; // this is the last object in directory
      WriteIndexRecord(i, record);
    6c54:	add	r2, sp, #80	; 0x50
    6c56:	mov	r1, r6
    6c58:	mov	r0, r5
        child.getName(r.name, 64);
        sibling = AppendIndexRecord(r);
        child.close();
      }
      record.scanned = true;
      record.child = sibling; // this is the last object in directory
    6c5a:	str.w	fp, [sp, #84]	; 0x54
        r.size=child.size();
        child.getName(r.name, 64);
        sibling = AppendIndexRecord(r);
        child.close();
      }
      record.scanned = true;
    6c5e:	strb.w	r3, [sp, #93]	; 0x5d
      record.child = sibling; // this is the last object in directory
      WriteIndexRecord(i, record);
    6c62:	bl	62c8 <MTPStorage_SD::WriteIndexRecord(unsigned long, Record const&)>
    6c66:	b.n	6b40 <MTPStorage_SD::ScanDir(unsigned long)+0x20>
    6c68:	.word	0x0000c240
    6c6c:	.word	0x0000c21c

00006c70 <MTPStorage_SD::ScanAll() [clone .part.45] [clone .constprop.58]>:
    }
  }

  void MTPStorage_SD::ScanAll() {
    6c70:	push	{r3, r4, r5, lr}

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex() {
    if (index_generated) return;
    6c72:	ldrb.w	r3, [r0, #176]	; 0xb0
    }
  }

  void MTPStorage_SD::ScanAll() {
    if (all_scanned_) return;
    all_scanned_ = true;
    6c76:	movs	r2, #1
      record.child = sibling; // this is the last object in directory
      WriteIndexRecord(i, record);
    }
  }

  void MTPStorage_SD::ScanAll() {
    6c78:	mov	r5, r0
    if (all_scanned_) return;
    all_scanned_ = true;
    6c7a:	strb.w	r2, [r0, #177]	; 0xb1

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex() {
    if (index_generated) return;
    6c7e:	cbz	r3, 6c9c <MTPStorage_SD::ScanAll() [clone .part.45] [clone .constprop.58]+0x2c>
  void MTPStorage_SD::ScanAll() {
    if (all_scanned_) return;
    all_scanned_ = true;

    GenerateIndex();
    for (uint32_t i = 0; i < index_entries_; i++) {
    6c80:	ldr.w	r3, [r5, #172]	; 0xac
    6c84:	cbz	r3, 6c9a <MTPStorage_SD::ScanAll() [clone .part.45] [clone .constprop.58]+0x2a>
    6c86:	movs	r4, #0
      ScanDir(i);
    6c88:	mov	r1, r4
    6c8a:	mov	r0, r5
    6c8c:	bl	6b20 <MTPStorage_SD::ScanDir(unsigned long)>
  void MTPStorage_SD::ScanAll() {
    if (all_scanned_) return;
    all_scanned_ = true;

    GenerateIndex();
    for (uint32_t i = 0; i < index_entries_; i++) {
    6c90:	ldr.w	r3, [r5, #172]	; 0xac
    6c94:	adds	r4, #1
    6c96:	cmp	r3, r4
    6c98:	bhi.n	6c88 <MTPStorage_SD::ScanAll() [clone .part.45] [clone .constprop.58]+0x18>
    6c9a:	pop	{r3, r4, r5, pc}
    6c9c:	bl	6330 <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]>
    6ca0:	b.n	6c80 <MTPStorage_SD::ScanAll() [clone .part.45] [clone .constprop.58]+0x10>
    6ca2:	nop

00006ca4 <MTPStorage_SD::StartGetObjectHandles(unsigned long)>:
      ScanDir(i);
    }
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t parent) {
    6ca4:	push	{r4, r5, lr}

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex() {
    if (index_generated) return;
    6ca6:	ldrb.w	r3, [r0, #176]	; 0xb0
    for (uint32_t i = 0; i < index_entries_; i++) {
      ScanDir(i);
    }
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t parent) {
    6caa:	sub	sp, #108	; 0x6c
    6cac:	mov	r4, r0
    6cae:	mov	r5, r1

  // MTP object handles should not change or be re-used during a session.
  // This would be easy if we could just have a list of all files in memory.
  // Since our RAM is limited, we'll keep the index in a file instead.
  void MTPStorage_SD::GenerateIndex() {
    if (index_generated) return;
    6cb0:	cbz	r3, 6cf2 <MTPStorage_SD::StartGetObjectHandles(unsigned long)+0x4e>
    }
  }

  void MTPStorage_SD::StartGetObjectHandles(uint32_t parent) {
    GenerateIndex();
    if (parent) {
    6cb2:	cbz	r5, 6cdc <MTPStorage_SD::StartGetObjectHandles(unsigned long)+0x38>
      if (parent == 0xFFFFFFFF) parent = 0;
    6cb4:	adds	r3, r5, #1
    6cb6:	it	eq
    6cb8:	moveq	r5, #0

      ScanDir(parent);
    6cba:	mov	r1, r5
    6cbc:	mov	r0, r4
    6cbe:	bl	6b20 <MTPStorage_SD::ScanDir(unsigned long)>
      follow_sibling_ = true;
    6cc2:	movs	r3, #1
    6cc4:	strb.w	r3, [r4, #184]	; 0xb8
      // Root folder?
      next_ = ReadIndexRecord(parent).child;
    6cc8:	mov	r2, r5
    6cca:	mov	r1, r4
    6ccc:	mov	r0, sp
    6cce:	bl	6420 <MTPStorage_SD::ReadIndexRecord(unsigned long)>
    6cd2:	ldr	r3, [sp, #4]
    6cd4:	str.w	r3, [r4, #180]	; 0xb4
    } else {
      ScanAll();
      follow_sibling_ = false;
      next_ = 1;
    }
  }
    6cd8:	add	sp, #108	; 0x6c
    6cda:	pop	{r4, r5, pc}
      WriteIndexRecord(i, record);
    }
  }

  void MTPStorage_SD::ScanAll() {
    if (all_scanned_) return;
    6cdc:	ldrb.w	r3, [r4, #177]	; 0xb1
    6ce0:	cbz	r3, 6cf8 <MTPStorage_SD::StartGetObjectHandles(unsigned long)+0x54>
      follow_sibling_ = true;
      // Root folder?
      next_ = ReadIndexRecord(parent).child;
    } else {
      ScanAll();
      follow_sibling_ = false;
    6ce2:	movs	r2, #0
      next_ = 1;
    6ce4:	movs	r3, #1
      follow_sibling_ = true;
      // Root folder?
      next_ = ReadIndexRecord(parent).child;
    } else {
      ScanAll();
      follow_sibling_ = false;
    6ce6:	strb.w	r2, [r4, #184]	; 0xb8
      next_ = 1;
    6cea:	str.w	r3, [r4, #180]	; 0xb4
    }
  }
    6cee:	add	sp, #108	; 0x6c
    6cf0:	pop	{r4, r5, pc}
    6cf2:	bl	6330 <MTPStorage_SD::GenerateIndex() [clone .part.42] [clone .constprop.60]>
    6cf6:	b.n	6cb2 <MTPStorage_SD::StartGetObjectHandles(unsigned long)+0xe>
    6cf8:	mov	r0, r4
    6cfa:	bl	6c70 <MTPStorage_SD::ScanAll() [clone .part.45] [clone .constprop.58]>
      follow_sibling_ = true;
      // Root folder?
      next_ = ReadIndexRecord(parent).child;
    } else {
      ScanAll();
      follow_sibling_ = false;
    6cfe:	movs	r2, #0
      next_ = 1;
    6d00:	movs	r3, #1
      follow_sibling_ = true;
      // Root folder?
      next_ = ReadIndexRecord(parent).child;
    } else {
      ScanAll();
      follow_sibling_ = false;
    6d02:	strb.w	r2, [r4, #184]	; 0xb8
      next_ = 1;
    6d06:	str.w	r3, [r4, #180]	; 0xb4
    6d0a:	b.n	6cee <MTPStorage_SD::StartGetObjectHandles(unsigned long)+0x4a>

00006d0c <SdBase<FsVolume>::errorHalt(Print*)>:
  //----------------------------------------------------------------------------
  /** %Print error info and halt.
   *
   * \param[in] pr Print destination.
   */
  void errorHalt(print_t* pr) {
    6d0c:	mov	r5, r0
    6d0e:	ldr.w	r0, [r0, #1156]	; 0x484
    6d12:	push	{r3, lr}
    6d14:	mov	r4, r1
    }
  }
  //----------------------------------------------------------------------------
  /** \return SD card error code. */
  uint8_t sdErrorCode() {
    if (m_card) {
    6d16:	cbz	r0, 6d48 <SdBase<FsVolume>::errorHalt(Print*)+0x3c>
      return m_card->errorCode();
    6d18:	ldr	r3, [r0, #0]
    6d1a:	ldr	r3, [r3, #36]	; 0x24
    6d1c:	blx	r3
  /** %Print error info and halt.
   *
   * \param[in] pr Print destination.
   */
  void errorHalt(print_t* pr) {
    if (sdErrorCode()) {
    6d1e:	cbnz	r0, 6d48 <SdBase<FsVolume>::errorHalt(Print*)+0x3c>
    6d20:	ldr.w	r3, [r5, #1144]	; 0x478
  /** \return Partition type, FAT_TYPE_EXFAT, FAT_TYPE_FAT32,
   *          FAT_TYPE_FAT16, or zero for error.
   */
  uint8_t fatType() const {
    return m_fVol ? m_fVol->fatType() :
           m_xVol ? m_xVol->fatType() : 0;
    6d24:	cbz	r3, 6d30 <SdBase<FsVolume>::errorHalt(Print*)+0x24>
    6d26:	ldrb	r3, [r3, #7]
      pr->print(F("SdError: 0X"));
      pr->print(sdErrorCode(), HEX);
      pr->print(F(",0X"));
      pr->println(sdErrorData(), HEX);
    } else if (!Vol::fatType()) {
    6d28:	cbz	r3, 6d3e <SdBase<FsVolume>::errorHalt(Print*)+0x32>
    6d2a:	bl	ac8c <yield>
    6d2e:	b.n	6d2a <SdBase<FsVolume>::errorHalt(Print*)+0x1e>
    6d30:	ldr.w	r3, [r5, #1148]	; 0x47c
    6d34:	cbz	r3, 6d3e <SdBase<FsVolume>::errorHalt(Print*)+0x32>
    6d36:	ldrb.w	r3, [r3, #1084]	; 0x43c
    6d3a:	cmp	r3, #0
    6d3c:	bne.n	6d2a <SdBase<FsVolume>::errorHalt(Print*)+0x1e>
      pr->println(F("Check SD format."));
    6d3e:	mov	r0, r4
    6d40:	ldr	r1, [pc, #84]	; (6d98 <SdBase<FsVolume>::errorHalt(Print*)+0x8c>)
    6d42:	bl	62a0 <Print::println(__FlashStringHelper const*)>
    6d46:	b.n	6d2a <SdBase<FsVolume>::errorHalt(Print*)+0x1e>
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }
    6d48:	ldr	r1, [pc, #80]	; (6d9c <SdBase<FsVolume>::errorHalt(Print*)+0x90>)
    6d4a:	mov	r0, r4
    6d4c:	bl	6ac <Print::write(char const*)>
    6d50:	ldr.w	r0, [r5, #1156]	; 0x484
    }
  }
  //----------------------------------------------------------------------------
  /** \return SD card error code. */
  uint8_t sdErrorCode() {
    if (m_card) {
    6d54:	cbz	r0, 6d94 <SdBase<FsVolume>::errorHalt(Print*)+0x88>
      return m_card->errorCode();
    6d56:	ldr	r3, [r0, #0]
    6d58:	ldr	r3, [r3, #36]	; 0x24
    6d5a:	blx	r3
    6d5c:	mov	r1, r0
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    6d5e:	movs	r3, #0
    6d60:	movs	r2, #16
    6d62:	mov	r0, r4
    6d64:	bl	ada0 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }
    6d68:	ldr	r1, [pc, #52]	; (6da0 <SdBase<FsVolume>::errorHalt(Print*)+0x94>)
    6d6a:	mov	r0, r4
    6d6c:	bl	6ac <Print::write(char const*)>
    6d70:	ldr.w	r0, [r5, #1156]	; 0x484
    }
    return SD_CARD_ERROR_INVALID_CARD_CONFIG;
  }
  //----------------------------------------------------------------------------
  /** \return SD card error data. */
  uint8_t sdErrorData() {return m_card ? m_card->errorData() : 0;}
    6d74:	cbz	r0, 6d90 <SdBase<FsVolume>::errorHalt(Print*)+0x84>
    6d76:	ldr	r3, [r0, #0]
    6d78:	ldr	r3, [r3, #40]	; 0x28
    6d7a:	blx	r3
    6d7c:	uxtb	r1, r0
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
    6d7e:	movs	r3, #0
    6d80:	movs	r2, #16
    6d82:	mov	r0, r4
    6d84:	bl	ada0 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(int n)				{ return print(n) + println(); }
	size_t println(unsigned int n)			{ return print(n) + println(); }
	size_t println(long n)				{ return print(n) + println(); }
	size_t println(unsigned long n)			{ return print(n) + println(); }

	size_t println(unsigned char n, int base)	{ return print(n, base) + println(); }
    6d88:	mov	r0, r4
    6d8a:	bl	ad80 <Print::println()>
    6d8e:	b.n	6d2a <SdBase<FsVolume>::errorHalt(Print*)+0x1e>
    6d90:	mov	r1, r0
    6d92:	b.n	6d7e <SdBase<FsVolume>::errorHalt(Print*)+0x72>
    }
  }
  //----------------------------------------------------------------------------
  /** \return SD card error code. */
  uint8_t sdErrorCode() {
    if (m_card) {
    6d94:	movs	r1, #41	; 0x29
    6d96:	b.n	6d5e <SdBase<FsVolume>::errorHalt(Print*)+0x52>
    6d98:	.word	0x0000c478
    6d9c:	.word	0x0000c468
    6da0:	.word	0x0000c474

00006da4 <MTPStorage_SD::init()>:
  // Return low time bits in units of 10 ms.
  *ms10 = second() & 1 ? 100 : 0;
}

  void MTPStorage_SD::init(void)
  { 
    6da4:	push	{r3, r4, r5, lr}
   * \param[in] config SDIO configuration.
   * \return generic card pointer or nullptr if SDIO is not supported.
   */
  SdCard* newCard(SdioConfig config) {
#if HAS_SDIO_CLASS
    m_sdioCard.begin(config);
    6da6:	ldr	r5, [pc, #72]	; (6df0 <MTPStorage_SD::init()+0x4c>)
    6da8:	add.w	r4, r5, #1160	; 0x488
    6dac:	mov	r0, r4
    6dae:	mov.w	r1, #0
    6db2:	bl	5a88 <SdioCard::begin(SdioConfig)>
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
    return m_card && !m_card->errorCode();
    6db6:	mov	r0, r4
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool cardBegin(SdioConfig sdioConfig) {
    m_card = m_cardFactory.newCard(sdioConfig);
    6db8:	str.w	r4, [r5, #1156]	; 0x484
    return m_card && !m_card->errorCode();
    6dbc:	bl	51e8 <SdioCard::errorCode() const>
    6dc0:	cbz	r0, 6dda <MTPStorage_SD::init()+0x36>
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }
    6dc2:	ldr	r1, [pc, #48]	; (6df4 <MTPStorage_SD::init()+0x50>)
    6dc4:	ldr	r0, [pc, #48]	; (6df8 <MTPStorage_SD::init()+0x54>)
    6dc6:	bl	6ac <Print::write(char const*)>
   * \param[in] pr Print destination.
   * \param[in] msg Message to print.
   */
  void errorHalt(print_t* pr, const char* msg) {
    pr->print(F("error: "));
    pr->println(msg);
    6dca:	ldr	r1, [pc, #48]	; (6dfc <MTPStorage_SD::init()+0x58>)
    6dcc:	ldr	r0, [pc, #40]	; (6df8 <MTPStorage_SD::init()+0x54>)
    6dce:	bl	62a0 <Print::println(__FlashStringHelper const*)>
    errorHalt(pr);
    6dd2:	ldr	r1, [pc, #36]	; (6df8 <MTPStorage_SD::init()+0x54>)
    6dd4:	ldr	r0, [pc, #24]	; (6df0 <MTPStorage_SD::init()+0x4c>)
    6dd6:	bl	6d0c <SdBase<FsVolume>::errorHalt(Print*)>
   *
   * \param[in] sdioConfig SDIO configuration.
   * \return true for success or false for failure.
   */
  bool begin(SdioConfig sdioConfig) {
    return cardBegin(sdioConfig) && Vol::begin(m_card);
    6dda:	ldr.w	r1, [r5, #1156]	; 0x484
    6dde:	mov	r0, r5
    6de0:	bl	470c <FsVolume::begin(BlockDeviceInterface*)>
    6de4:	cmp	r0, #0
    6de6:	beq.n	6dc2 <MTPStorage_SD::init()+0x1e>
      SPI.setSCK(SD_SCK);
    #endif
    if (!SD.begin(SD_CONFIG)) SD.errorHalt("SD.begin failed");
  
    // Set Time callback
    FsDateTime::callback = dateTime;
    6de8:	ldr	r3, [pc, #20]	; (6e00 <MTPStorage_SD::init()+0x5c>)
    6dea:	ldr	r2, [pc, #24]	; (6e04 <MTPStorage_SD::init()+0x60>)
    6dec:	str	r2, [r3, #0]
    6dee:	pop	{r3, r4, r5, pc}
    6df0:	.word	0x1fff1418
    6df4:	.word	0x0000c48c
    6df8:	.word	0x1fff099c
    6dfc:	.word	0x0000c494
    6e00:	.word	0x1fff13c8
    6e04:	.word	0x00006039

00006e08 <_GLOBAL__sub_I_SD>:
    WriteIndexRecord(handle, p1);
    WriteIndexRecord(newParent, p2);

    ConstructFilename(handle, newName);
    SD.rename(oldName,newName);
  }
    6e08:	push	{r4, r5, r6, r7}
 * \class FsVolume
 * \brief FsVolume class.
 */
class FsVolume {
 public:
  FsVolume() : m_fVol(nullptr), m_xVol(nullptr) {}
    6e0a:	ldr	r3, [pc, #56]	; (6e44 <_GLOBAL__sub_I_SD+0x3c>)
    6e0c:	ldr	r0, [pc, #56]	; (6e48 <_GLOBAL__sub_I_SD+0x40>)
#else  // HAS_SDIO_CLASS
class SdSpiCard {
#endif  // HAS_SDIO_CLASS
 public:
  /** Construct an instance of SdSpiCard. */
  SdSpiCard() : m_errorCode(SD_CARD_ERROR_INIT_NOT_CALLED), m_type(0) {}
    6e0e:	ldr	r7, [pc, #60]	; (6e4c <_GLOBAL__sub_I_SD+0x44>)
		}
		if (dataMode & 0x04) {
			c |= SPI_CTAR_CPHA;
			t = (t & 0xFFFF0FFF) | ((t & 0xF000) >> 4);
		}
		ctar = c | t;
    6e10:	ldr	r5, [pc, #60]	; (6e50 <_GLOBAL__sub_I_SD+0x48>)
    6e12:	str.w	r0, [r3, #1160]	; 0x488
    6e16:	movs	r4, #0
    6e18:	movs	r6, #40	; 0x28
    6e1a:	strb.w	r6, [r3, #1188]	; 0x4a4
 * \class SdioConfig
 * \brief SDIO card configuration.
 */
class SdioConfig {
 public:
  SdioConfig() : m_options(FIFO_SDIO) {}
    6e1e:	strb.w	r4, [r3, #1168]	; 0x490
    6e22:	strb.w	r4, [r3, #1191]	; 0x4a7
    6e26:	str.w	r7, [r3, #1172]	; 0x494
    6e2a:	str.w	r5, [r3, #1196]	; 0x4ac
    6e2e:	str.w	r4, [r3, #1144]	; 0x478
    6e32:	str.w	r4, [r3, #1148]	; 0x47c
#include "core_pins.h"
//#include "usb_dev.h"

#include "MTP_Storage.h"

SdFs SD;
    6e36:	ldr	r2, [pc, #28]	; (6e54 <_GLOBAL__sub_I_SD+0x4c>)
    6e38:	ldr	r1, [pc, #28]	; (6e58 <_GLOBAL__sub_I_SD+0x50>)
    6e3a:	mov	r0, r3
    WriteIndexRecord(handle, p1);
    WriteIndexRecord(newParent, p2);

    ConstructFilename(handle, newName);
    SD.rename(oldName,newName);
  }
    6e3c:	pop	{r4, r5, r6, r7}
#include "core_pins.h"
//#include "usb_dev.h"

#include "MTP_Storage.h"

SdFs SD;
    6e3e:	b.w	b514 <__aeabi_atexit>
    6e42:	nop
    6e44:	.word	0x1fff1418
    6e48:	.word	0x0000c3b8
    6e4c:	.word	0x0000c360
    6e50:	.word	0x38011001
    6e54:	.word	0x1fff0970
    6e58:	.word	0x00006035

00006e5c <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]>:

#else /******************************************************** Teensy 3 ********************************/

//#include "usb_dev.h"

  void MTPD::PrintPacket(const usb_packet_t *x) {
    6e5c:	push	{r4, r5, r6, lr}
    6e5e:	mov	r5, r0
	virtual size_t write(unsigned long n)   { return write((uint8_t)n); }
	virtual size_t write(long n)            { return write((uint8_t)n); }
	virtual size_t write(unsigned int n)    { return write((uint8_t)n); }
	virtual size_t write(int n)             { return write((uint8_t)n); }
	virtual size_t write(const uint8_t *buffer, size_t size)
					{ serial_write(buffer, size); return size; }
    6e60:	movs	r1, #7
    6e62:	ldr	r0, [pc, #152]	; (6efc <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0xa0>)
    6e64:	bl	95e4 <serial_write>

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    6e68:	movs	r3, #0
    6e6a:	movs	r2, #10
    6e6c:	ldr	r1, [r5, #8]
    6e6e:	ldr	r0, [pc, #144]	; (6f00 <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0xa4>)
    6e70:	bl	ada0 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    6e74:	movs	r1, #8
    6e76:	ldr	r0, [pc, #140]	; (6f04 <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0xa8>)
    6e78:	bl	95e4 <serial_write>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    6e7c:	ldrh	r1, [r5, #12]
    6e7e:	ldr	r0, [pc, #128]	; (6f00 <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0xa4>)
    6e80:	bl	ae20 <Print::print(long)>
    6e84:	movs	r1, #6
    6e86:	ldr	r0, [pc, #128]	; (6f08 <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0xac>)
    6e88:	bl	95e4 <serial_write>
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
    6e8c:	movs	r3, #0
    6e8e:	movs	r2, #16
    6e90:	ldrh	r1, [r5, #14]
    6e92:	ldr	r0, [pc, #108]	; (6f00 <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0xa4>)
    6e94:	bl	ada0 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    6e98:	movs	r1, #18
    6e9a:	ldr	r0, [pc, #112]	; (6f0c <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0xb0>)
    6e9c:	bl	95e4 <serial_write>

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
	size_t print(unsigned int n)			{ return printNumber(n, 10, 0); }
	size_t print(long n);
	size_t print(unsigned long n)			{ return printNumber(n, 10, 0); }
    6ea0:	movs	r3, #0
    6ea2:	ldr	r1, [r5, #16]
    6ea4:	ldr	r0, [pc, #88]	; (6f00 <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0xa4>)
    6ea6:	movs	r2, #10
    6ea8:	bl	ada0 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
        Serial1.print(tmp->type);
        Serial1.print(" op = ");
        Serial1.print(tmp->op, HEX);
        Serial1.print(" transaction_id = ");
        Serial1.print(tmp->transaction_id);
        for (int i = 0; i * 4 < x->len - 12; i ++) {
    6eac:	ldrh	r3, [r5, #0]
    6eae:	cmp	r3, #12
    6eb0:	ble.n	6eea <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0x8e>
    6eb2:	add.w	r6, r5, #16
    6eb6:	movs	r4, #0
    6eb8:	movs	r1, #2
    6eba:	ldr	r0, [pc, #84]	; (6f10 <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0xb4>)
    6ebc:	bl	95e4 <serial_write>
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    6ec0:	mov	r1, r4
    6ec2:	ldr	r0, [pc, #60]	; (6f00 <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0xa4>)
    6ec4:	bl	ae20 <Print::print(long)>
    6ec8:	movs	r1, #3
    6eca:	ldr	r0, [pc, #72]	; (6f14 <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0xb8>)
    6ecc:	bl	95e4 <serial_write>

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    6ed0:	movs	r3, #0
    6ed2:	movs	r2, #16
    6ed4:	ldr.w	r1, [r6, #4]!
    6ed8:	ldr	r0, [pc, #36]	; (6f00 <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0xa4>)
    6eda:	bl	ada0 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    6ede:	ldrh	r3, [r5, #0]
    6ee0:	adds	r4, #1
    6ee2:	subs	r3, #12
    6ee4:	cmp.w	r3, r4, lsl #2
    6ee8:	bgt.n	6eb8 <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0x5c>
    6eea:	ldr	r0, [pc, #44]	; (6f18 <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0xbc>)
    6eec:	movs	r1, #0
    6eee:	bl	95e4 <serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    6ef2:	ldr	r0, [pc, #12]	; (6f00 <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]+0xa4>)
          Serial1.print(tmp->params[i], HEX);
        }
        Serial1.println("");
      }
  #endif
    }
    6ef4:	ldmia.w	sp!, {r4, r5, r6, lr}
    6ef8:	b.w	ad80 <Print::println()>
    6efc:	.word	0x0000c4dc
    6f00:	.word	0x1fff098c
    6f04:	.word	0x0000c4e4
    6f08:	.word	0x0000c4f0
    6f0c:	.word	0x0000c4f8
    6f10:	.word	0x0000c50c
    6f14:	.word	0x0000c4e0
    6f18:	.word	0x0000c4ec

00006f1c <MTPD::get_buffer()>:

    void MTPD::get_buffer() {
    6f1c:	push	{r4, lr}
    6f1e:	mov	r4, r0
    6f20:	ldr	r0, [r4, #4]
      while (!data_buffer_) {
    6f22:	cbnz	r0, 6f2c <MTPD::get_buffer()+0x10>
        data_buffer_ = usb_malloc();
    6f24:	bl	9c54 <usb_malloc>
    6f28:	str	r0, [r4, #4]
        if (!data_buffer_) mtp_yield();
    6f2a:	cbz	r0, 6f2e <MTPD::get_buffer()+0x12>
    6f2c:	pop	{r4, pc}
    6f2e:	bl	62c4 <mtp_yield()>
    6f32:	b.n	6f20 <MTPD::get_buffer()+0x4>

00006f34 <MTPD::write(char const*, int) [clone .part.4]>:
    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
        write_length_ += len;
      } else {
        int pos = 0;
        while (pos < len) {
    6f34:	cmp	r2, #0
    6f36:	ble.n	6fa6 <MTPD::write(char const*, int) [clone .part.4]+0x72>
        data_buffer_ = usb_rx(MTP_RX_ENDPOINT);
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
    6f38:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
      if (write_get_length_) {
        write_length_ += len;
      } else {
        int pos = 0;
        while (pos < len) {
    6f3c:	mov.w	r9, #0
    6f40:	mov	r6, r2
    6f42:	mov	r7, r1
    6f44:	mov	r5, r0
          data_buffer_->len += to_copy;
          pos += to_copy;
          if (data_buffer_->len == sizeof(data_buffer_->buf)) {
            PrintPacket(data_buffer_);
            usb_tx(MTP_TX_ENDPOINT, data_buffer_);
            data_buffer_ = NULL;
    6f46:	mov	r8, r9
    6f48:	b.n	6f4e <MTPD::write(char const*, int) [clone .part.4]+0x1a>
    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
        write_length_ += len;
      } else {
        int pos = 0;
        while (pos < len) {
    6f4a:	cmp	r6, r9
    6f4c:	ble.n	6f98 <MTPD::write(char const*, int) [clone .part.4]+0x64>
          get_buffer();
    6f4e:	mov	r0, r5
    6f50:	bl	6f1c <MTPD::get_buffer()>
          int avail = sizeof(data_buffer_->buf) - data_buffer_->len;
    6f54:	ldr	r3, [r5, #4]
    6f56:	ldrh.w	r0, [r3], #8
    6f5a:	rsb	r2, r9, r6
    6f5e:	rsb	r4, r0, #64	; 0x40
    6f62:	cmp	r4, r2
    6f64:	it	ge
    6f66:	movge	r4, r2
          int to_copy = min(len - pos, avail);
          memcpy(data_buffer_->buf + data_buffer_->len,
                data + pos,
                to_copy);
    6f68:	add.w	r1, r7, r9
    6f6c:	add	r0, r3
    6f6e:	mov	r2, r4
    6f70:	bl	8c24 <memcpy>
          data_buffer_->len += to_copy;
    6f74:	ldr	r1, [r5, #4]
    6f76:	ldrh	r3, [r1, #0]
    6f78:	add	r3, r4
    6f7a:	uxth	r3, r3
          pos += to_copy;
          if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    6f7c:	cmp	r3, #64	; 0x40
          int to_copy = min(len - pos, avail);
          memcpy(data_buffer_->buf + data_buffer_->len,
                data + pos,
                to_copy);
          data_buffer_->len += to_copy;
          pos += to_copy;
    6f7e:	add	r9, r4
          int avail = sizeof(data_buffer_->buf) - data_buffer_->len;
          int to_copy = min(len - pos, avail);
          memcpy(data_buffer_->buf + data_buffer_->len,
                data + pos,
                to_copy);
          data_buffer_->len += to_copy;
    6f80:	strh	r3, [r1, #0]
          pos += to_copy;
          if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    6f82:	bne.n	6f4a <MTPD::write(char const*, int) [clone .part.4]+0x16>
      }
      Serial1.println("");
  #endif
  #if 1
      MTPContainer *tmp = (struct MTPContainer*)(x->buf);
      if(tmp->type==1)
    6f84:	ldrh	r3, [r1, #12]
    6f86:	cmp	r3, #1
    6f88:	beq.n	6f9c <MTPD::write(char const*, int) [clone .part.4]+0x68>
                to_copy);
          data_buffer_->len += to_copy;
          pos += to_copy;
          if (data_buffer_->len == sizeof(data_buffer_->buf)) {
            PrintPacket(data_buffer_);
            usb_tx(MTP_TX_ENDPOINT, data_buffer_);
    6f8a:	movs	r0, #4
    6f8c:	bl	9e50 <usb_tx>
    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
        write_length_ += len;
      } else {
        int pos = 0;
        while (pos < len) {
    6f90:	cmp	r6, r9
          data_buffer_->len += to_copy;
          pos += to_copy;
          if (data_buffer_->len == sizeof(data_buffer_->buf)) {
            PrintPacket(data_buffer_);
            usb_tx(MTP_TX_ENDPOINT, data_buffer_);
            data_buffer_ = NULL;
    6f92:	str.w	r8, [r5, #4]
    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
        write_length_ += len;
      } else {
        int pos = 0;
        while (pos < len) {
    6f96:	bgt.n	6f4e <MTPD::write(char const*, int) [clone .part.4]+0x1a>
    6f98:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6f9c:	mov	r0, r1
    6f9e:	bl	6e5c <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]>
    6fa2:	ldr	r1, [r5, #4]
    6fa4:	b.n	6f8a <MTPD::write(char const*, int) [clone .part.4]+0x56>
    6fa6:	bx	lr

00006fa8 <MTPD::writestring(char const*)>:
    void MTPD::write8 (uint8_t  x) { write((char*)&x, sizeof(x)); }
    void MTPD::write16(uint16_t x) { write((char*)&x, sizeof(x)); }
    void MTPD::write32(uint32_t x) { write((char*)&x, sizeof(x)); }
    void MTPD::write64(uint64_t x) { write((char*)&x, sizeof(x)); }

    void MTPD::writestring(const char* str) {
    6fa8:	push	{r4, r5, lr}
      if (*str) 
    6faa:	ldrb	r3, [r1, #0]
    void MTPD::write8 (uint8_t  x) { write((char*)&x, sizeof(x)); }
    void MTPD::write16(uint16_t x) { write((char*)&x, sizeof(x)); }
    void MTPD::write32(uint32_t x) { write((char*)&x, sizeof(x)); }
    void MTPD::write64(uint64_t x) { write((char*)&x, sizeof(x)); }

    void MTPD::writestring(const char* str) {
    6fac:	sub	sp, #12
    6fae:	mov	r4, r0
      if (*str) 
    6fb0:	cbz	r3, 700c <MTPD::writestring(char const*)+0x64>
      { write8(strlen(str) + 1);
    6fb2:	mov	r0, r1
    6fb4:	mov	r5, r1
    6fb6:	bl	bd40 <strlen>
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    6fba:	ldrb	r1, [r4, #8]
    6fbc:	adds	r0, #1
    6fbe:	strb.w	r0, [sp, #3]
    6fc2:	cbz	r1, 701e <MTPD::writestring(char const*)+0x76>
        write_length_ += len;
    6fc4:	ldr	r3, [r4, #12]
    6fc6:	adds	r3, #1
    6fc8:	str	r3, [r4, #12]
    void MTPD::write64(uint64_t x) { write((char*)&x, sizeof(x)); }

    void MTPD::writestring(const char* str) {
      if (*str) 
      { write8(strlen(str) + 1);
        while (*str) {  write16(*str);  ++str;  } write16(0);
    6fca:	ldrb	r2, [r5, #0]
    6fcc:	cbnz	r2, 6fdc <MTPD::writestring(char const*)+0x34>
    6fce:	b.n	7004 <MTPD::writestring(char const*)+0x5c>
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
        write_length_ += len;
    6fd0:	ldr	r3, [r4, #12]
    6fd2:	adds	r3, #2
    6fd4:	str	r3, [r4, #12]
    void MTPD::write64(uint64_t x) { write((char*)&x, sizeof(x)); }

    void MTPD::writestring(const char* str) {
      if (*str) 
      { write8(strlen(str) + 1);
        while (*str) {  write16(*str);  ++str;  } write16(0);
    6fd6:	ldrb.w	r2, [r5, #1]!
    6fda:	cbz	r2, 6ffa <MTPD::writestring(char const*)+0x52>
    6fdc:	strh.w	r2, [sp, #6]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    6fe0:	cmp	r1, #0
    6fe2:	bne.n	6fd0 <MTPD::writestring(char const*)+0x28>
    6fe4:	movs	r2, #2
    6fe6:	add.w	r1, sp, #6
    6fea:	mov	r0, r4
    6fec:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    void MTPD::write64(uint64_t x) { write((char*)&x, sizeof(x)); }

    void MTPD::writestring(const char* str) {
      if (*str) 
      { write8(strlen(str) + 1);
        while (*str) {  write16(*str);  ++str;  } write16(0);
    6ff0:	ldrb.w	r2, [r5, #1]!
    6ff4:	ldrb	r1, [r4, #8]
    6ff6:	cmp	r2, #0
    6ff8:	bne.n	6fdc <MTPD::writestring(char const*)+0x34>
    6ffa:	movs	r3, #0
    6ffc:	strh.w	r3, [sp, #4]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7000:	cbz	r1, 7042 <MTPD::writestring(char const*)+0x9a>
    7002:	ldr	r3, [r4, #12]
        write_length_ += len;
    7004:	adds	r3, #2
    7006:	str	r3, [r4, #12]
      { write8(strlen(str) + 1);
        while (*str) {  write16(*str);  ++str;  } write16(0);
      } else 
      { write8(0);
      }
    }
    7008:	add	sp, #12
    700a:	pop	{r4, r5, pc}
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    700c:	ldrb	r2, [r0, #8]
    700e:	strb.w	r3, [sp, #2]
    7012:	cbz	r2, 7034 <MTPD::writestring(char const*)+0x8c>
        write_length_ += len;
    7014:	ldr	r3, [r0, #12]
    7016:	adds	r3, #1
    7018:	str	r3, [r0, #12]
      { write8(strlen(str) + 1);
        while (*str) {  write16(*str);  ++str;  } write16(0);
      } else 
      { write8(0);
      }
    }
    701a:	add	sp, #12
    701c:	pop	{r4, r5, pc}
    701e:	movs	r2, #1
    7020:	add.w	r1, sp, #3
    7024:	mov	r0, r4
    7026:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    void MTPD::write64(uint64_t x) { write((char*)&x, sizeof(x)); }

    void MTPD::writestring(const char* str) {
      if (*str) 
      { write8(strlen(str) + 1);
        while (*str) {  write16(*str);  ++str;  } write16(0);
    702a:	ldrb	r2, [r5, #0]
    702c:	ldrb	r1, [r4, #8]
    702e:	cmp	r2, #0
    7030:	bne.n	6fdc <MTPD::writestring(char const*)+0x34>
    7032:	b.n	6ffa <MTPD::writestring(char const*)+0x52>
    7034:	movs	r2, #1
    7036:	add.w	r1, sp, #2
    703a:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
      } else 
      { write8(0);
      }
    }
    703e:	add	sp, #12
    7040:	pop	{r4, r5, pc}
    7042:	mov	r0, r4
    7044:	movs	r2, #2
    7046:	add	r1, sp, #4
    7048:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    704c:	add	sp, #12
    704e:	pop	{r4, r5, pc}

00007050 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]>:
          writestring("Teensy");
          break;
      }
    }

    void MTPD::GetDevicePropDesc(uint32_t prop) {
    7050:	push	{r4, r5, r6, lr}
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7052:	ldrb	r3, [r0, #8]
          writestring("Teensy");
          break;
      }
    }

    void MTPD::GetDevicePropDesc(uint32_t prop) {
    7054:	sub	sp, #8
    7056:	mov	r4, r0
    7058:	mov	r5, r1
    705a:	strh.w	r1, [sp, #4]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    705e:	cbz	r3, 7098 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]+0x48>
        write_length_ += len;
    7060:	ldr	r3, [r0, #12]
    7062:	movw	r2, #65535	; 0xffff
    7066:	adds	r3, #2
    7068:	str	r3, [r0, #12]
    706a:	strh.w	r2, [sp, #6]
    706e:	adds	r3, #2
    7070:	movs	r2, #0
    7072:	str	r3, [r4, #12]
    7074:	strb.w	r2, [sp, #2]
    7078:	adds	r3, #1
    707a:	str	r3, [r4, #12]
      writestring("1.0");      // version
      writestring("???");      // serial
    }

    void MTPD::GetDevicePropValue(uint32_t prop) {
      switch (prop) {
    707c:	movw	r3, #54274	; 0xd402
    7080:	cmp	r5, r3
    7082:	beq.n	70d4 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]+0x84>
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7084:	ldrb	r3, [r4, #8]
    7086:	movs	r2, #0
    7088:	strb.w	r2, [sp, #3]
    708c:	cbz	r3, 70f0 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]+0xa0>
        write_length_ += len;
    708e:	ldr	r3, [r4, #12]
    7090:	adds	r3, #1
    7092:	str	r3, [r4, #12]
          write8(0);       // read-only
          GetDevicePropValue(prop);
          GetDevicePropValue(prop);
          write8(0);       // no form
      }
    }
    7094:	add	sp, #8
    7096:	pop	{r4, r5, r6, pc}
    7098:	movs	r2, #2
    709a:	add	r1, sp, #4
    709c:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    70a0:	ldrb	r6, [r4, #8]
    70a2:	movw	r3, #65535	; 0xffff
    70a6:	strh.w	r3, [sp, #6]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    70aa:	cbnz	r6, 7100 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]+0xb0>
    70ac:	movs	r2, #2
    70ae:	add.w	r1, sp, #6
    70b2:	mov	r0, r4
    70b4:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    70b8:	ldrb	r3, [r4, #8]
    70ba:	strb.w	r6, [sp, #2]
    70be:	cbnz	r3, 7104 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]+0xb4>
    70c0:	movs	r2, #1
    70c2:	add.w	r1, sp, #2
    70c6:	mov	r0, r4
    70c8:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
      writestring("1.0");      // version
      writestring("???");      // serial
    }

    void MTPD::GetDevicePropValue(uint32_t prop) {
      switch (prop) {
    70cc:	movw	r3, #54274	; 0xd402
    70d0:	cmp	r5, r3
    70d2:	bne.n	7084 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]+0x34>
        case 0xd402: // friendly name
          // This is the name we'll actually see in the windows explorer.
          // Should probably be configurable.
          writestring("Teensy");
    70d4:	ldr	r1, [pc, #48]	; (7108 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]+0xb8>)
    70d6:	mov	r0, r4
    70d8:	bl	6fa8 <MTPD::writestring(char const*)>
    70dc:	ldr	r1, [pc, #40]	; (7108 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]+0xb8>)
    70de:	mov	r0, r4
    70e0:	bl	6fa8 <MTPD::writestring(char const*)>
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    70e4:	ldrb	r3, [r4, #8]
    70e6:	movs	r2, #0
    70e8:	strb.w	r2, [sp, #3]
    70ec:	cmp	r3, #0
    70ee:	bne.n	708e <MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]+0x3e>
    70f0:	mov	r0, r4
    70f2:	movs	r2, #1
    70f4:	add.w	r1, sp, #3
    70f8:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
          write8(0);       // read-only
          GetDevicePropValue(prop);
          GetDevicePropValue(prop);
          write8(0);       // no form
      }
    }
    70fc:	add	sp, #8
    70fe:	pop	{r4, r5, r6, pc}
    7100:	ldr	r3, [r4, #12]
    7102:	b.n	706e <MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]+0x1e>
    7104:	ldr	r3, [r4, #12]
    7106:	b.n	7078 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]+0x28>
    7108:	.word	0x0000c510

0000710c <MTPD::WriteDescriptor()>:
    //MTP_OPERATION_END_EDIT_OBJECT                         //0x95C5
  };
  const int supported_op_size=sizeof(supported_op);
  const int supported_op_num = supported_op_size/sizeof(supported_op[0]);

    void MTPD::WriteDescriptor() {
    710c:	push	{r4, r5, r6, r7, lr}
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    710e:	ldrb	r3, [r0, #8]
    //MTP_OPERATION_END_EDIT_OBJECT                         //0x95C5
  };
  const int supported_op_size=sizeof(supported_op);
  const int supported_op_num = supported_op_size/sizeof(supported_op[0]);

    void MTPD::WriteDescriptor() {
    7110:	sub	sp, #44	; 0x2c
    7112:	movs	r5, #100	; 0x64
    7114:	mov	r4, r0
    7116:	strh.w	r5, [sp, #6]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    711a:	cmp	r3, #0
    711c:	beq.n	71fe <MTPD::WriteDescriptor()+0xf2>
        write_length_ += len;
    711e:	ldr	r3, [r0, #12]
    7120:	movs	r2, #6
    7122:	adds	r3, #2
    7124:	str	r3, [r0, #12]
    7126:	str	r2, [sp, #20]
    7128:	adds	r3, #4
    712a:	movs	r2, #100	; 0x64
    712c:	str	r3, [r4, #12]
    712e:	strh.w	r2, [sp, #4]
    7132:	adds	r3, #2
    7134:	str	r3, [r4, #12]

    void MTPD::WriteDescriptor() {
      write16(100);  // MTP version
      write32(6);    // MTP extension
      write16(100);  // MTP version
      writestring("microsoft.com: 1.0;");
    7136:	ldr	r1, [pc, #464]	; (7308 <MTPD::WriteDescriptor()+0x1fc>)
    7138:	mov	r0, r4
    713a:	bl	6fa8 <MTPD::writestring(char const*)>
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    713e:	ldrb	r3, [r4, #8]
    7140:	movs	r2, #0
    7142:	strh.w	r2, [sp, #2]
    7146:	cmp	r3, #0
    7148:	beq.w	72c0 <MTPD::WriteDescriptor()+0x1b4>
        write_length_ += len;
    714c:	ldr	r3, [r4, #12]
    714e:	movs	r2, #18
    7150:	adds	r3, #2
    7152:	str	r3, [r4, #12]
    7154:	str	r2, [sp, #16]
    7156:	adds	r3, #4
    7158:	str	r3, [r4, #12]
    715a:	movs	r6, #1
    715c:	ldr	r5, [pc, #428]	; (730c <MTPD::WriteDescriptor()+0x200>)
    715e:	movw	r3, #4097	; 0x1001
    7162:	add.w	r7, r5, #34	; 0x22
    7166:	b.n	7178 <MTPD::WriteDescriptor()+0x6c>
    7168:	ldr	r3, [r4, #12]
      writestring("microsoft.com: 1.0;");
      write16(0);    // functional mode

      // Supported operations (array of uint16)
      write32(supported_op_num);
      for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    716a:	cmp	r7, r5
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
        write_length_ += len;
    716c:	add.w	r3, r3, #2
    7170:	str	r3, [r4, #12]
      writestring("microsoft.com: 1.0;");
      write16(0);    // functional mode

      // Supported operations (array of uint16)
      write32(supported_op_num);
      for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    7172:	beq.n	7190 <MTPD::WriteDescriptor()+0x84>
    7174:	ldrh.w	r3, [r5, #2]!
    7178:	strh.w	r3, [sp, #8]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    717c:	cmp	r6, #0
    717e:	bne.n	7168 <MTPD::WriteDescriptor()+0x5c>
    7180:	movs	r2, #2
    7182:	add	r1, sp, #8
    7184:	mov	r0, r4
    7186:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
      writestring("microsoft.com: 1.0;");
      write16(0);    // functional mode

      // Supported operations (array of uint16)
      write32(supported_op_num);
      for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
    718a:	cmp	r7, r5
    718c:	ldrb	r6, [r4, #8]
    718e:	bne.n	7174 <MTPD::WriteDescriptor()+0x68>
    7190:	movs	r3, #0
    7192:	str	r3, [sp, #36]	; 0x24
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7194:	cmp	r6, #0
    7196:	beq.n	7232 <MTPD::WriteDescriptor()+0x126>
        write_length_ += len;
    7198:	ldr	r3, [r4, #12]
    719a:	movs	r2, #1
    719c:	adds	r3, #4
    719e:	str	r3, [r4, #12]
    71a0:	str	r2, [sp, #32]
    71a2:	adds	r3, #4
    71a4:	movw	r2, #54274	; 0xd402
    71a8:	str	r3, [r4, #12]
    71aa:	strh.w	r2, [sp, #14]
    71ae:	adds	r3, #2
    71b0:	movs	r2, #0
    71b2:	str	r3, [r4, #12]
    71b4:	str	r2, [sp, #28]
    71b6:	adds	r3, #4
    71b8:	movs	r2, #2
    71ba:	str	r3, [r4, #12]
    71bc:	str	r2, [sp, #24]
    71be:	adds	r3, #4
    71c0:	mov.w	r2, #12288	; 0x3000
    71c4:	str	r3, [r4, #12]
    71c6:	strh.w	r2, [sp, #12]
    71ca:	adds	r3, #2
    71cc:	movw	r2, #12289	; 0x3001
    71d0:	str	r3, [r4, #12]
    71d2:	strh.w	r2, [sp, #10]
    71d6:	adds	r3, #2
    71d8:	str	r3, [r4, #12]

      write32(2);       // Playback formats (array of uint16)
      write16(0x3000);  // Undefined format
      write16(0x3001);  // Folders (associations)

      writestring("PJRC");     // Manufacturer
    71da:	mov	r0, r4
    71dc:	ldr	r1, [pc, #304]	; (7310 <MTPD::WriteDescriptor()+0x204>)
    71de:	bl	6fa8 <MTPD::writestring(char const*)>
      writestring("Teensy");   // Model
    71e2:	mov	r0, r4
    71e4:	ldr	r1, [pc, #300]	; (7314 <MTPD::WriteDescriptor()+0x208>)
    71e6:	bl	6fa8 <MTPD::writestring(char const*)>
      writestring("1.0");      // version
    71ea:	mov	r0, r4
    71ec:	ldr	r1, [pc, #296]	; (7318 <MTPD::WriteDescriptor()+0x20c>)
    71ee:	bl	6fa8 <MTPD::writestring(char const*)>
      writestring("???");      // serial
    71f2:	mov	r0, r4
    71f4:	ldr	r1, [pc, #292]	; (731c <MTPD::WriteDescriptor()+0x210>)
    71f6:	bl	6fa8 <MTPD::writestring(char const*)>
    }
    71fa:	add	sp, #44	; 0x2c
    71fc:	pop	{r4, r5, r6, r7, pc}
    71fe:	movs	r2, #2
    7200:	add.w	r1, sp, #6
    7204:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7208:	ldrb	r3, [r4, #8]
    720a:	movs	r2, #6
    720c:	str	r2, [sp, #20]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    720e:	cmp	r3, #0
    7210:	bne.n	72ee <MTPD::WriteDescriptor()+0x1e2>
    7212:	movs	r2, #4
    7214:	add	r1, sp, #20
    7216:	mov	r0, r4
    7218:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    721c:	ldrb	r3, [r4, #8]
    721e:	strh.w	r5, [sp, #4]
    7222:	cmp	r3, #0
    7224:	bne.n	72f2 <MTPD::WriteDescriptor()+0x1e6>
    7226:	movs	r2, #2
    7228:	add	r1, sp, #4
    722a:	mov	r0, r4
    722c:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7230:	b.n	7136 <MTPD::WriteDescriptor()+0x2a>
    7232:	movs	r2, #4
    7234:	add	r1, sp, #36	; 0x24
    7236:	mov	r0, r4
    7238:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    723c:	ldrb	r3, [r4, #8]
    723e:	movs	r2, #1
    7240:	str	r2, [sp, #32]
    7242:	cmp	r3, #0
    7244:	bne.n	72f6 <MTPD::WriteDescriptor()+0x1ea>
    7246:	movs	r2, #4
    7248:	add	r1, sp, #32
    724a:	mov	r0, r4
    724c:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7250:	ldrb	r3, [r4, #8]
    7252:	movw	r2, #54274	; 0xd402
    7256:	strh.w	r2, [sp, #14]
    725a:	cmp	r3, #0
    725c:	bne.n	72fa <MTPD::WriteDescriptor()+0x1ee>
    725e:	movs	r2, #2
    7260:	add.w	r1, sp, #14
    7264:	mov	r0, r4
    7266:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    726a:	ldrb	r3, [r4, #8]
    726c:	str	r6, [sp, #28]
    726e:	cmp	r3, #0
    7270:	bne.n	72fe <MTPD::WriteDescriptor()+0x1f2>
    7272:	movs	r2, #4
    7274:	add	r1, sp, #28
    7276:	mov	r0, r4
    7278:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    727c:	ldrb	r3, [r4, #8]
    727e:	movs	r5, #2
    7280:	str	r5, [sp, #24]
    7282:	cmp	r3, #0
    7284:	bne.n	7302 <MTPD::WriteDescriptor()+0x1f6>
    7286:	movs	r2, #4
    7288:	add	r1, sp, #24
    728a:	mov	r0, r4
    728c:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7290:	ldrb	r3, [r4, #8]
    7292:	mov.w	r2, #12288	; 0x3000
    7296:	strh.w	r2, [sp, #12]
    729a:	cbnz	r3, 72e6 <MTPD::WriteDescriptor()+0x1da>
    729c:	mov	r2, r5
    729e:	add	r1, sp, #12
    72a0:	mov	r0, r4
    72a2:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    72a6:	ldrb	r3, [r4, #8]
    72a8:	movw	r2, #12289	; 0x3001
    72ac:	strh.w	r2, [sp, #10]
    72b0:	cbnz	r3, 72e2 <MTPD::WriteDescriptor()+0x1d6>
    72b2:	mov	r2, r5
    72b4:	add.w	r1, sp, #10
    72b8:	mov	r0, r4
    72ba:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    72be:	b.n	71da <MTPD::WriteDescriptor()+0xce>
    72c0:	movs	r2, #2
    72c2:	add.w	r1, sp, r2
    72c6:	mov	r0, r4
    72c8:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    72cc:	ldrb	r3, [r4, #8]
    72ce:	movs	r2, #18
    72d0:	str	r2, [sp, #16]
    72d2:	cbnz	r3, 72ea <MTPD::WriteDescriptor()+0x1de>
    72d4:	movs	r2, #4
    72d6:	add	r1, sp, #16
    72d8:	mov	r0, r4
    72da:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    72de:	ldrb	r6, [r4, #8]
    72e0:	b.n	715c <MTPD::WriteDescriptor()+0x50>
    72e2:	ldr	r3, [r4, #12]
    72e4:	b.n	71d6 <MTPD::WriteDescriptor()+0xca>
    72e6:	ldr	r3, [r4, #12]
    72e8:	b.n	71ca <MTPD::WriteDescriptor()+0xbe>
    72ea:	ldr	r3, [r4, #12]
    72ec:	b.n	7156 <MTPD::WriteDescriptor()+0x4a>
    72ee:	ldr	r3, [r4, #12]
    72f0:	b.n	7128 <MTPD::WriteDescriptor()+0x1c>
    72f2:	ldr	r3, [r4, #12]
    72f4:	b.n	7132 <MTPD::WriteDescriptor()+0x26>
    72f6:	ldr	r3, [r4, #12]
    72f8:	b.n	71a2 <MTPD::WriteDescriptor()+0x96>
    72fa:	ldr	r3, [r4, #12]
    72fc:	b.n	71ae <MTPD::WriteDescriptor()+0xa2>
    72fe:	ldr	r3, [r4, #12]
    7300:	b.n	71b6 <MTPD::WriteDescriptor()+0xaa>
    7302:	ldr	r3, [r4, #12]
    7304:	b.n	71be <MTPD::WriteDescriptor()+0xb2>
    7306:	nop
    7308:	.word	0x0000c518
    730c:	.word	0x0000c4a4
    7310:	.word	0x0000c52c
    7314:	.word	0x0000c510
    7318:	.word	0x0000c534
    731c:	.word	0x0000c538

00007320 <MTPD::WriteStorageIDs()>:
          GetDevicePropValue(prop);
          write8(0);       // no form
      }
    }

    void MTPD::WriteStorageIDs() {
    7320:	push	{r4, r5, lr}
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7322:	ldrb	r3, [r0, #8]
          GetDevicePropValue(prop);
          write8(0);       // no form
      }
    }

    void MTPD::WriteStorageIDs() {
    7324:	sub	sp, #12
    7326:	movs	r5, #1
    7328:	mov	r4, r0
    732a:	str	r5, [sp, #4]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    732c:	cbz	r3, 733c <MTPD::WriteStorageIDs()+0x1c>
        write_length_ += len;
    732e:	ldr	r3, [r0, #12]
    7330:	adds	r3, #4
    7332:	str	r3, [r0, #12]
    7334:	adds	r3, #4
    7336:	str	r3, [r4, #12]
    }

    void MTPD::WriteStorageIDs() {
      write32(1); // 1 entry
      write32(1); // 1 storage
    }
    7338:	add	sp, #12
    733a:	pop	{r4, r5, pc}
    733c:	movs	r2, #4
    733e:	add.w	r1, sp, r2
    7342:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7346:	ldrb	r3, [r4, #8]
    7348:	str	r5, [sp, #0]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    734a:	cbnz	r3, 735a <MTPD::WriteStorageIDs()+0x3a>
    734c:	mov	r0, r4
    734e:	movs	r2, #4
    7350:	mov	r1, sp
    7352:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    }

    void MTPD::WriteStorageIDs() {
      write32(1); // 1 entry
      write32(1); // 1 storage
    }
    7356:	add	sp, #12
    7358:	pop	{r4, r5, pc}
    735a:	ldr	r3, [r4, #12]
    735c:	b.n	7334 <MTPD::WriteStorageIDs()+0x14>
    735e:	nop

00007360 <MTPD::GetObjectHandles(unsigned long, unsigned long)>:
      while (storage_->GetNextObjectHandle()) num++;
      return num;
    }

    void MTPD::GetObjectHandles(uint32_t storage, uint32_t parent) 
    {
    7360:	push	{r4, r5, r6, lr}
      uint32_t num = 0;
      if (!write_get_length_) {
    7362:	ldrb	r5, [r0, #8]
      while (storage_->GetNextObjectHandle()) num++;
      return num;
    }

    void MTPD::GetObjectHandles(uint32_t storage, uint32_t parent) 
    {
    7364:	sub	sp, #8
    7366:	mov	r4, r0
    7368:	mov	r6, r2
      uint32_t num = 0;
      if (!write_get_length_) {
    736a:	cbz	r5, 73aa <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x4a>
    736c:	movs	r3, #0
    736e:	str	r3, [sp, #0]
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
        write_length_ += len;
    7370:	ldr	r3, [r4, #12]
    7372:	adds	r3, #4
    7374:	str	r3, [r4, #12]
      if (!write_get_length_) {
        num = GetNumObjects(storage, parent);
      }
      write32(num);
      int handle;
      storage_->StartGetObjectHandles(parent);
    7376:	ldr	r0, [r4, #0]
    7378:	ldr	r3, [r0, #0]
    737a:	mov	r1, r6
    737c:	ldr	r3, [r3, #16]
    737e:	blx	r3
      while ((handle = storage_->GetNextObjectHandle()))
    7380:	ldr	r0, [r4, #0]
    7382:	ldr	r3, [r0, #0]
    7384:	ldr	r3, [r3, #20]
    7386:	blx	r3
    7388:	cbz	r0, 73a6 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x46>
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    738a:	ldrb	r3, [r4, #8]
    738c:	str	r0, [sp, #4]
    738e:	cbz	r3, 7398 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x38>
        write_length_ += len;
    7390:	ldr	r3, [r4, #12]
    7392:	adds	r3, #4
    7394:	str	r3, [r4, #12]
    7396:	b.n	7380 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x20>
    7398:	movs	r2, #4
    739a:	add.w	r1, sp, r2
    739e:	mov	r0, r4
    73a0:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    73a4:	b.n	7380 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x20>
      write32(num);
      int handle;
      storage_->StartGetObjectHandles(parent);
      while ((handle = storage_->GetNextObjectHandle()))
        write32(handle);
    }
    73a6:	add	sp, #8
    73a8:	pop	{r4, r5, r6, pc}
      writestring("");  // volume identifier
    }

    uint32_t MTPD::GetNumObjects(uint32_t storage, uint32_t parent) 
    {
      storage_->StartGetObjectHandles(parent);
    73aa:	ldr	r0, [r0, #0]
    73ac:	ldr	r3, [r0, #0]
    73ae:	mov	r1, r2
    73b0:	ldr	r3, [r3, #16]
    73b2:	blx	r3
    73b4:	b.n	73b8 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x58>
      int num = 0;
      while (storage_->GetNextObjectHandle()) num++;
    73b6:	adds	r5, #1
    73b8:	ldr	r0, [r4, #0]
    73ba:	ldr	r3, [r0, #0]
    73bc:	ldr	r3, [r3, #20]
    73be:	blx	r3
    73c0:	cmp	r0, #0
    73c2:	bne.n	73b6 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x56>
    73c4:	ldrb	r3, [r4, #8]
    73c6:	str	r5, [sp, #0]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    73c8:	cmp	r3, #0
    73ca:	bne.n	7370 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x10>
    73cc:	movs	r2, #4
    73ce:	mov	r1, sp
    73d0:	mov	r0, r4
    73d2:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    73d6:	b.n	7376 <MTPD::GetObjectHandles(unsigned long, unsigned long)+0x16>

000073d8 <MTPD::GetObjectInfo(unsigned long)>:
      while ((handle = storage_->GetNextObjectHandle()))
        write32(handle);
    }

    void MTPD::GetObjectInfo(uint32_t handle) 
    {
    73d8:	push	{r4, r5, r6, r7, lr}
    73da:	mov	r4, r0
    73dc:	sub	sp, #332	; 0x14c
      char filename[256];
      uint32_t dir, size, parent;
      storage_->GetObjectInfo(handle, filename, &dir, &size, &parent);
    73de:	ldr	r0, [r0, #0]
    73e0:	add	r6, sp, #24
    73e2:	add	r5, sp, #20
    73e4:	ldr	r3, [r0, #0]
    73e6:	stmia.w	sp, {r5, r6}
    73ea:	add	r2, sp, #72	; 0x48
    73ec:	ldr	r7, [r3, #24]
    73ee:	add	r3, sp, #16
    73f0:	blx	r7
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    73f2:	ldrb	r3, [r4, #8]
    73f4:	movs	r2, #1
    73f6:	str	r2, [sp, #28]
    73f8:	cmp	r3, #0
    73fa:	beq.n	74b0 <MTPD::GetObjectInfo(unsigned long)+0xd8>
        write_length_ += len;
    73fc:	ldr	r3, [r4, #12]
      char filename[256];
      uint32_t dir, size, parent;
      storage_->GetObjectInfo(handle, filename, &dir, &size, &parent);

      write32(1); // storage
      write16(dir? 0x3001 : 0x3000); // format
    73fe:	ldr	r2, [sp, #16]
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
        write_length_ += len;
    7400:	adds	r3, #4
    7402:	str	r3, [r4, #12]
      char filename[256];
      uint32_t dir, size, parent;
      storage_->GetObjectInfo(handle, filename, &dir, &size, &parent);

      write32(1); // storage
      write16(dir? 0x3001 : 0x3000); // format
    7404:	cmp	r2, #0
    7406:	bne.n	74a6 <MTPD::GetObjectInfo(unsigned long)+0xce>
    7408:	mov.w	r2, #12288	; 0x3000
    740c:	strh.w	r2, [sp, #14]
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
        write_length_ += len;
    7410:	adds	r3, #2
    7412:	movs	r2, #0
    7414:	str	r3, [r4, #12]
    7416:	strh.w	r2, [sp, #12]
    741a:	adds	r3, #2
    741c:	ldr	r2, [r5, #0]
    741e:	str	r3, [r4, #12]
    7420:	str	r2, [sp, #68]	; 0x44
    7422:	adds	r3, #4
    7424:	movs	r2, #0
    7426:	str	r3, [r4, #12]
    7428:	strh.w	r2, [sp, #10]
    742c:	adds	r3, #2
    742e:	movs	r2, #0
    7430:	str	r3, [r4, #12]
    7432:	str	r2, [sp, #64]	; 0x40
    7434:	adds	r3, #4
    7436:	movs	r2, #0
    7438:	str	r3, [r4, #12]
    743a:	str	r2, [sp, #60]	; 0x3c
    743c:	adds	r3, #4
    743e:	movs	r2, #0
    7440:	str	r3, [r4, #12]
    7442:	str	r2, [sp, #56]	; 0x38
    7444:	adds	r3, #4
    7446:	movs	r2, #0
    7448:	str	r3, [r4, #12]
    744a:	str	r2, [sp, #52]	; 0x34
    744c:	adds	r3, #4
    744e:	movs	r2, #0
    7450:	str	r3, [r4, #12]
    7452:	str	r2, [sp, #48]	; 0x30
    7454:	adds	r3, #4
    7456:	movs	r2, #0
    7458:	str	r3, [r4, #12]
    745a:	str	r2, [sp, #44]	; 0x2c
    745c:	adds	r3, #4
    745e:	ldr	r2, [r6, #0]
    7460:	str	r3, [r4, #12]
    7462:	str	r2, [sp, #40]	; 0x28
    7464:	adds	r3, #4
    7466:	ldr	r2, [sp, #16]
    7468:	str	r3, [r4, #12]
    746a:	strh.w	r2, [sp, #8]
    746e:	adds	r3, #2
    7470:	movs	r2, #0
    7472:	str	r3, [r4, #12]
    7474:	str	r2, [sp, #36]	; 0x24
    7476:	adds	r3, #4
    7478:	movs	r2, #0
    747a:	str	r3, [r4, #12]
    747c:	str	r2, [sp, #32]
    747e:	adds	r3, #4
    7480:	str	r3, [r4, #12]
      write32(0); // bit depth
      write32(parent); // parent
      write16(dir);
      write32(0); // association description
      write32(0);  // sequence number
      writestring(filename);
    7482:	add	r1, sp, #72	; 0x48
    7484:	mov	r0, r4
    7486:	bl	6fa8 <MTPD::writestring(char const*)>
      writestring("");  // date created
    748a:	mov	r0, r4
    748c:	ldr	r1, [pc, #384]	; (7610 <MTPD::GetObjectInfo(unsigned long)+0x238>)
    748e:	bl	6fa8 <MTPD::writestring(char const*)>
      writestring("");  // date modified
    7492:	mov	r0, r4
    7494:	ldr	r1, [pc, #376]	; (7610 <MTPD::GetObjectInfo(unsigned long)+0x238>)
    7496:	bl	6fa8 <MTPD::writestring(char const*)>
      writestring("");  // keywords
    749a:	mov	r0, r4
    749c:	ldr	r1, [pc, #368]	; (7610 <MTPD::GetObjectInfo(unsigned long)+0x238>)
    749e:	bl	6fa8 <MTPD::writestring(char const*)>
    }
    74a2:	add	sp, #332	; 0x14c
    74a4:	pop	{r4, r5, r6, r7, pc}
    74a6:	movw	r2, #12289	; 0x3001
    74aa:	strh.w	r2, [sp, #14]
    74ae:	b.n	7410 <MTPD::GetObjectInfo(unsigned long)+0x38>
    74b0:	add	r1, sp, #28
    74b2:	movs	r2, #4
    74b4:	mov	r0, r4
    74b6:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
      char filename[256];
      uint32_t dir, size, parent;
      storage_->GetObjectInfo(handle, filename, &dir, &size, &parent);

      write32(1); // storage
      write16(dir? 0x3001 : 0x3000); // format
    74ba:	ldr	r3, [sp, #16]
    74bc:	ldrb	r7, [r4, #8]
    74be:	cmp	r3, #0
    74c0:	movw	r3, #12289	; 0x3001
    74c4:	it	eq
    74c6:	moveq.w	r3, #12288	; 0x3000
    74ca:	strh.w	r3, [sp, #14]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    74ce:	cmp	r7, #0
    74d0:	bne.w	75de <MTPD::GetObjectInfo(unsigned long)+0x206>
    74d4:	add.w	r1, sp, #14
    74d8:	movs	r2, #2
    74da:	mov	r0, r4
    74dc:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    74e0:	ldrb	r3, [r4, #8]
    74e2:	strh.w	r7, [sp, #12]
    74e6:	cmp	r3, #0
    74e8:	bne.n	75e2 <MTPD::GetObjectInfo(unsigned long)+0x20a>
    74ea:	movs	r2, #2
    74ec:	add	r1, sp, #12
    74ee:	mov	r0, r4
    74f0:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    74f4:	ldrb	r3, [r4, #8]
    74f6:	ldr	r2, [r5, #0]
    74f8:	str	r2, [sp, #68]	; 0x44
    74fa:	cmp	r3, #0
    74fc:	bne.n	75e6 <MTPD::GetObjectInfo(unsigned long)+0x20e>
    74fe:	add	r1, sp, #68	; 0x44
    7500:	movs	r2, #4
    7502:	mov	r0, r4
    7504:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7508:	ldrb	r3, [r4, #8]
    750a:	strh.w	r7, [sp, #10]
    750e:	cmp	r3, #0
    7510:	bne.n	75ea <MTPD::GetObjectInfo(unsigned long)+0x212>
    7512:	add.w	r1, sp, #10
    7516:	movs	r2, #2
    7518:	mov	r0, r4
    751a:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    751e:	ldrb	r3, [r4, #8]
    7520:	str	r7, [sp, #64]	; 0x40
    7522:	cmp	r3, #0
    7524:	bne.n	75ee <MTPD::GetObjectInfo(unsigned long)+0x216>
    7526:	add	r1, sp, #64	; 0x40
    7528:	movs	r2, #4
    752a:	mov	r0, r4
    752c:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7530:	ldrb	r3, [r4, #8]
    7532:	str	r7, [sp, #60]	; 0x3c
    7534:	cmp	r3, #0
    7536:	bne.n	75f2 <MTPD::GetObjectInfo(unsigned long)+0x21a>
    7538:	add	r1, sp, #60	; 0x3c
    753a:	movs	r2, #4
    753c:	mov	r0, r4
    753e:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7542:	ldrb	r3, [r4, #8]
    7544:	str	r7, [sp, #56]	; 0x38
    7546:	cmp	r3, #0
    7548:	bne.n	75f6 <MTPD::GetObjectInfo(unsigned long)+0x21e>
    754a:	add	r1, sp, #56	; 0x38
    754c:	movs	r2, #4
    754e:	mov	r0, r4
    7550:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7554:	ldrb	r3, [r4, #8]
    7556:	str	r7, [sp, #52]	; 0x34
    7558:	cmp	r3, #0
    755a:	bne.n	75fa <MTPD::GetObjectInfo(unsigned long)+0x222>
    755c:	add	r1, sp, #52	; 0x34
    755e:	movs	r2, #4
    7560:	mov	r0, r4
    7562:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7566:	ldrb	r3, [r4, #8]
    7568:	str	r7, [sp, #48]	; 0x30
    756a:	cmp	r3, #0
    756c:	bne.n	75fe <MTPD::GetObjectInfo(unsigned long)+0x226>
    756e:	add	r1, sp, #48	; 0x30
    7570:	movs	r2, #4
    7572:	mov	r0, r4
    7574:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7578:	ldrb	r3, [r4, #8]
    757a:	str	r7, [sp, #44]	; 0x2c
    757c:	cmp	r3, #0
    757e:	bne.n	7602 <MTPD::GetObjectInfo(unsigned long)+0x22a>
    7580:	movs	r2, #4
    7582:	add	r1, sp, #44	; 0x2c
    7584:	mov	r0, r4
    7586:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    758a:	ldrb	r3, [r4, #8]
    758c:	ldr	r2, [r6, #0]
    758e:	str	r2, [sp, #40]	; 0x28
    7590:	cmp	r3, #0
    7592:	bne.n	7606 <MTPD::GetObjectInfo(unsigned long)+0x22e>
    7594:	add	r1, sp, #40	; 0x28
    7596:	movs	r2, #4
    7598:	mov	r0, r4
    759a:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    759e:	ldrb	r6, [r4, #8]
    75a0:	ldr	r3, [sp, #16]
    75a2:	strh.w	r3, [sp, #8]
    75a6:	cmp	r6, #0
    75a8:	bne.n	760a <MTPD::GetObjectInfo(unsigned long)+0x232>
    75aa:	add	r1, sp, #8
    75ac:	movs	r2, #2
    75ae:	mov	r0, r4
    75b0:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    75b4:	ldrb	r5, [r4, #8]
    75b6:	str	r6, [sp, #36]	; 0x24
    75b8:	cbnz	r5, 75da <MTPD::GetObjectInfo(unsigned long)+0x202>
    75ba:	add	r1, sp, #36	; 0x24
    75bc:	movs	r2, #4
    75be:	mov	r0, r4
    75c0:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    75c4:	ldrb	r3, [r4, #8]
    75c6:	str	r5, [sp, #32]
    75c8:	cbnz	r3, 75d6 <MTPD::GetObjectInfo(unsigned long)+0x1fe>
    75ca:	add	r1, sp, #32
    75cc:	movs	r2, #4
    75ce:	mov	r0, r4
    75d0:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    75d4:	b.n	7482 <MTPD::GetObjectInfo(unsigned long)+0xaa>
    75d6:	ldr	r3, [r4, #12]
    75d8:	b.n	747e <MTPD::GetObjectInfo(unsigned long)+0xa6>
    75da:	ldr	r3, [r4, #12]
    75dc:	b.n	7476 <MTPD::GetObjectInfo(unsigned long)+0x9e>
    75de:	ldr	r3, [r4, #12]
    75e0:	b.n	7410 <MTPD::GetObjectInfo(unsigned long)+0x38>
    75e2:	ldr	r3, [r4, #12]
    75e4:	b.n	741a <MTPD::GetObjectInfo(unsigned long)+0x42>
    75e6:	ldr	r3, [r4, #12]
    75e8:	b.n	7422 <MTPD::GetObjectInfo(unsigned long)+0x4a>
    75ea:	ldr	r3, [r4, #12]
    75ec:	b.n	742c <MTPD::GetObjectInfo(unsigned long)+0x54>
    75ee:	ldr	r3, [r4, #12]
    75f0:	b.n	7434 <MTPD::GetObjectInfo(unsigned long)+0x5c>
    75f2:	ldr	r3, [r4, #12]
    75f4:	b.n	743c <MTPD::GetObjectInfo(unsigned long)+0x64>
    75f6:	ldr	r3, [r4, #12]
    75f8:	b.n	7444 <MTPD::GetObjectInfo(unsigned long)+0x6c>
    75fa:	ldr	r3, [r4, #12]
    75fc:	b.n	744c <MTPD::GetObjectInfo(unsigned long)+0x74>
    75fe:	ldr	r3, [r4, #12]
    7600:	b.n	7454 <MTPD::GetObjectInfo(unsigned long)+0x7c>
    7602:	ldr	r3, [r4, #12]
    7604:	b.n	745c <MTPD::GetObjectInfo(unsigned long)+0x84>
    7606:	ldr	r3, [r4, #12]
    7608:	b.n	7464 <MTPD::GetObjectInfo(unsigned long)+0x8c>
    760a:	ldr	r3, [r4, #12]
    760c:	b.n	746e <MTPD::GetObjectInfo(unsigned long)+0x96>
    760e:	nop
    7610:	.word	0x0000c4ec

00007614 <MTPD::getObjectPropsSupported(unsigned long)>:
  };

  uint32_t propertyListNum = sizeof(propertyList)/sizeof(propertyList[0]);

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
    7614:	push	{r4, r5, r6, r7, lr}
      write32(propertyListNum);
    7616:	ldr	r7, [pc, #96]	; (7678 <MTPD::getObjectPropsSupported(unsigned long)+0x64>)
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7618:	ldrb	r2, [r0, #8]

  uint32_t propertyListNum = sizeof(propertyList)/sizeof(propertyList[0]);

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
    761a:	ldr	r3, [r7, #0]
  };

  uint32_t propertyListNum = sizeof(propertyList)/sizeof(propertyList[0]);

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
    761c:	sub	sp, #12
    761e:	mov	r5, r0
    7620:	str	r3, [sp, #4]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7622:	cbz	r2, 766a <MTPD::getObjectPropsSupported(unsigned long)+0x56>
        write_length_ += len;
    7624:	ldr	r2, [r0, #12]
    7626:	adds	r2, #4
    7628:	str	r2, [r0, #12]
  uint32_t propertyListNum = sizeof(propertyList)/sizeof(propertyList[0]);

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    762a:	cbz	r3, 7666 <MTPD::getObjectPropsSupported(unsigned long)+0x52>
    762c:	ldr	r6, [pc, #76]	; (767c <MTPD::getObjectPropsSupported(unsigned long)+0x68>)
    762e:	movw	r2, #56321	; 0xdc01
    7632:	movs	r4, #0
    7634:	b.n	7648 <MTPD::getObjectPropsSupported(unsigned long)+0x34>
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
        write_length_ += len;
    7636:	ldr	r3, [r5, #12]
    7638:	adds	r3, #2
    763a:	str	r3, [r5, #12]
  uint32_t propertyListNum = sizeof(propertyList)/sizeof(propertyList[0]);

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    763c:	ldr	r3, [r7, #0]
    763e:	adds	r4, #1
    7640:	cmp	r3, r4
    7642:	bls.n	7666 <MTPD::getObjectPropsSupported(unsigned long)+0x52>
    7644:	ldrh.w	r2, [r6, #2]!
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7648:	ldrb	r3, [r5, #8]
    764a:	strh.w	r2, [sp, #2]
    764e:	cmp	r3, #0
    7650:	bne.n	7636 <MTPD::getObjectPropsSupported(unsigned long)+0x22>
    7652:	movs	r2, #2
    7654:	add.w	r1, sp, r2
    7658:	mov	r0, r5
    765a:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
  uint32_t propertyListNum = sizeof(propertyList)/sizeof(propertyList[0]);

    void MTPD::getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    765e:	ldr	r3, [r7, #0]
    7660:	adds	r4, #1
    7662:	cmp	r3, r4
    7664:	bhi.n	7644 <MTPD::getObjectPropsSupported(unsigned long)+0x30>
    }
    7666:	add	sp, #12
    7668:	pop	{r4, r5, r6, r7, pc}
    766a:	movs	r2, #4
    766c:	add.w	r1, sp, r2
    7670:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7674:	ldr	r3, [r7, #0]
    7676:	b.n	762a <MTPD::getObjectPropsSupported(unsigned long)+0x16>
    7678:	.word	0x1fff0978
    767c:	.word	0x0000c4c8

00007680 <MTPD::getObjectPropValue(unsigned long, unsigned long)>:
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[128];
    7680:	push	{r4, r5, r6, r7, lr}
    7682:	mov	r5, r0
    7684:	sub	sp, #188	; 0xbc
      uint32_t dir;
      uint32_t size;
      uint32_t parent;

      storage_->GetObjectInfo(p1,name,&dir,&size,&parent);
    7686:	ldr	r0, [r0, #0]
    7688:	add	r6, sp, #20
    768a:	add	r4, sp, #16
    768c:	ldr	r3, [r0, #0]
    768e:	stmia.w	sp, {r4, r6}
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[128];
    7692:	mov	r4, r2
      uint32_t dir;
      uint32_t size;
      uint32_t parent;

      storage_->GetObjectInfo(p1,name,&dir,&size,&parent);
    7694:	ldr	r6, [r3, #24]
    7696:	add	r2, sp, #56	; 0x38
    7698:	add	r3, sp, #12
          break;
      }
    }

    void MTPD::getObjectPropValue(uint32_t p1, uint32_t p2)
    { char name[128];
    769a:	mov	r7, r1
      uint32_t dir;
      uint32_t size;
      uint32_t parent;

      storage_->GetObjectInfo(p1,name,&dir,&size,&parent);
    769c:	blx	r6

      switch(p2)
    769e:	sub.w	r2, r4, #56320	; 0xdc00
    76a2:	subs	r2, #1
    76a4:	cmp	r2, #67	; 0x43
    76a6:	bhi.n	770a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8a>
    76a8:	tbb	[pc, r2]
    76ac:	.word	0x6f62463d
    76b0:	.word	0x31372f2f
    76b4:	.word	0x2f572f31
    76b8:	.word	0x2f2f2f2f
    76bc:	.word	0x2f2f2f2f
    76c0:	.word	0x2f2f2f2f
    76c4:	.word	0x2f2f2f2f
    76c8:	.word	0x2f2f2f2f
    76cc:	.word	0x2f2f2f2f
    76d0:	.word	0x2f2f2f2f
    76d4:	.word	0x2f2f2f2f
    76d8:	.word	0x2f2f2f2f
    76dc:	.word	0x2f2f2f2f
    76e0:	.word	0x2f2f2f2f
    76e4:	.word	0x2f2f2f2f
    76e8:	.word	0x2f2f2f2f
    76ec:	.word	0x372f2f22
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    76f0:	ldrb	r3, [r5, #8]
    76f2:	str	r7, [sp, #52]	; 0x34
    76f4:	cmp	r3, #0
    76f6:	beq.n	779c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x11c>
        write_length_ += len;
    76f8:	ldr	r3, [r5, #12]
    76fa:	adds	r3, #4
    76fc:	str	r3, [r5, #12]
    76fe:	adds	r3, #4
    7700:	str	r3, [r5, #12]
    7702:	adds	r3, #4
    7704:	str	r3, [r5, #12]
    7706:	adds	r3, #4
    7708:	str	r3, [r5, #12]
          writestring(name);
          break;
        default:
          break;
      }
    }
    770a:	add	sp, #188	; 0xbc
    770c:	pop	{r4, r5, r6, r7, pc}
          break;
        case MTP_PROPERTY_DATE_CREATED:       //0xDC08:
          writestring("");
          break;
        case MTP_PROPERTY_DATE_MODIFIED:      //0xDC09:
          writestring("");
    770e:	mov	r0, r5
    7710:	ldr	r1, [pc, #268]	; (7820 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1a0>)
    7712:	bl	6fa8 <MTPD::writestring(char const*)>
          writestring(name);
          break;
        default:
          break;
      }
    }
    7716:	add	sp, #188	; 0xbc
    7718:	pop	{r4, r5, r6, r7, pc}
          write32(parent);
          write32(1);
          write32(0);
          break;
        case MTP_PROPERTY_NAME:               //0xDC44:
          writestring(name);
    771a:	add	r1, sp, #56	; 0x38
    771c:	mov	r0, r5
    771e:	bl	6fa8 <MTPD::writestring(char const*)>
          break;
        default:
          break;
      }
    }
    7722:	add	sp, #188	; 0xbc
    7724:	pop	{r4, r5, r6, r7, pc}
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7726:	ldrb	r3, [r5, #8]
    7728:	str	r7, [sp, #24]
    772a:	cmp	r3, #0
    772c:	beq.n	77ea <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x16a>
        write_length_ += len;
    772e:	ldr	r3, [r5, #12]
    7730:	adds	r3, #4
    7732:	str	r3, [r5, #12]
          writestring(name);
          break;
        default:
          break;
      }
    }
    7734:	add	sp, #188	; 0xbc
    7736:	pop	{r4, r5, r6, r7, pc}
      {
        case MTP_PROPERTY_STORAGE_ID:         //0xDC01:
          write32(p1);
          break;
        case MTP_PROPERTY_OBJECT_FORMAT:      //0xDC02:
          write16(dir?0x3001:0x3000);
    7738:	ldr	r3, [sp, #12]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    773a:	ldrb	r2, [r5, #8]
      {
        case MTP_PROPERTY_STORAGE_ID:         //0xDC01:
          write32(p1);
          break;
        case MTP_PROPERTY_OBJECT_FORMAT:      //0xDC02:
          write16(dir?0x3001:0x3000);
    773c:	cmp	r3, #0
    773e:	movw	r3, #12289	; 0x3001
    7742:	it	eq
    7744:	moveq.w	r3, #12288	; 0x3000
    7748:	strh.w	r3, [sp, #8]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    774c:	cmp	r2, #0
    774e:	beq.n	77de <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x15e>
        write_length_ += len;
    7750:	ldr	r3, [r5, #12]
    7752:	adds	r3, #2
    7754:	str	r3, [r5, #12]
          writestring(name);
          break;
        default:
          break;
      }
    }
    7756:	add	sp, #188	; 0xbc
    7758:	pop	{r4, r5, r6, r7, pc}
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    775a:	ldrb	r3, [r5, #8]
    775c:	ldr	r2, [sp, #20]
    775e:	str	r2, [sp, #36]	; 0x24
    7760:	cmp	r3, #0
    7762:	bne.n	772e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xae>
    7764:	mov	r0, r5
    7766:	movs	r2, #4
    7768:	add	r1, sp, #36	; 0x24
    776a:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    776e:	b.n	770a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8a>
    7770:	ldrb	r3, [r5, #8]
    7772:	movs	r2, #0
    7774:	strh.w	r2, [sp, #10]
    7778:	cmp	r3, #0
    777a:	bne.n	7750 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xd0>
    777c:	mov	r0, r5
    777e:	movs	r2, #2
    7780:	add.w	r1, sp, #10
    7784:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7788:	b.n	770a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8a>
    778a:	ldrb	r4, [r5, #8]
    778c:	ldr	r3, [sp, #16]
    778e:	str	r3, [sp, #32]
    7790:	cmp	r4, #0
    7792:	beq.n	77f6 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x176>
        write_length_ += len;
    7794:	ldr	r3, [r5, #12]
    7796:	adds	r3, #4
    7798:	str	r3, [r5, #12]
    779a:	b.n	7706 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x86>
    779c:	movs	r2, #4
    779e:	add	r1, sp, #52	; 0x34
    77a0:	mov	r0, r5
    77a2:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    77a6:	ldrb	r3, [r5, #8]
    77a8:	ldr	r2, [sp, #20]
    77aa:	str	r2, [sp, #48]	; 0x30
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    77ac:	cmp	r3, #0
    77ae:	bne.n	781a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x19a>
    77b0:	movs	r2, #4
    77b2:	add	r1, sp, #48	; 0x30
    77b4:	mov	r0, r5
    77b6:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    77ba:	ldrb	r4, [r5, #8]
    77bc:	movs	r3, #1
    77be:	str	r3, [sp, #44]	; 0x2c
    77c0:	cbnz	r4, 7816 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x196>
    77c2:	movs	r2, #4
    77c4:	add	r1, sp, #44	; 0x2c
    77c6:	mov	r0, r5
    77c8:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    77cc:	ldrb	r3, [r5, #8]
    77ce:	str	r4, [sp, #40]	; 0x28
    77d0:	cbnz	r3, 7812 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x192>
    77d2:	mov	r0, r5
    77d4:	movs	r2, #4
    77d6:	add	r1, sp, #40	; 0x28
    77d8:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    77dc:	b.n	770a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8a>
    77de:	mov	r0, r5
    77e0:	movs	r2, #2
    77e2:	add	r1, sp, #8
    77e4:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    77e8:	b.n	770a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8a>
    77ea:	mov	r0, r5
    77ec:	movs	r2, #4
    77ee:	add	r1, sp, #24
    77f0:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    77f4:	b.n	770a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8a>
    77f6:	movs	r2, #4
    77f8:	add	r1, sp, #32
    77fa:	mov	r0, r5
    77fc:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7800:	ldrb	r3, [r5, #8]
    7802:	str	r4, [sp, #28]
    7804:	cbnz	r3, 7812 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x192>
    7806:	mov	r0, r5
    7808:	movs	r2, #4
    780a:	add	r1, sp, #28
    780c:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7810:	b.n	770a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8a>
    7812:	ldr	r3, [r5, #12]
    7814:	b.n	7706 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x86>
    7816:	ldr	r3, [r5, #12]
    7818:	b.n	7702 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x82>
    781a:	ldr	r3, [r5, #12]
    781c:	b.n	76fe <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x7e>
    781e:	nop
    7820:	.word	0x0000c4ec

00007824 <MTPD::GetStorageInfo(unsigned long)>:
    void MTPD::OpenSession(void)
    {
      storage_->ResetIndex();
    }

    void MTPD::GetStorageInfo(uint32_t storage) {
    7824:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    7828:	mov	r4, r0
      uint16_t readOnly = storage_->readonly();
    782a:	ldr	r0, [r0, #0]
    782c:	ldr	r3, [r0, #0]
    void MTPD::OpenSession(void)
    {
      storage_->ResetIndex();
    }

    void MTPD::GetStorageInfo(uint32_t storage) {
    782e:	sub	sp, #32
      uint16_t readOnly = storage_->readonly();
    7830:	ldr	r3, [r3, #0]
    7832:	blx	r3
    7834:	mov	sl, r0
      uint16_t has_directories = storage_->has_directories();
    7836:	ldr	r0, [r4, #0]
    7838:	ldr	r3, [r0, #0]
    783a:	ldr	r3, [r3, #4]
    783c:	blx	r3
    783e:	mov	r5, r0
      uint64_t storage_size = storage_->size();
    7840:	ldr	r0, [r4, #0]
    7842:	ldr	r3, [r0, #0]
    7844:	ldr	r3, [r3, #8]
    7846:	blx	r3
    7848:	mov	r6, r0
      uint64_t storage_free = storage_->free();
    784a:	ldr	r0, [r4, #0]
    784c:	ldr	r3, [r0, #0]
    784e:	ldr	r3, [r3, #12]
    }

    void MTPD::GetStorageInfo(uint32_t storage) {
      uint16_t readOnly = storage_->readonly();
      uint16_t has_directories = storage_->has_directories();
      uint64_t storage_size = storage_->size();
    7850:	mov	r7, r1
      uint64_t storage_free = storage_->free();
    7852:	blx	r3
      
      write16(readOnly ? 0x0001 : 0x0004);   // storage type (removable RAM)
    7854:	cmp.w	sl, #0
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7858:	ldrb	r3, [r4, #8]
      uint16_t readOnly = storage_->readonly();
      uint16_t has_directories = storage_->has_directories();
      uint64_t storage_size = storage_->size();
      uint64_t storage_free = storage_->free();
      
      write16(readOnly ? 0x0001 : 0x0004);   // storage type (removable RAM)
    785a:	ite	eq
    785c:	moveq	r2, #4
    785e:	movne	r2, #1

    void MTPD::GetStorageInfo(uint32_t storage) {
      uint16_t readOnly = storage_->readonly();
      uint16_t has_directories = storage_->has_directories();
      uint64_t storage_size = storage_->size();
      uint64_t storage_free = storage_->free();
    7860:	mov	r8, r0
    7862:	mov	r9, r1
    7864:	strh.w	r2, [sp, #6]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7868:	cbz	r3, 78be <MTPD::GetStorageInfo(unsigned long)+0x9a>
        write_length_ += len;
    786a:	ldr	r3, [r4, #12]
    786c:	adds	r3, #2
    786e:	str	r3, [r4, #12]
      uint16_t has_directories = storage_->has_directories();
      uint64_t storage_size = storage_->size();
      uint64_t storage_free = storage_->free();
      
      write16(readOnly ? 0x0001 : 0x0004);   // storage type (removable RAM)
      write16(has_directories ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    7870:	cbnz	r5, 78b6 <MTPD::GetStorageInfo(unsigned long)+0x92>
    7872:	movs	r2, #1
    7874:	strh.w	r2, [sp, #10]
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
        write_length_ += len;
    7878:	adds	r3, #2
    787a:	movs	r2, #0
    787c:	str	r3, [r4, #12]
    787e:	strh.w	r2, [sp, #8]
    7882:	strd	r6, r7, [sp, #24]
    7886:	adds	r3, #2
    7888:	str	r3, [r4, #12]
    788a:	strd	r8, r9, [sp, #16]
    788e:	adds	r3, #8
    7890:	str	r3, [r4, #12]
    7892:	adds	r3, #8
    7894:	mov.w	r2, #4294967295
    7898:	str	r3, [r4, #12]
    789a:	str	r2, [sp, #12]
    789c:	adds	r3, #4
    789e:	str	r3, [r4, #12]
      write16(has_directories ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
      write16(0x0000);   // access capability (read-write)
      write64(storage_size);  // max capacity
      write64(storage_free);  // free space (100M)
      write32(0xFFFFFFFFUL);  // free space (objects)
      writestring("SD Card");  // storage descriptor
    78a0:	mov	r0, r4
    78a2:	ldr	r1, [pc, #164]	; (7948 <MTPD::GetStorageInfo(unsigned long)+0x124>)
    78a4:	bl	6fa8 <MTPD::writestring(char const*)>
      writestring("");  // volume identifier
    78a8:	mov	r0, r4
    78aa:	ldr	r1, [pc, #160]	; (794c <MTPD::GetStorageInfo(unsigned long)+0x128>)
    78ac:	bl	6fa8 <MTPD::writestring(char const*)>
    }
    78b0:	add	sp, #32
    78b2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    78b6:	movs	r2, #2
    78b8:	strh.w	r2, [sp, #10]
    78bc:	b.n	7878 <MTPD::GetStorageInfo(unsigned long)+0x54>
    78be:	movs	r2, #2
    78c0:	add.w	r1, sp, #6
    78c4:	mov	r0, r4
    78c6:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
      uint16_t has_directories = storage_->has_directories();
      uint64_t storage_size = storage_->size();
      uint64_t storage_free = storage_->free();
      
      write16(readOnly ? 0x0001 : 0x0004);   // storage type (removable RAM)
      write16(has_directories ? 0x0002: 0x0001);   // filesystem type (generic hierarchical)
    78ca:	cmp	r5, #0
    78cc:	ldrb	r5, [r4, #8]
    78ce:	ite	eq
    78d0:	moveq	r3, #1
    78d2:	movne	r3, #2
    78d4:	strh.w	r3, [sp, #10]
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    78d8:	cbnz	r5, 793a <MTPD::GetStorageInfo(unsigned long)+0x116>
    78da:	movs	r2, #2
    78dc:	add.w	r1, sp, #10
    78e0:	mov	r0, r4
    78e2:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    78e6:	ldrb	r3, [r4, #8]
    78e8:	strh.w	r5, [sp, #8]
    78ec:	cbnz	r3, 793e <MTPD::GetStorageInfo(unsigned long)+0x11a>
    78ee:	movs	r2, #2
    78f0:	add	r1, sp, #8
    78f2:	mov	r0, r4
    78f4:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    78f8:	ldrb	r3, [r4, #8]
    78fa:	strd	r6, r7, [sp, #24]
    78fe:	cbnz	r3, 7942 <MTPD::GetStorageInfo(unsigned long)+0x11e>
    7900:	movs	r2, #8
    7902:	add	r1, sp, #24
    7904:	mov	r0, r4
    7906:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    790a:	ldrb	r3, [r4, #8]
    790c:	strd	r8, r9, [sp, #16]
    7910:	cbnz	r3, 7936 <MTPD::GetStorageInfo(unsigned long)+0x112>
    7912:	movs	r2, #8
    7914:	add	r1, sp, #16
    7916:	mov	r0, r4
    7918:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    791c:	ldrb	r3, [r4, #8]
    791e:	mov.w	r2, #4294967295
    7922:	str	r2, [sp, #12]
    7924:	cbnz	r3, 7932 <MTPD::GetStorageInfo(unsigned long)+0x10e>
    7926:	movs	r2, #4
    7928:	add	r1, sp, #12
    792a:	mov	r0, r4
    792c:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7930:	b.n	78a0 <MTPD::GetStorageInfo(unsigned long)+0x7c>
    7932:	ldr	r3, [r4, #12]
    7934:	b.n	789c <MTPD::GetStorageInfo(unsigned long)+0x78>
    7936:	ldr	r3, [r4, #12]
    7938:	b.n	7892 <MTPD::GetStorageInfo(unsigned long)+0x6e>
    793a:	ldr	r3, [r4, #12]
    793c:	b.n	7878 <MTPD::GetStorageInfo(unsigned long)+0x54>
    793e:	ldr	r3, [r4, #12]
    7940:	b.n	7882 <MTPD::GetStorageInfo(unsigned long)+0x5e>
    7942:	ldr	r3, [r4, #12]
    7944:	b.n	788a <MTPD::GetStorageInfo(unsigned long)+0x66>
    7946:	nop
    7948:	.word	0x0000c53c
    794c:	.word	0x0000c4ec

00007950 <MTPD::getObjectPropDesc(unsigned long, unsigned long)>:
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    }

    void MTPD::getObjectPropDesc(uint32_t p1, uint32_t p2)
    {
    7950:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
      switch(p1)
    7954:	sub.w	r1, r1, #56320	; 0xdc00
    7958:	subs	r1, #1
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    }

    void MTPD::getObjectPropDesc(uint32_t p1, uint32_t p2)
    {
    795a:	sub	sp, #148	; 0x94
    795c:	mov	r4, r0
      switch(p1)
    795e:	cmp	r1, #67	; 0x43
    7960:	bhi.n	7a18 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    7962:	tbh	[pc, r1, lsl #1]
    7966:	.short	0x005c
    7968:	.word	0x0080006e
    796c:	.word	0x005900c6
    7970:	.word	0x00d80059
    7974:	.word	0x01690121
    7978:	.word	0x01b10059
    797c:	.word	0x00590059
    7980:	.word	0x00590059
    7984:	.word	0x00590059
    7988:	.word	0x00590059
    798c:	.word	0x00590059
    7990:	.word	0x00590059
    7994:	.word	0x00590059
    7998:	.word	0x00590059
    799c:	.word	0x00590059
    79a0:	.word	0x00590059
    79a4:	.word	0x00590059
    79a8:	.word	0x00590059
    79ac:	.word	0x00590059
    79b0:	.word	0x00590059
    79b4:	.word	0x00590059
    79b8:	.word	0x00590059
    79bc:	.word	0x00590059
    79c0:	.word	0x00590059
    79c4:	.word	0x00590059
    79c8:	.word	0x00590059
    79cc:	.word	0x00590059
    79d0:	.word	0x00590059
    79d4:	.word	0x00590059
    79d8:	.word	0x00590059
    79dc:	.word	0x00590059
    79e0:	.word	0x00590059
    79e4:	.word	0x01f70059
    79e8:	.word	0x00590059
    79ec:	.short	0x0044
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    79ee:	ldrb	r3, [r0, #8]
    79f0:	movw	r2, #56388	; 0xdc44
    79f4:	strh.w	r2, [sp, #70]	; 0x46
    79f8:	cmp	r3, #0
    79fa:	beq.w	7e78 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x528>
        write_length_ += len;
    79fe:	ldr	r3, [r4, #12]
    7a00:	adds	r3, #2
    7a02:	str	r3, [r4, #12]
    7a04:	adds	r3, #2
    7a06:	str	r3, [r4, #12]
    7a08:	adds	r3, #1
    7a0a:	str	r3, [r4, #12]
    7a0c:	adds	r3, #1
    7a0e:	str	r3, [r4, #12]
    7a10:	adds	r3, #4
    7a12:	str	r3, [r4, #12]
    7a14:	adds	r3, #1
    7a16:	str	r3, [r4, #12]
          write8(0);
          break;
        default:
          break;
      }
    }
    7a18:	add	sp, #148	; 0x94
    7a1a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7a1e:	ldrb	r3, [r0, #8]
    7a20:	movw	r2, #56321	; 0xdc01
    7a24:	strh.w	r2, [sp, #30]
    7a28:	cmp	r3, #0
    7a2a:	beq.w	7f8c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x63c>
        write_length_ += len;
    7a2e:	ldr	r3, [r4, #12]
    7a30:	adds	r3, #2
    7a32:	str	r3, [r4, #12]
    7a34:	adds	r3, #2
    7a36:	str	r3, [r4, #12]
    7a38:	adds	r3, #1
    7a3a:	str	r3, [r4, #12]
    7a3c:	adds	r3, #4
    7a3e:	str	r3, [r4, #12]
    7a40:	b.n	7a10 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7a42:	ldrb	r3, [r0, #8]
    7a44:	movw	r2, #56322	; 0xdc02
    7a48:	strh.w	r2, [sp, #36]	; 0x24
    7a4c:	cmp	r3, #0
    7a4e:	beq.w	7dfa <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x4aa>
        write_length_ += len;
    7a52:	ldr	r3, [r4, #12]
    7a54:	adds	r3, #2
    7a56:	str	r3, [r4, #12]
    7a58:	adds	r3, #2
    7a5a:	str	r3, [r4, #12]
    7a5c:	adds	r3, #1
    7a5e:	str	r3, [r4, #12]
    7a60:	adds	r3, #2
    7a62:	str	r3, [r4, #12]
    7a64:	b.n	7a10 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7a66:	ldrb	r3, [r0, #8]
    7a68:	movw	r2, #56323	; 0xdc03
    7a6c:	strh.w	r2, [sp, #42]	; 0x2a
    7a70:	cmp	r3, #0
    7a72:	bne.n	7a52 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x102>
    7a74:	movs	r2, #2
    7a76:	add.w	r1, sp, #42	; 0x2a
    7a7a:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7a7e:	ldrb	r7, [r4, #8]
    7a80:	movs	r6, #4
    7a82:	strh.w	r6, [sp, #40]	; 0x28
    7a86:	cmp	r7, #0
    7a88:	bne.w	8022 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d2>
    7a8c:	movs	r2, #2
    7a8e:	add	r1, sp, #40	; 0x28
    7a90:	mov	r0, r4
    7a92:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7a96:	ldrb	r5, [r4, #8]
    7a98:	strb.w	r7, [sp, #9]
    7a9c:	cmp	r5, #0
    7a9e:	bne.w	801e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ce>
    7aa2:	movs	r2, #1
    7aa4:	add.w	r1, sp, #9
    7aa8:	mov	r0, r4
    7aaa:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7aae:	ldrb	r7, [r4, #8]
    7ab0:	strh.w	r5, [sp, #38]	; 0x26
    7ab4:	cmp	r7, #0
    7ab6:	bne.w	801a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ca>
    7aba:	movs	r2, #2
    7abc:	add.w	r1, sp, #38	; 0x26
    7ac0:	mov	r0, r4
    7ac2:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7ac6:	ldrb	r5, [r4, #8]
    7ac8:	str	r7, [sp, #84]	; 0x54
    7aca:	cmp	r5, #0
    7acc:	bne.w	7ff6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    7ad0:	mov	r2, r6
    7ad2:	add	r1, sp, #84	; 0x54
    7ad4:	mov	r0, r4
    7ad6:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7ada:	ldrb	r3, [r4, #8]
    7adc:	strb.w	r5, [sp, #8]
    7ae0:	cmp	r3, #0
    7ae2:	bne.w	7ff2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    7ae6:	mov	r0, r4
    7ae8:	movs	r2, #1
    7aea:	add	r1, sp, #8
    7aec:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7af0:	b.n	7a18 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    7af2:	ldrb	r3, [r0, #8]
    7af4:	movw	r2, #56324	; 0xdc04
    7af8:	strh.w	r2, [sp, #46]	; 0x2e
    7afc:	cmp	r3, #0
    7afe:	beq.w	7d78 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x428>
        write_length_ += len;
    7b02:	ldr	r3, [r0, #12]
    7b04:	adds	r3, #2
    7b06:	str	r3, [r0, #12]
    7b08:	adds	r3, #2
    7b0a:	str	r3, [r4, #12]
    7b0c:	adds	r3, #1
    7b0e:	str	r3, [r4, #12]
    7b10:	adds	r3, #8
    7b12:	str	r3, [r4, #12]
    7b14:	b.n	7a10 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7b16:	ldrb	r3, [r0, #8]
    7b18:	movw	r2, #56327	; 0xdc07
    7b1c:	strh.w	r2, [sp, #50]	; 0x32
    7b20:	cmp	r3, #0
    7b22:	bne.w	79fe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
    7b26:	movs	r2, #2
    7b28:	add.w	r1, sp, #50	; 0x32
    7b2c:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7b30:	ldrb	r3, [r4, #8]
    7b32:	movw	r2, #65535	; 0xffff
    7b36:	strh.w	r2, [sp, #48]	; 0x30
    7b3a:	cmp	r3, #0
    7b3c:	bne.w	800a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    7b40:	movs	r2, #2
    7b42:	add	r1, sp, #48	; 0x30
    7b44:	mov	r0, r4
    7b46:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7b4a:	ldrb	r6, [r4, #8]
    7b4c:	movs	r5, #1
    7b4e:	strb.w	r5, [sp, #14]
    7b52:	cmp	r6, #0
    7b54:	bne.w	8006 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    7b58:	mov	r2, r5
    7b5a:	add.w	r1, sp, #14
    7b5e:	mov	r0, r4
    7b60:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7b64:	ldrb	r7, [r4, #8]
    7b66:	strb.w	r6, [sp, #13]
    7b6a:	cmp	r7, #0
    7b6c:	bne.w	8016 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    7b70:	mov	r2, r5
    7b72:	add.w	r1, sp, #13
    7b76:	mov	r0, r4
    7b78:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7b7c:	ldrb	r6, [r4, #8]
    7b7e:	str	r7, [sp, #92]	; 0x5c
    7b80:	cmp	r6, #0
    7b82:	bne.w	7ff6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    7b86:	movs	r2, #4
    7b88:	add	r1, sp, #92	; 0x5c
    7b8a:	mov	r0, r4
    7b8c:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7b90:	ldrb	r3, [r4, #8]
    7b92:	strb.w	r6, [sp, #12]
    7b96:	cmp	r3, #0
    7b98:	bne.w	7ff2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    7b9c:	mov	r2, r5
    7b9e:	mov	r0, r4
    7ba0:	add	r1, sp, #12
    7ba2:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7ba6:	b.n	7a18 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    7ba8:	ldrb	r3, [r0, #8]
    7baa:	movw	r2, #56328	; 0xdc08
    7bae:	strh.w	r2, [sp, #54]	; 0x36
    7bb2:	cmp	r3, #0
    7bb4:	bne.w	79fe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
    7bb8:	movs	r2, #2
    7bba:	add.w	r1, sp, #54	; 0x36
    7bbe:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7bc2:	ldrb	r6, [r4, #8]
    7bc4:	movw	r3, #65535	; 0xffff
    7bc8:	strh.w	r3, [sp, #52]	; 0x34
    7bcc:	cmp	r6, #0
    7bce:	bne.w	800a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    7bd2:	movs	r2, #2
    7bd4:	add	r1, sp, #52	; 0x34
    7bd6:	mov	r0, r4
    7bd8:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7bdc:	ldrb	r5, [r4, #8]
    7bde:	strb.w	r6, [sp, #17]
    7be2:	cmp	r5, #0
    7be4:	bne.w	8006 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    7be8:	movs	r2, #1
    7bea:	add.w	r1, sp, #17
    7bee:	mov	r0, r4
    7bf0:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7bf4:	ldrb	r6, [r4, #8]
    7bf6:	strb.w	r5, [sp, #16]
    7bfa:	cmp	r6, #0
    7bfc:	bne.w	8016 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    7c00:	movs	r2, #1
    7c02:	add	r1, sp, #16
    7c04:	mov	r0, r4
    7c06:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7c0a:	ldrb	r5, [r4, #8]
    7c0c:	str	r6, [sp, #96]	; 0x60
    7c0e:	cmp	r5, #0
    7c10:	bne.w	7ff6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    7c14:	movs	r2, #4
    7c16:	add	r1, sp, #96	; 0x60
    7c18:	mov	r0, r4
    7c1a:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7c1e:	ldrb	r3, [r4, #8]
    7c20:	strb.w	r5, [sp, #15]
    7c24:	cmp	r3, #0
    7c26:	bne.w	7ff2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    7c2a:	mov	r0, r4
    7c2c:	movs	r2, #1
    7c2e:	add.w	r1, sp, #15
    7c32:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7c36:	b.n	7a18 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    7c38:	ldrb	r3, [r0, #8]
    7c3a:	movw	r2, #56329	; 0xdc09
    7c3e:	strh.w	r2, [sp, #58]	; 0x3a
    7c42:	cmp	r3, #0
    7c44:	bne.w	79fe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
    7c48:	movs	r2, #2
    7c4a:	add.w	r1, sp, #58	; 0x3a
    7c4e:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7c52:	ldrb	r6, [r4, #8]
    7c54:	movw	r3, #65535	; 0xffff
    7c58:	strh.w	r3, [sp, #56]	; 0x38
    7c5c:	cmp	r6, #0
    7c5e:	bne.w	800a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    7c62:	movs	r2, #2
    7c64:	add	r1, sp, #56	; 0x38
    7c66:	mov	r0, r4
    7c68:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7c6c:	ldrb	r5, [r4, #8]
    7c6e:	strb.w	r6, [sp, #20]
    7c72:	cmp	r5, #0
    7c74:	bne.w	8006 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    7c78:	movs	r2, #1
    7c7a:	add	r1, sp, #20
    7c7c:	mov	r0, r4
    7c7e:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7c82:	ldrb	r6, [r4, #8]
    7c84:	strb.w	r5, [sp, #19]
    7c88:	cmp	r6, #0
    7c8a:	bne.w	8016 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    7c8e:	movs	r2, #1
    7c90:	add.w	r1, sp, #19
    7c94:	mov	r0, r4
    7c96:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7c9a:	ldrb	r5, [r4, #8]
    7c9c:	str	r6, [sp, #100]	; 0x64
    7c9e:	cmp	r5, #0
    7ca0:	bne.w	7ff6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    7ca4:	movs	r2, #4
    7ca6:	add	r1, sp, #100	; 0x64
    7ca8:	mov	r0, r4
    7caa:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7cae:	ldrb	r3, [r4, #8]
    7cb0:	strb.w	r5, [sp, #18]
    7cb4:	cmp	r3, #0
    7cb6:	bne.w	7ff2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    7cba:	mov	r0, r4
    7cbc:	movs	r2, #1
    7cbe:	add.w	r1, sp, #18
    7cc2:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7cc6:	b.n	7a18 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    7cc8:	ldrb	r3, [r0, #8]
    7cca:	movw	r2, #56331	; 0xdc0b
    7cce:	strh.w	r2, [sp, #62]	; 0x3e
    7cd2:	cmp	r3, #0
    7cd4:	bne.w	7a2e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xde>
    7cd8:	movs	r2, #2
    7cda:	add.w	r1, sp, #62	; 0x3e
    7cde:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7ce2:	ldrb	r6, [r4, #8]
    7ce4:	movs	r3, #6
    7ce6:	strh.w	r3, [sp, #60]	; 0x3c
    7cea:	cmp	r6, #0
    7cec:	bne.w	8002 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b2>
    7cf0:	movs	r2, #2
    7cf2:	add	r1, sp, #60	; 0x3c
    7cf4:	mov	r0, r4
    7cf6:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7cfa:	ldrb	r5, [r4, #8]
    7cfc:	strb.w	r6, [sp, #22]
    7d00:	cmp	r5, #0
    7d02:	bne.w	7ffe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ae>
    7d06:	movs	r2, #1
    7d08:	add.w	r1, sp, #22
    7d0c:	mov	r0, r4
    7d0e:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7d12:	ldrb	r6, [r4, #8]
    7d14:	str	r5, [sp, #108]	; 0x6c
    7d16:	cmp	r6, #0
    7d18:	bne.w	7ffa <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6aa>
    7d1c:	movs	r2, #4
    7d1e:	add	r1, sp, #108	; 0x6c
    7d20:	mov	r0, r4
    7d22:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7d26:	ldrb	r5, [r4, #8]
    7d28:	str	r6, [sp, #104]	; 0x68
    7d2a:	cmp	r5, #0
    7d2c:	bne.w	7ff6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    7d30:	movs	r2, #4
    7d32:	add	r1, sp, #104	; 0x68
    7d34:	mov	r0, r4
    7d36:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7d3a:	ldrb	r3, [r4, #8]
    7d3c:	strb.w	r5, [sp, #21]
    7d40:	cmp	r3, #0
    7d42:	bne.w	7ff2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    7d46:	mov	r0, r4
    7d48:	movs	r2, #1
    7d4a:	add.w	r1, sp, #21
    7d4e:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7d52:	b.n	7a18 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    7d54:	ldrb	r3, [r0, #8]
    7d56:	movw	r2, #56385	; 0xdc41
    7d5a:	strh.w	r2, [sp, #66]	; 0x42
    7d5e:	cmp	r3, #0
    7d60:	beq.w	7efa <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x5aa>
        write_length_ += len;
    7d64:	ldr	r3, [r0, #12]
    7d66:	adds	r3, #2
    7d68:	str	r3, [r0, #12]
    7d6a:	adds	r3, #2
    7d6c:	str	r3, [r4, #12]
    7d6e:	adds	r3, #1
    7d70:	str	r3, [r4, #12]
    7d72:	adds	r3, #8
    7d74:	str	r3, [r4, #12]
    7d76:	b.n	7b10 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c0>
    7d78:	movs	r2, #2
    7d7a:	add.w	r1, sp, #46	; 0x2e
    7d7e:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7d82:	ldrb	r6, [r4, #8]
    7d84:	movs	r5, #8
    7d86:	strh.w	r5, [sp, #44]	; 0x2c
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::write(const char *data, int len) {
      if (write_get_length_) {
    7d8a:	cmp	r6, #0
    7d8c:	bne.w	8012 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c2>
    7d90:	movs	r2, #2
    7d92:	add	r1, sp, #44	; 0x2c
    7d94:	mov	r0, r4
    7d96:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7d9a:	ldrb	r3, [r4, #8]
    7d9c:	strb.w	r6, [sp, #11]
    7da0:	cmp	r3, #0
    7da2:	bne.w	800e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6be>
    7da6:	movs	r2, #1
    7da8:	add.w	r1, sp, #11
    7dac:	mov	r0, r4
    7dae:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7db2:	ldrb	r6, [r4, #8]
    7db4:	movs	r2, #0
    7db6:	movs	r3, #0
    7db8:	strd	r2, r3, [sp, #120]	; 0x78
    7dbc:	cmp	r6, #0
    7dbe:	bne.w	8026 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d6>
    7dc2:	mov	r2, r5
    7dc4:	add	r1, sp, #120	; 0x78
    7dc6:	mov	r0, r4
    7dc8:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7dcc:	ldrb	r5, [r4, #8]
    7dce:	str	r6, [sp, #88]	; 0x58
    7dd0:	cmp	r5, #0
    7dd2:	bne.w	7ff6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    7dd6:	movs	r2, #4
    7dd8:	add	r1, sp, #88	; 0x58
    7dda:	mov	r0, r4
    7ddc:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7de0:	ldrb	r3, [r4, #8]
    7de2:	strb.w	r5, [sp, #10]
    7de6:	cmp	r3, #0
    7de8:	bne.w	7ff2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    7dec:	mov	r0, r4
    7dee:	movs	r2, #1
    7df0:	add.w	r1, sp, #10
    7df4:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7df8:	b.n	7a18 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    7dfa:	movs	r2, #2
    7dfc:	add	r1, sp, #36	; 0x24
    7dfe:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7e02:	ldrb	r7, [r4, #8]
    7e04:	movs	r6, #4
    7e06:	strh.w	r6, [sp, #34]	; 0x22
    7e0a:	cmp	r7, #0
    7e0c:	bne.w	8022 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d2>
    7e10:	movs	r2, #2
    7e12:	add.w	r1, sp, #34	; 0x22
    7e16:	mov	r0, r4
    7e18:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7e1c:	ldrb	r5, [r4, #8]
    7e1e:	strb.w	r7, [sp, #7]
    7e22:	cmp	r5, #0
    7e24:	bne.w	801e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ce>
    7e28:	movs	r2, #1
    7e2a:	add.w	r1, sp, #7
    7e2e:	mov	r0, r4
    7e30:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7e34:	ldrb	r7, [r4, #8]
    7e36:	strh.w	r5, [sp, #32]
    7e3a:	cmp	r7, #0
    7e3c:	bne.w	801a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ca>
    7e40:	movs	r2, #2
    7e42:	add	r1, sp, #32
    7e44:	mov	r0, r4
    7e46:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7e4a:	ldrb	r5, [r4, #8]
    7e4c:	str	r7, [sp, #80]	; 0x50
    7e4e:	cmp	r5, #0
    7e50:	bne.w	7ff6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    7e54:	mov	r2, r6
    7e56:	add	r1, sp, #80	; 0x50
    7e58:	mov	r0, r4
    7e5a:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7e5e:	ldrb	r3, [r4, #8]
    7e60:	strb.w	r5, [sp, #6]
    7e64:	cmp	r3, #0
    7e66:	bne.w	7ff2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    7e6a:	mov	r0, r4
    7e6c:	movs	r2, #1
    7e6e:	add.w	r1, sp, #6
    7e72:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7e76:	b.n	7a18 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    7e78:	movs	r2, #2
    7e7a:	add.w	r1, sp, #70	; 0x46
    7e7e:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7e82:	ldrb	r6, [r4, #8]
    7e84:	movw	r3, #65535	; 0xffff
    7e88:	strh.w	r3, [sp, #68]	; 0x44
    7e8c:	cmp	r6, #0
    7e8e:	bne.w	800a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ba>
    7e92:	movs	r2, #2
    7e94:	add	r1, sp, #68	; 0x44
    7e96:	mov	r0, r4
    7e98:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7e9c:	ldrb	r5, [r4, #8]
    7e9e:	strb.w	r6, [sp, #27]
    7ea2:	cmp	r5, #0
    7ea4:	bne.w	8006 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
    7ea8:	movs	r2, #1
    7eaa:	add.w	r1, sp, #27
    7eae:	mov	r0, r4
    7eb0:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7eb4:	ldrb	r6, [r4, #8]
    7eb6:	strb.w	r5, [sp, #26]
    7eba:	cmp	r6, #0
    7ebc:	bne.w	8016 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6c6>
    7ec0:	movs	r2, #1
    7ec2:	add.w	r1, sp, #26
    7ec6:	mov	r0, r4
    7ec8:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7ecc:	ldrb	r5, [r4, #8]
    7ece:	str	r6, [sp, #116]	; 0x74
    7ed0:	cmp	r5, #0
    7ed2:	bne.w	7ff6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    7ed6:	movs	r2, #4
    7ed8:	add	r1, sp, #116	; 0x74
    7eda:	mov	r0, r4
    7edc:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7ee0:	ldrb	r3, [r4, #8]
    7ee2:	strb.w	r5, [sp, #25]
    7ee6:	cmp	r3, #0
    7ee8:	bne.w	7ff2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    7eec:	mov	r0, r4
    7eee:	movs	r2, #1
    7ef0:	add.w	r1, sp, #25
    7ef4:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7ef8:	b.n	7a18 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    7efa:	movs	r2, #2
    7efc:	add.w	r1, sp, #66	; 0x42
    7f00:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7f04:	ldrb	r5, [r4, #8]
    7f06:	movs	r3, #10
    7f08:	strh.w	r3, [sp, #64]	; 0x40
    7f0c:	cmp	r5, #0
    7f0e:	bne.w	8032 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6e2>
    7f12:	movs	r2, #2
    7f14:	add	r1, sp, #64	; 0x40
    7f16:	mov	r0, r4
    7f18:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7f1c:	ldrb	r3, [r4, #8]
    7f1e:	strb.w	r5, [sp, #24]
    7f22:	cmp	r3, #0
    7f24:	bne.w	802e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6de>
    7f28:	movs	r2, #1
    7f2a:	add	r1, sp, #24
    7f2c:	mov	r0, r4
    7f2e:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7f32:	ldrb	r3, [r4, #8]
    7f34:	mov.w	r8, #0
    7f38:	mov.w	r9, #0
    7f3c:	strd	r8, r9, [sp, #136]	; 0x88
    7f40:	cmp	r3, #0
    7f42:	bne.n	802a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6da>
    7f44:	movs	r2, #8
    7f46:	add	r1, sp, #136	; 0x88
    7f48:	mov	r0, r4
    7f4a:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7f4e:	ldrb	r6, [r4, #8]
    7f50:	strd	r8, r9, [sp, #128]	; 0x80
    7f54:	cmp	r6, #0
    7f56:	bne.n	8026 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6d6>
    7f58:	movs	r2, #8
    7f5a:	add	r1, sp, #128	; 0x80
    7f5c:	mov	r0, r4
    7f5e:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7f62:	ldrb	r5, [r4, #8]
    7f64:	str	r6, [sp, #112]	; 0x70
    7f66:	cmp	r5, #0
    7f68:	bne.n	7ff6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    7f6a:	movs	r2, #4
    7f6c:	add	r1, sp, #112	; 0x70
    7f6e:	mov	r0, r4
    7f70:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7f74:	ldrb	r3, [r4, #8]
    7f76:	strb.w	r5, [sp, #23]
    7f7a:	cmp	r3, #0
    7f7c:	bne.n	7ff2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    7f7e:	mov	r0, r4
    7f80:	movs	r2, #1
    7f82:	add.w	r1, sp, #23
    7f86:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7f8a:	b.n	7a18 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    7f8c:	movs	r2, #2
    7f8e:	add.w	r1, sp, #30
    7f92:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7f96:	ldrb	r6, [r4, #8]
    7f98:	movs	r3, #6
    7f9a:	strh.w	r3, [sp, #28]
    7f9e:	cbnz	r6, 8002 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b2>
    7fa0:	movs	r2, #2
    7fa2:	add	r1, sp, #28
    7fa4:	mov	r0, r4
    7fa6:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7faa:	ldrb	r5, [r4, #8]
    7fac:	strb.w	r6, [sp, #5]
    7fb0:	cbnz	r5, 7ffe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6ae>
    7fb2:	movs	r2, #1
    7fb4:	add.w	r1, sp, #5
    7fb8:	mov	r0, r4
    7fba:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7fbe:	ldrb	r6, [r4, #8]
    7fc0:	str	r5, [sp, #76]	; 0x4c
    7fc2:	cbnz	r6, 7ffa <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6aa>
    7fc4:	movs	r2, #4
    7fc6:	add	r1, sp, #76	; 0x4c
    7fc8:	mov	r0, r4
    7fca:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7fce:	ldrb	r5, [r4, #8]
    7fd0:	str	r6, [sp, #72]	; 0x48
    7fd2:	cbnz	r5, 7ff6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a6>
    7fd4:	movs	r2, #4
    7fd6:	add	r1, sp, #72	; 0x48
    7fd8:	mov	r0, r4
    7fda:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7fde:	ldrb	r3, [r4, #8]
    7fe0:	strb.w	r5, [sp, #4]
    7fe4:	cbnz	r3, 7ff2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6a2>
    7fe6:	mov	r0, r4
    7fe8:	movs	r2, #1
    7fea:	add	r1, sp, #4
    7fec:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    7ff0:	b.n	7a18 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc8>
    7ff2:	ldr	r3, [r4, #12]
    7ff4:	b.n	7a14 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc4>
    7ff6:	ldr	r3, [r4, #12]
    7ff8:	b.n	7a10 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc0>
    7ffa:	ldr	r3, [r4, #12]
    7ffc:	b.n	7a3c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xec>
    7ffe:	ldr	r3, [r4, #12]
    8000:	b.n	7a38 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe8>
    8002:	ldr	r3, [r4, #12]
    8004:	b.n	7a34 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe4>
    8006:	ldr	r3, [r4, #12]
    8008:	b.n	7a08 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
    800a:	ldr	r3, [r4, #12]
    800c:	b.n	7a04 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb4>
    800e:	ldr	r3, [r4, #12]
    8010:	b.n	7b0c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1bc>
    8012:	ldr	r3, [r4, #12]
    8014:	b.n	7b08 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b8>
    8016:	ldr	r3, [r4, #12]
    8018:	b.n	7a0c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbc>
    801a:	ldr	r3, [r4, #12]
    801c:	b.n	7a60 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x110>
    801e:	ldr	r3, [r4, #12]
    8020:	b.n	7a5c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x10c>
    8022:	ldr	r3, [r4, #12]
    8024:	b.n	7a58 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x108>
    8026:	ldr	r3, [r4, #12]
    8028:	b.n	7b10 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c0>
    802a:	ldr	r3, [r4, #12]
    802c:	b.n	7d72 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x422>
    802e:	ldr	r3, [r4, #12]
    8030:	b.n	7d6e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x41e>
    8032:	ldr	r3, [r4, #12]
    8034:	b.n	7d6a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x41a>
    8036:	nop

00008038 <MTPD::receive_buffer()>:
        data_buffer_ = usb_malloc();
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::receive_buffer() {
    8038:	push	{r4, lr}
    803a:	mov	r4, r0
    803c:	ldr	r3, [r4, #4]
      while (!data_buffer_) {
        data_buffer_ = usb_rx(MTP_RX_ENDPOINT);
    803e:	movs	r0, #5
        if (!data_buffer_) mtp_yield();
      }
    }

    void MTPD::receive_buffer() {
      while (!data_buffer_) {
    8040:	cbnz	r3, 804a <MTPD::receive_buffer()+0x12>
        data_buffer_ = usb_rx(MTP_RX_ENDPOINT);
    8042:	bl	9ce0 <usb_rx>
    8046:	str	r0, [r4, #4]
        if (!data_buffer_) mtp_yield();
    8048:	cbz	r0, 804c <MTPD::receive_buffer()+0x14>
    804a:	pop	{r4, pc}
    804c:	bl	62c4 <mtp_yield()>
    8050:	b.n	803c <MTPD::receive_buffer()+0x4>
    8052:	nop

00008054 <MTPD::GetObject(unsigned long)>:
        }
      }
    }

    void MTPD::GetObject(uint32_t object_id) 
    {
    8054:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    8058:	mov	r6, r0
      uint32_t size = storage_->GetSize(object_id);
    805a:	ldr	r0, [r0, #0]
    805c:	ldr	r3, [r0, #0]
        }
      }
    }

    void MTPD::GetObject(uint32_t object_id) 
    {
    805e:	sub	sp, #8
      uint32_t size = storage_->GetSize(object_id);
    8060:	ldr	r3, [r3, #32]
        }
      }
    }

    void MTPD::GetObject(uint32_t object_id) 
    {
    8062:	mov	r8, r1
      uint32_t size = storage_->GetSize(object_id);
    8064:	blx	r3
      if (write_get_length_) {
    8066:	ldrb	r5, [r6, #8]
      }
    }

    void MTPD::GetObject(uint32_t object_id) 
    {
      uint32_t size = storage_->GetSize(object_id);
    8068:	mov	r7, r0
      if (write_get_length_) {
    806a:	cbnz	r5, 80c4 <MTPD::GetObject(unsigned long)+0x70>
        write_length_ += size;
      } else {
        uint32_t pos = 0;
        while (pos < size) {
    806c:	cbz	r0, 80be <MTPD::GetObject(unsigned long)+0x6a>
                      to_copy);
          pos += to_copy;
          data_buffer_->len += to_copy;
          if (data_buffer_->len == sizeof(data_buffer_->buf)) {
            usb_tx(MTP_TX_ENDPOINT, data_buffer_);
            data_buffer_ = NULL;
    806e:	mov	r9, r5
    8070:	b.n	8076 <MTPD::GetObject(unsigned long)+0x22>
      uint32_t size = storage_->GetSize(object_id);
      if (write_get_length_) {
        write_length_ += size;
      } else {
        uint32_t pos = 0;
        while (pos < size) {
    8072:	cmp	r7, r5
    8074:	bls.n	80be <MTPD::GetObject(unsigned long)+0x6a>
          get_buffer();
    8076:	mov	r0, r6
    8078:	bl	6f1c <MTPD::get_buffer()>
          uint32_t avail = sizeof(data_buffer_->buf) - data_buffer_->len;
          uint32_t to_copy = min(size - pos, avail);
          // Read directly from storage into usb buffer.
          storage_->read(object_id, pos,
    807c:	ldmia.w	r6, {r0, r3}
        write_length_ += size;
      } else {
        uint32_t pos = 0;
        while (pos < size) {
          get_buffer();
          uint32_t avail = sizeof(data_buffer_->buf) - data_buffer_->len;
    8080:	ldrh.w	r2, [r3], #8
          uint32_t to_copy = min(size - pos, avail);
          // Read directly from storage into usb buffer.
          storage_->read(object_id, pos,
                      (char*)(data_buffer_->buf + data_buffer_->len),
                      to_copy);
    8084:	ldr	r1, [r0, #0]
    8086:	subs	r4, r7, r5
    8088:	rsb	lr, r2, #64	; 0x40
    808c:	cmp	r4, lr
    808e:	it	cs
    8090:	movcs	r4, lr
    8092:	str	r4, [sp, #0]
    8094:	add	r3, r2
    8096:	ldr.w	sl, [r1, #36]	; 0x24
    809a:	mov	r2, r5
    809c:	mov	r1, r8
    809e:	blx	sl
          pos += to_copy;
          data_buffer_->len += to_copy;
    80a0:	ldr	r1, [r6, #4]
    80a2:	ldrh	r3, [r1, #0]
    80a4:	add	r3, r4
    80a6:	uxth	r3, r3
          if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    80a8:	cmp	r3, #64	; 0x40
          uint32_t to_copy = min(size - pos, avail);
          // Read directly from storage into usb buffer.
          storage_->read(object_id, pos,
                      (char*)(data_buffer_->buf + data_buffer_->len),
                      to_copy);
          pos += to_copy;
    80aa:	add	r5, r4
          data_buffer_->len += to_copy;
    80ac:	strh	r3, [r1, #0]
          if (data_buffer_->len == sizeof(data_buffer_->buf)) {
    80ae:	bne.n	8072 <MTPD::GetObject(unsigned long)+0x1e>
            usb_tx(MTP_TX_ENDPOINT, data_buffer_);
    80b0:	movs	r0, #4
    80b2:	bl	9e50 <usb_tx>
      uint32_t size = storage_->GetSize(object_id);
      if (write_get_length_) {
        write_length_ += size;
      } else {
        uint32_t pos = 0;
        while (pos < size) {
    80b6:	cmp	r7, r5
                      to_copy);
          pos += to_copy;
          data_buffer_->len += to_copy;
          if (data_buffer_->len == sizeof(data_buffer_->buf)) {
            usb_tx(MTP_TX_ENDPOINT, data_buffer_);
            data_buffer_ = NULL;
    80b8:	str.w	r9, [r6, #4]
      uint32_t size = storage_->GetSize(object_id);
      if (write_get_length_) {
        write_length_ += size;
      } else {
        uint32_t pos = 0;
        while (pos < size) {
    80bc:	bhi.n	8076 <MTPD::GetObject(unsigned long)+0x22>
            usb_tx(MTP_TX_ENDPOINT, data_buffer_);
            data_buffer_ = NULL;
          }
        }
      }
    }
    80be:	add	sp, #8
    80c0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

    void MTPD::GetObject(uint32_t object_id) 
    {
      uint32_t size = storage_->GetSize(object_id);
      if (write_get_length_) {
        write_length_ += size;
    80c4:	ldr	r3, [r6, #12]
    80c6:	add	r7, r3
    80c8:	str	r7, [r6, #12]
            usb_tx(MTP_TX_ENDPOINT, data_buffer_);
            data_buffer_ = NULL;
          }
        }
      }
    }
    80ca:	add	sp, #8
    80cc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

000080d0 <MTPD::read(char*, unsigned long)>:
      data_buffer_ = NULL;                                \
    } while(0)

    void MTPD::read(char* data, uint32_t size) 
    {
      while (size) {
    80d0:	cbz	r2, 813c <MTPD::read(char*, unsigned long)+0x6c>
      usb_tx(MTP_TX_ENDPOINT, data_buffer_);              \
      data_buffer_ = NULL;                                \
    } while(0)

    void MTPD::read(char* data, uint32_t size) 
    {
    80d2:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    80d6:	mov	r6, r0
    80d8:	mov	r5, r1
      while (size) {
    80da:	mov	r8, r2
        }
        size -= to_copy;
        data_buffer_->index += to_copy;
        if (data_buffer_->index == data_buffer_->len) {
          usb_free(data_buffer_);
          data_buffer_ = NULL;
    80dc:	movs	r7, #0
    } while(0)

    void MTPD::read(char* data, uint32_t size) 
    {
      while (size) {
        receive_buffer();
    80de:	mov	r0, r6
    80e0:	bl	8038 <MTPD::receive_buffer()>
        uint32_t to_copy = data_buffer_->len - data_buffer_->index;
    80e4:	ldr	r3, [r6, #4]
    80e6:	ldrh.w	lr, [r3, #2]
    80ea:	ldrh.w	ip, [r3]
    80ee:	rsb	r4, lr, ip
    80f2:	cmp	r4, r8
    80f4:	it	cs
    80f6:	movcs	r4, r8
        to_copy = min(to_copy, size);
        if (data) {
          memcpy(data, data_buffer_->buf + data_buffer_->index, to_copy);
    80f8:	add.w	r1, r3, #8
    80fc:	add	r1, lr
    80fe:	mov	r0, r5
    8100:	mov	r2, r4
          data += to_copy;
        }
        size -= to_copy;
    8102:	rsb	r8, r4, r8
    {
      while (size) {
        receive_buffer();
        uint32_t to_copy = data_buffer_->len - data_buffer_->index;
        to_copy = min(to_copy, size);
        if (data) {
    8106:	cbz	r5, 8118 <MTPD::read(char*, unsigned long)+0x48>
          memcpy(data, data_buffer_->buf + data_buffer_->index, to_copy);
    8108:	bl	8c24 <memcpy>
    810c:	ldr	r3, [r6, #4]
    810e:	ldrh.w	lr, [r3, #2]
    8112:	ldrh.w	ip, [r3]
          data += to_copy;
    8116:	add	r5, r4
        }
        size -= to_copy;
        data_buffer_->index += to_copy;
    8118:	add	r4, lr
    811a:	uxth	r4, r4
        if (data_buffer_->index == data_buffer_->len) {
    811c:	cmp	ip, r4
        if (data) {
          memcpy(data, data_buffer_->buf + data_buffer_->index, to_copy);
          data += to_copy;
        }
        size -= to_copy;
        data_buffer_->index += to_copy;
    811e:	strh	r4, [r3, #2]
        if (data_buffer_->index == data_buffer_->len) {
    8120:	beq.n	812c <MTPD::read(char*, unsigned long)+0x5c>
      data_buffer_ = NULL;                                \
    } while(0)

    void MTPD::read(char* data, uint32_t size) 
    {
      while (size) {
    8122:	cmp.w	r8, #0
    8126:	bne.n	80de <MTPD::read(char*, unsigned long)+0xe>
    8128:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          data += to_copy;
        }
        size -= to_copy;
        data_buffer_->index += to_copy;
        if (data_buffer_->index == data_buffer_->len) {
          usb_free(data_buffer_);
    812c:	mov	r0, r3
    812e:	bl	9c94 <usb_free>
          data_buffer_ = NULL;
    8132:	str	r7, [r6, #4]
      data_buffer_ = NULL;                                \
    } while(0)

    void MTPD::read(char* data, uint32_t size) 
    {
      while (size) {
    8134:	cmp.w	r8, #0
    8138:	bne.n	80de <MTPD::read(char*, unsigned long)+0xe>
    813a:	b.n	8128 <MTPD::read(char*, unsigned long)+0x58>
    813c:	bx	lr
    813e:	nop

00008140 <MTPD::ReadMTPHeader()>:
      } else 
      { write8(0);
      }
    }

    uint32_t MTPD::ReadMTPHeader() {
    8140:	push	{r4, lr}
      MTPHeader header;
      read(0,0);
    8142:	movs	r2, #0
      } else 
      { write8(0);
      }
    }

    uint32_t MTPD::ReadMTPHeader() {
    8144:	sub	sp, #16
      MTPHeader header;
      read(0,0);
    8146:	mov	r1, r2
      } else 
      { write8(0);
      }
    }

    uint32_t MTPD::ReadMTPHeader() {
    8148:	mov	r4, r0
      MTPHeader header;
      read(0,0);
    814a:	bl	80d0 <MTPD::read(char*, unsigned long)>
      read((char *)&header, sizeof(MTPHeader));
    814e:	mov	r0, r4
    8150:	movs	r2, #12
    8152:	add	r1, sp, #4
    8154:	bl	80d0 <MTPD::read(char*, unsigned long)>
      // check that the type is data
      return header.len - 12;
    8158:	ldr	r0, [sp, #4]
    }
    815a:	subs	r0, #12
    815c:	add	sp, #16
    815e:	pop	{r4, pc}

00008160 <MTPD::readstring(char*)>:
      uint32_t ret;
      read((char*)&ret, sizeof(ret));
      return ret;
    }

    uint32_t MTPD::readstring(char* buffer) {
    8160:	push	{r4, r5, r6, r7, lr}
    8162:	sub	sp, #12
    8164:	mov	r4, r1
      return header.len - 12;
    }

    uint8_t MTPD::read8() {
      uint8_t ret;
      read((char*)&ret, sizeof(ret));
    8166:	movs	r2, #1
    8168:	add.w	r1, sp, #6
      uint32_t ret;
      read((char*)&ret, sizeof(ret));
      return ret;
    }

    uint32_t MTPD::readstring(char* buffer) {
    816c:	mov	r6, r0
      return header.len - 12;
    }

    uint8_t MTPD::read8() {
      uint8_t ret;
      read((char*)&ret, sizeof(ret));
    816e:	bl	80d0 <MTPD::read(char*, unsigned long)>
      return ret;
    8172:	ldrb.w	r7, [sp, #6]
      return ret;
    }

    uint32_t MTPD::readstring(char* buffer) {
      int len = read8();
      if (!buffer) {
    8176:	cbz	r4, 81a4 <MTPD::readstring(char*)+0x44>
    8178:	adds	r5, r4, r7
        read(NULL, len * 2);
      } else {
        for (int i = 0; i < len; i++) {
    817a:	cbz	r7, 81b2 <MTPD::readstring(char*)+0x52>
      return ret;
    }

    uint16_t MTPD::read16() {
      uint16_t ret;
      read((char*)&ret, sizeof(ret));
    817c:	movs	r2, #2
    817e:	add.w	r1, sp, #6
    8182:	mov	r0, r6
    8184:	bl	80d0 <MTPD::read(char*, unsigned long)>
      return ret;
    8188:	ldrh.w	r3, [sp, #6]
      int len = read8();
      if (!buffer) {
        read(NULL, len * 2);
      } else {
        for (int i = 0; i < len; i++) {
          *(buffer++) = read16();
    818c:	strb.w	r3, [r4], #1
    uint32_t MTPD::readstring(char* buffer) {
      int len = read8();
      if (!buffer) {
        read(NULL, len * 2);
      } else {
        for (int i = 0; i < len; i++) {
    8190:	cmp	r5, r4
    8192:	bne.n	817c <MTPD::readstring(char*)+0x1c>
          *(buffer++) = read16();
        }
      }
      *(buffer++)=0; *(buffer++)=0; // to be sure
      return 2*len+1;
    8194:	movs	r0, #1
      } else {
        for (int i = 0; i < len; i++) {
          *(buffer++) = read16();
        }
      }
      *(buffer++)=0; *(buffer++)=0; // to be sure
    8196:	movs	r3, #0
      return 2*len+1;
    }
    8198:	add.w	r0, r0, r7, lsl #1
      } else {
        for (int i = 0; i < len; i++) {
          *(buffer++) = read16();
        }
      }
      *(buffer++)=0; *(buffer++)=0; // to be sure
    819c:	strb	r3, [r5, #0]
    819e:	strb	r3, [r5, #1]
      return 2*len+1;
    }
    81a0:	add	sp, #12
    81a2:	pop	{r4, r5, r6, r7, pc}
    }

    uint32_t MTPD::readstring(char* buffer) {
      int len = read8();
      if (!buffer) {
        read(NULL, len * 2);
    81a4:	lsls	r2, r7, #1
    81a6:	mov	r0, r6
    81a8:	mov	r1, r4
    81aa:	bl	80d0 <MTPD::read(char*, unsigned long)>
      } else {
        for (int i = 0; i < len; i++) {
          *(buffer++) = read16();
        }
      }
      *(buffer++)=0; *(buffer++)=0; // to be sure
    81ae:	strb	r4, [r4, #0]
    81b0:	udf	#255	; 0xff
    uint32_t MTPD::readstring(char* buffer) {
      int len = read8();
      if (!buffer) {
        read(NULL, len * 2);
      } else {
        for (int i = 0; i < len; i++) {
    81b2:	mov	r5, r4
    81b4:	b.n	8194 <MTPD::readstring(char*)+0x34>
    81b6:	nop

000081b8 <MTPD::setObjectPropValue(unsigned long, unsigned long) [clone .part.8]>:
        }
      }
      storage_->close();
    }

    uint32_t MTPD::setObjectPropValue(uint32_t p1, uint32_t p2)
    81b8:	push	{r4, r5, lr}
    81ba:	mov	r4, r0
    81bc:	sub	sp, #132	; 0x84
    81be:	mov	r5, r1
      receive_buffer();

      if(p2==0xDC07)
      {
        char filename[128];
        ReadMTPHeader();
    81c0:	bl	8140 <MTPD::ReadMTPHeader()>
        readstring(filename);
    81c4:	mov	r1, sp
    81c6:	mov	r0, r4
    81c8:	bl	8160 <MTPD::readstring(char*)>

        storage_->rename(p1,filename);
    81cc:	ldr	r0, [r4, #0]
    81ce:	ldr	r3, [r0, #0]
    81d0:	mov	r2, sp
    81d2:	mov	r1, r5
    81d4:	ldr	r3, [r3, #56]	; 0x38
    81d6:	blx	r3

        return 0x2001;
      }
      else
        return 0x2005;
    }
    81d8:	movw	r0, #8193	; 0x2001
    81dc:	add	sp, #132	; 0x84
    81de:	pop	{r4, r5, pc}

000081e0 <MTPD::read_until_short_packet()>:
          data_buffer_ = NULL;
        }
      }
    }

    void MTPD::read_until_short_packet() {
    81e0:	push	{r4, r5, r6, lr}
    81e2:	mov	r4, r0
      bool done = false;
      while (!done) {
        receive_buffer();
        done = data_buffer_->len != sizeof(data_buffer_->buf);
        usb_free(data_buffer_);
        data_buffer_ = NULL;
    81e4:	movs	r6, #0
    }

    void MTPD::read_until_short_packet() {
      bool done = false;
      while (!done) {
        receive_buffer();
    81e6:	mov	r0, r4
    81e8:	bl	8038 <MTPD::receive_buffer()>
        done = data_buffer_->len != sizeof(data_buffer_->buf);
    81ec:	ldr	r0, [r4, #4]
    81ee:	ldrh	r5, [r0, #0]
        usb_free(data_buffer_);
    81f0:	bl	9c94 <usb_free>
      }
    }

    void MTPD::read_until_short_packet() {
      bool done = false;
      while (!done) {
    81f4:	cmp	r5, #64	; 0x40
        receive_buffer();
        done = data_buffer_->len != sizeof(data_buffer_->buf);
        usb_free(data_buffer_);
        data_buffer_ = NULL;
    81f6:	str	r6, [r4, #4]
      }
    }

    void MTPD::read_until_short_packet() {
      bool done = false;
      while (!done) {
    81f8:	beq.n	81e6 <MTPD::read_until_short_packet()+0x6>
        receive_buffer();
        done = data_buffer_->len != sizeof(data_buffer_->buf);
        usb_free(data_buffer_);
        data_buffer_ = NULL;
      }
    }
    81fa:	pop	{r4, r5, r6, pc}

000081fc <MTPD::SendObjectInfo(unsigned long, unsigned long)>:

    uint32_t MTPD::SendObjectInfo(uint32_t storage, uint32_t parent) {
    81fc:	push	{r4, r5, r6, lr}
    81fe:	mov	r4, r0
    8200:	sub	sp, #256	; 0x100
    8202:	mov	r6, r2
      ReadMTPHeader();
    8204:	bl	8140 <MTPD::ReadMTPHeader()>
      return ret;
    }

    uint32_t MTPD::read32() {
      uint32_t ret;
      read((char*)&ret, sizeof(ret));
    8208:	mov	r0, r4
    820a:	mov	r1, sp
    820c:	movs	r2, #4
    820e:	bl	80d0 <MTPD::read(char*, unsigned long)>
      return ret;
    }

    uint16_t MTPD::read16() {
      uint16_t ret;
      read((char*)&ret, sizeof(ret));
    8212:	mov	r1, sp
    8214:	mov	r0, r4
    8216:	movs	r2, #2
    8218:	bl	80d0 <MTPD::read(char*, unsigned long)>
    821c:	mov	r1, sp
    821e:	mov	r0, r4
    8220:	movs	r2, #2
      return ret;
    8222:	ldrh.w	r5, [sp]
      return ret;
    }

    uint16_t MTPD::read16() {
      uint16_t ret;
      read((char*)&ret, sizeof(ret));
    8226:	bl	80d0 <MTPD::read(char*, unsigned long)>
      return ret;
    }

    uint32_t MTPD::read32() {
      uint32_t ret;
      read((char*)&ret, sizeof(ret));
    822a:	mov	r1, sp
    822c:	mov	r0, r4
    822e:	movs	r2, #4
    8230:	bl	80d0 <MTPD::read(char*, unsigned long)>
      return ret;
    }

    uint16_t MTPD::read16() {
      uint16_t ret;
      read((char*)&ret, sizeof(ret));
    8234:	mov	r1, sp
    8236:	mov	r0, r4
    8238:	movs	r2, #2
    823a:	bl	80d0 <MTPD::read(char*, unsigned long)>
      return ret;
    }

    uint32_t MTPD::read32() {
      uint32_t ret;
      read((char*)&ret, sizeof(ret));
    823e:	mov	r1, sp
    8240:	mov	r0, r4
    8242:	movs	r2, #4
    8244:	bl	80d0 <MTPD::read(char*, unsigned long)>
    8248:	mov	r1, sp
    824a:	mov	r0, r4
    824c:	movs	r2, #4
    824e:	bl	80d0 <MTPD::read(char*, unsigned long)>
    8252:	mov	r1, sp
    8254:	mov	r0, r4
    8256:	movs	r2, #4
    8258:	bl	80d0 <MTPD::read(char*, unsigned long)>
    825c:	mov	r1, sp
    825e:	mov	r0, r4
    8260:	movs	r2, #4
    8262:	bl	80d0 <MTPD::read(char*, unsigned long)>
    8266:	mov	r1, sp
    8268:	mov	r0, r4
    826a:	movs	r2, #4
    826c:	bl	80d0 <MTPD::read(char*, unsigned long)>
    8270:	mov	r1, sp
    8272:	mov	r0, r4
    8274:	movs	r2, #4
    8276:	bl	80d0 <MTPD::read(char*, unsigned long)>
    827a:	mov	r1, sp
    827c:	mov	r0, r4
    827e:	movs	r2, #4
    8280:	bl	80d0 <MTPD::read(char*, unsigned long)>
      return ret;
    }

    uint16_t MTPD::read16() {
      uint16_t ret;
      read((char*)&ret, sizeof(ret));
    8284:	mov	r1, sp
    8286:	mov	r0, r4
    8288:	movs	r2, #2
    828a:	bl	80d0 <MTPD::read(char*, unsigned long)>
      return ret;
    }

    uint32_t MTPD::read32() {
      uint32_t ret;
      read((char*)&ret, sizeof(ret));
    828e:	mov	r1, sp
    8290:	mov	r0, r4
    8292:	movs	r2, #4
    8294:	bl	80d0 <MTPD::read(char*, unsigned long)>
    8298:	movs	r2, #4
    829a:	mov	r1, sp
    829c:	mov	r0, r4
    829e:	bl	80d0 <MTPD::read(char*, unsigned long)>
      read32(); // parent
      read16(); // association type
      read32(); // association description
      read32(); // sequence number

      readstring(filename);
    82a2:	mov	r1, sp
    82a4:	mov	r0, r4
    82a6:	bl	8160 <MTPD::readstring(char*)>
      read_until_short_packet();  // ignores dates & keywords
    82aa:	mov	r0, r4
    82ac:	bl	81e0 <MTPD::read_until_short_packet()>
      return storage_->Create(parent, dir, filename);
    82b0:	ldr	r0, [r4, #0]
    82b2:	movw	r2, #12289	; 0x3001
    82b6:	ldr	r4, [r0, #0]
    82b8:	subs	r2, r5, r2
    82ba:	clz	r2, r2
    82be:	mov	r3, sp
    82c0:	mov	r1, r6
    82c2:	lsrs	r2, r2, #5
    82c4:	ldr	r4, [r4, #40]	; 0x28
    82c6:	blx	r4
    }
    82c8:	add	sp, #256	; 0x100
    82ca:	pop	{r4, r5, r6, pc}

000082cc <MTPD::SendObject()>:

    void MTPD::SendObject() {
    82cc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    82d0:	mov	r7, r0
      uint32_t len = ReadMTPHeader();
    82d2:	bl	8140 <MTPD::ReadMTPHeader()>
      while (len) 
    82d6:	cbz	r0, 8316 <MTPD::SendObject()+0x4a>
    82d8:	mov	r5, r0
        data_buffer_->index += to_copy;
        len -= to_copy;
        if (data_buffer_->index == data_buffer_->len) 
        {
          usb_free(data_buffer_);
          data_buffer_ = NULL;
    82da:	movs	r6, #0

    void MTPD::SendObject() {
      uint32_t len = ReadMTPHeader();
      while (len) 
      {
        receive_buffer();
    82dc:	mov	r0, r7
    82de:	bl	8038 <MTPD::receive_buffer()>
        uint32_t to_copy = data_buffer_->len - data_buffer_->index;
        to_copy = min(to_copy, len);
        storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy);
    82e2:	ldmia.w	r7, {r0, r1}
    void MTPD::SendObject() {
      uint32_t len = ReadMTPHeader();
      while (len) 
      {
        receive_buffer();
        uint32_t to_copy = data_buffer_->len - data_buffer_->index;
    82e6:	ldrh	r2, [r1, #2]
    82e8:	ldrh.w	r4, [r1], #8
        to_copy = min(to_copy, len);
        storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy);
    82ec:	ldr	r3, [r0, #0]
    void MTPD::SendObject() {
      uint32_t len = ReadMTPHeader();
      while (len) 
      {
        receive_buffer();
        uint32_t to_copy = data_buffer_->len - data_buffer_->index;
    82ee:	subs	r4, r4, r2
    82f0:	cmp	r4, r5
    82f2:	it	cs
    82f4:	movcs	r4, r5
        to_copy = min(to_copy, len);
        storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy);
    82f6:	ldr	r3, [r3, #44]	; 0x2c
    82f8:	add	r1, r2
    82fa:	mov	r2, r4
    82fc:	blx	r3
        data_buffer_->index += to_copy;
    82fe:	ldr	r0, [r7, #4]
    8300:	ldrh	r3, [r0, #2]
        len -= to_copy;
        if (data_buffer_->index == data_buffer_->len) 
    8302:	ldrh	r2, [r0, #0]
      {
        receive_buffer();
        uint32_t to_copy = data_buffer_->len - data_buffer_->index;
        to_copy = min(to_copy, len);
        storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy);
        data_buffer_->index += to_copy;
    8304:	add	r3, r4
    8306:	uxth	r3, r3
        len -= to_copy;
        if (data_buffer_->index == data_buffer_->len) 
    8308:	cmp	r2, r3
        receive_buffer();
        uint32_t to_copy = data_buffer_->len - data_buffer_->index;
        to_copy = min(to_copy, len);
        storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy);
        data_buffer_->index += to_copy;
        len -= to_copy;
    830a:	sub.w	r5, r5, r4
      {
        receive_buffer();
        uint32_t to_copy = data_buffer_->len - data_buffer_->index;
        to_copy = min(to_copy, len);
        storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy);
        data_buffer_->index += to_copy;
    830e:	strh	r3, [r0, #2]
        len -= to_copy;
        if (data_buffer_->index == data_buffer_->len) 
    8310:	beq.n	8322 <MTPD::SendObject()+0x56>
      return storage_->Create(parent, dir, filename);
    }

    void MTPD::SendObject() {
      uint32_t len = ReadMTPHeader();
      while (len) 
    8312:	cmp	r5, #0
    8314:	bne.n	82dc <MTPD::SendObject()+0x10>
        {
          usb_free(data_buffer_);
          data_buffer_ = NULL;
        }
      }
      storage_->close();
    8316:	ldr	r0, [r7, #0]
    8318:	ldr	r3, [r0, #0]
    }
    831a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        {
          usb_free(data_buffer_);
          data_buffer_ = NULL;
        }
      }
      storage_->close();
    831e:	ldr	r3, [r3, #48]	; 0x30
    8320:	bx	r3
        storage_->write((char*)(data_buffer_->buf + data_buffer_->index), to_copy);
        data_buffer_->index += to_copy;
        len -= to_copy;
        if (data_buffer_->index == data_buffer_->len) 
        {
          usb_free(data_buffer_);
    8322:	bl	9c94 <usb_free>
          data_buffer_ = NULL;
    8326:	str	r6, [r7, #4]
      return storage_->Create(parent, dir, filename);
    }

    void MTPD::SendObject() {
      uint32_t len = ReadMTPHeader();
      while (len) 
    8328:	cmp	r5, #0
    832a:	bne.n	82dc <MTPD::SendObject()+0x10>
    832c:	b.n	8316 <MTPD::SendObject()+0x4a>
    832e:	nop

00008330 <MTPD::loop()>:
      else
        return 0x2005;
    }

    void MTPD::loop() 
    {
    8330:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8334:	mov	r5, r0
    8336:	sub	sp, #28
      usb_packet_t *receive_buffer;
      if ((receive_buffer = usb_rx(MTP_RX_ENDPOINT))) {
    8338:	movs	r0, #5
    833a:	bl	9ce0 <usb_rx>
    833e:	cmp	r0, #0
    8340:	beq.n	83f2 <MTPD::loop()+0xc2>
      }
      Serial1.println("");
  #endif
  #if 1
      MTPContainer *tmp = (struct MTPContainer*)(x->buf);
      if(tmp->type==1)
    8342:	ldrh	r6, [r0, #12]
    8344:	cmp	r6, #1
    8346:	mov	r4, r0
    8348:	beq.w	8564 <MTPD::loop()+0x234>
    {
      usb_packet_t *receive_buffer;
      if ((receive_buffer = usb_rx(MTP_RX_ENDPOINT))) {
        PrintPacket(receive_buffer);

        int op = CONTAINER->op;
    834c:	ldrh	r2, [r4, #14]
        int p1 = CONTAINER->params[0];
    834e:	ldr	r7, [r4, #20]
        int p2 = CONTAINER->params[1];
    8350:	ldr.w	r9, [r4, #24]
        int p3 = CONTAINER->params[2];
    8354:	ldr	r3, [r4, #28]
        int id = CONTAINER->transaction_id;
    8356:	ldr.w	fp, [r4, #16]
        int len= CONTAINER->len;
    835a:	ldr.w	sl, [r4, #8]
        int typ= CONTAINER->type;

        int return_code =0x2001; //OK use as default value
    835e:	movw	r1, #8197	; 0x2005
    8362:	movw	r8, #8193	; 0x2001

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    8366:	movw	r0, #4108	; 0x100c
        int p3 = CONTAINER->params[2];
        int id = CONTAINER->transaction_id;
        int len= CONTAINER->len;
        int typ= CONTAINER->type;

        int return_code =0x2001; //OK use as default value
    836a:	cmp	r6, #2
    836c:	ite	eq
    836e:	moveq	r6, r1
    8370:	movne	r6, r8

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    8372:	cmp	r2, r0
    8374:	beq.w	8802 <MTPD::loop()+0x4d2>
    8378:	bhi.n	8404 <MTPD::loop()+0xd4>
    837a:	movw	r1, #4101	; 0x1005
    837e:	cmp	r2, r1
    8380:	beq.w	87a4 <MTPD::loop()+0x474>
    8384:	bls.w	84e8 <MTPD::loop()+0x1b8>
    8388:	movw	r1, #4104	; 0x1008
    838c:	cmp	r2, r1
    838e:	beq.w	8608 <MTPD::loop()+0x2d8>
    8392:	bhi.w	856c <MTPD::loop()+0x23c>
    8396:	movw	r1, #4102	; 0x1006
    839a:	cmp	r2, r1
    839c:	beq.w	8598 <MTPD::loop()+0x268>
    83a0:	movw	r1, #4103	; 0x1007
    83a4:	cmp	r2, r1
    83a6:	bne.w	87e8 <MTPD::loop()+0x4b8>
            break;

          case 0x1007:  // GetObjectHandles
            //printContainer(); 

            if (p2) 
    83aa:	cmp.w	r9, #0
    83ae:	beq.w	8848 <MTPD::loop()+0x518>
    83b2:	movw	r0, #8212	; 0x2014
    83b6:	b.n	8474 <MTPD::loop()+0x144>

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    83b8:	movw	r3, #38915	; 0x9803
    83bc:	cmp	r2, r3
    83be:	beq.w	86de <MTPD::loop()+0x3ae>
    83c2:	movw	r3, #38916	; 0x9804
    83c6:	cmp	r2, r3
    83c8:	bne.w	87e8 <MTPD::loop()+0x4b8>
      storage_->close();
    }

    uint32_t MTPD::setObjectPropValue(uint32_t p1, uint32_t p2)
    {
      receive_buffer();
    83cc:	mov	r0, r5
    83ce:	str	r1, [sp, #4]
    83d0:	bl	8038 <MTPD::receive_buffer()>

      if(p2==0xDC07)
    83d4:	movw	r3, #56327	; 0xdc07
    83d8:	cmp	r9, r3
    83da:	ldr	r1, [sp, #4]
    83dc:	bne.n	8472 <MTPD::loop()+0x142>
    83de:	mov	r0, r5
    83e0:	mov	r1, r7
    83e2:	bl	81b8 <MTPD::setObjectPropValue(unsigned long, unsigned long) [clone .part.8]>
          default:
              return_code = 0x2005;  // operation not supported
              break;
        }

        if (return_code) {
    83e6:	cmp	r0, #0
    83e8:	bne.w	88d2 <MTPD::loop()+0x5a2>

          PrintPacket(receive_buffer);
          usb_tx(MTP_TX_ENDPOINT, receive_buffer);
          receive_buffer = 0;
        } else {
            usb_free(receive_buffer);
    83ec:	mov	r0, r4
    83ee:	bl	9c94 <usb_free>
        }
      }
      // Maybe put event handling inside mtp_yield()?
      if ((receive_buffer = usb_rx(MTP_EVENT_ENDPOINT))) {
    83f2:	movs	r0, #6
    83f4:	bl	9ce0 <usb_rx>
    83f8:	cbz	r0, 83fe <MTPD::loop()+0xce>
        usb_free(receive_buffer);
    83fa:	bl	9c94 <usb_free>
      }
    }
    83fe:	add	sp, #28
    8400:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    8404:	movw	r0, #4121	; 0x1019
    8408:	cmp	r2, r0
    840a:	beq.w	87ee <MTPD::loop()+0x4be>
    840e:	bls.n	848e <MTPD::loop()+0x15e>
    8410:	movw	r3, #38914	; 0x9802
    8414:	cmp	r2, r3
    8416:	beq.w	85c0 <MTPD::loop()+0x290>
    841a:	bhi.n	83b8 <MTPD::loop()+0x88>
    841c:	movw	r3, #4122	; 0x101a
    8420:	cmp	r2, r3
    8422:	beq.n	8472 <MTPD::loop()+0x142>
    8424:	movw	r3, #38913	; 0x9801
    8428:	cmp	r2, r3
    842a:	bne.w	87e8 <MTPD::loop()+0x4b8>
              return_code = 0x2005;
              break;

          case 0x9801:  // getObjectPropsSupported

              TRANSMIT(getObjectPropsSupported(p1));
    842e:	mov.w	r8, #0
    8432:	movs	r3, #1
    8434:	strb	r3, [r5, #8]
    8436:	mov	r1, r7
    8438:	mov	r0, r5
    843a:	str.w	r8, [r5, #12]
    843e:	bl	7614 <MTPD::getObjectPropsSupported(unsigned long)>
    8442:	ldr	r3, [r5, #12]
    8444:	strb.w	r8, [r5, #8]
    8448:	adds	r3, #12
    844a:	movs	r2, #2
    844c:	strh.w	r2, [sp, #16]
    8450:	str	r3, [sp, #12]
    8452:	ldrh	r3, [r4, #14]
    8454:	strh.w	r3, [sp, #18]
    8458:	movs	r2, #12
    845a:	ldr	r3, [r4, #16]
    845c:	str	r3, [sp, #20]
    845e:	add.w	r1, sp, r2
    8462:	mov	r0, r5
    8464:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    8468:	mov	r1, r7
    846a:	mov	r0, r5
    846c:	bl	7614 <MTPD::getObjectPropsSupported(unsigned long)>
    8470:	b.n	8546 <MTPD::loop()+0x216>

    uint32_t MTPD::setObjectPropValue(uint32_t p1, uint32_t p2)
    {
      receive_buffer();

      if(p2==0xDC07)
    8472:	mov	r0, r1
              return_code = 0x2005;  // operation not supported
              break;
        }

        if (return_code) {
            CONTAINER->type=3;
    8474:	movs	r3, #3
            CONTAINER->len=len;
            CONTAINER->op=return_code;
    8476:	strh	r0, [r4, #14]
              break;
        }

        if (return_code) {
            CONTAINER->type=3;
            CONTAINER->len=len;
    8478:	str.w	sl, [r4, #8]
            CONTAINER->op=return_code;
            CONTAINER->transaction_id=id;
    847c:	str.w	fp, [r4, #16]
            CONTAINER->params[0]=p1;
    8480:	str	r7, [r4, #20]
              return_code = 0x2005;  // operation not supported
              break;
        }

        if (return_code) {
            CONTAINER->type=3;
    8482:	strh	r3, [r4, #12]
            CONTAINER->op=return_code;
            CONTAINER->transaction_id=id;
            CONTAINER->params[0]=p1;

          PrintPacket(receive_buffer);
          usb_tx(MTP_TX_ENDPOINT, receive_buffer);
    8484:	mov	r1, r4
    8486:	movs	r0, #4
    8488:	bl	9e50 <usb_tx>
    848c:	b.n	83f2 <MTPD::loop()+0xc2>

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    848e:	movw	r3, #4112	; 0x1010
    8492:	cmp	r2, r3
    8494:	beq.n	8472 <MTPD::loop()+0x142>
    8496:	bls.w	8730 <MTPD::loop()+0x400>
    849a:	movw	r3, #4116	; 0x1014
    849e:	cmp	r2, r3
    84a0:	beq.w	8690 <MTPD::loop()+0x360>
    84a4:	movw	r3, #4117	; 0x1015
    84a8:	cmp	r2, r3
    84aa:	bne.w	87e8 <MTPD::loop()+0x4b8>
      writestring("1.0");      // version
      writestring("???");      // serial
    }

    void MTPD::GetDevicePropValue(uint32_t prop) {
      switch (prop) {
    84ae:	movw	r3, #54274	; 0xd402
          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;

          case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    84b2:	mov.w	r8, #0
    84b6:	movs	r2, #1
      writestring("1.0");      // version
      writestring("???");      // serial
    }

    void MTPD::GetDevicePropValue(uint32_t prop) {
      switch (prop) {
    84b8:	cmp	r7, r3
          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;

          case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    84ba:	str.w	r8, [r5, #12]
    84be:	strb	r2, [r5, #8]
      writestring("1.0");      // version
      writestring("???");      // serial
    }

    void MTPD::GetDevicePropValue(uint32_t prop) {
      switch (prop) {
    84c0:	beq.w	8890 <MTPD::loop()+0x560>
          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;

          case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    84c4:	movs	r2, #12
    84c6:	movs	r3, #2
    84c8:	strb.w	r8, [r5, #8]
    84cc:	str	r2, [sp, #12]
    84ce:	strh.w	r3, [sp, #16]
    84d2:	ldrh	r3, [r4, #14]
    84d4:	strh.w	r3, [sp, #18]
    84d8:	ldr	r3, [r4, #16]
    84da:	str	r3, [sp, #20]
    84dc:	add.w	r1, sp, r2
    84e0:	mov	r0, r5
    84e2:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    84e6:	b.n	8546 <MTPD::loop()+0x216>

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    84e8:	movw	r3, #4098	; 0x1002
    84ec:	cmp	r2, r3
    84ee:	beq.w	8820 <MTPD::loop()+0x4f0>
    84f2:	bls.w	8746 <MTPD::loop()+0x416>
    84f6:	movw	r3, #4099	; 0x1003
    84fa:	cmp	r2, r3
    84fc:	beq.n	85bc <MTPD::loop()+0x28c>
    84fe:	movw	r3, #4100	; 0x1004
    8502:	cmp	r2, r3
    8504:	bne.w	87e8 <MTPD::loop()+0x4b8>
          case 0x1003:  // CloseSession
            //
            break;

          case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
    8508:	movs	r3, #1
    850a:	mov.w	r8, #0
    850e:	strb	r3, [r5, #8]
    8510:	mov	r0, r5
    8512:	str.w	r8, [r5, #12]
    8516:	bl	7320 <MTPD::WriteStorageIDs()>
    851a:	ldr	r3, [r5, #12]
    851c:	strb.w	r8, [r5, #8]
    8520:	adds	r3, #12
    8522:	movs	r2, #2
    8524:	strh.w	r2, [sp, #16]
    8528:	str	r3, [sp, #12]
    852a:	ldrh	r3, [r4, #14]
    852c:	strh.w	r3, [sp, #18]
    8530:	movs	r2, #12
    8532:	ldr	r3, [r4, #16]
    8534:	str	r3, [sp, #20]
    8536:	mov	r0, r5
    8538:	add.w	r1, sp, r2
    853c:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    8540:	mov	r0, r5
    8542:	bl	7320 <MTPD::WriteStorageIDs()>
          TRANSMIT(getObjectPropDesc(p1,p2));
              break;

          case 0x9803:  // getObjectPropertyValue

            TRANSMIT(getObjectPropValue(p1,p2));
    8546:	mov	r0, r5
    8548:	bl	6f1c <MTPD::get_buffer()>
    854c:	ldr	r1, [r5, #4]
      }
      Serial1.println("");
  #endif
  #if 1
      MTPContainer *tmp = (struct MTPContainer*)(x->buf);
      if(tmp->type==1)
    854e:	ldrh	r3, [r1, #12]
    8550:	cmp	r3, #1
    8552:	beq.w	8726 <MTPD::loop()+0x3f6>
          TRANSMIT(getObjectPropDesc(p1,p2));
              break;

          case 0x9803:  // getObjectPropertyValue

            TRANSMIT(getObjectPropValue(p1,p2));
    8556:	movs	r0, #4
    8558:	bl	9e50 <usb_tx>
    855c:	movs	r3, #0
    855e:	uxth	r0, r6
    8560:	str	r3, [r5, #4]
              break;
    8562:	b.n	8474 <MTPD::loop()+0x144>
    8564:	bl	6e5c <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]>
    8568:	ldrh	r6, [r4, #12]
    856a:	b.n	834c <MTPD::loop()+0x1c>

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    856c:	movw	r3, #4105	; 0x1009
    8570:	cmp	r2, r3
    8572:	beq.n	864c <MTPD::loop()+0x31c>
    8574:	movw	r3, #4107	; 0x100b
    8578:	cmp	r2, r3
    857a:	bne.w	87e8 <MTPD::loop()+0x4b8>
          case 0x1009:  // GetObject
            TRANSMIT(GetObject(p1));
            break;

          case 0x100B:  // DeleteObject
            if (CONTAINER->len>16 && p2) 
    857e:	cmp.w	sl, #16
    8582:	bls.w	882c <MTPD::loop()+0x4fc>
    8586:	cmp.w	r9, #0
    858a:	beq.w	882c <MTPD::loop()+0x4fc>
    858e:	movw	r0, #8212	; 0x2014
                return_code = 0x2014; // spec by format unsupported
            } else 
            {  return_code = deleteObject(p1);
            }
              CONTAINER->len  = len = 12;
            break;
    8592:	mov.w	sl, #12
    8596:	b.n	8474 <MTPD::loop()+0x144>
          case 0x1005:  // GetStorageInfo
            TRANSMIT(GetStorageInfo(p1));
            break;

          case 0x1006:  // GetNumObjects
            if (CONTAINER->params[1]) 
    8598:	cmp.w	r9, #0
    859c:	bne.w	83b2 <MTPD::loop()+0x82>
      writestring("");  // volume identifier
    }

    uint32_t MTPD::GetNumObjects(uint32_t storage, uint32_t parent) 
    {
      storage_->StartGetObjectHandles(parent);
    85a0:	ldr	r0, [r5, #0]
    85a2:	ldr	r2, [r0, #0]
    85a4:	mov	r1, r3
    85a6:	ldr	r3, [r2, #16]
    85a8:	blx	r3
      int num = 0;
    85aa:	mov	r7, r9
    85ac:	b.n	85b0 <MTPD::loop()+0x280>
      while (storage_->GetNextObjectHandle()) num++;
    85ae:	adds	r7, #1
    85b0:	ldr	r0, [r5, #0]
    85b2:	ldr	r3, [r0, #0]
    85b4:	ldr	r3, [r3, #20]
    85b6:	blx	r3
    85b8:	cmp	r0, #0
    85ba:	bne.n	85ae <MTPD::loop()+0x27e>
    85bc:	uxth	r0, r6
    85be:	b.n	8474 <MTPD::loop()+0x144>
              TRANSMIT(getObjectPropsSupported(p1));
              break;

          case 0x9802:  // getObjectPropDesc

          TRANSMIT(getObjectPropDesc(p1,p2));
    85c0:	mov.w	r8, #0
    85c4:	movs	r3, #1
    85c6:	strb	r3, [r5, #8]
    85c8:	mov	r2, r9
    85ca:	mov	r1, r7
    85cc:	mov	r0, r5
    85ce:	str.w	r8, [r5, #12]
    85d2:	bl	7950 <MTPD::getObjectPropDesc(unsigned long, unsigned long)>
    85d6:	ldr	r3, [r5, #12]
    85d8:	strb.w	r8, [r5, #8]
    85dc:	adds	r3, #12
    85de:	movs	r2, #2
    85e0:	strh.w	r2, [sp, #16]
    85e4:	str	r3, [sp, #12]
    85e6:	ldrh	r3, [r4, #14]
    85e8:	strh.w	r3, [sp, #18]
    85ec:	movs	r2, #12
    85ee:	add.w	r1, sp, r2
    85f2:	ldr	r3, [r4, #16]
    85f4:	str	r3, [sp, #20]
    85f6:	mov	r0, r5
    85f8:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    85fc:	mov	r2, r9
    85fe:	mov	r1, r7
    8600:	mov	r0, r5
    8602:	bl	7950 <MTPD::getObjectPropDesc(unsigned long, unsigned long)>
    8606:	b.n	8546 <MTPD::loop()+0x216>
              TRANSMIT(GetObjectHandles(p1, p3));
            }
            break;

          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
    8608:	mov.w	r8, #0
    860c:	movs	r3, #1
    860e:	strb	r3, [r5, #8]
    8610:	mov	r1, r7
    8612:	mov	r0, r5
    8614:	str.w	r8, [r5, #12]
    8618:	bl	73d8 <MTPD::GetObjectInfo(unsigned long)>
    861c:	ldr	r3, [r5, #12]
    861e:	strb.w	r8, [r5, #8]
    8622:	adds	r3, #12
    8624:	movs	r2, #2
    8626:	strh.w	r2, [sp, #16]
    862a:	str	r3, [sp, #12]
    862c:	ldrh	r3, [r4, #14]
    862e:	strh.w	r3, [sp, #18]
    8632:	movs	r2, #12
    8634:	ldr	r3, [r4, #16]
    8636:	str	r3, [sp, #20]
    8638:	add.w	r1, sp, r2
    863c:	mov	r0, r5
    863e:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    8642:	mov	r1, r7
    8644:	mov	r0, r5
    8646:	bl	73d8 <MTPD::GetObjectInfo(unsigned long)>
    864a:	b.n	8546 <MTPD::loop()+0x216>
            break;

          case 0x1009:  // GetObject
            TRANSMIT(GetObject(p1));
    864c:	mov.w	r8, #0
    8650:	movs	r3, #1
    8652:	strb	r3, [r5, #8]
    8654:	mov	r1, r7
    8656:	mov	r0, r5
    8658:	str.w	r8, [r5, #12]
    865c:	bl	8054 <MTPD::GetObject(unsigned long)>
    8660:	ldr	r3, [r5, #12]
    8662:	strb.w	r8, [r5, #8]
    8666:	adds	r3, #12
    8668:	movs	r2, #2
    866a:	strh.w	r2, [sp, #16]
    866e:	str	r3, [sp, #12]
    8670:	ldrh	r3, [r4, #14]
    8672:	strh.w	r3, [sp, #18]
    8676:	movs	r2, #12
    8678:	ldr	r3, [r4, #16]
    867a:	str	r3, [sp, #20]
    867c:	add.w	r1, sp, r2
    8680:	mov	r0, r5
    8682:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    8686:	mov	r1, r7
    8688:	mov	r0, r5
    868a:	bl	8054 <MTPD::GetObject(unsigned long)>
    868e:	b.n	8546 <MTPD::loop()+0x216>
          break;
      }
    }

    void MTPD::GetDevicePropDesc(uint32_t prop) {
      switch (prop) {
    8690:	movw	r3, #54274	; 0xd402
              SendObject();
              CONTAINER->len  = len = 12;
              break;

          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    8694:	mov.w	r8, #0
    8698:	movs	r2, #1
          break;
      }
    }

    void MTPD::GetDevicePropDesc(uint32_t prop) {
      switch (prop) {
    869a:	cmp	r7, r3
              SendObject();
              CONTAINER->len  = len = 12;
              break;

          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    869c:	str.w	r8, [r5, #12]
    86a0:	strb	r2, [r5, #8]
          break;
      }
    }

    void MTPD::GetDevicePropDesc(uint32_t prop) {
      switch (prop) {
    86a2:	bne.w	84c4 <MTPD::loop()+0x194>
    86a6:	mov	r1, r7
    86a8:	mov	r0, r5
    86aa:	bl	7050 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]>
              SendObject();
              CONTAINER->len  = len = 12;
              break;

          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    86ae:	ldr	r3, [r5, #12]
    86b0:	strb.w	r8, [r5, #8]
    86b4:	adds	r3, #12
    86b6:	movs	r2, #2
    86b8:	strh.w	r2, [sp, #16]
    86bc:	str	r3, [sp, #12]
    86be:	ldrh	r3, [r4, #14]
    86c0:	strh.w	r3, [sp, #18]
    86c4:	movs	r2, #12
    86c6:	ldr	r3, [r4, #16]
    86c8:	str	r3, [sp, #20]
    86ca:	add.w	r1, sp, r2
    86ce:	mov	r0, r5
    86d0:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    86d4:	mov	r1, r7
    86d6:	mov	r0, r5
    86d8:	bl	7050 <MTPD::GetDevicePropDesc(unsigned long) [clone .part.6]>
    86dc:	b.n	8546 <MTPD::loop()+0x216>
          TRANSMIT(getObjectPropDesc(p1,p2));
              break;

          case 0x9803:  // getObjectPropertyValue

            TRANSMIT(getObjectPropValue(p1,p2));
    86de:	mov.w	r8, #0
    86e2:	movs	r3, #1
    86e4:	strb	r3, [r5, #8]
    86e6:	mov	r2, r9
    86e8:	mov	r1, r7
    86ea:	mov	r0, r5
    86ec:	str.w	r8, [r5, #12]
    86f0:	bl	7680 <MTPD::getObjectPropValue(unsigned long, unsigned long)>
    86f4:	ldr	r3, [r5, #12]
    86f6:	strb.w	r8, [r5, #8]
    86fa:	adds	r3, #12
    86fc:	movs	r2, #2
    86fe:	strh.w	r2, [sp, #16]
    8702:	str	r3, [sp, #12]
    8704:	ldrh	r3, [r4, #14]
    8706:	strh.w	r3, [sp, #18]
    870a:	movs	r2, #12
    870c:	add.w	r1, sp, r2
    8710:	ldr	r3, [r4, #16]
    8712:	str	r3, [sp, #20]
    8714:	mov	r0, r5
    8716:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    871a:	mov	r2, r9
    871c:	mov	r1, r7
    871e:	mov	r0, r5
    8720:	bl	7680 <MTPD::getObjectPropValue(unsigned long, unsigned long)>
    8724:	b.n	8546 <MTPD::loop()+0x216>
    8726:	mov	r0, r1
    8728:	bl	6e5c <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]>
    872c:	ldr	r1, [r5, #4]
    872e:	b.n	8556 <MTPD::loop()+0x226>

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    8730:	movw	r3, #4109	; 0x100d
    8734:	cmp	r2, r3
    8736:	bne.n	87e8 <MTPD::loop()+0x4b8>
              CONTAINER->params[1]=p2;
              CONTAINER->len  = len = 12 + 3 * 4;
              break;

          case 0x100D:  // SendObject
              SendObject();
    8738:	mov	r0, r5
    873a:	bl	82cc <MTPD::SendObject()>
              CONTAINER->len  = len = 12;
              break;
    873e:	mov.w	sl, #12
    8742:	uxth	r0, r6
    8744:	b.n	8474 <MTPD::loop()+0x144>

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    8746:	movw	r3, #4097	; 0x1001
    874a:	cmp	r2, r3
    874c:	bne.n	87e8 <MTPD::loop()+0x4b8>
        {
          case 0x1001:
            p1=0;
            TRANSMIT(WriteDescriptor());
    874e:	movs	r3, #1
    8750:	movs	r7, #0
    8752:	strb	r3, [r5, #8]
    8754:	mov	r0, r5
    8756:	str	r7, [r5, #12]
    8758:	bl	710c <MTPD::WriteDescriptor()>
    875c:	ldr	r3, [r5, #12]
    875e:	strb	r7, [r5, #8]
    8760:	adds	r3, #12
    8762:	movs	r2, #2
    8764:	strh.w	r2, [sp, #16]
    8768:	str	r3, [sp, #12]
    876a:	ldrh	r3, [r4, #14]
    876c:	strh.w	r3, [sp, #18]
    8770:	movs	r2, #12
    8772:	ldr	r3, [r4, #16]
    8774:	str	r3, [sp, #20]
    8776:	add.w	r1, sp, r2
    877a:	mov	r0, r5
    877c:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    8780:	mov	r0, r5
    8782:	bl	710c <MTPD::WriteDescriptor()>
    8786:	mov	r0, r5
    8788:	bl	6f1c <MTPD::get_buffer()>
    878c:	ldr	r1, [r5, #4]
      }
      Serial1.println("");
  #endif
  #if 1
      MTPContainer *tmp = (struct MTPContainer*)(x->buf);
      if(tmp->type==1)
    878e:	ldrh	r3, [r1, #12]
    8790:	cmp	r3, #1
    8792:	beq.w	88c8 <MTPD::loop()+0x598>

        switch (op)
        {
          case 0x1001:
            p1=0;
            TRANSMIT(WriteDescriptor());
    8796:	movs	r0, #4
    8798:	movs	r7, #0
    879a:	bl	9e50 <usb_tx>
    879e:	uxth	r0, r6
    87a0:	str	r7, [r5, #4]
            break;
    87a2:	b.n	8474 <MTPD::loop()+0x144>
          case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
            break;

          case 0x1005:  // GetStorageInfo
            TRANSMIT(GetStorageInfo(p1));
    87a4:	mov.w	r8, #0
    87a8:	movs	r3, #1
    87aa:	strb	r3, [r5, #8]
    87ac:	mov	r1, r7
    87ae:	mov	r0, r5
    87b0:	str.w	r8, [r5, #12]
    87b4:	bl	7824 <MTPD::GetStorageInfo(unsigned long)>
    87b8:	ldr	r3, [r5, #12]
    87ba:	strb.w	r8, [r5, #8]
    87be:	adds	r3, #12
    87c0:	movs	r2, #2
    87c2:	strh.w	r2, [sp, #16]
    87c6:	str	r3, [sp, #12]
    87c8:	ldrh	r3, [r4, #14]
    87ca:	strh.w	r3, [sp, #18]
    87ce:	movs	r2, #12
    87d0:	ldr	r3, [r4, #16]
    87d2:	str	r3, [sp, #20]
    87d4:	add.w	r1, sp, r2
    87d8:	mov	r0, r5
    87da:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    87de:	mov	r1, r7
    87e0:	mov	r0, r5
    87e2:	bl	7824 <MTPD::GetStorageInfo(unsigned long)>
    87e6:	b.n	8546 <MTPD::loop()+0x216>
              return_code = setObjectPropValue(p1,p2);
              break;

          default:
              return_code = 0x2005;  // operation not supported
              break;
    87e8:	movw	r0, #8197	; 0x2005
    87ec:	b.n	8474 <MTPD::loop()+0x144>
    }

    uint32_t MTPD::moveObject(uint32_t p1, uint32_t p3)
    { // p1 object
      // p3 new directory
      storage_->move(p1,p3);
    87ee:	ldr	r0, [r5, #0]
    87f0:	ldr	r1, [r0, #0]
    87f2:	mov	r2, r3
    87f4:	ldr	r3, [r1, #60]	; 0x3c
    87f6:	mov	r1, r7
    87f8:	blx	r3
              break;

          case 0x1019:  // MoveObject
              return_code = moveObject(p1,p3);
              CONTAINER->len  = len = 12;
              break;
    87fa:	mov.w	sl, #12
    87fe:	mov	r0, r8
    8800:	b.n	8474 <MTPD::loop()+0x144>
    8802:	cmp	r7, #0
    8804:	it	eq
    8806:	moveq	r7, #1
              CONTAINER->len  = len = 12;
            break;

          case 0x100C:  // SendObjectInfo
              if (!p1) p1 = 1;
              CONTAINER->params[2] = SendObjectInfo(p1, // storage
    8808:	mov	r0, r5
    880a:	mov	r1, r7
    880c:	mov	r2, r9
    880e:	bl	81fc <MTPD::SendObjectInfo(unsigned long, unsigned long)>
                                                    p2); // parent

              CONTAINER->params[1]=p2;
              CONTAINER->len  = len = 12 + 3 * 4;
              break;
    8812:	mov.w	sl, #24
            break;

          case 0x100C:  // SendObjectInfo
              if (!p1) p1 = 1;
              CONTAINER->params[2] = SendObjectInfo(p1, // storage
                                                    p2); // parent
    8816:	str	r0, [r4, #28]

              CONTAINER->params[1]=p2;
    8818:	str.w	r9, [r4, #24]
    881c:	uxth	r0, r6
              CONTAINER->len  = len = 12 + 3 * 4;
              break;
    881e:	b.n	8474 <MTPD::loop()+0x144>
      write32(1); // 1 storage
    }

    void MTPD::OpenSession(void)
    {
      storage_->ResetIndex();
    8820:	ldr	r0, [r5, #0]
    8822:	ldr	r3, [r0, #0]
    8824:	ldr	r3, [r3, #64]	; 0x40
    8826:	blx	r3
    8828:	uxth	r0, r6
    882a:	b.n	8474 <MTPD::loop()+0x144>
      }
    }

    uint32_t MTPD::deleteObject(uint32_t p1)
    {
        if (!storage_->DeleteObject(p1))
    882c:	ldr	r0, [r5, #0]
    882e:	ldr	r3, [r0, #0]
    8830:	mov	r1, r7
    8832:	ldr	r3, [r3, #52]	; 0x34
    8834:	blx	r3
    8836:	movw	r1, #8193	; 0x2001
    883a:	movw	r3, #8210	; 0x2012
    883e:	cmp	r0, #0
    8840:	ite	ne
    8842:	movne	r0, r1
    8844:	moveq	r0, r3
    8846:	b.n	8592 <MTPD::loop()+0x262>

            if (p2) 
            { return_code = 0x2014; // spec by format unsupported
            } else 
            { 
              TRANSMIT(GetObjectHandles(p1, p3));
    8848:	movs	r2, #1
    884a:	strb	r2, [r5, #8]
    884c:	mov	r1, r7
    884e:	mov	r2, r3
    8850:	mov	r0, r5
    8852:	str.w	r9, [r5, #12]
    8856:	str	r3, [sp, #4]
    8858:	bl	7360 <MTPD::GetObjectHandles(unsigned long, unsigned long)>
    885c:	ldr	r2, [r5, #12]
    885e:	strb.w	r9, [r5, #8]
    8862:	adds	r2, #12
    8864:	movs	r1, #2
    8866:	strh.w	r1, [sp, #16]
    886a:	str	r2, [sp, #12]
    886c:	ldrh	r2, [r4, #14]
    886e:	strh.w	r2, [sp, #18]
    8872:	ldr	r2, [r4, #16]
    8874:	str	r2, [sp, #20]
    8876:	movs	r2, #12
    8878:	add.w	r1, sp, r2
    887c:	mov	r0, r5
    887e:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    8882:	ldr	r3, [sp, #4]
    8884:	mov	r1, r7
    8886:	mov	r2, r3
    8888:	mov	r0, r5
    888a:	bl	7360 <MTPD::GetObjectHandles(unsigned long, unsigned long)>
    888e:	b.n	8546 <MTPD::loop()+0x216>
    void MTPD::GetDevicePropValue(uint32_t prop) {
      switch (prop) {
        case 0xd402: // friendly name
          // This is the name we'll actually see in the windows explorer.
          // Should probably be configurable.
          writestring("Teensy");
    8890:	mov	r0, r5
    8892:	ldr	r1, [pc, #68]	; (88d8 <MTPD::loop()+0x5a8>)
    8894:	bl	6fa8 <MTPD::writestring(char const*)>
          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;

          case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    8898:	ldr	r3, [r5, #12]
    889a:	strb.w	r8, [r5, #8]
    889e:	adds	r3, #12
    88a0:	movs	r2, #2
    88a2:	strh.w	r2, [sp, #16]
    88a6:	str	r3, [sp, #12]
    88a8:	ldrh	r3, [r4, #14]
    88aa:	strh.w	r3, [sp, #18]
    88ae:	movs	r2, #12
    88b0:	ldr	r3, [r4, #16]
    88b2:	str	r3, [sp, #20]
    88b4:	add.w	r1, sp, r2
    88b8:	mov	r0, r5
    88ba:	bl	6f34 <MTPD::write(char const*, int) [clone .part.4]>
    void MTPD::GetDevicePropValue(uint32_t prop) {
      switch (prop) {
        case 0xd402: // friendly name
          // This is the name we'll actually see in the windows explorer.
          // Should probably be configurable.
          writestring("Teensy");
    88be:	ldr	r1, [pc, #24]	; (88d8 <MTPD::loop()+0x5a8>)
    88c0:	mov	r0, r5
    88c2:	bl	6fa8 <MTPD::writestring(char const*)>
    88c6:	b.n	8546 <MTPD::loop()+0x216>
    88c8:	mov	r0, r1
    88ca:	bl	6e5c <MTPD::PrintPacket(usb_packet_struct const*) [clone .part.2]>
    88ce:	ldr	r1, [r5, #4]
    88d0:	b.n	8796 <MTPD::loop()+0x466>
    88d2:	uxth	r0, r0
    88d4:	b.n	8474 <MTPD::loop()+0x144>
    88d6:	nop
    88d8:	.word	0x0000c510

000088dc <EventResponder::triggerEvent(int, void*)>:
	}

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
    88dc:	push	{r4}
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    88de:	ldrb	r4, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    88e0:	str	r1, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    88e2:	cmp	r4, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    88e4:	str	r2, [r0, #12]
		if (_type == EventTypeImmediate) {
    88e6:	beq.n	88f0 <EventResponder::triggerEvent(int, void*)+0x14>
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
		}
	}
    88e8:	ldr.w	r4, [sp], #4
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    88ec:	b.w	aab4 <EventResponder::triggerEventNotImmediate()>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    88f0:	ldr	r3, [r0, #8]
		} else {
			triggerEventNotImmediate();
		}
	}
    88f2:	ldr.w	r4, [sp], #4
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    88f6:	bx	r3

000088f8 <breakTime(long, tmElements_t&)>:
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    88f8:	ldr	r2, [pc, #400]	; (8a8c <breakTime(long, tmElements_t&)+0x194>)
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    88fa:	ldr	r3, [pc, #404]	; (8a90 <breakTime(long, tmElements_t&)+0x198>)
// leap year calulator expects year argument as years offset from 1970
#define LEAP_YEAR(Y)     ( ((1970+(Y))>0) && !((1970+(Y))%4) && ( ((1970+(Y))%100) || !((1970+(Y))%400) ) )

static  const uint8_t monthDays[]={31,28,31,30,31,30,31,31,30,31,30,31}; // API starts months from 1, this array starts from 0
 
void breakTime(time_t timeInput, tmElements_t &tm){
    88fc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    8900:	ldr	r6, [pc, #400]	; (8a94 <breakTime(long, tmElements_t&)+0x19c>)
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    8902:	ldr.w	sl, [pc, #416]	; 8aa4 <breakTime(long, tmElements_t&)+0x1ac>
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    8906:	ldr	r4, [pc, #400]	; (8a98 <breakTime(long, tmElements_t&)+0x1a0>)
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
  
  year = 0;  
  days = 0;
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    8908:	ldr.w	r9, [pc, #400]	; 8a9c <breakTime(long, tmElements_t&)+0x1a4>
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
    890c:	umull	r5, r2, r2, r0
    8910:	mov.w	ip, r2, lsr #16
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    8914:	add.w	r7, ip, #4
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    8918:	umull	r2, r5, r3, r0
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    891c:	umull	r6, r2, r6, r0
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    8920:	umull	sl, fp, r7, sl
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    8924:	lsrs	r5, r5, #5
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    8926:	lsrs	r2, r2, #11
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    8928:	umull	r6, r3, r3, r5
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    892c:	umull	r6, r4, r4, r2
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    8930:	rsb	r6, fp, r7
    8934:	add.w	r6, fp, r6, lsr #1
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    8938:	lsrs	r3, r3, #5
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    893a:	lsrs	r6, r6, #2
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    893c:	lsrs	r4, r4, #4
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    893e:	rsb	r6, r6, r6, lsl #3
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    8942:	rsb	r3, r3, r3, lsl #4
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    8946:	add.w	r4, r4, r4, lsl #1
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    894a:	sub.w	r3, r5, r3, lsl #2
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    894e:	subs	r6, r7, r6
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    8950:	rsb	r5, r5, r5, lsl #4
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    8954:	sub.w	r2, r2, r4, lsl #3
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    8958:	sub.w	r0, r0, r5, lsl #2
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    895c:	adds	r6, #1
    895e:	movs	r4, #0
  time = (uint32_t)timeInput;
  tm.Second = time % 60;
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
  time /= 60; // now it is hours
  tm.Hour = time % 24;
    8960:	strb	r2, [r1, #2]
  uint8_t month, monthLength;
  uint32_t time;
  unsigned long days;

  time = (uint32_t)timeInput;
  tm.Second = time % 60;
    8962:	strb	r0, [r1, #0]
  time /= 60; // now it is minutes
  tm.Minute = time % 60;
    8964:	strb	r3, [r1, #1]
  time /= 60; // now it is hours
  tm.Hour = time % 24;
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
    8966:	strb	r6, [r1, #3]
  
  year = 0;  
  days = 0;
    8968:	mov	r2, r4
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    896a:	movw	fp, #365	; 0x16d
    896e:	mov.w	r8, #100	; 0x64
    8972:	mov.w	sl, #400	; 0x190
    8976:	b.n	8996 <breakTime(long, tmElements_t&)+0x9e>
    8978:	rsb	r5, r6, r5, asr #7
    897c:	mls	r5, sl, r5, r3
    8980:	cbnz	r0, 89e0 <breakTime(long, tmElements_t&)+0xe8>
    8982:	cmp	r5, #0
    8984:	ite	ne
    8986:	movne	r0, fp
    8988:	moveq.w	r0, #366	; 0x16e
    898c:	add	r2, r0
    898e:	cmp	ip, r2
    8990:	add.w	r4, r4, #1
    8994:	bcc.n	89be <breakTime(long, tmElements_t&)+0xc6>
    8996:	uxtb	r7, r4
    8998:	addw	r3, r7, #1970	; 0x7b2
    899c:	smull	r0, r5, r9, r3
    89a0:	asrs	r6, r3, #31
    89a2:	rsb	r0, r6, r5, asr #5
    89a6:	ands.w	lr, r3, #3
    89aa:	mls	r0, r8, r0, r3
    89ae:	beq.n	8978 <breakTime(long, tmElements_t&)+0x80>
    89b0:	movw	r0, #365	; 0x16d
    89b4:	add	r2, r0
    89b6:	cmp	ip, r2
    89b8:	add.w	r4, r4, #1
    89bc:	bcs.n	8996 <breakTime(long, tmElements_t&)+0x9e>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
    89be:	strb	r7, [r1, #6]
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    89c0:	cmp.w	lr, #0
    89c4:	bne.n	89e6 <breakTime(long, tmElements_t&)+0xee>
    89c6:	ldr	r0, [pc, #212]	; (8a9c <breakTime(long, tmElements_t&)+0x1a4>)
    89c8:	asrs	r6, r3, #31
    89ca:	smull	r4, r0, r0, r3
    89ce:	rsb	r4, r6, r0, asr #5
    89d2:	movs	r5, #100	; 0x64
    89d4:	mls	r4, r5, r4, r3
    89d8:	cbz	r4, 8a4a <breakTime(long, tmElements_t&)+0x152>
    89da:	mov.w	r4, #366	; 0x16e
    89de:	b.n	89ec <breakTime(long, tmElements_t&)+0xf4>
  time /= 24; // now it is days
  tm.Wday = ((time + 4) % 7) + 1;  // Sunday is day 1 
  
  year = 0;  
  days = 0;
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    89e0:	mov.w	r0, #366	; 0x16e
    89e4:	b.n	898c <breakTime(long, tmElements_t&)+0x94>
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    89e6:	movw	r4, #365	; 0x16d
    89ea:	asrs	r6, r3, #31
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    89ec:	ldr	r0, [pc, #172]	; (8a9c <breakTime(long, tmElements_t&)+0x1a4>)
        monthLength=29;
      } else {
        monthLength=28;
      }
    } else {
      monthLength = monthDays[month];
    89ee:	ldr	r5, [pc, #176]	; (8aa0 <breakTime(long, tmElements_t&)+0x1a8>)
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    89f0:	smull	r7, r0, r0, r3
    89f4:	rsb	r8, r6, r0, asr #5
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    89f8:	subs	r2, r2, r4
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    89fa:	rsb	r6, r6, r0, asr #7
    89fe:	movs	r4, #100	; 0x64
    8a00:	mov.w	r0, #400	; 0x190
    8a04:	mls	r6, r0, r6, r3
    8a08:	mls	r8, r4, r8, r3
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
  time  -= days; // now it is days in this year, starting at 0
    8a0c:	rsb	r2, r2, ip
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    8a10:	movs	r0, #1
    8a12:	movs	r3, #0
    8a14:	b.n	8a1c <breakTime(long, tmElements_t&)+0x124>
    8a16:	adds	r0, #1
    8a18:	uxtb	r0, r0
    8a1a:	adds	r3, #1
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
    8a1c:	cmp	r3, #1
    8a1e:	uxtb	r7, r3
    8a20:	beq.n	8a64 <breakTime(long, tmElements_t&)+0x16c>
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    8a22:	ldrb	r4, [r3, r5]
    8a24:	cmp	r4, r2
    8a26:	bhi.n	8a3c <breakTime(long, tmElements_t&)+0x144>
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    8a28:	cmp	r0, #12
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
      time -= monthLength;
    8a2a:	sub.w	r2, r2, r4
  time  -= days; // now it is days in this year, starting at 0
  
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    8a2e:	bne.n	8a16 <breakTime(long, tmElements_t&)+0x11e>
    8a30:	movs	r7, #13
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
  tm.Day = time + 1;     // day of month
    8a32:	adds	r2, #1
    8a34:	strb	r2, [r1, #4]
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    8a36:	strb	r7, [r1, #5]
  tm.Day = time + 1;     // day of month
}
    8a38:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8a3c:	adds	r7, #1
    8a3e:	uxtb	r7, r7
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
  tm.Day = time + 1;     // day of month
    8a40:	adds	r2, #1
    8a42:	strb	r2, [r1, #4]
      time -= monthLength;
    } else {
        break;
    }
  }
  tm.Month = month + 1;  // jan is month 1  
    8a44:	strb	r7, [r1, #5]
  tm.Day = time + 1;     // day of month
}
    8a46:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {
    year++;
  }
  tm.Year = year; // year is offset from 1970 
  
  days -= LEAP_YEAR(year) ? 366 : 365;
    8a4a:	mov.w	r4, #400	; 0x190
    8a4e:	rsb	r0, r6, r0, asr #7
    8a52:	mls	r0, r4, r0, r3
    8a56:	cmp	r0, #0
    8a58:	movw	r4, #365	; 0x16d
    8a5c:	it	eq
    8a5e:	moveq.w	r4, #366	; 0x16e
    8a62:	b.n	89ec <breakTime(long, tmElements_t&)+0xf4>
  days=0;
  month=0;
  monthLength=0;
  for (month=0; month<12; month++) {
    if (month==1) { // february
      if (LEAP_YEAR(year)) {
    8a64:	cmp.w	lr, #0
    8a68:	bne.n	8a80 <breakTime(long, tmElements_t&)+0x188>
    8a6a:	cmp.w	r8, #0
    8a6e:	bne.n	8a88 <breakTime(long, tmElements_t&)+0x190>
    8a70:	cmp	r6, #0
    8a72:	ite	ne
    8a74:	movne	r4, #28
    8a76:	moveq	r4, #29
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    8a78:	cmp	r2, r4
    8a7a:	bcc.n	8a84 <breakTime(long, tmElements_t&)+0x18c>
      time -= monthLength;
    8a7c:	subs	r2, r2, r4
    8a7e:	b.n	8a16 <breakTime(long, tmElements_t&)+0x11e>
    8a80:	movs	r4, #28
    8a82:	b.n	8a78 <breakTime(long, tmElements_t&)+0x180>
      }
    } else {
      monthLength = monthDays[month];
    }
    
    if (time >= monthLength) {
    8a84:	movs	r7, #2
    8a86:	b.n	8a32 <breakTime(long, tmElements_t&)+0x13a>
    8a88:	movs	r4, #29
    8a8a:	b.n	8a78 <breakTime(long, tmElements_t&)+0x180>
    8a8c:	.word	0xc22e4507
    8a90:	.word	0x88888889
    8a94:	.word	0x91a2b3c5
    8a98:	.word	0xaaaaaaab
    8a9c:	.word	0x51eb851f
    8aa0:	.word	0x0000c544
    8aa4:	.word	0x24924925

00008aa8 <refreshCache(long) [clone .part.0]>:

static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
    8aa8:	push	{r4, lr}
  if (t != cacheTime) {
    breakTime(t, tm); 
    8aaa:	ldr	r1, [pc, #12]	; (8ab8 <refreshCache(long) [clone .part.0]+0x10>)

static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
    8aac:	mov	r4, r0
  if (t != cacheTime) {
    breakTime(t, tm); 
    8aae:	bl	88f8 <breakTime(long, tmElements_t&)>
    cacheTime = t; 
    8ab2:	ldr	r3, [pc, #8]	; (8abc <refreshCache(long) [clone .part.0]+0x14>)
    8ab4:	str	r4, [r3, #0]
    8ab6:	pop	{r4, pc}
    8ab8:	.word	0x1fff18d0
    8abc:	.word	0x1fff18cc

00008ac0 <now()>:
#ifdef TIME_DRIFT_INFO   // define this to get drift data
time_t sysUnsyncedTime = 0; // the time sysTime unadjusted by sync  
#endif


time_t now() {
    8ac0:	push	{r4, r5, r6, r7, lr}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8ac2:	ldr	r4, [pc, #128]	; (8b44 <now()+0x84>)
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    8ac4:	ldr	r6, [pc, #128]	; (8b48 <now()+0x88>)
    8ac6:	ldr	r3, [r4, #0]
    8ac8:	ldr	r2, [r6, #0]
    8aca:	ldr	r5, [pc, #128]	; (8b4c <now()+0x8c>)
#ifdef TIME_DRIFT_INFO   // define this to get drift data
time_t sysUnsyncedTime = 0; // the time sysTime unadjusted by sync  
#endif


time_t now() {
    8acc:	sub	sp, #12
    8ace:	ldr	r0, [r5, #0]
    8ad0:	str	r3, [sp, #0]
	return ret;
    8ad2:	ldr	r3, [sp, #0]
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    8ad4:	subs	r3, r3, r2
    8ad6:	cmp.w	r3, #1000	; 0x3e8
    8ada:	bcc.n	8afc <now()+0x3c>
    8adc:	adds	r0, #1
    8ade:	b.n	8ae2 <now()+0x22>
    8ae0:	mov	r0, r1
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8ae2:	ldr	r3, [r4, #0]
    8ae4:	str	r3, [sp, #0]
	return ret;
    8ae6:	ldr	r3, [sp, #0]
		// millis() and prevMillis are both unsigned ints thus the subtraction will always be the absolute value of the difference
    sysTime++;
    prevMillis += 1000;	
    8ae8:	add.w	r2, r2, #1000	; 0x3e8
#endif


time_t now() {
	// calculate number of seconds passed since last call to now()
  while (millis() - prevMillis >= 1000) {
    8aec:	subs	r3, r3, r2
    8aee:	cmp.w	r3, #1000	; 0x3e8
    8af2:	add.w	r1, r0, #1
    8af6:	bcs.n	8ae0 <now()+0x20>
    8af8:	str	r0, [r5, #0]
    8afa:	str	r2, [r6, #0]
    prevMillis += 1000;	
#ifdef TIME_DRIFT_INFO
    sysUnsyncedTime++; // this can be compared to the synced time to measure long term drift     
#endif
  }
  if (nextSyncTime <= sysTime) {
    8afc:	ldr	r7, [pc, #80]	; (8b50 <now()+0x90>)
    8afe:	ldr	r3, [r7, #0]
    8b00:	cmp	r0, r3
    8b02:	bcc.n	8b24 <now()+0x64>
    if (getTimePtr != 0) {
    8b04:	ldr	r3, [pc, #76]	; (8b54 <now()+0x94>)
    8b06:	ldr	r3, [r3, #0]
    8b08:	cbz	r3, 8b24 <now()+0x64>
      time_t t = getTimePtr();
    8b0a:	blx	r3
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    8b0c:	ldr	r3, [pc, #72]	; (8b58 <now()+0x98>)
#endif
  }
  if (nextSyncTime <= sysTime) {
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
    8b0e:	cbnz	r0, 8b28 <now()+0x68>
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    8b10:	ldr	r1, [pc, #72]	; (8b5c <now()+0x9c>)
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    8b12:	ldr	r2, [r3, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    8b14:	ldrb	r3, [r1, #0]
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    8b16:	ldr	r0, [r5, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    8b18:	adds	r3, #0
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    8b1a:	add	r2, r0
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    8b1c:	it	ne
    8b1e:	movne	r3, #1
    if (getTimePtr != 0) {
      time_t t = getTimePtr();
      if (t != 0) {
        setTime(t);
      } else {
        nextSyncTime = sysTime + syncInterval;
    8b20:	str	r2, [r7, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
    8b22:	strb	r3, [r1, #0]
      }
    }
  }  
  return (time_t)sysTime;
}
    8b24:	add	sp, #12
    8b26:	pop	{r4, r5, r6, r7, pc}
	// do not remove this "redundant" code without
	// carefully verifying the case mentioned here:
	//
	// https://forum.pjrc.com/threads/17469-millis%28%29-on-teensy-3?p=104924&viewfull=1#post104924
	//
	volatile uint32_t ret = systick_millis_count; // single aligned 32 bit is atomic
    8b28:	ldr	r2, [r4, #0]
    8b2a:	str	r2, [sp, #4]
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    8b2c:	ldr	r3, [r3, #0]
  Status = timeSet;
    8b2e:	ldr	r2, [pc, #44]	; (8b5c <now()+0x9c>)
	return ret;
    8b30:	ldr	r4, [sp, #4]
#ifdef TIME_DRIFT_INFO
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
    8b32:	str	r0, [r5, #0]
  nextSyncTime = (uint32_t)t + syncInterval;
    8b34:	add	r3, r0
  Status = timeSet;
    8b36:	movs	r1, #2
  prevMillis = millis();  // restart counting from now (thanks to Korman for this fix)
    8b38:	str	r4, [r6, #0]
 if(sysUnsyncedTime == 0) 
   sysUnsyncedTime = t;   // store the time of the first call to set a valid Time   
#endif

  sysTime = (uint32_t)t;  
  nextSyncTime = (uint32_t)t + syncInterval;
    8b3a:	str	r3, [r7, #0]
  Status = timeSet;
    8b3c:	strb	r1, [r2, #0]
        Status = (Status == timeNotSet) ?  timeNotSet : timeNeedsSync;
      }
    }
  }  
  return (time_t)sysTime;
}
    8b3e:	add	sp, #12
    8b40:	pop	{r4, r5, r6, r7, pc}
    8b42:	nop
    8b44:	.word	0x1fff1998
    8b48:	.word	0x1fff18e4
    8b4c:	.word	0x1fff18d8
    8b50:	.word	0x1fff18e8
    8b54:	.word	0x1fff18e0
    8b58:	.word	0x1fff097c
    8b5c:	.word	0x1fff18dc

00008b60 <hour()>:
    breakTime(t, tm); 
    cacheTime = t; 
  }
}

int hour() { // the hour now 
    8b60:	push	{r3, lr}
  return hour(now()); 
    8b62:	bl	8ac0 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    8b66:	ldr	r3, [pc, #16]	; (8b78 <hour()+0x18>)
    8b68:	ldr	r3, [r3, #0]
    8b6a:	cmp	r0, r3
    8b6c:	beq.n	8b72 <hour()+0x12>
    8b6e:	bl	8aa8 <refreshCache(long) [clone .part.0]>
  return hour(now()); 
}

int hour(time_t t) { // the hour for the given time
  refreshCache(t);
  return tm.Hour;  
    8b72:	ldr	r3, [pc, #8]	; (8b7c <hour()+0x1c>)
  }
}

int hour() { // the hour now 
  return hour(now()); 
}
    8b74:	ldrb	r0, [r3, #2]
    8b76:	pop	{r3, pc}
    8b78:	.word	0x1fff18cc
    8b7c:	.word	0x1fff18d0

00008b80 <minute()>:

uint8_t isPM(time_t t) { // returns true if PM
  return (hour(t) >= 12); 
}

int minute() {
    8b80:	push	{r3, lr}
  return minute(now()); 
    8b82:	bl	8ac0 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    8b86:	ldr	r3, [pc, #16]	; (8b98 <minute()+0x18>)
    8b88:	ldr	r3, [r3, #0]
    8b8a:	cmp	r0, r3
    8b8c:	beq.n	8b92 <minute()+0x12>
    8b8e:	bl	8aa8 <refreshCache(long) [clone .part.0]>
  return minute(now()); 
}

int minute(time_t t) { // the minute for the given time
  refreshCache(t);
  return tm.Minute;  
    8b92:	ldr	r3, [pc, #8]	; (8b9c <minute()+0x1c>)
  return (hour(t) >= 12); 
}

int minute() {
  return minute(now()); 
}
    8b94:	ldrb	r0, [r3, #1]
    8b96:	pop	{r3, pc}
    8b98:	.word	0x1fff18cc
    8b9c:	.word	0x1fff18d0

00008ba0 <second()>:
int minute(time_t t) { // the minute for the given time
  refreshCache(t);
  return tm.Minute;  
}

int second() {
    8ba0:	push	{r3, lr}
  return second(now()); 
    8ba2:	bl	8ac0 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    8ba6:	ldr	r3, [pc, #16]	; (8bb8 <second()+0x18>)
    8ba8:	ldr	r3, [r3, #0]
    8baa:	cmp	r0, r3
    8bac:	beq.n	8bb2 <second()+0x12>
    8bae:	bl	8aa8 <refreshCache(long) [clone .part.0]>
  return second(now()); 
}

int second(time_t t) {  // the second for the given time
  refreshCache(t);
  return tm.Second;
    8bb2:	ldr	r3, [pc, #8]	; (8bbc <second()+0x1c>)
  return tm.Minute;  
}

int second() {
  return second(now()); 
}
    8bb4:	ldrb	r0, [r3, #0]
    8bb6:	pop	{r3, pc}
    8bb8:	.word	0x1fff18cc
    8bbc:	.word	0x1fff18d0

00008bc0 <day()>:
int second(time_t t) {  // the second for the given time
  refreshCache(t);
  return tm.Second;
}

int day(){
    8bc0:	push	{r3, lr}
  return(day(now())); 
    8bc2:	bl	8ac0 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    8bc6:	ldr	r3, [pc, #16]	; (8bd8 <day()+0x18>)
    8bc8:	ldr	r3, [r3, #0]
    8bca:	cmp	r0, r3
    8bcc:	beq.n	8bd2 <day()+0x12>
    8bce:	bl	8aa8 <refreshCache(long) [clone .part.0]>
  return(day(now())); 
}

int day(time_t t) { // the day for the given time (0-6)
  refreshCache(t);
  return tm.Day;
    8bd2:	ldr	r3, [pc, #8]	; (8bdc <day()+0x1c>)
  return tm.Second;
}

int day(){
  return(day(now())); 
}
    8bd4:	ldrb	r0, [r3, #4]
    8bd6:	pop	{r3, pc}
    8bd8:	.word	0x1fff18cc
    8bdc:	.word	0x1fff18d0

00008be0 <month()>:
int weekday(time_t t) {
  refreshCache(t);
  return tm.Wday;
}
   
int month(){
    8be0:	push	{r3, lr}
  return month(now()); 
    8be2:	bl	8ac0 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    8be6:	ldr	r3, [pc, #16]	; (8bf8 <month()+0x18>)
    8be8:	ldr	r3, [r3, #0]
    8bea:	cmp	r0, r3
    8bec:	beq.n	8bf2 <month()+0x12>
    8bee:	bl	8aa8 <refreshCache(long) [clone .part.0]>
  return month(now()); 
}

int month(time_t t) {  // the month for the given time
  refreshCache(t);
  return tm.Month;
    8bf2:	ldr	r3, [pc, #8]	; (8bfc <month()+0x1c>)
  return tm.Wday;
}
   
int month(){
  return month(now()); 
}
    8bf4:	ldrb	r0, [r3, #5]
    8bf6:	pop	{r3, pc}
    8bf8:	.word	0x1fff18cc
    8bfc:	.word	0x1fff18d0

00008c00 <year()>:
int month(time_t t) {  // the month for the given time
  refreshCache(t);
  return tm.Month;
}

int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
    8c00:	push	{r3, lr}
  return year(now()); 
    8c02:	bl	8ac0 <now()>
static tmElements_t tm;          // a cache of time elements
static time_t cacheTime;   // the time the cache was updated
static uint32_t syncInterval = 300;  // time sync will be attempted after this many seconds

void refreshCache(time_t t) {
  if (t != cacheTime) {
    8c06:	ldr	r3, [pc, #20]	; (8c1c <year()+0x1c>)
    8c08:	ldr	r3, [r3, #0]
    8c0a:	cmp	r0, r3
    8c0c:	beq.n	8c12 <year()+0x12>
    8c0e:	bl	8aa8 <refreshCache(long) [clone .part.0]>
  return year(now()); 
}

int year(time_t t) { // the year for the given time
  refreshCache(t);
  return tmYearToCalendar(tm.Year);
    8c12:	ldr	r3, [pc, #12]	; (8c20 <year()+0x20>)
  refreshCache(t);
  return tm.Month;
}

int year() {  // as in Processing, the full four digit year: (2009, 2010 etc) 
  return year(now()); 
    8c14:	ldrb	r0, [r3, #6]
}
    8c16:	addw	r0, r0, #1970	; 0x7b2
    8c1a:	pop	{r3, pc}
    8c1c:	.word	0x1fff18cc
    8c20:	.word	0x1fff18d0

00008c24 <memcpy>:
	@ r1: src
	@ r2: len
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
    8c24:	mov	ip, r0
#else
	push	{r0}
#endif
	orr	r3, r1, r0
    8c26:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    8c2a:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    8c2e:	bne.n	8d0c <memcpy+0xe8>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    8c30:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    8c32:	bcc.n	8cb8 <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    8c34:	ldr.w	r3, [r1], #4
    8c38:	str.w	r3, [r0], #4
    8c3c:	ldr.w	r3, [r1], #4
    8c40:	str.w	r3, [r0], #4
    8c44:	ldr.w	r3, [r1], #4
    8c48:	str.w	r3, [r0], #4
    8c4c:	ldr.w	r3, [r1], #4
    8c50:	str.w	r3, [r0], #4
    8c54:	ldr.w	r3, [r1], #4
    8c58:	str.w	r3, [r0], #4
    8c5c:	ldr.w	r3, [r1], #4
    8c60:	str.w	r3, [r0], #4
    8c64:	ldr.w	r3, [r1], #4
    8c68:	str.w	r3, [r0], #4
    8c6c:	ldr.w	r3, [r1], #4
    8c70:	str.w	r3, [r0], #4
    8c74:	ldr.w	r3, [r1], #4
    8c78:	str.w	r3, [r0], #4
    8c7c:	ldr.w	r3, [r1], #4
    8c80:	str.w	r3, [r0], #4
    8c84:	ldr.w	r3, [r1], #4
    8c88:	str.w	r3, [r0], #4
    8c8c:	ldr.w	r3, [r1], #4
    8c90:	str.w	r3, [r0], #4
    8c94:	ldr.w	r3, [r1], #4
    8c98:	str.w	r3, [r0], #4
    8c9c:	ldr.w	r3, [r1], #4
    8ca0:	str.w	r3, [r0], #4
    8ca4:	ldr.w	r3, [r1], #4
    8ca8:	str.w	r3, [r0], #4
    8cac:	ldr.w	r3, [r1], #4
    8cb0:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    8cb4:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    8cb6:	bcs.n	8c34 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    8cb8:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    8cba:	bcc.n	8ce0 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    8cbc:	ldr.w	r3, [r1], #4
    8cc0:	str.w	r3, [r0], #4
    8cc4:	ldr.w	r3, [r1], #4
    8cc8:	str.w	r3, [r0], #4
    8ccc:	ldr.w	r3, [r1], #4
    8cd0:	str.w	r3, [r0], #4
    8cd4:	ldr.w	r3, [r1], #4
    8cd8:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    8cdc:	subs	r2, #16
	bhs	.Lmid_block_loop
    8cde:	bcs.n	8cbc <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    8ce0:	adds	r2, #12
	blo	.Lcopy_less_than_4
    8ce2:	bcc.n	8cf0 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    8ce4:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    8ce8:	str.w	r3, [r0], #4
	subs	r2, #4
    8cec:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    8cee:	bcs.n	8ce4 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    8cf0:	adds	r2, #4
	beq	.Ldone
    8cf2:	beq.n	8d06 <memcpy+0xe2>

	lsls	r2, r2, #31
    8cf4:	lsls	r2, r2, #31
	itt ne
    8cf6:	itt	ne
	ldrbne  r3, [r1], #1
    8cf8:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    8cfc:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    8d00:	bcc.n	8d06 <memcpy+0xe2>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
    8d02:	ldrh	r3, [r1, #0]
	strh	r3, [r0]
    8d04:	strh	r3, [r0, #0]
	strb	r3, [r0, #1]
#endif /* __ARM_FEATURE_UNALIGNED */

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    8d06:	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    8d08:	bx	lr
    8d0a:	nop
#define Ldst_aligned Lbig_block

	/* Copy word by word using LDR when alignment can be done in hardware,
	i.e., SCTLR.A is set, supporting unaligned access in LDR and STR.  */

	cmp	r2, #8
    8d0c:	cmp	r2, #8
	blo	.Lbyte_copy
    8d0e:	bcc.n	8d38 <memcpy+0x114>

	/* if src is aligned, just go to the big block loop.  */
	lsls	r3, r1, #30
    8d10:	lsls	r3, r1, #30
	beq	.Ldst_aligned
    8d12:	beq.n	8c30 <memcpy+0xc>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    8d14:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    8d18:	beq.n	8c30 <memcpy+0xc>

	rsb	r3, #4
    8d1a:	rsb	r3, r3, #4
	subs	r2, r3
    8d1e:	subs	r2, r2, r3

	lsls    r3, r3, #31
    8d20:	lsls	r3, r3, #31
	itt ne
    8d22:	itt	ne
	ldrbne  r3, [r1], #1
    8d24:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    8d28:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    8d2c:	bcc.n	8c30 <memcpy+0xc>

#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
    8d2e:	ldrh.w	r3, [r1], #2
	strh    r3, [r0], #2
    8d32:	strh.w	r3, [r0], #2
	b	.Ldst_aligned
    8d36:	b.n	8c30 <memcpy+0xc>
	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    8d38:	subs	r2, #4
	blo	.Lcopy_less_than_4
    8d3a:	bcc.n	8cf0 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    8d3c:	subs	r2, #1
	ldrb    r3, [r1], #1
    8d3e:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    8d42:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    8d46:	bcs.n	8d3c <memcpy+0x118>

	ldrb	r3, [r1]
    8d48:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    8d4a:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    8d4c:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    8d4e:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    8d50:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    8d52:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    8d54:	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    8d56:	bx	lr

00008d58 <usb_serial_getchar>:

#define TRANSMIT_FLUSH_TIMEOUT	5   /* in milliseconds */

// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    8d58:	push	{r3, r4, r5, lr}
	unsigned int i;
	int c;

	if (!rx_packet) {
    8d5a:	ldr	r5, [pc, #60]	; (8d98 <usb_serial_getchar+0x40>)
    8d5c:	ldr	r0, [r5, #0]
    8d5e:	cbz	r0, 8d80 <usb_serial_getchar+0x28>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
    8d60:	ldrh	r3, [r0, #2]
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
    8d62:	ldrh	r2, [r0, #0]
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    8d64:	adds	r1, r0, r3
    8d66:	adds	r3, #1
	if (i >= rx_packet->len) {
    8d68:	cmp	r3, r2
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
    8d6a:	ldrb	r4, [r1, #8]
	if (i >= rx_packet->len) {
    8d6c:	bcs.n	8d74 <usb_serial_getchar+0x1c>
		usb_free(rx_packet);
		rx_packet = NULL;
	} else {
		rx_packet->index = i;
    8d6e:	strh	r3, [r0, #2]
	}
	return c;
    8d70:	mov	r0, r4
}
    8d72:	pop	{r3, r4, r5, pc}
		if (!rx_packet) return -1;
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
    8d74:	bl	9c94 <usb_free>
		rx_packet = NULL;
    8d78:	movs	r3, #0
	} else {
		rx_packet->index = i;
	}
	return c;
    8d7a:	mov	r0, r4
	}
	i = rx_packet->index;
	c = rx_packet->buf[i++];
	if (i >= rx_packet->len) {
		usb_free(rx_packet);
		rx_packet = NULL;
    8d7c:	str	r3, [r5, #0]
    8d7e:	pop	{r3, r4, r5, pc}
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    8d80:	ldr	r3, [pc, #24]	; (8d9c <usb_serial_getchar+0x44>)
    8d82:	ldrb	r3, [r3, #0]
    8d84:	cbz	r3, 8d92 <usb_serial_getchar+0x3a>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    8d86:	movs	r0, #2
    8d88:	bl	9ce0 <usb_rx>
    8d8c:	str	r0, [r5, #0]
		if (!rx_packet) return -1;
    8d8e:	cmp	r0, #0
    8d90:	bne.n	8d60 <usb_serial_getchar+0x8>
{
	unsigned int i;
	int c;

	if (!rx_packet) {
		if (!usb_configuration) return -1;
    8d92:	mov.w	r0, #4294967295
    8d96:	pop	{r3, r4, r5, pc}
    8d98:	.word	0x1fff18f8
    8d9c:	.word	0x1fff1a9c

00008da0 <usb_serial_peekchar>:
	return c;
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
    8da0:	push	{r4, lr}
	if (!rx_packet) {
    8da2:	ldr	r4, [pc, #36]	; (8dc8 <usb_serial_peekchar+0x28>)
    8da4:	ldr	r0, [r4, #0]
    8da6:	cbz	r0, 8db0 <usb_serial_peekchar+0x10>
		if (!usb_configuration) return -1;
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
		if (!rx_packet) return -1;
	}
	if (!rx_packet) return -1;
	return rx_packet->buf[rx_packet->index];
    8da8:	ldrh	r3, [r0, #2]
    8daa:	add	r0, r3
    8dac:	ldrb	r0, [r0, #8]
}
    8dae:	pop	{r4, pc}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    8db0:	ldr	r3, [pc, #24]	; (8dcc <usb_serial_peekchar+0x2c>)
    8db2:	ldrb	r3, [r3, #0]
    8db4:	cbz	r3, 8dc2 <usb_serial_peekchar+0x22>
		rx_packet = usb_rx(CDC_RX_ENDPOINT);
    8db6:	movs	r0, #2
    8db8:	bl	9ce0 <usb_rx>
    8dbc:	str	r0, [r4, #0]
		if (!rx_packet) return -1;
    8dbe:	cmp	r0, #0
    8dc0:	bne.n	8da8 <usb_serial_peekchar+0x8>

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	if (!rx_packet) {
		if (!usb_configuration) return -1;
    8dc2:	mov.w	r0, #4294967295
    8dc6:	pop	{r4, pc}
    8dc8:	.word	0x1fff18f8
    8dcc:	.word	0x1fff1a9c

00008dd0 <usb_serial_available>:
// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    8dd0:	ldr	r3, [pc, #16]	; (8de4 <usb_serial_available+0x14>)
static inline uint32_t usb_rx_byte_count(uint32_t endpoint) __attribute__((always_inline));
static inline uint32_t usb_rx_byte_count(uint32_t endpoint)
{
        endpoint--;
        if (endpoint >= NUM_ENDPOINTS) return 0;
        return usb_rx_byte_count_data[endpoint];
    8dd2:	ldr	r2, [pc, #20]	; (8de8 <usb_serial_available+0x18>)
    8dd4:	ldr	r3, [r3, #0]

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	int count;
	count = usb_rx_byte_count(CDC_RX_ENDPOINT);
    8dd6:	ldrh	r0, [r2, #2]
	if (rx_packet) count += rx_packet->len - rx_packet->index;
    8dd8:	cbz	r3, 8de2 <usb_serial_available+0x12>
    8dda:	ldrh	r2, [r3, #0]
    8ddc:	ldrh	r3, [r3, #2]
    8dde:	subs	r3, r2, r3
    8de0:	add	r0, r3
	return count;
}
    8de2:	bx	lr
    8de4:	.word	0x1fff18f8
    8de8:	.word	0x1fff1d74

00008dec <usb_serial_flush_input>:
// discard any buffered input
void usb_serial_flush_input(void)
{
	usb_packet_t *rx;

	if (!usb_configuration) return;
    8dec:	ldr	r3, [pc, #44]	; (8e1c <usb_serial_flush_input+0x30>)
    8dee:	ldrb	r3, [r3, #0]
    8df0:	cbz	r3, 8e1a <usb_serial_flush_input+0x2e>
	return count;
}

// discard any buffered input
void usb_serial_flush_input(void)
{
    8df2:	push	{r4, lr}
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
    8df4:	ldr	r4, [pc, #40]	; (8e20 <usb_serial_flush_input+0x34>)
    8df6:	ldr	r0, [r4, #0]
    8df8:	cbz	r0, 8e0e <usb_serial_flush_input+0x22>
		usb_free(rx_packet);
    8dfa:	bl	9c94 <usb_free>
		rx_packet = NULL;
    8dfe:	movs	r3, #0
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    8e00:	movs	r0, #2
	usb_packet_t *rx;

	if (!usb_configuration) return;
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
    8e02:	str	r3, [r4, #0]
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    8e04:	bl	9ce0 <usb_rx>
		if (!rx) break;
    8e08:	cbz	r0, 8e18 <usb_serial_flush_input+0x2c>
		usb_free(rx);
    8e0a:	bl	9c94 <usb_free>
	if (rx_packet) {
		usb_free(rx_packet);
		rx_packet = NULL;
	}
	while (1) {
		rx = usb_rx(CDC_RX_ENDPOINT);
    8e0e:	movs	r0, #2
    8e10:	bl	9ce0 <usb_rx>
		if (!rx) break;
    8e14:	cmp	r0, #0
    8e16:	bne.n	8e0a <usb_serial_flush_input+0x1e>
    8e18:	pop	{r4, pc}
    8e1a:	bx	lr
    8e1c:	.word	0x1fff1a9c
    8e20:	.word	0x1fff18f8

00008e24 <usb_serial_write>:
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    8e24:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    8e28:	ldr.w	r9, [pc, #248]	; 8f24 <usb_serial_write+0x100>
	return usb_serial_write(&c, 1);
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    8e2c:	sub	sp, #12
	uint32_t len;
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
    8e2e:	movs	r2, #1
    8e30:	strb.w	r2, [r9]
	while (size > 0) {
    8e34:	str	r1, [sp, #4]
    8e36:	cbz	r1, 8e94 <usb_serial_write+0x70>
    8e38:	ldr.w	r8, [pc, #236]	; 8f28 <usb_serial_write+0x104>
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    8e3c:	ldr	r7, [pc, #216]	; (8f18 <usb_serial_write+0xf4>)
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    8e3e:	ldr	r6, [sp, #4]
    8e40:	mov	fp, r0
		if (!tx_packet) {
    8e42:	ldr.w	r0, [r8]
    8e46:	cbz	r0, 8eb6 <usb_serial_write+0x92>
    8e48:	ldr	r5, [pc, #208]	; (8f1c <usb_serial_write+0xf8>)
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
    8e4a:	ldrh	r4, [r0, #2]
    8e4c:	rsb	r1, r4, #64	; 0x40
    8e50:	cmp	r1, r6
    8e52:	it	cs
    8e54:	movcs	r1, r6
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    8e56:	add.w	lr, r4, r1
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    8e5a:	movs	r2, #0
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    8e5c:	uxth.w	lr, lr
					return -1;
				}
				yield();
			}
		}
		transmit_previous_timeout = 0;
    8e60:	strb	r2, [r5, #0]
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
    8e62:	subs	r6, r6, r1
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
    8e64:	strh.w	lr, [r0, #2]
			}
		}
		transmit_previous_timeout = 0;
		len = CDC_TX_SIZE - tx_packet->index;
		if (len > size) len = size;
		dest = tx_packet->buf + tx_packet->index;
    8e68:	add.w	r2, r0, #8
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
    8e6c:	cbz	r1, 8e84 <usb_serial_write+0x60>
    8e6e:	subs	r4, #1
    8e70:	add	r2, r4
    8e72:	add	r1, fp
    8e74:	ldrb.w	r4, [fp], #1
    8e78:	strb.w	r4, [r2, #1]!
    8e7c:	cmp	fp, r1
    8e7e:	bne.n	8e74 <usb_serial_write+0x50>
    8e80:	ldrh.w	lr, [r0, #2]
		if (tx_packet->index >= CDC_TX_SIZE) {
    8e84:	cmp.w	lr, #63	; 0x3f
    8e88:	bhi.n	8ea2 <usb_serial_write+0x7e>
			tx_packet->len = CDC_TX_SIZE;
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
    8e8a:	ldr	r2, [pc, #148]	; (8f20 <usb_serial_write+0xfc>)
    8e8c:	movs	r1, #5
    8e8e:	strb	r1, [r2, #0]
	uint32_t wait_count;
	const uint8_t *src = (const uint8_t *)buffer;
	uint8_t *dest;

	tx_noautoflush = 1;
	while (size > 0) {
    8e90:	cmp	r6, #0
    8e92:	bne.n	8e42 <usb_serial_write+0x1e>
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
    8e94:	ldr	r0, [sp, #4]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
			tx_packet = NULL;
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
    8e96:	movs	r3, #0
    8e98:	strb.w	r3, [r9]
	return ret;
}
    8e9c:	add	sp, #12
    8e9e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dest = tx_packet->buf + tx_packet->index;
		tx_packet->index += len;
		size -= len;
		while (len-- > 0) *dest++ = *src++;
		if (tx_packet->index >= CDC_TX_SIZE) {
			tx_packet->len = CDC_TX_SIZE;
    8ea2:	movs	r2, #64	; 0x40
    8ea4:	strh	r2, [r0, #0]
			usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8ea6:	mov	r1, r0
    8ea8:	movs	r0, #3
    8eaa:	bl	9e50 <usb_tx>
			tx_packet = NULL;
    8eae:	movs	r2, #0
    8eb0:	str.w	r2, [r8]
    8eb4:	b.n	8e8a <usb_serial_write+0x66>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    8eb6:	ldrb	r2, [r7, #0]
    8eb8:	cbz	r2, 8f06 <usb_serial_write+0xe2>
    8eba:	ldr	r5, [pc, #96]	; (8f1c <usb_serial_write+0xf8>)
    8ebc:	movw	r4, #41721	; 0xa2f9
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
    8ec0:	mov.w	sl, #1
    8ec4:	b.n	8ed6 <usb_serial_write+0xb2>
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    8ec6:	subs	r4, #1
    8ec8:	beq.n	8ef8 <usb_serial_write+0xd4>
    8eca:	ldrb	r2, [r5, #0]
    8ecc:	cbnz	r2, 8ef8 <usb_serial_write+0xd4>
					transmit_previous_timeout = 1;
					return -1;
				}
				yield();
    8ece:	bl	ac8c <yield>
	tx_noautoflush = 1;
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
    8ed2:	ldrb	r2, [r7, #0]
    8ed4:	cbz	r2, 8f06 <usb_serial_write+0xe2>
					tx_noautoflush = 0;
					return -1;
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
    8ed6:	movs	r0, #3
    8ed8:	bl	9d1c <usb_tx_packet_count>
    8edc:	cmp	r0, #7
    8ede:	bhi.n	8ec6 <usb_serial_write+0xa2>
					tx_noautoflush = 1;
    8ee0:	strb.w	sl, [r9]
					tx_packet = usb_malloc();
    8ee4:	bl	9c54 <usb_malloc>
    8ee8:	str.w	r0, [r8]
					if (tx_packet) break;
    8eec:	cmp	r0, #0
    8eee:	bne.n	8e4a <usb_serial_write+0x26>
					tx_noautoflush = 0;
    8ef0:	ldr	r3, [pc, #48]	; (8f24 <usb_serial_write+0x100>)
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    8ef2:	subs	r4, #1
				}
				if (usb_tx_packet_count(CDC_TX_ENDPOINT) < TX_PACKET_LIMIT) {
					tx_noautoflush = 1;
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
    8ef4:	strb	r0, [r3, #0]
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
    8ef6:	bne.n	8eca <usb_serial_write+0xa6>
					transmit_previous_timeout = 1;
    8ef8:	movs	r3, #1
					return -1;
    8efa:	mov.w	r0, #4294967295
					tx_packet = usb_malloc();
					if (tx_packet) break;
					tx_noautoflush = 0;
				}
				if (++wait_count > TX_TIMEOUT || transmit_previous_timeout) {
					transmit_previous_timeout = 1;
    8efe:	strb	r3, [r5, #0]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    8f00:	add	sp, #12
    8f02:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    8f06:	movs	r3, #0
					return -1;
    8f08:	mov.w	r0, #4294967295
	while (size > 0) {
		if (!tx_packet) {
			wait_count = 0;
			while (1) {
				if (!usb_configuration) {
					tx_noautoflush = 0;
    8f0c:	strb.w	r3, [r9]
		}
		usb_cdc_transmit_flush_timer = TRANSMIT_FLUSH_TIMEOUT;
	}
	tx_noautoflush = 0;
	return ret;
}
    8f10:	add	sp, #12
    8f12:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8f16:	nop
    8f18:	.word	0x1fff1a9c
    8f1c:	.word	0x1fff18f4
    8f20:	.word	0x1fff18ec
    8f24:	.word	0x1fff18ed
    8f28:	.word	0x1fff18f0

00008f2c <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    8f2c:	push	{lr}
    8f2e:	sub	sp, #12
    8f30:	add	r3, sp, #8
	return usb_serial_write(&c, 1);
    8f32:	movs	r1, #1
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    8f34:	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    8f38:	mov	r0, r3
    8f3a:	bl	8e24 <usb_serial_write>
}
    8f3e:	add	sp, #12
    8f40:	ldr.w	pc, [sp], #4

00008f44 <usb_serial_write_buffer_free>:
	tx_noautoflush = 0;
	return ret;
}

int usb_serial_write_buffer_free(void)
{
    8f44:	push	{r3, r4, r5, lr}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
    8f46:	ldr	r5, [pc, #56]	; (8f80 <usb_serial_write_buffer_free+0x3c>)

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    8f48:	ldr	r4, [pc, #56]	; (8f84 <usb_serial_write_buffer_free+0x40>)
	if (!tx_packet) {
    8f4a:	ldr	r0, [r5, #0]

int usb_serial_write_buffer_free(void)
{
	uint32_t len;

	tx_noautoflush = 1;
    8f4c:	movs	r3, #1
    8f4e:	strb	r3, [r4, #0]
	if (!tx_packet) {
    8f50:	cbz	r0, 8f5e <usb_serial_write_buffer_free+0x1a>
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    8f52:	ldrh	r0, [r0, #2]
	// space we just promised the user could write without blocking?
	// But does this come with other performance downsides?  Could it lead to
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
    8f54:	movs	r3, #0
    8f56:	strb	r3, [r4, #0]
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
			return 0;
		}
	}
	len = CDC_TX_SIZE - tx_packet->index;
    8f58:	rsb	r0, r0, #64	; 0x40
	// buffer data never actually transmitting in some usage cases?  More
	// investigation is needed.
	// https://github.com/PaulStoffregen/cores/issues/10#issuecomment-61514955
	tx_noautoflush = 0;
	return len;
}
    8f5c:	pop	{r3, r4, r5, pc}
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    8f5e:	ldr	r3, [pc, #40]	; (8f88 <usb_serial_write_buffer_free+0x44>)
    8f60:	ldrb	r3, [r3, #0]
    8f62:	cbnz	r3, 8f6a <usb_serial_write_buffer_free+0x26>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
			tx_noautoflush = 0;
    8f64:	movs	r0, #0
    8f66:	strb	r0, [r4, #0]
			return 0;
    8f68:	pop	{r3, r4, r5, pc}
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    8f6a:	movs	r0, #3
    8f6c:	bl	9d1c <usb_tx_packet_count>
{
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
    8f70:	cmp	r0, #7
    8f72:	bhi.n	8f64 <usb_serial_write_buffer_free+0x20>
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
		  (tx_packet = usb_malloc()) == NULL) {
    8f74:	bl	9c54 <usb_malloc>
    8f78:	str	r0, [r5, #0]
	uint32_t len;

	tx_noautoflush = 1;
	if (!tx_packet) {
		if (!usb_configuration ||
		  usb_tx_packet_count(CDC_TX_ENDPOINT) >= TX_PACKET_LIMIT ||
    8f7a:	cmp	r0, #0
    8f7c:	bne.n	8f52 <usb_serial_write_buffer_free+0xe>
    8f7e:	b.n	8f64 <usb_serial_write_buffer_free+0x20>
    8f80:	.word	0x1fff18f0
    8f84:	.word	0x1fff18ed
    8f88:	.word	0x1fff1a9c

00008f8c <usb_serial_flush_output>:
	tx_noautoflush = 0;
	return len;
}

void usb_serial_flush_output(void)
{
    8f8c:	push	{r3, r4, r5, r6, r7, lr}
	if (!usb_configuration) return;
    8f8e:	ldr	r3, [pc, #68]	; (8fd4 <usb_serial_flush_output+0x48>)
    8f90:	ldrb	r3, [r3, #0]
    8f92:	cbz	r3, 8fb8 <usb_serial_flush_output+0x2c>
	tx_noautoflush = 1;
	if (tx_packet) {
    8f94:	ldr	r6, [pc, #64]	; (8fd8 <usb_serial_flush_output+0x4c>)
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    8f96:	ldr	r5, [pc, #68]	; (8fdc <usb_serial_flush_output+0x50>)
	if (tx_packet) {
    8f98:	ldr	r4, [r6, #0]
}

void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
    8f9a:	movs	r7, #1
    8f9c:	strb	r7, [r5, #0]
	if (tx_packet) {
    8f9e:	cbz	r4, 8fba <usb_serial_flush_output+0x2e>
		usb_cdc_transmit_flush_timer = 0;
    8fa0:	ldr	r2, [pc, #60]	; (8fe0 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
    8fa2:	ldrh	r3, [r4, #2]
void usb_serial_flush_output(void)
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
    8fa4:	movs	r7, #0
    8fa6:	strb	r7, [r2, #0]
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8fa8:	mov	r1, r4
{
	if (!usb_configuration) return;
	tx_noautoflush = 1;
	if (tx_packet) {
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
    8faa:	strh	r3, [r4, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8fac:	movs	r0, #3
    8fae:	bl	9e50 <usb_tx>
		tx_packet = NULL;
    8fb2:	str	r7, [r6, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
	tx_noautoflush = 0;
    8fb4:	movs	r3, #0
    8fb6:	strb	r3, [r5, #0]
    8fb8:	pop	{r3, r4, r5, r6, r7, pc}
		usb_cdc_transmit_flush_timer = 0;
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    8fba:	bl	9c54 <usb_malloc>
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    8fbe:	ldr	r3, [pc, #32]	; (8fe0 <usb_serial_flush_output+0x54>)
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
    8fc0:	cbz	r0, 8fce <usb_serial_flush_output+0x42>
			usb_cdc_transmit_flush_timer = 0;
			usb_tx(CDC_TX_ENDPOINT, tx);
    8fc2:	mov	r1, r0
    8fc4:	movs	r0, #3
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_cdc_transmit_flush_timer = 0;
    8fc6:	strb	r4, [r3, #0]
			usb_tx(CDC_TX_ENDPOINT, tx);
    8fc8:	bl	9e50 <usb_tx>
    8fcc:	b.n	8fb4 <usb_serial_flush_output+0x28>
		} else {
			usb_cdc_transmit_flush_timer = 1;
    8fce:	strb	r7, [r3, #0]
    8fd0:	b.n	8fb4 <usb_serial_flush_output+0x28>
    8fd2:	nop
    8fd4:	.word	0x1fff1a9c
    8fd8:	.word	0x1fff18f0
    8fdc:	.word	0x1fff18ed
    8fe0:	.word	0x1fff18ec

00008fe4 <usb_serial_flush_callback>:
	}
	tx_noautoflush = 0;
}

void usb_serial_flush_callback(void)
{
    8fe4:	push	{r3, r4, r5, lr}
	if (tx_noautoflush) return;
    8fe6:	ldr	r3, [pc, #56]	; (9020 <usb_serial_flush_callback+0x3c>)
    8fe8:	ldrb	r3, [r3, #0]
    8fea:	cbnz	r3, 900a <usb_serial_flush_callback+0x26>
	if (tx_packet) {
    8fec:	ldr	r4, [pc, #52]	; (9024 <usb_serial_flush_callback+0x40>)
    8fee:	ldr	r1, [r4, #0]
    8ff0:	cbz	r1, 900c <usb_serial_flush_callback+0x28>
    8ff2:	and.w	r5, r3, #255	; 0xff
		tx_packet->len = tx_packet->index;
    8ff6:	ldrh	r3, [r1, #2]
    8ff8:	strh	r3, [r1, #0]
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
    8ffa:	movs	r0, #3
    8ffc:	bl	9e50 <usb_tx>
		tx_packet = NULL;
    9000:	str	r5, [r4, #0]
    9002:	pop	{r3, r4, r5, pc}
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
		} else {
			usb_cdc_transmit_flush_timer = 1;
    9004:	ldr	r3, [pc, #32]	; (9028 <usb_serial_flush_callback+0x44>)
    9006:	movs	r2, #1
    9008:	strb	r2, [r3, #0]
    900a:	pop	{r3, r4, r5, pc}
	if (tx_packet) {
		tx_packet->len = tx_packet->index;
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
    900c:	bl	9c54 <usb_malloc>
		if (tx) {
    9010:	cmp	r0, #0
    9012:	beq.n	9004 <usb_serial_flush_callback+0x20>
			usb_tx(CDC_TX_ENDPOINT, tx);
    9014:	mov	r1, r0
		} else {
			usb_cdc_transmit_flush_timer = 1;
		}
	}
}
    9016:	ldmia.w	sp!, {r3, r4, r5, lr}
		usb_tx(CDC_TX_ENDPOINT, tx_packet);
		tx_packet = NULL;
	} else {
		usb_packet_t *tx = usb_malloc();
		if (tx) {
			usb_tx(CDC_TX_ENDPOINT, tx);
    901a:	movs	r0, #3
    901c:	b.w	9e50 <usb_tx>
    9020:	.word	0x1fff18ed
    9024:	.word	0x1fff18f0
    9028:	.word	0x1fff18ec

0000902c <fault_isr>:
void _init_Teensyduino_internal_(void) __attribute__((noinline));
void __libc_init_array(void);


void fault_isr(void)
{
    902c:	push	{r3, lr}
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    902e:	ldr	r4, [pc, #64]	; (9070 <fault_isr+0x44>)
    9030:	b.n	9044 <fault_isr+0x18>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    9032:	ldr	r3, [r4, #0]
    9034:	lsls	r1, r3, #21
    9036:	bmi.n	9054 <fault_isr+0x28>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    9038:	ldr	r3, [r4, #0]
    903a:	lsls	r2, r3, #20
    903c:	bmi.n	905e <fault_isr+0x32>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    903e:	ldr	r3, [r4, #0]
    9040:	lsls	r3, r3, #19
    9042:	bmi.n	9068 <fault_isr+0x3c>
        asm("ldr %0, [sp, #0]" : "=r" (addr) ::);
#endif
	while (1) {
		// keep polling some communication while in fault
		// mode, so we don't completely die.
		if (SIM_SCGC4 & SIM_SCGC4_USBOTG) usb_isr();
    9044:	ldr	r3, [r4, #0]
    9046:	lsls	r0, r3, #13
    9048:	bpl.n	9032 <fault_isr+0x6>
    904a:	bl	9ed4 <usb_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART0) uart0_status_isr();
    904e:	ldr	r3, [r4, #0]
    9050:	lsls	r1, r3, #21
    9052:	bpl.n	9038 <fault_isr+0xc>
    9054:	bl	97ec <uart0_status_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART1) uart1_status_isr();
    9058:	ldr	r3, [r4, #0]
    905a:	lsls	r2, r3, #20
    905c:	bpl.n	903e <fault_isr+0x12>
    905e:	bl	b048 <uart1_status_isr>
		if (SIM_SCGC4 & SIM_SCGC4_UART2) uart2_status_isr();
    9062:	ldr	r3, [r4, #0]
    9064:	lsls	r3, r3, #19
    9066:	bpl.n	9044 <fault_isr+0x18>
    9068:	bl	b438 <uart2_status_isr>
    906c:	b.n	9044 <fault_isr+0x18>
    906e:	nop
    9070:	.word	0x40048034

00009074 <unused_isr>:
	}
}

void unused_isr(void)
{
    9074:	push	{r3, lr}
	fault_isr();
    9076:	bl	902c <fault_isr>
    907a:	nop

0000907c <startup_early_hook>:
extern void rtc_set(unsigned long t);


static void startup_default_early_hook(void) {
#if defined(KINETISK)
	WDOG_STCTRLH = WDOG_STCTRLH_ALLOWUPDATE;
    907c:	ldr	r3, [pc, #4]	; (9084 <startup_early_hook+0x8>)
    907e:	movs	r2, #16
    9080:	strh	r2, [r3, #0]
    9082:	bx	lr
    9084:	.word	0x40052000

00009088 <startup_late_hook>:
#elif defined(KINETISL)
	SIM_COPC = 0;  // disable the watchdog
#endif
}
static void startup_default_late_hook(void) {}
    9088:	bx	lr
    908a:	nop

0000908c <_sbrk>:

void * _sbrk(int incr)
{
	char *prev, *stack;

	prev = __brkval;
    908c:	ldr	r1, [pc, #36]	; (90b4 <_sbrk+0x28>)

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

void * _sbrk(int incr)
{
    908e:	push	{r3, lr}
	char *prev, *stack;

	prev = __brkval;
    9090:	ldr	r3, [r1, #0]
	if (incr != 0) {
    9092:	cbz	r0, 90a2 <_sbrk+0x16>
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
    9094:	mov	r2, sp
		if (prev + incr >= stack - STACK_MARGIN) {
    9096:	add	r0, r3
    9098:	sub.w	r2, r2, #8192	; 0x2000
    909c:	cmp	r0, r2
    909e:	bcs.n	90a6 <_sbrk+0x1a>
			errno = ENOMEM;
			return (void *)-1;
		}
		__brkval = prev + incr;
    90a0:	str	r0, [r1, #0]
	}
	return prev;
    90a2:	mov	r0, r3
}
    90a4:	pop	{r3, pc}

	prev = __brkval;
	if (incr != 0) {
		__asm__ volatile("mov %0, sp" : "=r" (stack) ::);
		if (prev + incr >= stack - STACK_MARGIN) {
			errno = ENOMEM;
    90a6:	bl	b52c <__errno>
    90aa:	movs	r3, #12
    90ac:	str	r3, [r0, #0]
			return (void *)-1;
    90ae:	mov.w	r0, #4294967295
    90b2:	pop	{r3, pc}
    90b4:	.word	0x1fff0980

000090b8 <nvic_execution_priority>:
	uint32_t priority=256;
	uint32_t primask, faultmask, basepri, ipsr;

	// full algorithm in ARM DDI0403D, page B1-639
	// this isn't quite complete, but hopefully good enough
	__asm__ volatile("mrs %0, faultmask\n" : "=r" (faultmask)::);
    90b8:	mrs	r0, FAULTMASK
	if (faultmask) return -1;
    90bc:	cbnz	r0, 90dc <nvic_execution_priority+0x24>
	__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    90be:	mrs	r3, PRIMASK
	if (primask) return 0;
    90c2:	cbnz	r3, 90e0 <nvic_execution_priority+0x28>
	__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    90c4:	mrs	r2, IPSR
	if (ipsr) {
    90c8:	cbnz	r2, 90e2 <nvic_execution_priority+0x2a>

#pragma GCC diagnostic pop

int nvic_execution_priority(void)
{
	uint32_t priority=256;
    90ca:	mov.w	r0, #256	; 0x100
	__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
	if (ipsr) {
		if (ipsr < 16) priority = 0; // could be non-zero
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
	}
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
    90ce:	mrs	r3, BASEPRI
	if (basepri > 0 && basepri < priority) priority = basepri;
    90d2:	cbz	r3, 90e0 <nvic_execution_priority+0x28>
    90d4:	cmp	r0, r3
    90d6:	it	cs
    90d8:	movcs	r0, r3
	return priority;
    90da:	bx	lr
	uint32_t primask, faultmask, basepri, ipsr;

	// full algorithm in ARM DDI0403D, page B1-639
	// this isn't quite complete, but hopefully good enough
	__asm__ volatile("mrs %0, faultmask\n" : "=r" (faultmask)::);
	if (faultmask) return -1;
    90dc:	mov.w	r0, #4294967295
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
	}
	__asm__ volatile("mrs %0, basepri\n" : "=r" (basepri)::);
	if (basepri > 0 && basepri < priority) priority = basepri;
	return priority;
}
    90e0:	bx	lr
	if (faultmask) return -1;
	__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
	if (primask) return 0;
	__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
	if (ipsr) {
		if (ipsr < 16) priority = 0; // could be non-zero
    90e2:	cmp	r2, #15
    90e4:	bhi.n	90ea <nvic_execution_priority+0x32>
    90e6:	mov	r0, r3
    90e8:	b.n	90ce <nvic_execution_priority+0x16>
		else priority = NVIC_GET_PRIORITY(ipsr - 16);
    90ea:	ldr	r3, [pc, #4]	; (90f0 <nvic_execution_priority+0x38>)
    90ec:	ldrb	r0, [r2, r3]
    90ee:	b.n	90ce <nvic_execution_priority+0x16>
    90f0:	.word	0xe000e3f0

000090f4 <serial_putchar.part.0>:
#else
	return 0;
#endif
}

void serial_putchar(uint32_t c)
    90f4:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
{
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
    90f8:	ldr	r3, [pc, #132]	; (9180 <serial_putchar.part.0+0x8c>)
    90fa:	ldr	r3, [r3, #0]
#else
	return 0;
#endif
}

void serial_putchar(uint32_t c)
    90fc:	mov	r7, r0
{
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
    90fe:	cbz	r3, 9104 <serial_putchar.part.0+0x10>
    9100:	movs	r2, #1
    9102:	strb	r2, [r3, #0]
	head = tx_buffer_head;
    9104:	ldr.w	r9, [pc, #136]	; 9190 <serial_putchar.part.0+0x9c>
    9108:	ldr	r5, [pc, #120]	; (9184 <serial_putchar.part.0+0x90>)
    910a:	ldrb.w	r4, [r9]
    910e:	ldr.w	r8, [pc, #132]	; 9194 <serial_putchar.part.0+0xa0>
	if (++head >= SERIAL1_TX_BUFFER_SIZE) head = 0;
	while (tx_buffer_tail == head) {
		int priority = nvic_execution_priority();
		if (priority <= IRQ_PRIORITY) {
			if ((UART0_S1 & UART_S1_TDRE)) {
    9112:	ldr	r6, [pc, #116]	; (9188 <serial_putchar.part.0+0x94>)
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
	head = tx_buffer_head;
	if (++head >= SERIAL1_TX_BUFFER_SIZE) head = 0;
    9114:	adds	r4, #1
    9116:	cmp	r4, #63	; 0x3f
    9118:	itet	hi
    911a:	movhi.w	sl, #0
    911e:	uxtbls.w	sl, r4
    9122:	movhi	r4, sl
	while (tx_buffer_tail == head) {
    9124:	mov	fp, r5
    9126:	ldrb	r3, [r5, #0]
    9128:	cmp	r3, r4
    912a:	bne.n	915a <serial_putchar.part.0+0x66>
		int priority = nvic_execution_priority();
    912c:	bl	90b8 <nvic_execution_priority>
		if (priority <= IRQ_PRIORITY) {
    9130:	cmp	r0, #64	; 0x40
    9132:	bgt.n	9174 <serial_putchar.part.0+0x80>
			if ((UART0_S1 & UART_S1_TDRE)) {
    9134:	ldrb	r3, [r6, #4]
    9136:	lsls	r3, r3, #24
    9138:	bpl.n	9126 <serial_putchar.part.0+0x32>
				uint32_t tail = tx_buffer_tail;
    913a:	ldrb.w	r3, [fp]
				if (++tail >= SERIAL1_TX_BUFFER_SIZE) tail = 0;
    913e:	adds	r3, #1
    9140:	cmp	r3, #63	; 0x3f
    9142:	itte	hi
    9144:	movhi	r2, #0
    9146:	movhi	r3, r2
    9148:	uxtbls	r2, r3
				n = tx_buffer[tail];
    914a:	ldrb.w	r3, [r8, r3]
    914e:	uxtb	r3, r3
				if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
				UART0_D = n;
    9150:	strb	r3, [r6, #7]
				tx_buffer_tail = tail;
    9152:	strb	r2, [r5, #0]

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
	head = tx_buffer_head;
	if (++head >= SERIAL1_TX_BUFFER_SIZE) head = 0;
	while (tx_buffer_tail == head) {
    9154:	ldrb	r3, [r5, #0]
    9156:	cmp	r3, r4
    9158:	beq.n	912c <serial_putchar.part.0+0x38>
		} else if (priority >= 256) {
			yield();
		}
	}
	tx_buffer[head] = c;
	transmitting = 1;
    915a:	ldr	r1, [pc, #48]	; (918c <serial_putchar.part.0+0x98>)
	tx_buffer_head = head;
	UART0_C2 = C2_TX_ACTIVE;
    915c:	ldr	r3, [pc, #40]	; (9188 <serial_putchar.part.0+0x94>)
			}
		} else if (priority >= 256) {
			yield();
		}
	}
	tx_buffer[head] = c;
    915e:	uxtb	r7, r7
    9160:	strb.w	r7, [r8, r4]
	transmitting = 1;
    9164:	movs	r0, #1
	tx_buffer_head = head;
	UART0_C2 = C2_TX_ACTIVE;
    9166:	movs	r2, #188	; 0xbc
		} else if (priority >= 256) {
			yield();
		}
	}
	tx_buffer[head] = c;
	transmitting = 1;
    9168:	strb	r0, [r1, #0]
	tx_buffer_head = head;
    916a:	strb.w	sl, [r9]
	UART0_C2 = C2_TX_ACTIVE;
    916e:	strb	r2, [r3, #3]
    9170:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				n = tx_buffer[tail];
				if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
				UART0_D = n;
				tx_buffer_tail = tail;
			}
		} else if (priority >= 256) {
    9174:	cmp	r0, #255	; 0xff
    9176:	ble.n	9126 <serial_putchar.part.0+0x32>
			yield();
    9178:	bl	ac8c <yield>
    917c:	b.n	9126 <serial_putchar.part.0+0x32>
    917e:	nop
    9180:	.word	0x1fff1990
    9184:	.word	0x1fff198d
    9188:	.word	0x4006a000
    918c:	.word	0x1fff198c
    9190:	.word	0x1fff1994
    9194:	.word	0x1fff1908

00009198 <serial_begin>:
#define C2_TX_COMPLETING	C2_ENABLE | UART_C2_TCIE
#define C2_TX_INACTIVE		C2_ENABLE

void serial_begin(uint32_t divisor)
{
	SIM_SCGC4 |= SIM_SCGC4_UART0;	// turn on clock, TODO: use bitband
    9198:	ldr	r2, [pc, #200]	; (9264 <serial_begin+0xcc>)
	rx_buffer_head = 0;
	rx_buffer_tail = 0;
	tx_buffer_head = 0;
	tx_buffer_tail = 0;
	transmitting = 0;
	switch (rx_pin_num) {
    919a:	ldr	r1, [pc, #204]	; (9268 <serial_begin+0xd0>)
#define C2_TX_COMPLETING	C2_ENABLE | UART_C2_TCIE
#define C2_TX_INACTIVE		C2_ENABLE

void serial_begin(uint32_t divisor)
{
	SIM_SCGC4 |= SIM_SCGC4_UART0;	// turn on clock, TODO: use bitband
    919c:	ldr	r3, [r2, #0]
#define C2_TX_ACTIVE		C2_ENABLE | UART_C2_TIE
#define C2_TX_COMPLETING	C2_ENABLE | UART_C2_TCIE
#define C2_TX_INACTIVE		C2_ENABLE

void serial_begin(uint32_t divisor)
{
    919e:	push	{r4, r5, r6, r7, lr}
	SIM_SCGC4 |= SIM_SCGC4_UART0;	// turn on clock, TODO: use bitband
    91a0:	orr.w	r3, r3, #1024	; 0x400
    91a4:	str	r3, [r2, #0]
	rx_buffer_head = 0;
	rx_buffer_tail = 0;
	tx_buffer_head = 0;
	tx_buffer_tail = 0;
	transmitting = 0;
	switch (rx_pin_num) {
    91a6:	ldrb	r2, [r1, #0]
#define C2_TX_INACTIVE		C2_ENABLE

void serial_begin(uint32_t divisor)
{
	SIM_SCGC4 |= SIM_SCGC4_UART0;	// turn on clock, TODO: use bitband
	rx_buffer_head = 0;
    91a8:	ldr	r7, [pc, #192]	; (926c <serial_begin+0xd4>)
	rx_buffer_tail = 0;
    91aa:	ldr	r6, [pc, #196]	; (9270 <serial_begin+0xd8>)
	tx_buffer_head = 0;
    91ac:	ldr	r5, [pc, #196]	; (9274 <serial_begin+0xdc>)
	tx_buffer_tail = 0;
    91ae:	ldr	r4, [pc, #200]	; (9278 <serial_begin+0xe0>)
	transmitting = 0;
    91b0:	ldr	r1, [pc, #200]	; (927c <serial_begin+0xe4>)
#define C2_TX_INACTIVE		C2_ENABLE

void serial_begin(uint32_t divisor)
{
	SIM_SCGC4 |= SIM_SCGC4_UART0;	// turn on clock, TODO: use bitband
	rx_buffer_head = 0;
    91b2:	movs	r3, #0
	rx_buffer_tail = 0;
	tx_buffer_head = 0;
	tx_buffer_tail = 0;
	transmitting = 0;
	switch (rx_pin_num) {
    91b4:	cmp	r2, #21
#define C2_TX_INACTIVE		C2_ENABLE

void serial_begin(uint32_t divisor)
{
	SIM_SCGC4 |= SIM_SCGC4_UART0;	// turn on clock, TODO: use bitband
	rx_buffer_head = 0;
    91b6:	strb	r3, [r7, #0]
	rx_buffer_tail = 0;
    91b8:	strb	r3, [r6, #0]
	tx_buffer_head = 0;
    91ba:	strb	r3, [r5, #0]
	tx_buffer_tail = 0;
    91bc:	strb	r3, [r4, #0]
	transmitting = 0;
    91be:	strb	r3, [r1, #0]
	switch (rx_pin_num) {
    91c0:	beq.n	924e <serial_begin+0xb6>
    91c2:	cmp	r2, #27
    91c4:	beq.n	9244 <serial_begin+0xac>
    91c6:	cbz	r2, 922a <serial_begin+0x92>
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
		#endif
	}
	switch (tx_pin_num) {
    91c8:	ldr	r3, [pc, #180]	; (9280 <serial_begin+0xe8>)
    91ca:	ldrb	r3, [r3, #0]
    91cc:	cmp	r3, #5
    91ce:	beq.n	923a <serial_begin+0xa2>
    91d0:	cmp	r3, #26
    91d2:	beq.n	9258 <serial_begin+0xc0>
    91d4:	cmp	r3, #1
    91d6:	beq.n	9210 <serial_begin+0x78>
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 26: CORE_PIN26_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
		#endif
	}
#if defined(HAS_KINETISK_UART0)
	if (divisor < 32) divisor = 32;
    91d8:	cmp	r0, #31
    91da:	bhi.n	921c <serial_begin+0x84>
    91dc:	movs	r0, #0
    91de:	mov	r2, r0
    91e0:	movs	r5, #1
	UART0_BDH = (divisor >> 13) & 0x1F;
    91e2:	ldr	r3, [pc, #160]	; (9284 <serial_begin+0xec>)
	UART0_BDH = (divisor >> 8) & 0x1F;
	UART0_BDL = divisor & 0xFF;
	UART0_C1 = 0;
#endif
	UART0_C2 = C2_TX_INACTIVE;
	NVIC_SET_PRIORITY(IRQ_UART0_STATUS, IRQ_PRIORITY);
    91e4:	ldr	r4, [pc, #160]	; (9288 <serial_begin+0xf0>)
		case 26: CORE_PIN26_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
		#endif
	}
#if defined(HAS_KINETISK_UART0)
	if (divisor < 32) divisor = 32;
	UART0_BDH = (divisor >> 13) & 0x1F;
    91e6:	strb	r2, [r3, #0]
	UART0_BDL = divisor & 0xFF;
	UART0_C1 = 0;
#endif
	UART0_C2 = C2_TX_INACTIVE;
	NVIC_SET_PRIORITY(IRQ_UART0_STATUS, IRQ_PRIORITY);
	NVIC_ENABLE_IRQ(IRQ_UART0_STATUS);
    91e8:	ldr	r1, [pc, #160]	; (928c <serial_begin+0xf4>)
		#endif
	}
#if defined(HAS_KINETISK_UART0)
	if (divisor < 32) divisor = 32;
	UART0_BDH = (divisor >> 13) & 0x1F;
	UART0_BDL = (divisor >> 5) & 0xFF;
    91ea:	strb	r5, [r3, #1]
	UART0_C4 = divisor & 0x1F;
#ifdef HAS_KINETISK_UART0_FIFO
	UART0_C1 = UART_C1_ILT;
    91ec:	movs	r2, #4
	UART0_TWFIFO = 2; // tx watermark, causes S1_TDRE to set
    91ee:	mov.w	lr, #2
	UART0_RWFIFO = 4; // rx watermark, causes S1_RDRF to set
	UART0_PFIFO = UART_PFIFO_TXFE | UART_PFIFO_RXFE;
    91f2:	movs	r7, #136	; 0x88
	if (divisor < 1) divisor = 1;
	UART0_BDH = (divisor >> 8) & 0x1F;
	UART0_BDL = divisor & 0xFF;
	UART0_C1 = 0;
#endif
	UART0_C2 = C2_TX_INACTIVE;
    91f4:	movs	r6, #60	; 0x3c
	NVIC_SET_PRIORITY(IRQ_UART0_STATUS, IRQ_PRIORITY);
    91f6:	movs	r5, #64	; 0x40
	}
#if defined(HAS_KINETISK_UART0)
	if (divisor < 32) divisor = 32;
	UART0_BDH = (divisor >> 13) & 0x1F;
	UART0_BDL = (divisor >> 5) & 0xFF;
	UART0_C4 = divisor & 0x1F;
    91f8:	strb	r0, [r3, #10]
#ifdef HAS_KINETISK_UART0_FIFO
	UART0_C1 = UART_C1_ILT;
    91fa:	strb	r2, [r3, #2]
	UART0_BDL = divisor & 0xFF;
	UART0_C1 = 0;
#endif
	UART0_C2 = C2_TX_INACTIVE;
	NVIC_SET_PRIORITY(IRQ_UART0_STATUS, IRQ_PRIORITY);
	NVIC_ENABLE_IRQ(IRQ_UART0_STATUS);
    91fc:	mov.w	r0, #2147483648	; 0x80000000
	UART0_BDH = (divisor >> 13) & 0x1F;
	UART0_BDL = (divisor >> 5) & 0xFF;
	UART0_C4 = divisor & 0x1F;
#ifdef HAS_KINETISK_UART0_FIFO
	UART0_C1 = UART_C1_ILT;
	UART0_TWFIFO = 2; // tx watermark, causes S1_TDRE to set
    9200:	strb.w	lr, [r3, #19]
	UART0_RWFIFO = 4; // rx watermark, causes S1_RDRF to set
    9204:	strb	r2, [r3, #21]
	UART0_PFIFO = UART_PFIFO_TXFE | UART_PFIFO_RXFE;
    9206:	strb	r7, [r3, #16]
	if (divisor < 1) divisor = 1;
	UART0_BDH = (divisor >> 8) & 0x1F;
	UART0_BDL = divisor & 0xFF;
	UART0_C1 = 0;
#endif
	UART0_C2 = C2_TX_INACTIVE;
    9208:	strb	r6, [r3, #3]
	NVIC_SET_PRIORITY(IRQ_UART0_STATUS, IRQ_PRIORITY);
    920a:	strb	r5, [r4, #0]
	NVIC_ENABLE_IRQ(IRQ_UART0_STATUS);
    920c:	str	r0, [r1, #0]
    920e:	pop	{r4, r5, r6, r7, pc}
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
		#endif
	}
	switch (tx_pin_num) {
		case 1:  CORE_PIN1_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
    9210:	ldr	r3, [pc, #124]	; (9290 <serial_begin+0xf8>)
    9212:	mov.w	r2, #836	; 0x344
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 26: CORE_PIN26_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
		#endif
	}
#if defined(HAS_KINETISK_UART0)
	if (divisor < 32) divisor = 32;
    9216:	cmp	r0, #31
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
		#endif
	}
	switch (tx_pin_num) {
		case 1:  CORE_PIN1_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
    9218:	str	r2, [r3, #0]
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 26: CORE_PIN26_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
		#endif
	}
#if defined(HAS_KINETISK_UART0)
	if (divisor < 32) divisor = 32;
    921a:	bls.n	91dc <serial_begin+0x44>
    921c:	ubfx	r2, r0, #13, #5
    9220:	ubfx	r5, r0, #5, #8
    9224:	and.w	r0, r0, #31
    9228:	b.n	91e2 <serial_begin+0x4a>
	rx_buffer_tail = 0;
	tx_buffer_head = 0;
	tx_buffer_tail = 0;
	transmitting = 0;
	switch (rx_pin_num) {
		case 0:  CORE_PIN0_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
    922a:	ldr	r3, [pc, #104]	; (9294 <serial_begin+0xfc>)
    922c:	movw	r2, #787	; 0x313
    9230:	str	r2, [r3, #0]
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
		#endif
	}
	switch (tx_pin_num) {
    9232:	ldr	r3, [pc, #76]	; (9280 <serial_begin+0xe8>)
    9234:	ldrb	r3, [r3, #0]
    9236:	cmp	r3, #5
    9238:	bne.n	91d0 <serial_begin+0x38>
		case 1:  CORE_PIN1_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
		case 5:  CORE_PIN5_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
    923a:	ldr	r3, [pc, #92]	; (9298 <serial_begin+0x100>)
    923c:	mov.w	r2, #836	; 0x344
    9240:	str	r2, [r3, #0]
    9242:	b.n	91d8 <serial_begin+0x40>
		#if defined(KINETISL)
		case 3:  CORE_PIN3_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(2); break;
		case 25: CORE_PIN25_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(4); break;
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
    9244:	ldr	r3, [pc, #84]	; (929c <serial_begin+0x104>)
    9246:	movw	r2, #787	; 0x313
    924a:	str	r2, [r3, #0]
    924c:	b.n	91c8 <serial_begin+0x30>
	tx_buffer_head = 0;
	tx_buffer_tail = 0;
	transmitting = 0;
	switch (rx_pin_num) {
		case 0:  CORE_PIN0_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
		case 21: CORE_PIN21_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
    924e:	ldr	r3, [pc, #80]	; (92a0 <serial_begin+0x108>)
    9250:	movw	r2, #787	; 0x313
    9254:	str	r2, [r3, #0]
    9256:	b.n	91c8 <serial_begin+0x30>
		#if defined(KINETISL)
		case 4:  CORE_PIN4_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(2); break;
		case 24: CORE_PIN24_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(4); break;
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 26: CORE_PIN26_CONFIG = PORT_PCR_DSE | PORT_PCR_SRE | PORT_PCR_MUX(3); break;
    9258:	ldr	r3, [pc, #72]	; (92a4 <serial_begin+0x10c>)
    925a:	mov.w	r2, #836	; 0x344
    925e:	str	r2, [r3, #0]
    9260:	b.n	91d8 <serial_begin+0x40>
    9262:	nop
    9264:	.word	0x40048034
    9268:	.word	0x1fff1948
    926c:	.word	0x1fff1904
    9270:	.word	0x1fff1905
    9274:	.word	0x1fff1994
    9278:	.word	0x1fff198d
    927c:	.word	0x1fff198c
    9280:	.word	0x1fff0984
    9284:	.word	0x4006a000
    9288:	.word	0xe000e41f
    928c:	.word	0xe000e100
    9290:	.word	0x4004a044
    9294:	.word	0x4004a040
    9298:	.word	0x4004c01c
    929c:	.word	0x4004903c
    92a0:	.word	0x4004c018
    92a4:	.word	0x40049038

000092a8 <serial_format>:

void serial_format(uint32_t format)
{
	uint8_t c;

	c = UART0_C1;
    92a8:	ldr	r3, [pc, #100]	; (9310 <serial_format+0x68>)
	c = (c & ~0x13) | (format & 0x03);	// configure parity
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
	UART0_C1 = c;
    92aa:	ldr	r1, [pc, #100]	; (9310 <serial_format+0x68>)

void serial_format(uint32_t format)
{
	uint8_t c;

	c = UART0_C1;
    92ac:	ldrb	r3, [r3, #2]
	c = (c & ~0x13) | (format & 0x03);	// configure parity
    92ae:	and.w	r2, r3, #236	; 0xec
    92b2:	and.w	r3, r0, #3
    92b6:	orrs	r3, r2
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
    92b8:	lsls	r2, r0, #29
	UART0_C1 = c;
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
    92ba:	and.w	r2, r0, #15
{
	uint8_t c;

	c = UART0_C1;
	c = (c & ~0x13) | (format & 0x03);	// configure parity
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
    92be:	it	mi
    92c0:	orrmi.w	r3, r3, #16
	UART0_C1 = c;
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
    92c4:	cmp	r2, #4
	uint8_t c;

	c = UART0_C1;
	c = (c & ~0x13) | (format & 0x03);	// configure parity
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
	UART0_C1 = c;
    92c6:	strb	r3, [r1, #2]
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
    92c8:	beq.n	9304 <serial_format+0x5c>
	c = UART0_S2 & ~0x10;
    92ca:	ldr	r3, [pc, #68]	; (9310 <serial_format+0x68>)
	if (format & 0x10) c |= 0x10;		// rx invert
	UART0_S2 = c;
    92cc:	ldr	r2, [pc, #64]	; (9310 <serial_format+0x68>)
	c = UART0_C1;
	c = (c & ~0x13) | (format & 0x03);	// configure parity
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
	UART0_C1 = c;
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
	c = UART0_S2 & ~0x10;
    92ce:	ldrb	r3, [r3, #5]
	if (format & 0x10) c |= 0x10;		// rx invert
    92d0:	lsls	r1, r0, #27
	c = UART0_C1;
	c = (c & ~0x13) | (format & 0x03);	// configure parity
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
	UART0_C1 = c;
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
	c = UART0_S2 & ~0x10;
    92d2:	and.w	r3, r3, #239	; 0xef
	if (format & 0x10) c |= 0x10;		// rx invert
    92d6:	it	mi
    92d8:	orrmi.w	r3, r3, #16
	UART0_S2 = c;
    92dc:	strb	r3, [r2, #5]
	c = UART0_C3 & ~0x10;
    92de:	ldrb	r3, [r2, #6]
	if (format & 0x20) c |= 0x10;		// tx invert
    92e0:	lsls	r2, r0, #26
	UART0_C1 = c;
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
	c = UART0_S2 & ~0x10;
	if (format & 0x10) c |= 0x10;		// rx invert
	UART0_S2 = c;
	c = UART0_C3 & ~0x10;
    92e2:	and.w	r3, r3, #239	; 0xef
	if (format & 0x20) c |= 0x10;		// tx invert
	UART0_C3 = c;
    92e6:	ldr	r2, [pc, #40]	; (9310 <serial_format+0x68>)
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
	c = UART0_S2 & ~0x10;
	if (format & 0x10) c |= 0x10;		// rx invert
	UART0_S2 = c;
	c = UART0_C3 & ~0x10;
	if (format & 0x20) c |= 0x10;		// tx invert
    92e8:	it	mi
    92ea:	orrmi.w	r3, r3, #16
	UART0_C3 = c;
    92ee:	strb	r3, [r2, #6]
	UART0_C4 = c;
	use9Bits = format & 0x80;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(KINETISL)
	// For T3.5/T3.6/TLC See about turning on 2 stop bit mode
	if ( format & 0x100) {
    92f0:	lsls	r3, r0, #23
    92f2:	bpl.n	9302 <serial_format+0x5a>
		uint8_t bdl = UART0_BDL;
    92f4:	ldrb	r3, [r2, #1]
		UART0_BDH |= UART_BDH_SBNS;		// Turn on 2 stop bits - was turned off by set baud
    92f6:	ldrb	r1, [r2, #0]
	use9Bits = format & 0x80;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(KINETISL)
	// For T3.5/T3.6/TLC See about turning on 2 stop bit mode
	if ( format & 0x100) {
		uint8_t bdl = UART0_BDL;
    92f8:	uxtb	r3, r3
		UART0_BDH |= UART_BDH_SBNS;		// Turn on 2 stop bits - was turned off by set baud
    92fa:	orr.w	r1, r1, #32
    92fe:	strb	r1, [r2, #0]
		UART0_BDL = bdl;		// Says BDH not acted on until BDL is written
    9300:	strb	r3, [r2, #1]
    9302:	bx	lr

	c = UART0_C1;
	c = (c & ~0x13) | (format & 0x03);	// configure parity
	if (format & 0x04) c |= 0x10;		// 9 bits (might include parity)
	UART0_C1 = c;
	if ((format & 0x0F) == 0x04) UART0_C3 |= 0x40; // 8N2 is 9 bit with 9th bit always 1
    9304:	ldrb	r3, [r1, #6]
    9306:	orr.w	r3, r3, #64	; 0x40
    930a:	strb	r3, [r1, #6]
    930c:	b.n	92ca <serial_format+0x22>
    930e:	nop
    9310:	.word	0x4006a000

00009314 <serial_end>:
#endif
}

void serial_end(void)
{
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
    9314:	ldr	r3, [pc, #168]	; (93c0 <serial_end+0xac>)
    9316:	ldr	r3, [r3, #0]
    9318:	lsls	r3, r3, #21
    931a:	bpl.n	938a <serial_end+0x76>
	}
#endif
}

void serial_end(void)
{
    931c:	push	{r4, lr}
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	while (transmitting) yield();  // wait for buffered data to send
    931e:	ldr	r4, [pc, #164]	; (93c4 <serial_end+0xb0>)
    9320:	ldrb	r3, [r4, #0]
    9322:	cbz	r3, 932e <serial_end+0x1a>
    9324:	bl	ac8c <yield>
    9328:	ldrb	r3, [r4, #0]
    932a:	cmp	r3, #0
    932c:	bne.n	9324 <serial_end+0x10>
	NVIC_DISABLE_IRQ(IRQ_UART0_STATUS);
    932e:	ldr	r0, [pc, #152]	; (93c8 <serial_end+0xb4>)
	UART0_C2 = 0;
    9330:	ldr	r2, [pc, #152]	; (93cc <serial_end+0xb8>)
	switch (rx_pin_num) {
    9332:	ldr	r3, [pc, #156]	; (93d0 <serial_end+0xbc>)

void serial_end(void)
{
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	while (transmitting) yield();  // wait for buffered data to send
	NVIC_DISABLE_IRQ(IRQ_UART0_STATUS);
    9334:	mov.w	r4, #2147483648	; 0x80000000
	UART0_C2 = 0;
    9338:	movs	r1, #0

void serial_end(void)
{
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	while (transmitting) yield();  // wait for buffered data to send
	NVIC_DISABLE_IRQ(IRQ_UART0_STATUS);
    933a:	str	r4, [r0, #0]
	UART0_C2 = 0;
    933c:	strb	r1, [r2, #3]
	switch (rx_pin_num) {
    933e:	ldrb	r3, [r3, #0]
    9340:	cmp	r3, #21
    9342:	beq.n	938c <serial_end+0x78>
    9344:	cmp	r3, #27
    9346:	beq.n	93b4 <serial_end+0xa0>
    9348:	cbnz	r3, 9352 <serial_end+0x3e>
		case 0:  CORE_PIN0_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
    934a:	ldr	r3, [pc, #136]	; (93d4 <serial_end+0xc0>)
    934c:	movw	r2, #259	; 0x103
    9350:	str	r2, [r3, #0]
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		#endif
	}
	switch (tx_pin_num & 127) {
    9352:	ldr	r3, [pc, #132]	; (93d8 <serial_end+0xc4>)
    9354:	ldrb	r3, [r3, #0]
    9356:	and.w	r3, r3, #127	; 0x7f
    935a:	cmp	r3, #5
    935c:	beq.n	93a0 <serial_end+0x8c>
    935e:	cmp	r3, #26
    9360:	beq.n	93aa <serial_end+0x96>
    9362:	cmp	r3, #1
    9364:	bne.n	936e <serial_end+0x5a>
		case 1:  CORE_PIN1_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
    9366:	ldr	r3, [pc, #116]	; (93dc <serial_end+0xc8>)
    9368:	movw	r2, #259	; 0x103
    936c:	str	r2, [r3, #0]
	}
	UART0_S1;
	UART0_D; // clear leftover error status
	rx_buffer_head = 0;
	rx_buffer_tail = 0;
	if (rts_pin) rts_deassert();
    936e:	ldr	r2, [pc, #112]	; (93e0 <serial_end+0xcc>)
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 26: CORE_PIN26_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		#endif
	}
	UART0_S1;
    9370:	ldr	r3, [pc, #88]	; (93cc <serial_end+0xb8>)
	UART0_D; // clear leftover error status
	rx_buffer_head = 0;
    9372:	ldr	r0, [pc, #112]	; (93e4 <serial_end+0xd0>)
	rx_buffer_tail = 0;
    9374:	ldr	r1, [pc, #112]	; (93e8 <serial_end+0xd4>)
	if (rts_pin) rts_deassert();
    9376:	ldr	r2, [r2, #0]
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 26: CORE_PIN26_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		#endif
	}
	UART0_S1;
    9378:	ldrb	r4, [r3, #4]
	UART0_D; // clear leftover error status
    937a:	ldrb	r3, [r3, #7]
	rx_buffer_head = 0;
    937c:	movs	r3, #0
    937e:	strb	r3, [r0, #0]
	rx_buffer_tail = 0;
    9380:	strb	r3, [r1, #0]
	if (rts_pin) rts_deassert();
    9382:	cbz	r2, 9388 <serial_end+0x74>
    9384:	movs	r3, #1
    9386:	strb	r3, [r2, #0]
    9388:	pop	{r4, pc}
    938a:	bx	lr
	while (transmitting) yield();  // wait for buffered data to send
	NVIC_DISABLE_IRQ(IRQ_UART0_STATUS);
	UART0_C2 = 0;
	switch (rx_pin_num) {
		case 0:  CORE_PIN0_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		case 21: CORE_PIN21_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
    938c:	ldr	r3, [pc, #92]	; (93ec <serial_end+0xd8>)
    938e:	movw	r2, #259	; 0x103
    9392:	str	r2, [r3, #0]
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		#endif
	}
	switch (tx_pin_num & 127) {
    9394:	ldr	r3, [pc, #64]	; (93d8 <serial_end+0xc4>)
    9396:	ldrb	r3, [r3, #0]
    9398:	and.w	r3, r3, #127	; 0x7f
    939c:	cmp	r3, #5
    939e:	bne.n	935e <serial_end+0x4a>
		case 1:  CORE_PIN1_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		case 5:  CORE_PIN5_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
    93a0:	ldr	r3, [pc, #76]	; (93f0 <serial_end+0xdc>)
    93a2:	movw	r2, #259	; 0x103
    93a6:	str	r2, [r3, #0]
    93a8:	b.n	936e <serial_end+0x5a>
		#if defined(KINETISL)
		case 4:  CORE_PIN4_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		case 24: CORE_PIN24_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 26: CORE_PIN26_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
    93aa:	ldr	r3, [pc, #72]	; (93f4 <serial_end+0xe0>)
    93ac:	movw	r2, #259	; 0x103
    93b0:	str	r2, [r3, #0]
    93b2:	b.n	936e <serial_end+0x5a>
		#if defined(KINETISL)
		case 3:  CORE_PIN3_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		case 25: CORE_PIN25_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
		#endif
		#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
		case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_MUX(1); break;
    93b4:	ldr	r3, [pc, #64]	; (93f8 <serial_end+0xe4>)
    93b6:	movw	r2, #259	; 0x103
    93ba:	str	r2, [r3, #0]
    93bc:	b.n	9352 <serial_end+0x3e>
    93be:	nop
    93c0:	.word	0x40048034
    93c4:	.word	0x1fff198c
    93c8:	.word	0xe000e180
    93cc:	.word	0x4006a000
    93d0:	.word	0x1fff1948
    93d4:	.word	0x4004a040
    93d8:	.word	0x1fff0984
    93dc:	.word	0x4004a044
    93e0:	.word	0x1fff1900
    93e4:	.word	0x1fff1904
    93e8:	.word	0x1fff1905
    93ec:	.word	0x4004c018
    93f0:	.word	0x4004c01c
    93f4:	.word	0x40049038
    93f8:	.word	0x4004903c

000093fc <serial_set_transmit_pin>:
	rx_buffer_tail = 0;
	if (rts_pin) rts_deassert();
}

void serial_set_transmit_pin(uint8_t pin)
{
    93fc:	ldr	r2, [pc, #40]	; (9428 <serial_set_transmit_pin+0x2c>)
    93fe:	push	{r3, r4, r5, lr}
    9400:	mov	r5, r0
	while (transmitting) ;
    9402:	ldrb	r3, [r2, #0]
    9404:	and.w	r4, r3, #255	; 0xff
    9408:	cmp	r3, #0
    940a:	bne.n	9402 <serial_set_transmit_pin+0x6>
	pinMode(pin, OUTPUT);
    940c:	movs	r1, #1
    940e:	mov	r0, r5
    9410:	bl	99fc <pinMode>
	digitalWrite(pin, LOW);
    9414:	mov	r1, r4
    9416:	mov	r0, r5
    9418:	bl	99f0 <digitalWrite>
	transmit_pin = portOutputRegister(pin);
    941c:	ldr	r2, [pc, #12]	; (942c <serial_set_transmit_pin+0x30>)
    941e:	ldr	r3, [pc, #16]	; (9430 <serial_set_transmit_pin+0x34>)
    9420:	ldr.w	r2, [r2, r5, lsl #3]
    9424:	str	r2, [r3, #0]
    9426:	pop	{r3, r4, r5, pc}
    9428:	.word	0x1fff198c
    942c:	.word	0x0000c550
    9430:	.word	0x1fff1990

00009434 <serial_set_tx>:

void serial_set_tx(uint8_t pin, uint8_t opendrain)
{
	uint32_t cfg;

	if (opendrain) pin |= 128;
    9434:	cbz	r1, 943a <serial_set_tx+0x6>
    9436:	orr.w	r0, r0, #128	; 0x80
	if (pin == tx_pin_num) return;
    943a:	ldr	r2, [pc, #120]	; (94b4 <serial_set_tx+0x80>)
    943c:	ldrb	r3, [r2, #0]
    943e:	cmp	r0, r3
    9440:	beq.n	947a <serial_set_tx+0x46>
	transmit_mask = digitalPinToBitMask(pin);
	#endif
}

void serial_set_tx(uint8_t pin, uint8_t opendrain)
{
    9442:	push	{r4}
	uint32_t cfg;

	if (opendrain) pin |= 128;
	if (pin == tx_pin_num) return;
	if ((SIM_SCGC4 & SIM_SCGC4_UART0)) {
    9444:	ldr	r4, [pc, #112]	; (94b8 <serial_set_tx+0x84>)
    9446:	ldr	r4, [r4, #0]
    9448:	lsls	r4, r4, #21
    944a:	bpl.n	9474 <serial_set_tx+0x40>
		switch (tx_pin_num & 127) {
    944c:	and.w	r3, r3, #127	; 0x7f
    9450:	cmp	r3, #5
    9452:	beq.n	94aa <serial_set_tx+0x76>
    9454:	cmp	r3, #26
    9456:	beq.n	94a2 <serial_set_tx+0x6e>
    9458:	cmp	r3, #1
    945a:	beq.n	9486 <serial_set_tx+0x52>
			#endif
		}
		if (opendrain) {
			cfg = PORT_PCR_DSE | PORT_PCR_ODE;
		} else {
			cfg = PORT_PCR_DSE | PORT_PCR_SRE;
    945c:	cmp	r1, #0
		}
		switch (pin & 127) {
    945e:	and.w	r1, r0, #127	; 0x7f
			#endif
		}
		if (opendrain) {
			cfg = PORT_PCR_DSE | PORT_PCR_ODE;
		} else {
			cfg = PORT_PCR_DSE | PORT_PCR_SRE;
    9462:	ite	ne
    9464:	movne	r3, #96	; 0x60
    9466:	moveq	r3, #68	; 0x44
		}
		switch (pin & 127) {
    9468:	cmp	r1, #5
    946a:	beq.n	9498 <serial_set_tx+0x64>
    946c:	cmp	r1, #26
    946e:	beq.n	948e <serial_set_tx+0x5a>
    9470:	cmp	r1, #1
    9472:	beq.n	947c <serial_set_tx+0x48>
			#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
			case 26: CORE_PIN26_CONFIG = cfg | PORT_PCR_MUX(3); break;
			#endif
		}
	}
	tx_pin_num = pin;
    9474:	strb	r0, [r2, #0]
}
    9476:	ldr.w	r4, [sp], #4
    947a:	bx	lr
			cfg = PORT_PCR_DSE | PORT_PCR_ODE;
		} else {
			cfg = PORT_PCR_DSE | PORT_PCR_SRE;
		}
		switch (pin & 127) {
			case 1:  CORE_PIN1_CONFIG = cfg | PORT_PCR_MUX(3); break;
    947c:	ldr	r1, [pc, #60]	; (94bc <serial_set_tx+0x88>)
    947e:	orr.w	r3, r3, #768	; 0x300
    9482:	str	r3, [r1, #0]
    9484:	b.n	9474 <serial_set_tx+0x40>

	if (opendrain) pin |= 128;
	if (pin == tx_pin_num) return;
	if ((SIM_SCGC4 & SIM_SCGC4_UART0)) {
		switch (tx_pin_num & 127) {
			case 1:  CORE_PIN1_CONFIG = 0; break; // PTB17
    9486:	ldr	r3, [pc, #52]	; (94bc <serial_set_tx+0x88>)
    9488:	movs	r4, #0
    948a:	str	r4, [r3, #0]
    948c:	b.n	945c <serial_set_tx+0x28>
			#if defined(KINETISL)
			case 4:  CORE_PIN4_CONFIG = cfg | PORT_PCR_MUX(2); break;
			case 24: CORE_PIN24_CONFIG = cfg | PORT_PCR_MUX(4); break;
			#endif
			#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
			case 26: CORE_PIN26_CONFIG = cfg | PORT_PCR_MUX(3); break;
    948e:	ldr	r1, [pc, #48]	; (94c0 <serial_set_tx+0x8c>)
    9490:	orr.w	r3, r3, #768	; 0x300
    9494:	str	r3, [r1, #0]
    9496:	b.n	9474 <serial_set_tx+0x40>
		} else {
			cfg = PORT_PCR_DSE | PORT_PCR_SRE;
		}
		switch (pin & 127) {
			case 1:  CORE_PIN1_CONFIG = cfg | PORT_PCR_MUX(3); break;
			case 5:  CORE_PIN5_CONFIG = cfg | PORT_PCR_MUX(3); break;
    9498:	ldr	r1, [pc, #40]	; (94c4 <serial_set_tx+0x90>)
    949a:	orr.w	r3, r3, #768	; 0x300
    949e:	str	r3, [r1, #0]
    94a0:	b.n	9474 <serial_set_tx+0x40>
			#if defined(KINETISL)
			case 4:  CORE_PIN4_CONFIG = 0; break; // PTA2
			case 24: CORE_PIN24_CONFIG = 0; break; // PTE20
			#endif
			#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
			case 26: CORE_PIN26_CONFIG = 0; break; //PTA14
    94a2:	ldr	r3, [pc, #28]	; (94c0 <serial_set_tx+0x8c>)
    94a4:	movs	r4, #0
    94a6:	str	r4, [r3, #0]
    94a8:	b.n	945c <serial_set_tx+0x28>
	if (opendrain) pin |= 128;
	if (pin == tx_pin_num) return;
	if ((SIM_SCGC4 & SIM_SCGC4_UART0)) {
		switch (tx_pin_num & 127) {
			case 1:  CORE_PIN1_CONFIG = 0; break; // PTB17
			case 5:  CORE_PIN5_CONFIG = 0; break; // PTD7
    94aa:	ldr	r3, [pc, #24]	; (94c4 <serial_set_tx+0x90>)
    94ac:	movs	r4, #0
    94ae:	str	r4, [r3, #0]
    94b0:	b.n	945c <serial_set_tx+0x28>
    94b2:	nop
    94b4:	.word	0x1fff0984
    94b8:	.word	0x40048034
    94bc:	.word	0x4004a044
    94c0:	.word	0x40049038
    94c4:	.word	0x4004c01c

000094c8 <serial_set_rx>:
	tx_pin_num = pin;
}

void serial_set_rx(uint8_t pin)
{
	if (pin == rx_pin_num) return;
    94c8:	ldr	r2, [pc, #92]	; (9528 <serial_set_rx+0x60>)
    94ca:	ldrb	r3, [r2, #0]
    94cc:	cmp	r3, r0
    94ce:	beq.n	94ee <serial_set_rx+0x26>
	if ((SIM_SCGC4 & SIM_SCGC4_UART0)) {
    94d0:	ldr	r1, [pc, #88]	; (952c <serial_set_rx+0x64>)
    94d2:	ldr	r1, [r1, #0]
    94d4:	lsls	r1, r1, #21
    94d6:	bpl.n	94ec <serial_set_rx+0x24>
		switch (rx_pin_num) {
    94d8:	cmp	r3, #21
    94da:	beq.n	951e <serial_set_rx+0x56>
    94dc:	cmp	r3, #27
    94de:	beq.n	9516 <serial_set_rx+0x4e>
    94e0:	cbz	r3, 94fa <serial_set_rx+0x32>
			#endif
			#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
			case 27: CORE_PIN27_CONFIG = 0; break; // PTA15
			#endif
		}
		switch (pin) {
    94e2:	cmp	r0, #21
    94e4:	beq.n	9502 <serial_set_rx+0x3a>
    94e6:	cmp	r0, #27
    94e8:	beq.n	950c <serial_set_rx+0x44>
    94ea:	cbz	r0, 94f0 <serial_set_rx+0x28>
			#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
			case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
			#endif
		}
	}
	rx_pin_num = pin;
    94ec:	strb	r0, [r2, #0]
    94ee:	bx	lr
			#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
			case 27: CORE_PIN27_CONFIG = 0; break; // PTA15
			#endif
		}
		switch (pin) {
			case 0:  CORE_PIN0_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
    94f0:	ldr	r3, [pc, #60]	; (9530 <serial_set_rx+0x68>)
    94f2:	movw	r1, #787	; 0x313
    94f6:	str	r1, [r3, #0]
    94f8:	b.n	94ec <serial_set_rx+0x24>
void serial_set_rx(uint8_t pin)
{
	if (pin == rx_pin_num) return;
	if ((SIM_SCGC4 & SIM_SCGC4_UART0)) {
		switch (rx_pin_num) {
			case 0:  CORE_PIN0_CONFIG = 0; break; // PTB16
    94fa:	ldr	r1, [pc, #52]	; (9530 <serial_set_rx+0x68>)
			#endif
			#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
			case 27: CORE_PIN27_CONFIG = 0; break; // PTA15
			#endif
		}
		switch (pin) {
    94fc:	cmp	r0, #21
void serial_set_rx(uint8_t pin)
{
	if (pin == rx_pin_num) return;
	if ((SIM_SCGC4 & SIM_SCGC4_UART0)) {
		switch (rx_pin_num) {
			case 0:  CORE_PIN0_CONFIG = 0; break; // PTB16
    94fe:	str	r3, [r1, #0]
			#endif
			#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
			case 27: CORE_PIN27_CONFIG = 0; break; // PTA15
			#endif
		}
		switch (pin) {
    9500:	bne.n	94e6 <serial_set_rx+0x1e>
			case 0:  CORE_PIN0_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
			case 21: CORE_PIN21_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
    9502:	ldr	r3, [pc, #48]	; (9534 <serial_set_rx+0x6c>)
    9504:	movw	r1, #787	; 0x313
    9508:	str	r1, [r3, #0]
    950a:	b.n	94ec <serial_set_rx+0x24>
			#if defined(KINETISL)
			case 3:  CORE_PIN3_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(2); break;
			case 25: CORE_PIN25_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(4); break;
			#endif
			#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
			case 27: CORE_PIN27_CONFIG = PORT_PCR_PE | PORT_PCR_PS | PORT_PCR_PFE | PORT_PCR_MUX(3); break;
    950c:	ldr	r3, [pc, #40]	; (9538 <serial_set_rx+0x70>)
    950e:	movw	r1, #787	; 0x313
    9512:	str	r1, [r3, #0]
    9514:	b.n	94ec <serial_set_rx+0x24>
			#if defined(KINETISL)
			case 3:  CORE_PIN3_CONFIG = 0; break; // PTA1
			case 25: CORE_PIN25_CONFIG = 0; break; // PTE21
			#endif
			#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
			case 27: CORE_PIN27_CONFIG = 0; break; // PTA15
    9516:	ldr	r3, [pc, #32]	; (9538 <serial_set_rx+0x70>)
    9518:	movs	r1, #0
    951a:	str	r1, [r3, #0]
    951c:	b.n	94e2 <serial_set_rx+0x1a>
{
	if (pin == rx_pin_num) return;
	if ((SIM_SCGC4 & SIM_SCGC4_UART0)) {
		switch (rx_pin_num) {
			case 0:  CORE_PIN0_CONFIG = 0; break; // PTB16
			case 21: CORE_PIN21_CONFIG = 0; break; // PTD6
    951e:	ldr	r3, [pc, #20]	; (9534 <serial_set_rx+0x6c>)
    9520:	movs	r1, #0
    9522:	str	r1, [r3, #0]
    9524:	b.n	94e2 <serial_set_rx+0x1a>
    9526:	nop
    9528:	.word	0x1fff1948
    952c:	.word	0x40048034
    9530:	.word	0x4004a040
    9534:	.word	0x4004c018
    9538:	.word	0x4004903c

0000953c <serial_set_rts>:



int serial_set_rts(uint8_t pin)
{
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return 0;
    953c:	ldr	r3, [pc, #52]	; (9574 <serial_set_rts+0x38>)
    953e:	ldr	r3, [r3, #0]
    9540:	ands.w	r3, r3, #1024	; 0x400
    9544:	beq.n	9552 <serial_set_rts+0x16>
	if (pin < CORE_NUM_DIGITAL) {
    9546:	cmp	r0, #63	; 0x3f
    9548:	bls.n	9556 <serial_set_rts+0x1a>
		rts_mask = digitalPinToBitMask(pin);
		#endif
		pinMode(pin, OUTPUT);
		rts_assert();
	} else {
		rts_pin = NULL;
    954a:	ldr	r3, [pc, #44]	; (9578 <serial_set_rts+0x3c>)
    954c:	movs	r0, #0
    954e:	str	r0, [r3, #0]
		return 0;
    9550:	bx	lr



int serial_set_rts(uint8_t pin)
{
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return 0;
    9552:	mov	r0, r3
    9554:	bx	lr
	if (pin < CORE_NUM_DIGITAL) {
		rts_pin = portOutputRegister(pin);
    9556:	ldr	r3, [pc, #36]	; (957c <serial_set_rts+0x40>)
}



int serial_set_rts(uint8_t pin)
{
    9558:	push	{r4, lr}
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return 0;
	if (pin < CORE_NUM_DIGITAL) {
		rts_pin = portOutputRegister(pin);
    955a:	ldr	r4, [pc, #28]	; (9578 <serial_set_rts+0x3c>)
    955c:	ldr.w	r3, [r3, r0, lsl #3]
    9560:	str	r3, [r4, #0]
		#if defined(KINETISL)
		rts_mask = digitalPinToBitMask(pin);
		#endif
		pinMode(pin, OUTPUT);
    9562:	movs	r1, #1
    9564:	bl	99fc <pinMode>
		rts_assert();
    9568:	ldr	r3, [r4, #0]
    956a:	movs	r2, #0
    956c:	strb	r2, [r3, #0]
		UART0_MODEM &= ~UART_MODEM_RXRTSE;
		return 0;
	}
	UART0_MODEM |= UART_MODEM_RXRTSE;
*/
	return 1;
    956e:	movs	r0, #1
    9570:	pop	{r4, pc}
    9572:	nop
    9574:	.word	0x40048034
    9578:	.word	0x1fff1900
    957c:	.word	0x0000c550

00009580 <serial_set_cts>:
}

int serial_set_cts(uint8_t pin)
{
#if defined(KINETISK)
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return 0;
    9580:	ldr	r3, [pc, #60]	; (95c0 <serial_set_cts+0x40>)
    9582:	ldr	r3, [r3, #0]
    9584:	ands.w	r3, r3, #1024	; 0x400
    9588:	beq.n	959c <serial_set_cts+0x1c>
	if (pin == 18) {
    958a:	cmp	r0, #18
    958c:	beq.n	95a0 <serial_set_cts+0x20>
		CORE_PIN18_CONFIG = PORT_PCR_MUX(3) | PORT_PCR_PE; // weak pulldown
	} else if (pin == 20) {
    958e:	cmp	r0, #20
    9590:	beq.n	95b6 <serial_set_cts+0x36>
		CORE_PIN20_CONFIG = PORT_PCR_MUX(3) | PORT_PCR_PE; // weak pulldown
	} else {
		UART0_MODEM &= ~UART_MODEM_TXCTSE;
    9592:	ldr	r2, [pc, #48]	; (95c4 <serial_set_cts+0x44>)
    9594:	ldrb	r3, [r2, #13]
    9596:	and.w	r3, r3, #254	; 0xfe
    959a:	strb	r3, [r2, #13]
		return 0;
    959c:	movs	r0, #0
    959e:	bx	lr
int serial_set_cts(uint8_t pin)
{
#if defined(KINETISK)
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return 0;
	if (pin == 18) {
		CORE_PIN18_CONFIG = PORT_PCR_MUX(3) | PORT_PCR_PE; // weak pulldown
    95a0:	ldr	r3, [pc, #36]	; (95c8 <serial_set_cts+0x48>)
    95a2:	movw	r2, #770	; 0x302
    95a6:	str	r2, [r3, #0]
		CORE_PIN20_CONFIG = PORT_PCR_MUX(3) | PORT_PCR_PE; // weak pulldown
	} else {
		UART0_MODEM &= ~UART_MODEM_TXCTSE;
		return 0;
	}
	UART0_MODEM |= UART_MODEM_TXCTSE;
    95a8:	ldr	r2, [pc, #24]	; (95c4 <serial_set_cts+0x44>)
    95aa:	ldrb	r3, [r2, #13]
    95ac:	orr.w	r3, r3, #1
    95b0:	strb	r3, [r2, #13]
	return 1;
    95b2:	movs	r0, #1
    95b4:	bx	lr
#if defined(KINETISK)
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return 0;
	if (pin == 18) {
		CORE_PIN18_CONFIG = PORT_PCR_MUX(3) | PORT_PCR_PE; // weak pulldown
	} else if (pin == 20) {
		CORE_PIN20_CONFIG = PORT_PCR_MUX(3) | PORT_PCR_PE; // weak pulldown
    95b6:	ldr	r3, [pc, #20]	; (95cc <serial_set_cts+0x4c>)
    95b8:	movw	r2, #770	; 0x302
    95bc:	str	r2, [r3, #0]
    95be:	b.n	95a8 <serial_set_cts+0x28>
    95c0:	.word	0x40048034
    95c4:	.word	0x4006a000
    95c8:	.word	0x4004a00c
    95cc:	.word	0x4004c014

000095d0 <serial_putchar>:

void serial_putchar(uint32_t c)
{
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
    95d0:	ldr	r3, [pc, #12]	; (95e0 <serial_putchar+0x10>)
    95d2:	ldr	r3, [r3, #0]
    95d4:	lsls	r3, r3, #21
    95d6:	bpl.n	95dc <serial_putchar+0xc>
    95d8:	b.w	90f4 <serial_putchar.part.0>
    95dc:	bx	lr
    95de:	nop
    95e0:	.word	0x40048034

000095e4 <serial_write>:
	UART0_C2 = C2_TX_ACTIVE;
}

#ifdef HAS_KINETISK_UART0_FIFO
void serial_write(const void *buf, unsigned int count)
{
    95e4:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const uint8_t *p = (const uint8_t *)buf;
	const uint8_t *end = p + count;
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
    95e8:	ldr	r3, [pc, #164]	; (9690 <serial_write+0xac>)
    95ea:	ldr	r3, [r3, #0]
    95ec:	lsls	r2, r3, #21
    95ee:	bpl.n	9682 <serial_write+0x9e>
	if (transmit_pin) transmit_assert();
    95f0:	ldr	r3, [pc, #160]	; (9694 <serial_write+0xb0>)
    95f2:	ldr	r3, [r3, #0]
    95f4:	mov	r5, r0
    95f6:	cbz	r3, 95fc <serial_write+0x18>
    95f8:	movs	r2, #1
    95fa:	strb	r2, [r3, #0]

#ifdef HAS_KINETISK_UART0_FIFO
void serial_write(const void *buf, unsigned int count)
{
	const uint8_t *p = (const uint8_t *)buf;
	const uint8_t *end = p + count;
    95fc:	add.w	sl, r5, r1
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
	while (p < end) {
    9600:	cmp	r5, sl
    9602:	bcs.n	9686 <serial_write+0xa2>
    9604:	ldr.w	r8, [pc, #156]	; 96a4 <serial_write+0xc0>
    9608:	ldr	r4, [pc, #140]	; (9698 <serial_write+0xb4>)
    960a:	ldr.w	r9, [pc, #156]	; 96a8 <serial_write+0xc4>
		head = tx_buffer_head;
		if (++head >= SERIAL1_TX_BUFFER_SIZE) head = 0;
		if (tx_buffer_tail == head) {
			UART0_C2 = C2_TX_ACTIVE;
    960e:	ldr	r7, [pc, #140]	; (969c <serial_write+0xb8>)
    9610:	b.n	9628 <serial_write+0x44>
				} else if (priority >= 256) {
					yield();
				}
			} while (tx_buffer_tail == head);
		}
		tx_buffer[head] = *p++;
    9612:	ldrb.w	r2, [r5], #1
    9616:	strb.w	r2, [r9, fp]
		transmitting = 1;
    961a:	ldr	r2, [pc, #132]	; (96a0 <serial_write+0xbc>)
    961c:	movs	r3, #1
	const uint8_t *end = p + count;
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
	while (p < end) {
    961e:	cmp	sl, r5
					yield();
				}
			} while (tx_buffer_tail == head);
		}
		tx_buffer[head] = *p++;
		transmitting = 1;
    9620:	strb	r3, [r2, #0]
		tx_buffer_head = head;
    9622:	strb.w	r6, [r8]
	const uint8_t *end = p + count;
	uint32_t head, n;

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
	while (p < end) {
    9626:	beq.n	9686 <serial_write+0xa2>
		head = tx_buffer_head;
    9628:	ldrb.w	r3, [r8]
		if (++head >= SERIAL1_TX_BUFFER_SIZE) head = 0;
		if (tx_buffer_tail == head) {
    962c:	ldrb	r2, [r4, #0]

	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	if (transmit_pin) transmit_assert();
	while (p < end) {
		head = tx_buffer_head;
		if (++head >= SERIAL1_TX_BUFFER_SIZE) head = 0;
    962e:	add.w	fp, r3, #1
    9632:	cmp.w	fp, #63	; 0x3f
    9636:	itte	hi
    9638:	movhi	r6, #0
    963a:	movhi	fp, r6
    963c:	uxtbls.w	r6, fp
		if (tx_buffer_tail == head) {
    9640:	cmp	fp, r2
    9642:	bne.n	9612 <serial_write+0x2e>
			UART0_C2 = C2_TX_ACTIVE;
    9644:	movs	r2, #188	; 0xbc
    9646:	strb	r2, [r7, #3]
    9648:	b.n	9656 <serial_write+0x72>
			do {
				int priority = nvic_execution_priority();
				if (priority <= IRQ_PRIORITY) {
					if ((UART0_S1 & UART_S1_TDRE)) {
    964a:	ldrb	r2, [r7, #4]
    964c:	lsls	r3, r2, #24
    964e:	bmi.n	9668 <serial_write+0x84>
						tx_buffer_tail = tail;
					}
				} else if (priority >= 256) {
					yield();
				}
			} while (tx_buffer_tail == head);
    9650:	ldrb	r2, [r4, #0]
    9652:	cmp	fp, r2
    9654:	bne.n	9612 <serial_write+0x2e>
		head = tx_buffer_head;
		if (++head >= SERIAL1_TX_BUFFER_SIZE) head = 0;
		if (tx_buffer_tail == head) {
			UART0_C2 = C2_TX_ACTIVE;
			do {
				int priority = nvic_execution_priority();
    9656:	bl	90b8 <nvic_execution_priority>
				if (priority <= IRQ_PRIORITY) {
    965a:	cmp	r0, #64	; 0x40
    965c:	ble.n	964a <serial_write+0x66>
						n = tx_buffer[tail];
						if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
						UART0_D = n;
						tx_buffer_tail = tail;
					}
				} else if (priority >= 256) {
    965e:	cmp	r0, #255	; 0xff
    9660:	ble.n	9650 <serial_write+0x6c>
					yield();
    9662:	bl	ac8c <yield>
    9666:	b.n	9650 <serial_write+0x6c>
			UART0_C2 = C2_TX_ACTIVE;
			do {
				int priority = nvic_execution_priority();
				if (priority <= IRQ_PRIORITY) {
					if ((UART0_S1 & UART_S1_TDRE)) {
						uint32_t tail = tx_buffer_tail;
    9668:	ldrb	r2, [r4, #0]
						if (++tail >= SERIAL1_TX_BUFFER_SIZE) tail = 0;
    966a:	adds	r2, #1
    966c:	cmp	r2, #63	; 0x3f
    966e:	itte	hi
    9670:	movhi	r1, #0
    9672:	movhi	r2, r1
    9674:	uxtbls	r1, r2
						n = tx_buffer[tail];
    9676:	ldrb.w	r2, [r9, r2]
    967a:	uxtb	r2, r2
						if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
						UART0_D = n;
    967c:	strb	r2, [r7, #7]
						tx_buffer_tail = tail;
    967e:	strb	r1, [r4, #0]
    9680:	b.n	9650 <serial_write+0x6c>
    9682:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		tx_buffer[head] = *p++;
		transmitting = 1;
		tx_buffer_head = head;
	}
	UART0_C2 = C2_TX_ACTIVE;
    9686:	ldr	r3, [pc, #20]	; (969c <serial_write+0xb8>)
    9688:	movs	r2, #188	; 0xbc
    968a:	strb	r2, [r3, #3]
    968c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9690:	.word	0x40048034
    9694:	.word	0x1fff1990
    9698:	.word	0x1fff198d
    969c:	.word	0x4006a000
    96a0:	.word	0x1fff198c
    96a4:	.word	0x1fff1994
    96a8:	.word	0x1fff1908

000096ac <serial_flush>:
	while (count-- > 0) serial_putchar(*p++);
}
#endif

void serial_flush(void)
{
    96ac:	push	{r4, lr}
	while (transmitting) yield(); // wait
    96ae:	ldr	r4, [pc, #16]	; (96c0 <serial_flush+0x14>)
    96b0:	ldrb	r3, [r4, #0]
    96b2:	cbz	r3, 96be <serial_flush+0x12>
    96b4:	bl	ac8c <yield>
    96b8:	ldrb	r3, [r4, #0]
    96ba:	cmp	r3, #0
    96bc:	bne.n	96b4 <serial_flush+0x8>
    96be:	pop	{r4, pc}
    96c0:	.word	0x1fff198c

000096c4 <serial_write_buffer_free>:
int serial_write_buffer_free(void)
{
	uint32_t head, tail;

	head = tx_buffer_head;
	tail = tx_buffer_tail;
    96c4:	ldr	r2, [pc, #24]	; (96e0 <serial_write_buffer_free+0x1c>)

int serial_write_buffer_free(void)
{
	uint32_t head, tail;

	head = tx_buffer_head;
    96c6:	ldr	r3, [pc, #28]	; (96e4 <serial_write_buffer_free+0x20>)
    96c8:	ldrb	r3, [r3, #0]
	tail = tx_buffer_tail;
    96ca:	ldrb	r0, [r2, #0]

int serial_write_buffer_free(void)
{
	uint32_t head, tail;

	head = tx_buffer_head;
    96cc:	uxtb	r3, r3
	tail = tx_buffer_tail;
    96ce:	uxtb	r0, r0
	if (head >= tail) return SERIAL1_TX_BUFFER_SIZE - 1 - head + tail;
    96d0:	cmp	r3, r0
    96d2:	ite	cs
    96d4:	addcs	r0, #63	; 0x3f
	return tail - head - 1;
    96d6:	addcc.w	r0, r0, #4294967295
    96da:	subs	r0, r0, r3
}
    96dc:	bx	lr
    96de:	nop
    96e0:	.word	0x1fff198d
    96e4:	.word	0x1fff1994

000096e8 <serial_available>:

int serial_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    96e8:	ldr	r2, [pc, #20]	; (9700 <serial_available+0x18>)
	tail = rx_buffer_tail;
    96ea:	ldr	r3, [pc, #24]	; (9704 <serial_available+0x1c>)

int serial_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    96ec:	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    96ee:	ldrb	r3, [r3, #0]

int serial_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    96f0:	uxtb	r0, r0
	tail = rx_buffer_tail;
    96f2:	uxtb	r3, r3
	if (head >= tail) return head - tail;
    96f4:	cmp	r0, r3
	return SERIAL1_RX_BUFFER_SIZE + head - tail;
    96f6:	it	cc
    96f8:	addcc	r0, #64	; 0x40
    96fa:	subs	r0, r0, r3
}
    96fc:	bx	lr
    96fe:	nop
    9700:	.word	0x1fff1904
    9704:	.word	0x1fff1905

00009708 <serial_getchar>:

int serial_getchar(void)
{
    9708:	push	{r4, r5}
	uint32_t head, tail;
	int c;

	head = rx_buffer_head;
    970a:	ldr	r3, [pc, #84]	; (9760 <serial_getchar+0x58>)
	tail = rx_buffer_tail;
    970c:	ldr	r4, [pc, #84]	; (9764 <serial_getchar+0x5c>)
int serial_getchar(void)
{
	uint32_t head, tail;
	int c;

	head = rx_buffer_head;
    970e:	ldrb	r2, [r3, #0]
	tail = rx_buffer_tail;
    9710:	ldrb	r3, [r4, #0]
int serial_getchar(void)
{
	uint32_t head, tail;
	int c;

	head = rx_buffer_head;
    9712:	uxtb	r2, r2
	tail = rx_buffer_tail;
    9714:	uxtb	r3, r3
	if (head == tail) return -1;
    9716:	cmp	r2, r3
    9718:	beq.n	9758 <serial_getchar+0x50>
	if (++tail >= SERIAL1_RX_BUFFER_SIZE) tail = 0;
    971a:	adds	r3, #1
    971c:	cmp	r3, #63	; 0x3f
    971e:	bls.n	973e <serial_getchar+0x36>
	c = rx_buffer[tail];
    9720:	ldr	r1, [pc, #68]	; (9768 <serial_getchar+0x60>)
	rx_buffer_tail = tail;
	if (rts_pin) {
    9722:	ldr	r3, [pc, #72]	; (976c <serial_getchar+0x64>)

	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
	if (++tail >= SERIAL1_RX_BUFFER_SIZE) tail = 0;
	c = rx_buffer[tail];
    9724:	ldrb	r0, [r1, #0]
	rx_buffer_tail = tail;
	if (rts_pin) {
    9726:	ldr	r1, [r3, #0]
	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
	if (++tail >= SERIAL1_RX_BUFFER_SIZE) tail = 0;
	c = rx_buffer[tail];
	rx_buffer_tail = tail;
    9728:	movs	r3, #0

	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
	if (++tail >= SERIAL1_RX_BUFFER_SIZE) tail = 0;
	c = rx_buffer[tail];
    972a:	uxtb	r0, r0
	rx_buffer_tail = tail;
    972c:	strb	r3, [r4, #0]
	if (rts_pin) {
    972e:	cbz	r1, 973a <serial_getchar+0x32>
		int avail;
		if (head >= tail) avail = head - tail;
		else avail = SERIAL1_RX_BUFFER_SIZE + head - tail;
    9730:	subs	r3, r2, r3
		if (avail <= RTS_LOW_WATERMARK) rts_assert();
    9732:	cmp	r3, #26
    9734:	bgt.n	973a <serial_getchar+0x32>
    9736:	movs	r3, #0
    9738:	strb	r3, [r1, #0]
	}
	return c;
}
    973a:	pop	{r4, r5}
    973c:	bx	lr

	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
	if (++tail >= SERIAL1_RX_BUFFER_SIZE) tail = 0;
	c = rx_buffer[tail];
    973e:	ldr	r0, [pc, #40]	; (9768 <serial_getchar+0x60>)
	rx_buffer_tail = tail;
	if (rts_pin) {
    9740:	ldr	r1, [pc, #40]	; (976c <serial_getchar+0x64>)

	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
	if (++tail >= SERIAL1_RX_BUFFER_SIZE) tail = 0;
	c = rx_buffer[tail];
    9742:	ldrb	r0, [r0, r3]
	rx_buffer_tail = tail;
	if (rts_pin) {
    9744:	ldr	r1, [r1, #0]
	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
	if (++tail >= SERIAL1_RX_BUFFER_SIZE) tail = 0;
	c = rx_buffer[tail];
	rx_buffer_tail = tail;
    9746:	uxtb	r5, r3

	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
	if (++tail >= SERIAL1_RX_BUFFER_SIZE) tail = 0;
	c = rx_buffer[tail];
    9748:	uxtb	r0, r0
	rx_buffer_tail = tail;
    974a:	strb	r5, [r4, #0]
	if (rts_pin) {
    974c:	cmp	r1, #0
    974e:	beq.n	973a <serial_getchar+0x32>
		int avail;
		if (head >= tail) avail = head - tail;
    9750:	cmp	r2, r3
		else avail = SERIAL1_RX_BUFFER_SIZE + head - tail;
    9752:	it	cc
    9754:	addcc	r2, #64	; 0x40
    9756:	b.n	9730 <serial_getchar+0x28>
	uint32_t head, tail;
	int c;

	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
    9758:	mov.w	r0, #4294967295
    975c:	b.n	973a <serial_getchar+0x32>
    975e:	nop
    9760:	.word	0x1fff1904
    9764:	.word	0x1fff1905
    9768:	.word	0x1fff194c
    976c:	.word	0x1fff1900

00009770 <serial_peek>:

int serial_peek(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    9770:	ldr	r2, [pc, #32]	; (9794 <serial_peek+0x24>)
	tail = rx_buffer_tail;
    9772:	ldr	r3, [pc, #36]	; (9798 <serial_peek+0x28>)

int serial_peek(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    9774:	ldrb	r2, [r2, #0]
	tail = rx_buffer_tail;
    9776:	ldrb	r3, [r3, #0]
    9778:	uxtb	r3, r3
	if (head == tail) return -1;
    977a:	cmp	r2, r3
    977c:	beq.n	978e <serial_peek+0x1e>
	if (++tail >= SERIAL1_RX_BUFFER_SIZE) tail = 0;
    977e:	adds	r3, #1
    9780:	cmp	r3, #64	; 0x40
    9782:	it	cs
    9784:	movcs	r3, #0
	return rx_buffer[tail];
    9786:	ldr	r2, [pc, #20]	; (979c <serial_peek+0x2c>)
    9788:	ldrb	r0, [r2, r3]
    978a:	uxtb	r0, r0
    978c:	bx	lr
{
	uint32_t head, tail;

	head = rx_buffer_head;
	tail = rx_buffer_tail;
	if (head == tail) return -1;
    978e:	mov.w	r0, #4294967295
	if (++tail >= SERIAL1_RX_BUFFER_SIZE) tail = 0;
	return rx_buffer[tail];
}
    9792:	bx	lr
    9794:	.word	0x1fff1904
    9798:	.word	0x1fff1905
    979c:	.word	0x1fff194c

000097a0 <serial_clear>:

void serial_clear(void)
{
#ifdef HAS_KINETISK_UART0_FIFO
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
    97a0:	ldr	r3, [pc, #52]	; (97d8 <serial_clear+0x38>)
    97a2:	ldr	r3, [r3, #0]
    97a4:	lsls	r3, r3, #21
    97a6:	bpl.n	97d6 <serial_clear+0x36>
	if (++tail >= SERIAL1_RX_BUFFER_SIZE) tail = 0;
	return rx_buffer[tail];
}

void serial_clear(void)
{
    97a8:	push	{r4, r5}
#ifdef HAS_KINETISK_UART0_FIFO
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	UART0_C2 &= ~(UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
    97aa:	ldr	r3, [pc, #48]	; (97dc <serial_clear+0x3c>)
	UART0_CFIFO = UART_CFIFO_RXFLUSH;
	UART0_C2 |= (UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
#endif
	rx_buffer_head = rx_buffer_tail;
    97ac:	ldr	r4, [pc, #48]	; (97e0 <serial_clear+0x40>)

void serial_clear(void)
{
#ifdef HAS_KINETISK_UART0_FIFO
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	UART0_C2 &= ~(UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
    97ae:	ldrb	r2, [r3, #3]
	UART0_CFIFO = UART_CFIFO_RXFLUSH;
	UART0_C2 |= (UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
#endif
	rx_buffer_head = rx_buffer_tail;
	if (rts_pin) rts_assert();
    97b0:	ldr	r0, [pc, #48]	; (97e4 <serial_clear+0x44>)
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	UART0_C2 &= ~(UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
	UART0_CFIFO = UART_CFIFO_RXFLUSH;
	UART0_C2 |= (UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
#endif
	rx_buffer_head = rx_buffer_tail;
    97b2:	ldr	r1, [pc, #52]	; (97e8 <serial_clear+0x48>)

void serial_clear(void)
{
#ifdef HAS_KINETISK_UART0_FIFO
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	UART0_C2 &= ~(UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
    97b4:	and.w	r2, r2, #203	; 0xcb
	UART0_CFIFO = UART_CFIFO_RXFLUSH;
    97b8:	movs	r5, #64	; 0x40

void serial_clear(void)
{
#ifdef HAS_KINETISK_UART0_FIFO
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	UART0_C2 &= ~(UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
    97ba:	strb	r2, [r3, #3]
	UART0_CFIFO = UART_CFIFO_RXFLUSH;
    97bc:	strb	r5, [r3, #17]
	UART0_C2 |= (UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
    97be:	ldrb	r2, [r3, #3]
    97c0:	orr.w	r2, r2, #52	; 0x34
    97c4:	strb	r2, [r3, #3]
#endif
	rx_buffer_head = rx_buffer_tail;
    97c6:	ldrb	r3, [r4, #0]
	if (rts_pin) rts_assert();
    97c8:	ldr	r2, [r0, #0]
	if (!(SIM_SCGC4 & SIM_SCGC4_UART0)) return;
	UART0_C2 &= ~(UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
	UART0_CFIFO = UART_CFIFO_RXFLUSH;
	UART0_C2 |= (UART_C2_RE | UART_C2_RIE | UART_C2_ILIE);
#endif
	rx_buffer_head = rx_buffer_tail;
    97ca:	uxtb	r3, r3
    97cc:	strb	r3, [r1, #0]
	if (rts_pin) rts_assert();
    97ce:	cbz	r2, 97d4 <serial_clear+0x34>
    97d0:	movs	r3, #0
    97d2:	strb	r3, [r2, #0]
}
    97d4:	pop	{r4, r5}
    97d6:	bx	lr
    97d8:	.word	0x40048034
    97dc:	.word	0x4006a000
    97e0:	.word	0x1fff1905
    97e4:	.word	0x1fff1900
    97e8:	.word	0x1fff1904

000097ec <uart0_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart0_status_isr(void)
{
    97ec:	push	{r4, r5, r6, r7}
	uint8_t c;
#ifdef HAS_KINETISK_UART0_FIFO
	uint32_t newhead;
	uint8_t avail;

	if (UART0_S1 & (UART_S1_RDRF | UART_S1_IDLE)) {
    97ee:	ldr	r3, [pc, #224]	; (98d0 <uart0_status_isr+0xe4>)
    97f0:	ldrb	r2, [r3, #4]
    97f2:	tst.w	r2, #48	; 0x30
    97f6:	beq.n	9852 <uart0_status_isr+0x66>
		__disable_irq();
    97f8:	cpsid	i
		avail = UART0_RCFIFO;
    97fa:	ldrb	r1, [r3, #22]
		if (avail == 0) {
    97fc:	and.w	r2, r1, #255	; 0xff
    9800:	cmp	r1, #0
    9802:	beq.n	9880 <uart0_status_isr+0x94>
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
    9804:	cpsie	i
			head = rx_buffer_head;
    9806:	ldr	r7, [pc, #204]	; (98d4 <uart0_status_isr+0xe8>)
			tail = rx_buffer_tail;
    9808:	ldr	r1, [pc, #204]	; (98d8 <uart0_status_isr+0xec>)
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
    980a:	ldrb	r0, [r7, #0]
			tail = rx_buffer_tail;
    980c:	ldrb	r5, [r1, #0]
				}
				newhead = head + 1;
				if (newhead >= SERIAL1_RX_BUFFER_SIZE) newhead = 0;
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
    980e:	ldr	r6, [pc, #204]	; (98dc <uart0_status_isr+0xf0>)
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
    9810:	mov	r4, r3
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
    9812:	uxtb	r0, r0
			tail = rx_buffer_tail;
    9814:	uxtb	r5, r5
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
				}
				newhead = head + 1;
    9816:	adds	r3, r0, #1
				if (newhead >= SERIAL1_RX_BUFFER_SIZE) newhead = 0;
    9818:	cmp	r3, #64	; 0x40
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
    981a:	ldrb	r1, [r4, #7]
				}
				newhead = head + 1;
				if (newhead >= SERIAL1_RX_BUFFER_SIZE) newhead = 0;
    981c:	it	cs
    981e:	movcs	r3, #0
				if (newhead != tail) {
    9820:	cmp	r3, r5
					head = newhead;
					rx_buffer[head] = n;
				}
			} while (--avail > 0);
    9822:	add.w	r2, r2, #4294967295
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART0_C3 & 0x80)) {
					n = UART0_D | 0x100;
				} else {
					n = UART0_D;
    9826:	uxtb	r1, r1
				}
				newhead = head + 1;
				if (newhead >= SERIAL1_RX_BUFFER_SIZE) newhead = 0;
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
    9828:	itt	ne
    982a:	strbne	r1, [r6, r3]
    982c:	movne	r0, r3
				}
			} while (--avail > 0);
    982e:	ands.w	r2, r2, #255	; 0xff
    9832:	bne.n	9816 <uart0_status_isr+0x2a>
			rx_buffer_head = head;
			if (rts_pin) {
    9834:	ldr	r3, [pc, #168]	; (98e0 <uart0_status_isr+0xf4>)
    9836:	ldr	r3, [r3, #0]
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
				}
			} while (--avail > 0);
			rx_buffer_head = head;
    9838:	uxtb	r2, r0
    983a:	strb	r2, [r7, #0]
			if (rts_pin) {
    983c:	cbz	r3, 9852 <uart0_status_isr+0x66>
				int avail;
				if (head >= tail) avail = head - tail;
    983e:	cmp	r0, r5
				else avail = SERIAL1_RX_BUFFER_SIZE + head - tail;
    9840:	itet	cc
    9842:	rsbcc	r5, r5, #64	; 0x40
				}
			} while (--avail > 0);
			rx_buffer_head = head;
			if (rts_pin) {
				int avail;
				if (head >= tail) avail = head - tail;
    9846:	subcs	r0, r0, r5
				else avail = SERIAL1_RX_BUFFER_SIZE + head - tail;
    9848:	addcc	r0, r0, r5
				if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    984a:	cmp	r0, #39	; 0x27
    984c:	itt	gt
    984e:	movgt	r2, #1
    9850:	strbgt	r2, [r3, #0]
			}
		}
	}
	c = UART0_C2;
    9852:	ldr	r1, [pc, #124]	; (98d0 <uart0_status_isr+0xe4>)
    9854:	ldrb	r2, [r1, #3]
    9856:	uxtb	r2, r2
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
    9858:	lsls	r5, r2, #24
    985a:	bmi.n	988a <uart0_status_isr+0x9e>
			UART0_D = n;
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART0_S1 & UART_S1_TC)) {
    985c:	lsls	r2, r2, #25
    985e:	bpl.n	987c <uart0_status_isr+0x90>
    9860:	ldr	r3, [pc, #108]	; (98d0 <uart0_status_isr+0xe4>)
    9862:	ldrb	r3, [r3, #4]
    9864:	lsls	r3, r3, #25
    9866:	bpl.n	987c <uart0_status_isr+0x90>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    9868:	ldr	r3, [pc, #120]	; (98e4 <uart0_status_isr+0xf8>)
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART0_S1 & UART_S1_TC)) {
		transmitting = 0;
    986a:	ldr	r1, [pc, #124]	; (98e8 <uart0_status_isr+0xfc>)
		if (transmit_pin) transmit_deassert();
    986c:	ldr	r3, [r3, #0]
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART0_S1 & UART_S1_TC)) {
		transmitting = 0;
    986e:	movs	r2, #0
    9870:	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    9872:	cbz	r3, 9876 <uart0_status_isr+0x8a>
    9874:	strb	r2, [r3, #0]
		UART0_C2 = C2_TX_INACTIVE;
    9876:	ldr	r3, [pc, #88]	; (98d0 <uart0_status_isr+0xe4>)
    9878:	movs	r2, #60	; 0x3c
    987a:	strb	r2, [r3, #3]
	}
}
    987c:	pop	{r4, r5, r6, r7}
    987e:	bx	lr
			// the chance, interrupts are disabled so a higher
			// priority interrupt (hopefully) doesn't delay.
			// TODO: change this to disabling the IDLE interrupt
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
    9880:	movs	r2, #64	; 0x40
			// to read the data register.  But reading with no
			// data causes a FIFO underrun, which causes the
			// FIFO to return corrupted data.  If anyone from
			// Freescale reads this, what a poor design!  There
			// write should be a write-1-to-clear for IDLE.
			c = UART0_D;
    9882:	ldrb	r1, [r3, #7]
			// the chance, interrupts are disabled so a higher
			// priority interrupt (hopefully) doesn't delay.
			// TODO: change this to disabling the IDLE interrupt
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART0_CFIFO = UART_CFIFO_RXFLUSH;
    9884:	strb	r2, [r3, #17]
			__enable_irq();
    9886:	cpsie	i
    9888:	b.n	9852 <uart0_status_isr+0x66>
				if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
			}
		}
	}
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
    988a:	ldrb	r3, [r1, #4]
    988c:	lsls	r4, r3, #24
    988e:	bpl.n	985c <uart0_status_isr+0x70>
		head = tx_buffer_head;
    9890:	ldr	r3, [pc, #88]	; (98ec <uart0_status_isr+0x100>)
		tail = tx_buffer_tail;
    9892:	ldr	r6, [pc, #92]	; (98f0 <uart0_status_isr+0x104>)
			}
		}
	}
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    9894:	ldrb	r4, [r3, #0]
		tail = tx_buffer_tail;
    9896:	ldrb	r3, [r6, #0]
			}
		}
	}
	c = UART0_C2;
	if ((c & UART_C2_TIE) && (UART0_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    9898:	uxtb	r4, r4
		tail = tx_buffer_tail;
    989a:	uxtb	r3, r3
		do {
			if (tail == head) break;
    989c:	cmp	r4, r3
    989e:	beq.n	98be <uart0_status_isr+0xd2>
    98a0:	ldr	r5, [pc, #80]	; (98f4 <uart0_status_isr+0x108>)
    98a2:	b.n	98a8 <uart0_status_isr+0xbc>
    98a4:	cmp	r3, r4
    98a6:	beq.n	98be <uart0_status_isr+0xd2>
			if (++tail >= SERIAL1_TX_BUFFER_SIZE) tail = 0;
    98a8:	adds	r3, #1
    98aa:	cmp	r3, #64	; 0x40
    98ac:	it	cs
    98ae:	movcs	r3, #0
			avail = UART0_S1;
    98b0:	ldrb	r0, [r1, #4]
			n = tx_buffer[tail];
    98b2:	ldrb	r0, [r5, r3]
    98b4:	uxtb	r0, r0
			if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART0_D = n;
    98b6:	strb	r0, [r1, #7]
		} while (UART0_TCFIFO < 8);
    98b8:	ldrb	r0, [r1, #20]
    98ba:	cmp	r0, #7
    98bc:	bls.n	98a4 <uart0_status_isr+0xb8>
		tx_buffer_tail = tail;
    98be:	uxtb	r3, r3
		if (UART0_S1 & UART_S1_TDRE) UART0_C2 = C2_TX_COMPLETING;
    98c0:	ldr	r1, [pc, #12]	; (98d0 <uart0_status_isr+0xe4>)
			avail = UART0_S1;
			n = tx_buffer[tail];
			if (use9Bits) UART0_C3 = (UART0_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART0_D = n;
		} while (UART0_TCFIFO < 8);
		tx_buffer_tail = tail;
    98c2:	strb	r3, [r6, #0]
		if (UART0_S1 & UART_S1_TDRE) UART0_C2 = C2_TX_COMPLETING;
    98c4:	ldrb	r3, [r1, #4]
    98c6:	lsls	r0, r3, #24
    98c8:	itt	mi
    98ca:	movmi	r3, #124	; 0x7c
    98cc:	strbmi	r3, [r1, #3]
    98ce:	b.n	985c <uart0_status_isr+0x70>
    98d0:	.word	0x4006a000
    98d4:	.word	0x1fff1904
    98d8:	.word	0x1fff1905
    98dc:	.word	0x1fff194c
    98e0:	.word	0x1fff1900
    98e4:	.word	0x1fff1990
    98e8:	.word	0x1fff198c
    98ec:	.word	0x1fff1994
    98f0:	.word	0x1fff198d
    98f4:	.word	0x1fff1908

000098f8 <digitalWrite.part.1>:



// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
    98f8:	push	{r4}
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
    98fa:	ldr	r3, [pc, #68]	; (9940 <digitalWrite.part.1+0x48>)
    98fc:	ldr.w	r2, [r3, r0, lsl #3]
    9900:	ldrb.w	r4, [r2, #640]	; 0x280
    9904:	cbz	r4, 9914 <digitalWrite.part.1+0x1c>
		if (val) {
			*portSetRegister(pin) = 1;
    9906:	movs	r3, #1
void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
    9908:	cbz	r1, 992a <digitalWrite.part.1+0x32>
			*portSetRegister(pin) = 1;
    990a:	strb.w	r3, [r2, #128]	; 0x80
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    990e:	ldr.w	r4, [sp], #4
    9912:	bx	lr
		} else {
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
    9914:	add.w	r3, r3, r0, lsl #3
    9918:	ldr	r3, [r3, #4]
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    991a:	ldr	r2, [r3, #0]
			*portClearRegister(pin) = digitalPinToBitMask(pin);
		}
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
    991c:	cbnz	r1, 9934 <digitalWrite.part.1+0x3c>
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
			//*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else {
			// TODO use bitband for atomic read-mod-write
			*config &= ~(PORT_PCR_PE);
    991e:	bic.w	r2, r2, #2
    9922:	str	r2, [r3, #0]
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    9924:	ldr.w	r4, [sp], #4
    9928:	bx	lr
#ifdef KINETISK
	if (*portModeRegister(pin)) {
		if (val) {
			*portSetRegister(pin) = 1;
		} else {
			*portClearRegister(pin) = 1;
    992a:	strb.w	r3, [r2, #256]	; 0x100
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    992e:	ldr.w	r4, [sp], #4
    9932:	bx	lr
#endif
	} else {
		volatile uint32_t *config = portConfigRegister(pin);
		if (val) {
			// TODO use bitband for atomic read-mod-write
			*config |= (PORT_PCR_PE | PORT_PCR_PS);
    9934:	orr.w	r2, r2, #3
    9938:	str	r2, [r3, #0]
			*config &= ~(PORT_PCR_PE);
			//*config = PORT_PCR_MUX(1);
		}
	}

}
    993a:	ldr.w	r4, [sp], #4
    993e:	bx	lr
    9940:	.word	0x0000c550

00009944 <pinMode.part.2>:
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    9944:	ldr	r2, [pc, #112]	; (99b8 <pinMode.part.2+0x74>)
    9946:	add.w	r3, r2, r0, lsl #3

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    994a:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);
    994c:	ldr	r3, [r3, #4]

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    994e:	beq.n	9974 <pinMode.part.2+0x30>
    9950:	cmp	r1, #4
    9952:	beq.n	998c <pinMode.part.2+0x48>
		} else {
		    *config &= ~PORT_PCR_ODE;
                }
	} else {
#ifdef KINETISK
		*portModeRegister(pin) = 0;
    9954:	ldr.w	r0, [r2, r0, lsl #3]
    9958:	movs	r2, #0
    995a:	strb.w	r2, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
    995e:	cbz	r1, 996c <pinMode.part.2+0x28>
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
    9960:	cmp	r1, #2
    9962:	beq.n	99a6 <pinMode.part.2+0x62>
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
		} else if (mode == INPUT_PULLDOWN) {
    9964:	cmp	r1, #3
    9966:	beq.n	99ae <pinMode.part.2+0x6a>
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    9968:	str	r2, [r3, #0]
    996a:	bx	lr
		*portModeRegister(pin) = 0;
#else
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
    996c:	mov.w	r2, #256	; 0x100
    9970:	str	r2, [r3, #0]
    9972:	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    9974:	ldr.w	r0, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    9978:	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    997c:	strb.w	r1, [r0, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    9980:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
		} else {
		    *config &= ~PORT_PCR_ODE;
    9982:	ldr	r2, [r3, #0]
    9984:	bic.w	r2, r2, #32
    9988:	str	r2, [r3, #0]
    998a:	bx	lr
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    998c:	ldr.w	r1, [r2, r0, lsl #3]
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    9990:	mov.w	r2, #324	; 0x144
	if (pin >= CORE_NUM_DIGITAL) return;
	config = portConfigRegister(pin);

	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
#ifdef KINETISK
		*portModeRegister(pin) = 1;
    9994:	movs	r0, #1
    9996:	strb.w	r0, [r1, #640]	; 0x280
#else
		*portModeRegister(pin) |= digitalPinToBitMask(pin); // TODO: atomic
#endif
		*config = PORT_PCR_SRE | PORT_PCR_DSE | PORT_PCR_MUX(1);
    999a:	str	r2, [r3, #0]
		if (mode == OUTPUT_OPENDRAIN) {
		    *config |= PORT_PCR_ODE;
    999c:	ldr	r2, [r3, #0]
    999e:	orr.w	r2, r2, #32
    99a2:	str	r2, [r3, #0]
    99a4:	bx	lr
		*portModeRegister(pin) &= ~digitalPinToBitMask(pin);
#endif
		if (mode == INPUT) {
			*config = PORT_PCR_MUX(1);
		} else if (mode == INPUT_PULLUP) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE | PORT_PCR_PS;
    99a6:	movw	r2, #259	; 0x103
    99aa:	str	r2, [r3, #0]
    99ac:	bx	lr
		} else if (mode == INPUT_PULLDOWN) {
			*config = PORT_PCR_MUX(1) | PORT_PCR_PE;
    99ae:	mov.w	r2, #258	; 0x102
    99b2:	str	r2, [r3, #0]
    99b4:	bx	lr
    99b6:	nop
    99b8:	.word	0x0000c550

000099bc <attachInterruptVector>:
static void portcd_interrupt(void);
#endif

void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void))
{
	_VectorsRam[irq + 16] = function;
    99bc:	adds	r0, #16
    99be:	ldr	r3, [pc, #8]	; (99c8 <attachInterruptVector+0xc>)
    99c0:	str.w	r1, [r3, r0, lsl #2]
    99c4:	bx	lr
    99c6:	nop
    99c8:	.word	0x1fff0200

000099cc <rtc_set>:
{
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
    99cc:	push	{r4, r5}
	RTC_SR = 0;
    99ce:	ldr	r3, [pc, #20]	; (99e4 <rtc_set+0x18>)
	RTC_TPR = 0;
    99d0:	ldr	r5, [pc, #20]	; (99e8 <rtc_set+0x1c>)
	RTC_TSR = t;
    99d2:	ldr	r4, [pc, #24]	; (99ec <rtc_set+0x20>)
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    99d4:	movs	r2, #0
	RTC_TPR = 0;
	RTC_TSR = t;
	RTC_SR = RTC_SR_TCE;
    99d6:	movs	r1, #16
	return RTC_TSR;
}

void rtc_set(unsigned long t)
{
	RTC_SR = 0;
    99d8:	str	r2, [r3, #0]
	RTC_TPR = 0;
    99da:	str	r2, [r5, #0]
	RTC_TSR = t;
    99dc:	str	r0, [r4, #0]
	RTC_SR = RTC_SR_TCE;
    99de:	str	r1, [r3, #0]
}
    99e0:	pop	{r4, r5}
    99e2:	bx	lr
    99e4:	.word	0x4003d014
    99e8:	.word	0x4003d004
    99ec:	.word	0x4003d000

000099f0 <digitalWrite>:

// TODO: startup code needs to initialize all pins to GPIO mode, input by default

void digitalWrite(uint8_t pin, uint8_t val)
{
	if (pin >= CORE_NUM_DIGITAL) return;
    99f0:	cmp	r0, #63	; 0x3f
    99f2:	bhi.n	99f8 <digitalWrite+0x8>
    99f4:	b.w	98f8 <digitalWrite.part.1>
    99f8:	bx	lr
    99fa:	nop

000099fc <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	volatile uint32_t *config;

	if (pin >= CORE_NUM_DIGITAL) return;
    99fc:	cmp	r0, #63	; 0x3f
    99fe:	bhi.n	9a04 <pinMode+0x8>
    9a00:	b.w	9944 <pinMode.part.2>
    9a04:	bx	lr
    9a06:	nop

00009a08 <micros>:

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    9a08:	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    9a0a:	ldr	r1, [pc, #48]	; (9a3c <micros+0x34>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    9a0c:	ldr	r3, [pc, #48]	; (9a40 <micros+0x38>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    9a0e:	ldr	r2, [pc, #52]	; (9a44 <micros+0x3c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    9a10:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    9a12:	ldr	r0, [r1, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    9a14:	ldr	r2, [r2, #0]
	__enable_irq();
    9a16:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    9a18:	lsls	r2, r2, #5
    9a1a:	bpl.n	9a22 <micros+0x1a>
    9a1c:	cmp	r3, #50	; 0x32
    9a1e:	it	hi
    9a20:	addhi	r0, #1
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    9a22:	ldr	r1, [pc, #36]	; (9a48 <micros+0x40>)
    9a24:	rsb	r3, r3, #95744	; 0x17600
    9a28:	mov.w	r2, #1000	; 0x3e8
    9a2c:	adds	r3, #255	; 0xff
    9a2e:	umull	r1, r3, r1, r3
    9a32:	mul.w	r0, r2, r0
}
    9a36:	add.w	r0, r0, r3, lsr #6
    9a3a:	bx	lr
    9a3c:	.word	0x1fff1998
    9a40:	.word	0xe000e018
    9a44:	.word	0xe000ed04
    9a48:	.word	0xaaaaaaab

00009a4c <delay>:

void delay(uint32_t ms)
{
    9a4c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    9a50:	mov	r5, r0

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    9a52:	cpsid	i
	current = SYST_CVR;
	count = systick_millis_count;
    9a54:	ldr	r7, [pc, #128]	; (9ad8 <delay+0x8c>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    9a56:	ldr	r3, [pc, #132]	; (9adc <delay+0x90>)
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    9a58:	ldr	r2, [pc, #132]	; (9ae0 <delay+0x94>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    9a5a:	ldr	r3, [r3, #0]
	count = systick_millis_count;
    9a5c:	ldr	r4, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    9a5e:	ldr	r2, [r2, #0]
	__enable_irq();
    9a60:	cpsie	i
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    9a62:	lsls	r2, r2, #5
    9a64:	bpl.n	9a6c <delay+0x20>
    9a66:	cmp	r3, #50	; 0x32
    9a68:	it	hi
    9a6a:	addhi	r4, #1

void delay(uint32_t ms)
{
	uint32_t start = micros();

	if (ms > 0) {
    9a6c:	cbz	r5, 9ad4 <delay+0x88>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    9a6e:	rsb	r3, r3, #95744	; 0x17600
    9a72:	ldr	r6, [pc, #112]	; (9ae4 <delay+0x98>)
uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
	current = SYST_CVR;
    9a74:	ldr.w	r9, [pc, #100]	; 9adc <delay+0x90>
	count = systick_millis_count;
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    9a78:	ldr.w	r8, [pc, #100]	; 9ae0 <delay+0x94>
#if defined(KINETISL) && F_CPU == 48000000
	return count * 1000 + ((current * (uint32_t)87381) >> 22);
#elif defined(KINETISL) && F_CPU == 24000000
	return count * 1000 + ((current * (uint32_t)174763) >> 22);
#endif
	return count * 1000 + current / (F_CPU / 1000000);
    9a7c:	adds	r3, #255	; 0xff
    9a7e:	mov.w	r2, #1000	; 0x3e8
    9a82:	umull	r1, r3, r6, r3
    9a86:	mul.w	r4, r2, r4
    9a8a:	add.w	r4, r4, r3, lsr #6

uint32_t micros(void)
{
	uint32_t count, current, istatus;

	__disable_irq();
    9a8e:	cpsid	i
	current = SYST_CVR;
    9a90:	ldr.w	r1, [r9]
	count = systick_millis_count;
    9a94:	ldr	r2, [r7, #0]
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
    9a96:	ldr.w	lr, [r8]
	__enable_irq();
    9a9a:	cpsie	i
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    9a9c:	rsb	r3, r1, #95744	; 0x17600
    9aa0:	adds	r3, #255	; 0xff
    9aa2:	umull	r0, r3, r6, r3
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    9aa6:	tst.w	lr, #67108864	; 0x4000000
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    9aaa:	rsb	r3, r4, r3, lsr #6
    9aae:	mov.w	r0, #1000	; 0x3e8
	istatus = SCB_ICSR;	// bit 26 indicates if systick exception pending
	__enable_irq();
	 //systick_current = current;
	 //systick_count = count;
	 //systick_istatus = istatus & SCB_ICSR_PENDSTSET ? 1 : 0;
	if ((istatus & SCB_ICSR_PENDSTSET) && current > 50) count++;
    9ab2:	beq.n	9aba <delay+0x6e>
    9ab4:	cmp	r1, #50	; 0x32
    9ab6:	it	hi
    9ab8:	addhi	r2, #1
{
	uint32_t start = micros();

	if (ms > 0) {
		while (1) {
			while ((micros() - start) >= 1000) {
    9aba:	mla	r3, r0, r2, r3
    9abe:	cmp.w	r3, #1000	; 0x3e8
    9ac2:	bcc.n	9ace <delay+0x82>
				ms--;
				if (ms == 0) return;
    9ac4:	subs	r5, #1
    9ac6:	beq.n	9ad4 <delay+0x88>
				start += 1000;
    9ac8:	add.w	r4, r4, #1000	; 0x3e8
    9acc:	b.n	9a8e <delay+0x42>
			}
			yield();
    9ace:	bl	ac8c <yield>
		}
    9ad2:	b.n	9a8e <delay+0x42>
    9ad4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    9ad8:	.word	0x1fff1998
    9adc:	.word	0xe000e018
    9ae0:	.word	0xe000ed04
    9ae4:	.word	0xaaaaaaab

00009ae8 <_init_Teensyduino_internal_>:
#endif

//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
    9ae8:	push	{r3, r4, r5, r6, r7, lr}
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    9aea:	ldr	r3, [pc, #312]	; (9c24 <_init_Teensyduino_internal_+0x13c>)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    9aec:	ldr	r0, [pc, #312]	; (9c28 <_init_Teensyduino_internal_+0x140>)
	FTM0_MOD = DEFAULT_FTM_MOD;
    9aee:	ldr.w	ip, [pc, #348]	; 9c4c <_init_Teensyduino_internal_+0x164>
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
    9af2:	ldr	r4, [pc, #312]	; (9c2c <_init_Teensyduino_internal_+0x144>)
	FTM0_C2SC = 0x28;
    9af4:	ldr	r1, [pc, #312]	; (9c30 <_init_Teensyduino_internal_+0x148>)
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    9af6:	ldr.w	lr, [pc, #344]	; 9c50 <_init_Teensyduino_internal_+0x168>
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
    9afa:	ldr	r6, [pc, #312]	; (9c34 <_init_Teensyduino_internal_+0x14c>)
	FTM0_C4SC = 0x28;
    9afc:	ldr	r5, [pc, #312]	; (9c38 <_init_Teensyduino_internal_+0x150>)
	FTM0_C5SC = 0x28;
    9afe:	ldr	r7, [pc, #316]	; (9c3c <_init_Teensyduino_internal_+0x154>)
//void init_pins(void)
__attribute__((noinline))
void _init_Teensyduino_internal_(void)
{
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	NVIC_ENABLE_IRQ(IRQ_PORTA);
    9b00:	mov.w	r2, #134217728	; 0x8000000
    9b04:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTB);
    9b06:	mov.w	r2, #268435456	; 0x10000000
    9b0a:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTC);
    9b0c:	mov.w	r2, #536870912	; 0x20000000
    9b10:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTD);
    9b12:	mov.w	r2, #1073741824	; 0x40000000
    9b16:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTE);
    9b18:	mov.w	r2, #2147483648	; 0x80000000
    9b1c:	str	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_PORTA);
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
    9b1e:	movs	r2, #0
    9b20:	str	r2, [r0, #0]
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    9b22:	movs	r3, #40	; 0x28
	NVIC_ENABLE_IRQ(IRQ_PORTCD);
#endif
	//SIM_SCGC6 |= SIM_SCGC6_FTM0;	// TODO: use bitband for atomic read-mod-write
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
    9b24:	movw	r0, #49151	; 0xbfff
    9b28:	str.w	r0, [ip]
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
    9b2c:	str.w	r3, [lr]
	FTM0_C1SC = 0x28;
    9b30:	str	r3, [r4, #0]
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    9b32:	add.w	lr, lr, #528384	; 0x81000
	//SIM_SCGC6 |= SIM_SCGC6_FTM1;
	FTM0_CNT = 0;
	FTM0_MOD = DEFAULT_FTM_MOD;
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
    9b36:	str	r3, [r1, #0]
	FTM0_C3SC = 0x28;
    9b38:	str	r3, [r6, #0]
	FTM0_C4SC = 0x28;
    9b3a:	str	r3, [r5, #0]
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    9b3c:	add.w	r6, r6, #524288	; 0x80000
	FTM0_C0SC = 0x28; // MSnB:MSnA = 10, ELSnB:ELSnA = 10
	FTM0_C1SC = 0x28;
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
    9b40:	str	r3, [r7, #0]
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
    9b42:	add.w	r5, r5, #524288	; 0x80000
	FTM0_C2SC = 0x28;
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
    9b46:	str	r3, [r4, #40]	; 0x28
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    9b48:	add.w	r7, r7, #524288	; 0x80000
	FTM0_C3SC = 0x28;
	FTM0_C4SC = 0x28;
	FTM0_C5SC = 0x28;
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
    9b4c:	str	r3, [r1, #40]	; 0x28
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    9b4e:	add.w	r4, r4, #528384	; 0x81000
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
    9b52:	add.w	r1, r1, #528384	; 0x81000
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    9b56:	addw	r6, r6, #4072	; 0xfe8
	FTM3_C1SC = 0x28;
    9b5a:	addw	r5, r5, #4072	; 0xfe8
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
    9b5e:	add.w	r7, r7, #4080	; 0xff0
	FTM3_C4SC = 0x28;
    9b62:	adds	r1, #16
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
    9b64:	add.w	lr, lr, #16
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
    9b68:	adds	r4, #32
#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM0_C6SC = 0x28;
	FTM0_C7SC = 0x28;
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_C0SC = 0x28;
    9b6a:	str	r3, [r6, #0]
	FTM3_C1SC = 0x28;
    9b6c:	str	r3, [r5, #0]
	FTM3_C2SC = 0x28;
    9b6e:	str.w	r3, [lr]
	FTM3_C3SC = 0x28;
    9b72:	str	r3, [r7, #0]
	FTM3_C4SC = 0x28;
    9b74:	str	r3, [r1, #0]
	FTM3_C5SC = 0x28;
    9b76:	str	r3, [r4, #0]
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9b78:	ldr	r4, [pc, #196]	; (9c40 <_init_Teensyduino_internal_+0x158>)
	FTM3_C1SC = 0x28;
	FTM3_C2SC = 0x28;
	FTM3_C3SC = 0x28;
	FTM3_C4SC = 0x28;
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
    9b7a:	str	r3, [r7, #24]
	FTM3_C7SC = 0x28;
    9b7c:	str	r3, [r1, #24]
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9b7e:	movs	r1, #9
    9b80:	str	r1, [r4, #0]
	FTM1_CNT = 0;
    9b82:	sub.w	r7, r7, #524288	; 0x80000
	FTM1_MOD = DEFAULT_FTM_MOD;
    9b86:	add.w	r4, r4, #4096	; 0x1000
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    9b8a:	subs	r7, #32
	FTM1_MOD = DEFAULT_FTM_MOD;
    9b8c:	adds	r4, #8
	FTM3_C5SC = 0x28;
	FTM3_C6SC = 0x28;
	FTM3_C7SC = 0x28;
#endif
	FTM0_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
	FTM1_CNT = 0;
    9b8e:	str	r2, [r7, #0]
	FTM1_MOD = DEFAULT_FTM_MOD;
    9b90:	str	r0, [r4, #0]
	FTM1_C0SC = 0x28;
    9b92:	str	r3, [r7, #8]
	FTM1_C1SC = 0x28;
    9b94:	str	r3, [r4, #12]
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9b96:	str.w	r1, [r7, #-4]
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    9b9a:	add.w	r4, r4, #518144	; 0x7e800
	FTM2_MOD = DEFAULT_FTM_MOD;
    9b9e:	add.w	r7, r7, #520192	; 0x7f000
    9ba2:	adds	r7, #4
	FTM1_MOD = DEFAULT_FTM_MOD;
	FTM1_C0SC = 0x28;
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
    9ba4:	addw	r4, r4, #2044	; 0x7fc
    9ba8:	str	r2, [r4, #0]
	FTM2_MOD = DEFAULT_FTM_MOD;
    9baa:	str	r0, [r7, #0]
	FTM2_C0SC = 0x28;
    9bac:	str	r3, [r4, #8]
	FTM2_C1SC = 0x28;
    9bae:	str	r3, [r7, #12]
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9bb0:	str.w	r1, [r4, #-4]
	FTM1_C1SC = 0x28;
	FTM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#if defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
	FTM2_CNT = 0;
	FTM2_MOD = DEFAULT_FTM_MOD;
	FTM2_C0SC = 0x28;
    9bb4:	adds	r4, #8
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
    9bb6:	addw	r4, r4, #4092	; 0xffc
	FTM2_C0SC = 0x28;
	FTM2_C1SC = 0x28;
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
    9bba:	str.w	r2, [r7, #4092]	; 0xffc
	FTM3_MOD = DEFAULT_FTM_MOD;
    9bbe:	str	r0, [r4, #0]
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    9bc0:	sub.w	r4, r4, #460800	; 0x70800
    9bc4:	subw	r4, r4, #2012	; 0x7dc
	FTM2_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
	FTM3_CNT = 0;
	FTM3_MOD = DEFAULT_FTM_MOD;
	FTM3_C0SC = 0x28;
    9bc8:	str	r3, [r6, #0]
	FTM3_C1SC = 0x28;
    9bca:	str	r3, [r5, #0]
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
    9bcc:	str.w	r1, [r7, #4088]	; 0xff8
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    9bd0:	ldr	r1, [r4, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    9bd2:	ldr	r0, [pc, #112]	; (9c44 <_init_Teensyduino_internal_+0x15c>)
	FTM3_C0SC = 0x28;
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
    9bd4:	orr.w	r1, r1, #512	; 0x200
    9bd8:	str	r1, [r4, #0]
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    9bda:	ldr	r1, [r0, #0]
	TPM1_CNT = 0;
	TPM1_MOD = 32767;
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    9bdc:	ldr	r4, [pc, #104]	; (9c48 <_init_Teensyduino_internal_+0x160>)
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
	TPM1_CNT = 0;
    9bde:	add.w	lr, lr, #65280	; 0xff00
    9be2:	add.w	lr, lr, #232	; 0xe8
	TPM1_MOD = 32767;
    9be6:	add.w	r7, r7, #69632	; 0x11000
	TPM1_C0SC = 0x28;
    9bea:	add.w	r6, r6, #65536	; 0x10000
	TPM1_C1SC = 0x28;
    9bee:	add.w	r5, r5, #65536	; 0x10000
	FTM3_C1SC = 0x28;
	FTM3_SC = FTM_SC_CLKS(1) | FTM_SC_PS(DEFAULT_FTM_PRESCALE);
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
    9bf2:	orr.w	r1, r1, #33554432	; 0x2000000
    9bf6:	str	r1, [r0, #0]
	TPM1_CNT = 0;
    9bf8:	str.w	r2, [lr]
	TPM1_MOD = 32767;
    9bfc:	movw	r1, #32767	; 0x7fff
	TPM1_C0SC = 0x28;
	TPM1_C1SC = 0x28;
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    9c00:	movs	r2, #8
#endif
#if defined(__MK66FX1M0__)
	SIM_SCGC2 |= SIM_SCGC2_TPM1;
	SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2);
	TPM1_CNT = 0;
	TPM1_MOD = 32767;
    9c02:	str	r1, [r7, #0]
	TPM1_C0SC = 0x28;
    9c04:	str	r3, [r6, #0]
	TPM1_C1SC = 0x28;
    9c06:	str	r3, [r5, #0]
	TPM1_SC = FTM_SC_CLKS(1) | FTM_SC_PS(0);
    9c08:	str	r2, [r4, #0]
#endif
	analog_init();
    9c0a:	bl	af48 <analog_init>

	// for background about this startup delay, please see these conversations
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
    9c0e:	movs	r0, #25
    9c10:	bl	9a4c <delay>
	usb_init();
    9c14:	bl	a900 <usb_init>
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    9c18:	movw	r0, #275	; 0x113
}
    9c1c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	// https://forum.pjrc.com/threads/36606-startup-time-(400ms)?p=113980&viewfull=1#post113980
	// https://forum.pjrc.com/threads/31290-Teensey-3-2-Teensey-Loader-1-24-Issues?p=87273&viewfull=1#post87273

	delay(TEENSY_INIT_USB_DELAY_BEFORE);
	usb_init();
	delay(TEENSY_INIT_USB_DELAY_AFTER);
    9c20:	b.w	9a4c <delay>
    9c24:	.word	0xe000e104
    9c28:	.word	0x40038004
    9c2c:	.word	0x40038014
    9c30:	.word	0x4003801c
    9c34:	.word	0x40038024
    9c38:	.word	0x4003802c
    9c3c:	.word	0x40038034
    9c40:	.word	0x40038000
    9c44:	.word	0x40048004
    9c48:	.word	0x400c9000
    9c4c:	.word	0x40038008
    9c50:	.word	0x4003800c

00009c54 <usb_malloc>:
usb_packet_t * usb_malloc(void)
{
	unsigned int n, avail;
	uint8_t *p;

	__disable_irq();
    9c54:	cpsid	i
	avail = usb_buffer_available;
    9c56:	ldr	r0, [pc, #52]	; (9c8c <usb_malloc+0x38>)
    9c58:	ldr	r2, [r0, #0]
	n = __builtin_clz(avail); // clz = count leading zeros
    9c5a:	clz	r3, r2
	if (n >= NUM_USB_BUFFERS) {
    9c5e:	cmp	r3, #19
    9c60:	bgt.n	9c84 <usb_malloc+0x30>
	}
	//serial_print("malloc:");
	//serial_phex(n);
	//serial_print("\n");

	usb_buffer_available = avail & ~(0x80000000 >> n);
    9c62:	mov.w	r1, #2147483648	; 0x80000000
    9c66:	lsrs	r1, r3
    9c68:	bic.w	r2, r2, r1
    9c6c:	str	r2, [r0, #0]
	__enable_irq();
    9c6e:	cpsie	i
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
    9c70:	ldr	r0, [pc, #28]	; (9c90 <usb_malloc+0x3c>)
    9c72:	add.w	r3, r3, r3, lsl #3
    9c76:	lsls	r3, r3, #3
    9c78:	adds	r2, r0, r3
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
    9c7a:	movs	r1, #0
    9c7c:	str	r1, [r0, r3]
	*(uint32_t *)(p + 4) = 0;
	return (usb_packet_t *)p;
    9c7e:	mov	r0, r2
	p = usb_buffer_memory + (n * sizeof(usb_packet_t));
	//serial_print("malloc:");
	//serial_phex32((int)p);
	//serial_print("\n");
	*(uint32_t *)p = 0;
	*(uint32_t *)(p + 4) = 0;
    9c80:	str	r1, [r2, #4]
	return (usb_packet_t *)p;
}
    9c82:	bx	lr

	__disable_irq();
	avail = usb_buffer_available;
	n = __builtin_clz(avail); // clz = count leading zeros
	if (n >= NUM_USB_BUFFERS) {
		__enable_irq();
    9c84:	cpsie	i
		return NULL;
    9c86:	movs	r0, #0
    9c88:	bx	lr
    9c8a:	nop
    9c8c:	.word	0x1fff0988
    9c90:	.word	0x1fff03d0

00009c94 <usb_free>:
void usb_free(usb_packet_t *p)
{
	unsigned int n, mask;

	//serial_print("free:");
	n = ((uint8_t *)p - usb_buffer_memory) / sizeof(usb_packet_t);
    9c94:	ldr	r3, [pc, #52]	; (9ccc <usb_free+0x38>)
    9c96:	ldr	r2, [pc, #56]	; (9cd0 <usb_free+0x3c>)
    9c98:	subs	r3, r0, r3
    9c9a:	umull	r2, r3, r2, r3
    9c9e:	lsrs	r3, r3, #4
	if (n >= NUM_USB_BUFFERS) return;
    9ca0:	cmp	r3, #19
    9ca2:	bhi.n	9cbe <usb_free+0x2a>
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    9ca4:	ldr	r2, [pc, #44]	; (9cd4 <usb_free+0x40>)
    9ca6:	ldrb	r2, [r2, #0]
    9ca8:	cbnz	r2, 9cc0 <usb_free+0x2c>
		usb_rx_memory(p);
		return;
	}

	mask = (0x80000000 >> n);
	__disable_irq();
    9caa:	cpsid	i
	usb_buffer_available |= mask;
    9cac:	ldr	r0, [pc, #40]	; (9cd8 <usb_free+0x44>)
    9cae:	mov.w	r1, #2147483648	; 0x80000000
    9cb2:	ldr	r2, [r0, #0]
    9cb4:	lsr.w	r3, r1, r3
    9cb8:	orrs	r2, r3
    9cba:	str	r2, [r0, #0]
	__enable_irq();
    9cbc:	cpsie	i
    9cbe:	bx	lr
	//serial_phex(n);
	//serial_print("\n");

	// if any endpoints are starving for memory to receive
	// packets, give this memory to them immediately!
	if (usb_rx_memory_needed && usb_configuration) {
    9cc0:	ldr	r2, [pc, #24]	; (9cdc <usb_free+0x48>)
    9cc2:	ldrb	r2, [r2, #0]
    9cc4:	cmp	r2, #0
    9cc6:	beq.n	9caa <usb_free+0x16>
		//serial_print("give to rx:");
		//serial_phex32((int)p);
		//serial_print("\n");
		usb_rx_memory(p);
    9cc8:	b.w	9d48 <usb_rx_memory>
    9ccc:	.word	0x1fff03d0
    9cd0:	.word	0x38e38e39
    9cd4:	.word	0x1fff1a91
    9cd8:	.word	0x1fff0988
    9cdc:	.word	0x1fff1a9c

00009ce0 <usb_rx>:


usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
    9ce0:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    9ce2:	cmp	r3, #5
    9ce4:	bhi.n	9d10 <usb_rx+0x30>
	__disable_irq();
    9ce6:	cpsid	i
	ret = rx_first[endpoint];
    9ce8:	ldr	r1, [pc, #40]	; (9d14 <usb_rx+0x34>)
    9cea:	ldr.w	r0, [r1, r3, lsl #2]
	if (ret) {
    9cee:	cbz	r0, 9d0c <usb_rx+0x2c>




usb_packet_t *usb_rx(uint32_t endpoint)
{
    9cf0:	push	{r4, r5, r6}
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
    9cf2:	ldr	r4, [pc, #36]	; (9d18 <usb_rx+0x38>)
    9cf4:	ldrh	r5, [r0, #0]
    9cf6:	ldrh.w	r2, [r4, r3, lsl #1]
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
	__disable_irq();
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
    9cfa:	ldr	r6, [r0, #4]
    9cfc:	str.w	r6, [r1, r3, lsl #2]
		usb_rx_byte_count_data[endpoint] -= ret->len;
    9d00:	subs	r2, r2, r5
    9d02:	strh.w	r2, [r4, r3, lsl #1]
	}
	__enable_irq();
    9d06:	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    9d08:	pop	{r4, r5, r6}
    9d0a:	bx	lr
	ret = rx_first[endpoint];
	if (ret) {
		rx_first[endpoint] = ret->next;
		usb_rx_byte_count_data[endpoint] -= ret->len;
	}
	__enable_irq();
    9d0c:	cpsie	i
	//serial_phex(endpoint);
	//serial_print(", packet=");
	//serial_phex32(ret);
	//serial_print("\n");
	return ret;
}
    9d0e:	bx	lr

usb_packet_t *usb_rx(uint32_t endpoint)
{
	usb_packet_t *ret;
	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return NULL;
    9d10:	movs	r0, #0
    9d12:	bx	lr
    9d14:	.word	0x1fff19fc
    9d18:	.word	0x1fff1d74

00009d1c <usb_tx_packet_count>:
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
    9d1c:	subs	r0, #1
	if (endpoint >= NUM_ENDPOINTS) return 0;
    9d1e:	cmp	r0, #5
    9d20:	bhi.n	9d3a <usb_tx_packet_count+0x1e>
	__disable_irq();
    9d22:	cpsid	i
	for (p = tx_first[endpoint]; p; p = p->next) count++;
    9d24:	ldr	r3, [pc, #28]	; (9d44 <usb_tx_packet_count+0x28>)
    9d26:	ldr.w	r3, [r3, r0, lsl #2]
    9d2a:	cbz	r3, 9d3e <usb_tx_packet_count+0x22>
    9d2c:	movs	r0, #0
    9d2e:	ldr	r3, [r3, #4]
    9d30:	adds	r0, #1
    9d32:	cmp	r3, #0
    9d34:	bne.n	9d2e <usb_tx_packet_count+0x12>
	__enable_irq();
    9d36:	cpsie	i
	return count;
    9d38:	bx	lr
{
	const usb_packet_t *p;
	uint32_t count=0;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return 0;
    9d3a:	movs	r0, #0
	__disable_irq();
	for (p = tx_first[endpoint]; p; p = p->next) count++;
	__enable_irq();
	return count;
}
    9d3c:	bx	lr
// https://forum.pjrc.com/threads/58663?p=223513&viewfull=1#post223513
//
uint32_t usb_tx_packet_count(uint32_t endpoint)
{
	const usb_packet_t *p;
	uint32_t count=0;
    9d3e:	mov	r0, r3
    9d40:	b.n	9d36 <usb_tx_packet_count+0x1a>
    9d42:	nop
    9d44:	.word	0x1fff1a58

00009d48 <usb_rx_memory>:
// user is creating data very quickly, their consumption could starve reception
// without this prioritization.  The packet buffer (input) is assigned to the
// first endpoint needing memory.
//
void usb_rx_memory(usb_packet_t *packet)
{
    9d48:	push	{r4, r5}
	unsigned int i;
	const uint8_t *cfg;

	cfg = usb_endpoint_config_table;
	//serial_print("rx_mem:");
	__disable_irq();
    9d4a:	cpsid	i
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    9d4c:	ldr	r2, [pc, #236]	; (9e3c <usb_rx_memory+0xf4>)
    9d4e:	ldrb	r3, [r2, #0]
    9d50:	lsls	r1, r3, #28
    9d52:	bpl.n	9d62 <usb_rx_memory+0x1a>
			if (table[index(i, RX, EVEN)].desc == 0) {
    9d54:	ldr	r3, [pc, #232]	; (9e40 <usb_rx_memory+0xf8>)
    9d56:	ldr	r1, [r3, #32]
    9d58:	cmp	r1, #0
    9d5a:	beq.n	9dfc <usb_rx_memory+0xb4>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    9d5c:	ldr	r1, [r3, #40]	; 0x28
    9d5e:	cmp	r1, #0
    9d60:	beq.n	9e18 <usb_rx_memory+0xd0>
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    9d62:	ldrb	r3, [r2, #1]
    9d64:	lsls	r3, r3, #28
    9d66:	bpl.n	9d76 <usb_rx_memory+0x2e>
			if (table[index(i, RX, EVEN)].desc == 0) {
    9d68:	ldr	r3, [pc, #212]	; (9e40 <usb_rx_memory+0xf8>)
    9d6a:	ldr	r1, [r3, #64]	; 0x40
    9d6c:	cmp	r1, #0
    9d6e:	beq.n	9e2c <usb_rx_memory+0xe4>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    9d70:	ldr	r1, [r3, #72]	; 0x48
    9d72:	cmp	r1, #0
    9d74:	beq.n	9e1c <usb_rx_memory+0xd4>
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    9d76:	ldrb	r3, [r2, #2]
    9d78:	lsls	r5, r3, #28
    9d7a:	bpl.n	9d8a <usb_rx_memory+0x42>
			if (table[index(i, RX, EVEN)].desc == 0) {
    9d7c:	ldr	r3, [pc, #192]	; (9e40 <usb_rx_memory+0xf8>)
    9d7e:	ldr	r1, [r3, #96]	; 0x60
    9d80:	cmp	r1, #0
    9d82:	beq.n	9e28 <usb_rx_memory+0xe0>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    9d84:	ldr	r1, [r3, #104]	; 0x68
    9d86:	cmp	r1, #0
    9d88:	beq.n	9e20 <usb_rx_memory+0xd8>
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    9d8a:	ldrb	r3, [r2, #3]
    9d8c:	lsls	r4, r3, #28
    9d8e:	bpl.n	9da2 <usb_rx_memory+0x5a>
			if (table[index(i, RX, EVEN)].desc == 0) {
    9d90:	ldr	r3, [pc, #172]	; (9e40 <usb_rx_memory+0xf8>)
    9d92:	ldr.w	r1, [r3, #128]	; 0x80
    9d96:	cmp	r1, #0
    9d98:	beq.n	9e30 <usb_rx_memory+0xe8>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    9d9a:	ldr.w	r1, [r3, #136]	; 0x88
    9d9e:	cmp	r1, #0
    9da0:	beq.n	9e24 <usb_rx_memory+0xdc>
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    9da2:	ldrb	r3, [r2, #4]
    9da4:	lsls	r1, r3, #28
    9da6:	bpl.n	9db8 <usb_rx_memory+0x70>
			if (table[index(i, RX, EVEN)].desc == 0) {
    9da8:	ldr	r3, [pc, #148]	; (9e40 <usb_rx_memory+0xf8>)
    9daa:	ldr.w	r1, [r3, #160]	; 0xa0
    9dae:	cmp	r1, #0
    9db0:	beq.n	9e38 <usb_rx_memory+0xf0>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    9db2:	ldr.w	r1, [r3, #168]	; 0xa8
    9db6:	cbz	r1, 9dde <usb_rx_memory+0x96>
	__disable_irq();
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
    9db8:	ldrb	r3, [r2, #5]
    9dba:	lsls	r3, r3, #28
    9dbc:	bpl.n	9dd0 <usb_rx_memory+0x88>
			if (table[index(i, RX, EVEN)].desc == 0) {
    9dbe:	ldr	r3, [pc, #128]	; (9e40 <usb_rx_memory+0xf8>)
    9dc0:	ldr.w	r2, [r3, #192]	; 0xc0
    9dc4:	cmp	r2, #0
    9dc6:	beq.n	9e34 <usb_rx_memory+0xec>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    9dc8:	ldr.w	r2, [r3, #200]	; 0xc8
    9dcc:	movs	r4, #25
    9dce:	cbz	r2, 9de0 <usb_rx_memory+0x98>
				//serial_print(",odd\n");
				return;
			}
		}
	}
	__enable_irq();
    9dd0:	cpsie	i
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
    9dd2:	ldr	r3, [pc, #112]	; (9e44 <usb_rx_memory+0xfc>)
    9dd4:	movs	r2, #0
    9dd6:	strb	r2, [r3, #0]
	usb_free(packet);
	return;
}
    9dd8:	pop	{r4, r5}
	__enable_irq();
	// we should never reach this point.  If we get here, it means
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
    9dda:	b.w	9c94 <usb_free>
				__enable_irq();
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    9dde:	movs	r4, #21
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    9de0:	ldr	r1, [pc, #96]	; (9e44 <usb_rx_memory+0xfc>)
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9de2:	ldr	r5, [pc, #100]	; (9e48 <usb_rx_memory+0x100>)
				usb_rx_memory_needed--;
    9de4:	ldrb	r2, [r1, #0]
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    9de6:	str.w	r5, [r3, r4, lsl #3]
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    9dea:	add.w	r3, r3, r4, lsl #3
    9dee:	adds	r0, #8
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    9df0:	subs	r2, #1
				//serial_phex(i);
				//serial_print(",even\n");
				return;
			}
			if (table[index(i, RX, ODD)].desc == 0) {
				table[index(i, RX, ODD)].addr = packet->buf;
    9df2:	str	r0, [r3, #4]
				table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				usb_rx_memory_needed--;
    9df4:	strb	r2, [r1, #0]
				__enable_irq();
    9df6:	cpsie	i
	// usb_rx_memory_needed was set greater than zero, but no memory
	// was actually needed.
	usb_rx_memory_needed = 0;
	usb_free(packet);
	return;
}
    9df8:	pop	{r4, r5}
    9dfa:	bx	lr
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    9dfc:	movs	r2, #4
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    9dfe:	ldr	r4, [pc, #68]	; (9e44 <usb_rx_memory+0xfc>)
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    9e00:	ldr	r5, [pc, #72]	; (9e4c <usb_rx_memory+0x104>)
				usb_rx_memory_needed--;
    9e02:	ldrb	r1, [r4, #0]
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    9e04:	str.w	r5, [r3, r2, lsl #3]
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    9e08:	add.w	r3, r3, r2, lsl #3
    9e0c:	adds	r0, #8
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    9e0e:	subs	r2, r1, #1
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
				table[index(i, RX, EVEN)].addr = packet->buf;
    9e10:	str	r0, [r3, #4]
				table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				usb_rx_memory_needed--;
    9e12:	strb	r2, [r4, #0]
				__enable_irq();
    9e14:	cpsie	i
				//serial_phex(i);
				//serial_print(",even\n");
				return;
    9e16:	b.n	9df8 <usb_rx_memory+0xb0>
			}
			if (table[index(i, RX, ODD)].desc == 0) {
    9e18:	movs	r4, #5
    9e1a:	b.n	9de0 <usb_rx_memory+0x98>
    9e1c:	movs	r4, #9
    9e1e:	b.n	9de0 <usb_rx_memory+0x98>
    9e20:	movs	r4, #13
    9e22:	b.n	9de0 <usb_rx_memory+0x98>
    9e24:	movs	r4, #17
    9e26:	b.n	9de0 <usb_rx_memory+0x98>
	for (i=1; i <= NUM_ENDPOINTS; i++) {
#ifdef AUDIO_INTERFACE
		if (i == AUDIO_RX_ENDPOINT) continue;
#endif
		if (*cfg++ & USB_ENDPT_EPRXEN) {
			if (table[index(i, RX, EVEN)].desc == 0) {
    9e28:	movs	r2, #12
    9e2a:	b.n	9dfe <usb_rx_memory+0xb6>
    9e2c:	movs	r2, #8
    9e2e:	b.n	9dfe <usb_rx_memory+0xb6>
    9e30:	movs	r2, #16
    9e32:	b.n	9dfe <usb_rx_memory+0xb6>
    9e34:	movs	r2, #24
    9e36:	b.n	9dfe <usb_rx_memory+0xb6>
    9e38:	movs	r2, #20
    9e3a:	b.n	9dfe <usb_rx_memory+0xb6>
    9e3c:	.word	0x0000c7dc
    9e40:	.word	0x1fff0000
    9e44:	.word	0x1fff1a91
    9e48:	.word	0x004000c8
    9e4c:	.word	0x00400088

00009e50 <usb_tx>:
void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
	uint8_t next;

	endpoint--;
    9e50:	subs	r3, r0, #1
	if (endpoint >= NUM_ENDPOINTS) return;
    9e52:	cmp	r3, #5
    9e54:	bhi.n	9e92 <usb_tx+0x42>
//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    9e56:	ldr	r2, [pc, #108]	; (9ec4 <usb_tx+0x74>)
    9e58:	lsls	r0, r0, #5
    9e5a:	orr.w	r0, r0, #16

//#define index(endpoint, tx, odd) (((endpoint) << 2) | ((tx) << 1) | (odd))
//#define stat2bufferdescriptor(stat) (table + ((stat) >> 2))

void usb_tx(uint32_t endpoint, usb_packet_t *packet)
{
    9e5e:	push	{r4, r5}
	bdt_t *b = &table[index(endpoint, TX, EVEN)];
    9e60:	add	r0, r2
	uint8_t next;

	endpoint--;
	if (endpoint >= NUM_ENDPOINTS) return;
	__disable_irq();
    9e62:	cpsid	i
	//serial_print("txstate=");
	//serial_phex(tx_state[endpoint]);
	//serial_print("\n");
	switch (tx_state[endpoint]) {
    9e64:	ldr	r4, [pc, #96]	; (9ec8 <usb_tx+0x78>)
    9e66:	ldrb	r2, [r4, r3]
    9e68:	cmp	r2, #3
    9e6a:	bhi.n	9ea4 <usb_tx+0x54>
    9e6c:	tbb	[pc, r2]
    9e70:	.word	0x17151202
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
    9e74:	movs	r2, #3
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9e76:	ldrh	r5, [r1, #0]
		}
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
    9e78:	strb	r2, [r4, r3]
	b->addr = packet->buf;
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9e7a:	tst.w	r0, #8
    9e7e:	ite	ne
    9e80:	movne	r3, #200	; 0xc8
    9e82:	moveq	r3, #136	; 0x88
    9e84:	orr.w	r3, r3, r5, lsl #16
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    9e88:	adds	r1, #8
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
    9e8a:	str	r3, [r0, #0]
		tx_last[endpoint] = packet;
		__enable_irq();
		return;
	}
	tx_state[endpoint] = next;
	b->addr = packet->buf;
    9e8c:	str	r1, [r0, #4]
	b->desc = BDT_DESC(packet->len, ((uint32_t)b & 8) ? DATA1 : DATA0);
	__enable_irq();
    9e8e:	cpsie	i
}
    9e90:	pop	{r4, r5}
    9e92:	bx	lr
	switch (tx_state[endpoint]) {
	  case TX_STATE_BOTH_FREE_EVEN_FIRST:
		next = TX_STATE_ODD_FREE;
		break;
	  case TX_STATE_BOTH_FREE_ODD_FIRST:
		b++;
    9e94:	adds	r0, #8
		next = TX_STATE_EVEN_FREE;
    9e96:	movs	r2, #2
		break;
    9e98:	b.n	9e76 <usb_tx+0x26>
	  case TX_STATE_EVEN_FREE:
		next = TX_STATE_NONE_FREE_ODD_FIRST;
    9e9a:	movs	r2, #5
    9e9c:	b.n	9e76 <usb_tx+0x26>
		break;
	  case TX_STATE_ODD_FREE:
		b++;
    9e9e:	adds	r0, #8
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
    9ea0:	movs	r2, #4
		break;
    9ea2:	b.n	9e76 <usb_tx+0x26>
	  default:
		if (tx_first[endpoint] == NULL) {
    9ea4:	ldr	r2, [pc, #36]	; (9ecc <usb_tx+0x7c>)
    9ea6:	ldr.w	r0, [r2, r3, lsl #2]
    9eaa:	cbz	r0, 9ebc <usb_tx+0x6c>
			tx_first[endpoint] = packet;
		} else {
			tx_last[endpoint]->next = packet;
    9eac:	ldr	r2, [pc, #32]	; (9ed0 <usb_tx+0x80>)
    9eae:	ldr.w	r0, [r2, r3, lsl #2]
    9eb2:	str	r1, [r0, #4]
		}
		tx_last[endpoint] = packet;
    9eb4:	str.w	r1, [r2, r3, lsl #2]
		__enable_irq();
    9eb8:	cpsie	i
		return;
    9eba:	b.n	9e90 <usb_tx+0x40>
		b++;
		next = TX_STATE_NONE_FREE_EVEN_FIRST;
		break;
	  default:
		if (tx_first[endpoint] == NULL) {
			tx_first[endpoint] = packet;
    9ebc:	str.w	r1, [r2, r3, lsl #2]
    9ec0:	ldr	r2, [pc, #12]	; (9ed0 <usb_tx+0x80>)
    9ec2:	b.n	9eb4 <usb_tx+0x64>
    9ec4:	.word	0x1fff0000
    9ec8:	.word	0x1fff1aa0
    9ecc:	.word	0x1fff1a58
    9ed0:	.word	0x1fff1a70

00009ed4 <usb_isr>:
}



void usb_isr(void)
{
    9ed4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    9ed8:	ldr.w	fp, [pc, #776]	; a1e4 <usb_isr+0x310>
		USB0_ISTAT = USB_ISTAT_SOFTOK;
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
		uint8_t endpoint;
		stat = USB0_STAT;
    9edc:	ldr.w	sl, [pc, #776]	; a1e8 <usb_isr+0x314>
}



void usb_isr(void)
{
    9ee0:	sub	sp, #28
    9ee2:	b.n	9f6e <usb_isr+0x9a>
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
    9ee4:	ldr	r7, [pc, #688]	; (a198 <usb_isr+0x2c4>)
    9ee6:	mov.w	r8, r3, lsr #2
    9eea:	add.w	r9, r7, r8, lsl #3
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9eee:	subs	r6, #1
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9ef0:	ldr.w	r2, [r9, #4]
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9ef4:	and.w	r3, r3, #8
			serial_print(((uint32_t)b & 8) ? ", odd" : ", even");
			serial_print(", count:");
			serial_phex(b->desc >> 16);
			serial_print("\n");
#endif
			endpoint--;	// endpoint is index to zero-based arrays
    9ef8:	uxtb	r6, r6
		endpoint = stat >> 4;
		if (endpoint == 0) {
			usb_control(stat);
		} else {
			bdt_t *b = stat2bufferdescriptor(stat);
			usb_packet_t *packet = (usb_packet_t *)((uint8_t *)(b->addr) - 8);
    9efa:	sub.w	r0, r2, #8
				b->addr = &usb_audio_sync_feedback;
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
    9efe:	and.w	r4, r3, #255	; 0xff
    9f02:	cmp	r3, #0
    9f04:	bne.w	a10e <usb_isr+0x23a>
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
    9f08:	ldr.w	r3, [r7, r8, lsl #3]
    9f0c:	lsrs	r3, r3, #16
    9f0e:	uxth	r1, r3
    9f10:	strh.w	r1, [r2, #-8]
				if (packet->len > 0) {
    9f14:	cmp	r3, #0
    9f16:	beq.w	a0fc <usb_isr+0x228>
					packet->index = 0;
					packet->next = NULL;
					if (rx_first[endpoint] == NULL) {
    9f1a:	ldr	r3, [pc, #640]	; (a19c <usb_isr+0x2c8>)
					}
				}
			} else { // receive
				packet->len = b->desc >> 16;
				if (packet->len > 0) {
					packet->index = 0;
    9f1c:	strh.w	r4, [r2, #-6]
					packet->next = NULL;
    9f20:	str.w	r4, [r2, #-4]
					if (rx_first[endpoint] == NULL) {
    9f24:	ldr.w	r2, [r3, r6, lsl #2]
    9f28:	cmp	r2, #0
    9f2a:	beq.w	a362 <usb_isr+0x48e>
						//serial_print("rx Nth, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
    9f2e:	ldr	r5, [pc, #624]	; (a1a0 <usb_isr+0x2cc>)
    9f30:	ldr.w	r3, [r5, r6, lsl #2]
    9f34:	str	r0, [r3, #4]
					}
					rx_last[endpoint] = packet;
					usb_rx_byte_count_data[endpoint] += packet->len;
    9f36:	ldr	r4, [pc, #620]	; (a1a4 <usb_isr+0x2d0>)
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_last[endpoint]->next = packet;
					}
					rx_last[endpoint] = packet;
    9f38:	str.w	r0, [r5, r6, lsl #2]
					usb_rx_byte_count_data[endpoint] += packet->len;
    9f3c:	ldrh.w	r3, [r4, r6, lsl #1]
    9f40:	add	r1, r3
    9f42:	strh.w	r1, [r4, r6, lsl #1]
					// TODO: implement a per-endpoint maximum # of allocated
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
    9f46:	bl	9c54 <usb_malloc>
					if (packet) {
    9f4a:	cmp	r0, #0
    9f4c:	beq.w	a36a <usb_isr+0x496>
						b->addr = packet->buf;
						b->desc = BDT_DESC(64,
    9f50:	ldr	r2, [pc, #596]	; (a1a8 <usb_isr+0x2d4>)
    9f52:	ldr	r3, [pc, #600]	; (a1ac <usb_isr+0x2d8>)
    9f54:	tst.w	r9, #8
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    9f58:	add.w	r0, r0, #8
						b->desc = BDT_DESC(64,
    9f5c:	it	ne
    9f5e:	movne	r3, r2
					// packets, so a flood of incoming data on 1 endpoint
					// doesn't starve the others if the user isn't reading
					// it regularly
					packet = usb_malloc();
					if (packet) {
						b->addr = packet->buf;
    9f60:	str.w	r0, [r9, #4]
						b->desc = BDT_DESC(64,
    9f64:	str.w	r3, [r7, r8, lsl #3]
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
				}
			}

		}
		USB0_ISTAT = USB_ISTAT_TOKDNE;
    9f68:	movs	r3, #8
    9f6a:	strb.w	r3, [fp]
	//serial_print("isr");
	//status = USB0_ISTAT;
	//serial_phex(status);
	//serial_print("\n");
	restart:
	status = USB0_ISTAT;
    9f6e:	ldrb.w	r4, [fp]
    9f72:	uxtb	r4, r4

	if ((status & USB_ISTAT_SOFTOK /* 04 */ )) {
    9f74:	lsls	r5, r4, #29
    9f76:	bpl.n	9fae <usb_isr+0xda>
		if (usb_configuration) {
    9f78:	ldr	r3, [pc, #564]	; (a1b0 <usb_isr+0x2dc>)
    9f7a:	ldrb	r3, [r3, #0]
    9f7c:	cbz	r3, 9fa8 <usb_isr+0xd4>
			t = usb_reboot_timer;
    9f7e:	ldr	r1, [pc, #564]	; (a1b4 <usb_isr+0x2e0>)
    9f80:	ldrb	r2, [r1, #0]
			if (t) {
    9f82:	and.w	r3, r2, #255	; 0xff
    9f86:	cbz	r2, 9f92 <usb_isr+0xbe>
				usb_reboot_timer = --t;
    9f88:	subs	r3, #1
    9f8a:	uxtb	r3, r3
    9f8c:	strb	r3, [r1, #0]
				if (!t) _reboot_Teensyduino_();
    9f8e:	cbnz	r3, 9f92 <usb_isr+0xbe>


void _reboot_Teensyduino_(void)
{
	// TODO: initialize R0 with a code....
	__asm__ volatile("bkpt");
    9f90:	bkpt	0x0000
			if (t) {
				usb_reboot_timer = --t;
				if (!t) _reboot_Teensyduino_();
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
    9f92:	ldr	r1, [pc, #548]	; (a1b8 <usb_isr+0x2e4>)
    9f94:	ldrb	r2, [r1, #0]
			if (t) {
    9f96:	and.w	r3, r2, #255	; 0xff
    9f9a:	cbz	r2, 9fa8 <usb_isr+0xd4>
				usb_cdc_transmit_flush_timer = --t;
    9f9c:	subs	r3, #1
    9f9e:	uxtb	r3, r3
    9fa0:	strb	r3, [r1, #0]
				if (t == 0) usb_serial_flush_callback();
    9fa2:	cmp	r3, #0
    9fa4:	beq.w	a30e <usb_isr+0x43a>
#endif
#ifdef MULTITOUCH_INTERFACE
			usb_touchscreen_update_callback();
#endif
		}
		USB0_ISTAT = USB_ISTAT_SOFTOK;
    9fa8:	movs	r3, #4
    9faa:	strb.w	r3, [fp]
	}

	if ((status & USB_ISTAT_TOKDNE /* 08 */ )) {
    9fae:	and.w	r3, r4, #8
    9fb2:	and.w	r2, r3, #255	; 0xff
    9fb6:	cmp	r3, #0
    9fb8:	beq.w	a156 <usb_isr+0x282>
		uint8_t endpoint;
		stat = USB0_STAT;
    9fbc:	ldrb.w	r3, [sl]
    9fc0:	uxtb	r3, r3
		//serial_print("token: ep=");
		//serial_phex(stat >> 4);
		//serial_print(stat & 0x08 ? ",tx" : ",rx");
		//serial_print(stat & 0x04 ? ",odd\n" : ",even\n");
		endpoint = stat >> 4;
		if (endpoint == 0) {
    9fc2:	lsrs	r6, r3, #4
    9fc4:	bne.n	9ee4 <usb_isr+0x10>
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    9fc6:	lsrs	r0, r3, #2
    9fc8:	ldr.w	r9, [pc, #460]	; a198 <usb_isr+0x2c4>
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    9fcc:	ldr.w	r2, [r9, r0, lsl #3]
	bdt_t *b;
	uint32_t pid, size;
	uint8_t *buf;
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
    9fd0:	add.w	r1, r9, r0, lsl #3
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    9fd4:	ubfx	r2, r2, #2, #4
    9fd8:	subs	r2, #1
	const uint8_t *data;

	b = stat2bufferdescriptor(stat);
	pid = BDT_PID(b->desc);
	//count = b->desc >> 16;
	buf = b->addr;
    9fda:	ldr	r1, [r1, #4]
	//serial_phex(pid);
	//serial_print(", count:");
	//serial_phex(count);
	//serial_print("\n");

	switch (pid) {
    9fdc:	cmp	r2, #12
    9fde:	bhi.w	a0f4 <usb_isr+0x220>
    9fe2:	tbb	[pc, r2]
    9fe6:	.short	0x7d7d
    9fe8:	.word	0x87878787
    9fec:	.word	0x87488787
    9ff0:	.short	0x8787
    9ff2:	.byte	0x07
    9ff3:	.byte	0x00
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    9ff4:	ldr	r2, [r1, #0]
    9ff6:	ldr	r5, [pc, #452]	; (a1bc <usb_isr+0x2e8>)
		setup.word2 = *(uint32_t *)(buf + 4);
    9ff8:	ldr	r1, [r1, #4]
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    9ffa:	ldr	r7, [pc, #452]	; (a1c0 <usb_isr+0x2ec>)
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    9ffc:	ldr	r6, [pc, #452]	; (a1c4 <usb_isr+0x2f0>)
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    9ffe:	ldr	r4, [pc, #424]	; (a1a8 <usb_isr+0x2d4>)
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);
    a000:	str	r1, [r5, #4]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    a002:	uxth	r1, r2
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
		setup.word2 = *(uint32_t *)(buf + 4);

		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    a004:	str.w	r4, [r9, r0, lsl #3]
	switch (pid) {
	case 0x0D: // Setup received from host
		//serial_print("PID=Setup\n");
		//if (count != 8) ; // panic?
		// grab the 8 byte setup info
		setup.word1 = *(uint32_t *)(buf);
    a008:	str	r2, [r5, #0]
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    a00a:	movs	r0, #1
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    a00c:	movs	r2, #0
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    a00e:	cmp.w	r1, #2176	; 0x880
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
		//table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 1);
		//table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 1);

		// clear any leftover pending IN transactions
		ep0_tx_ptr = NULL;
    a012:	str	r2, [r7, #0]
			//serial_print("leftover tx even\n");
		//}
		//if (table[index(0, TX, ODD)].desc & 0x80) {
			//serial_print("leftover tx odd\n");
		//}
		table[index(0, TX, EVEN)].desc = 0;
    a014:	str.w	r2, [r9, #16]
		table[index(0, TX, ODD)].desc = 0;
    a018:	str.w	r2, [r9, #24]
		// first IN after Setup is always DATA1
		ep0_tx_data_toggle = 1;
    a01c:	strb	r0, [r6, #0]
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    a01e:	beq.w	a486 <usb_isr+0x5b2>
    a022:	bls.w	a1ec <usb_isr+0x318>
    a026:	movw	r4, #8993	; 0x2321
    a02a:	cmp	r1, r4
    a02c:	beq.w	a4cc <usb_isr+0x5f8>
    a030:	bhi.w	a394 <usb_isr+0x4c0>
    a034:	movw	r4, #8225	; 0x2021
    a038:	cmp	r1, r4
    a03a:	beq.w	a3ac <usb_isr+0x4d8>
    a03e:	movw	r4, #8737	; 0x2221
    a042:	cmp	r1, r4
    a044:	beq.w	a490 <usb_isr+0x5bc>
    a048:	cmp.w	r1, #2304	; 0x900
    a04c:	bne.w	a3a6 <usb_isr+0x4d2>
	  case 0x0500: // SET_ADDRESS
		break;
	  case 0x0900: // SET_CONFIGURATION
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
    a050:	ldr	r2, [pc, #348]	; (a1b0 <usb_isr+0x2dc>)
    a052:	ldr	r4, [pc, #324]	; (a198 <usb_isr+0x2c4>)
    a054:	ldrb	r1, [r5, #2]
    a056:	strb	r1, [r2, #0]
    a058:	add.w	r5, r4, #192	; 0xc0
    a05c:	b.n	a066 <usb_isr+0x192>
    a05e:	adds	r4, #8
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    a060:	cmp	r5, r4
    a062:	beq.w	a534 <usb_isr+0x660>
			if (table[i].desc & BDT_OWN) {
    a066:	ldr	r3, [r4, #32]
    a068:	lsls	r0, r3, #24
    a06a:	bpl.n	a05e <usb_isr+0x18a>
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
    a06c:	ldr	r0, [r4, #36]	; 0x24
    a06e:	subs	r0, #8
    a070:	bl	9c94 <usb_free>
    a074:	b.n	a05e <usb_isr+0x18a>
		//serial_print("PID=IN:");
		//serial_phex(stat);
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
    a076:	ldr	r7, [pc, #328]	; (a1c0 <usb_isr+0x2ec>)
    a078:	ldr	r2, [r7, #0]
		if (data) {
    a07a:	cbz	r2, a0ca <usb_isr+0x1f6>
			size = ep0_tx_len;
    a07c:	ldr	r3, [pc, #328]	; (a1c8 <usb_isr+0x2f4>)
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a07e:	ldr	r6, [pc, #324]	; (a1c4 <usb_isr+0x2f0>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a080:	ldr	r1, [pc, #328]	; (a1cc <usb_isr+0x2f8>)
		//serial_print("\n");

		// send remaining data, if any...
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
    a082:	ldrh	r0, [r3, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a084:	ldrb	r4, [r6, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a086:	ldrb	r5, [r1, #0]
    a088:	cmp	r0, #64	; 0x40
    a08a:	mov	lr, r0
    a08c:	orr.w	r8, r5, #2
    a090:	it	cs
    a092:	movcs.w	lr, #64	; 0x40
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a096:	cmp	r4, #0
	ep0_tx_data_toggle ^= 1;
    a098:	eor.w	r4, r4, #1
    a09c:	strb	r4, [r6, #0]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    a09e:	rsb	r0, lr, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a0a2:	ite	eq
    a0a4:	moveq	r4, #136	; 0x88
    a0a6:	movne	r4, #200	; 0xc8
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a0a8:	add.w	r6, r9, r8, lsl #3
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    a0ac:	uxth	r0, r0
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    a0ae:	eor.w	r5, r5, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a0b2:	orr.w	r4, r4, lr, lsl #16
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a0b6:	str	r2, [r6, #4]
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
    a0b8:	strh	r0, [r3, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a0ba:	str.w	r4, [r9, r8, lsl #3]
		data = ep0_tx_ptr;
		if (data) {
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
    a0be:	add	r2, lr
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    a0c0:	strb	r5, [r1, #0]
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    a0c2:	cmp	r0, #0
    a0c4:	beq.w	a2b0 <usb_isr+0x3dc>
    a0c8:	str	r2, [r7, #0]
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
    a0ca:	ldr	r3, [pc, #240]	; (a1bc <usb_isr+0x2e8>)
    a0cc:	ldrh	r2, [r3, #0]
    a0ce:	cmp.w	r2, #1280	; 0x500
    a0d2:	bne.n	a0f4 <usb_isr+0x220>
			setup.bRequest = 0;
    a0d4:	movs	r1, #0
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    a0d6:	ldrb	r2, [r3, #2]
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
		}

		if (setup.bRequest == 5 && setup.bmRequestType == 0) {
			setup.bRequest = 0;
    a0d8:	strb	r1, [r3, #1]
			//serial_print("set address: ");
			//serial_phex16(setup.wValue);
			//serial_print("\n");
			USB0_ADDR = setup.wValue;
    a0da:	ldr	r3, [pc, #244]	; (a1d0 <usb_isr+0x2fc>)
    a0dc:	strb	r2, [r3, #0]
    a0de:	b.n	a0f4 <usb_isr+0x220>
		break;
	case 0x01:  // OUT transaction received from host
	case 0x02:
		//serial_print("PID=OUT\n");
#ifdef CDC_STATUS_INTERFACE
		if (setup.wRequestAndType == 0x2021 /*CDC_SET_LINE_CODING*/) {
    a0e0:	ldr	r2, [pc, #216]	; (a1bc <usb_isr+0x2e8>)
    a0e2:	ldrh	r4, [r2, #0]
    a0e4:	movw	r2, #8225	; 0x2021
    a0e8:	cmp	r4, r2
    a0ea:	beq.w	a2ba <usb_isr+0x3e6>
		if (usb_audio_set_feature(&setup, buf)) {
			endpoint0_transmit(NULL, 0);
		}
#endif
		// give the buffer back
		b->desc = BDT_DESC(EP0_SIZE, DATA1);
    a0ee:	ldr	r2, [pc, #184]	; (a1a8 <usb_isr+0x2d4>)
    a0f0:	str.w	r2, [r9, r0, lsl #3]
	//default:
		//serial_print("PID=unknown:");
		//serial_phex(pid);
		//serial_print("\n");
	}
	USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    a0f4:	ldr	r2, [pc, #220]	; (a1d4 <usb_isr+0x300>)
    a0f6:	movs	r3, #1
    a0f8:	strb	r3, [r2, #0]
    a0fa:	b.n	9f68 <usb_isr+0x94>
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
					}
				} else {
					b->desc = BDT_DESC(64, ((uint32_t)b & 8) ? DATA1 : DATA0);
    a0fc:	ldr	r2, [pc, #168]	; (a1a8 <usb_isr+0x2d4>)
    a0fe:	ldr	r3, [pc, #172]	; (a1ac <usb_isr+0x2d8>)
    a100:	tst.w	r9, #8
    a104:	it	ne
    a106:	movne	r3, r2
    a108:	str.w	r3, [r7, r8, lsl #3]
    a10c:	b.n	9f68 <usb_isr+0x94>
				b->desc = (3 << 16) | BDT_OWN;
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
    a10e:	bl	9c94 <usb_free>
				packet = tx_first[endpoint];
    a112:	ldr	r2, [pc, #196]	; (a1d8 <usb_isr+0x304>)
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    a114:	ldr	r1, [pc, #196]	; (a1dc <usb_isr+0x308>)
				tx_state[endpoint] ^= 1;
			} else
#endif
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
    a116:	ldr.w	r3, [r2, r6, lsl #2]
				if (packet) {
    a11a:	cmp	r3, #0
    a11c:	beq.w	a378 <usb_isr+0x4a4>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    a120:	ldr	r0, [r3, #4]
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
    a122:	ldrb	r4, [r1, r6]
			if (stat & 0x08) { // transmit
				usb_free(packet);
				packet = tx_first[endpoint];
				if (packet) {
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
    a124:	str.w	r0, [r2, r6, lsl #2]
					b->addr = packet->buf;
    a128:	add.w	r2, r3, #8
    a12c:	str.w	r2, [r9, #4]
					switch (tx_state[endpoint]) {
    a130:	cmp	r4, #3
    a132:	bhi.n	a140 <usb_isr+0x26c>
    a134:	tbb	[pc, r4]
    a138:	.word	0x2629022c
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
    a13c:	movs	r2, #2
    a13e:	strb	r2, [r1, r6]
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
						break;
					  default:
						break;
					}
					b->desc = BDT_DESC(packet->len,
    a140:	ldrh	r2, [r3, #0]
    a142:	tst.w	r9, #8
    a146:	ite	eq
    a148:	moveq	r3, #136	; 0x88
    a14a:	movne	r3, #200	; 0xc8
    a14c:	orr.w	r3, r3, r2, lsl #16
    a150:	str.w	r3, [r7, r8, lsl #3]
    a154:	b.n	9f68 <usb_isr+0x94>
		goto restart;
	}



	if (status & USB_ISTAT_USBRST /* 01 */ ) {
    a156:	lsls	r0, r4, #31
    a158:	bmi.w	a314 <usb_isr+0x440>
		USB0_CTL = USB_CTL_USBENSOFEN;
		return;
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
    a15c:	lsls	r1, r4, #24
    a15e:	bmi.w	a3b4 <usb_isr+0x4e0>
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    a162:	lsls	r2, r4, #30
    a164:	bpl.n	a174 <usb_isr+0x2a0>
		uint8_t err = USB0_ERRSTAT;
    a166:	ldr	r2, [pc, #120]	; (a1e0 <usb_isr+0x30c>)
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    a168:	ldr	r1, [pc, #120]	; (a1e4 <usb_isr+0x310>)
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    a16a:	ldrb	r3, [r2, #0]
		USB0_ERRSTAT = err;
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    a16c:	movs	r0, #2
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
		USB0_ISTAT = USB_ISTAT_STALL;
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
		uint8_t err = USB0_ERRSTAT;
    a16e:	uxtb	r3, r3
		USB0_ERRSTAT = err;
    a170:	strb	r3, [r2, #0]
		//serial_print("err:");
		//serial_phex(err);
		//serial_print("\n");
		USB0_ISTAT = USB_ISTAT_ERROR;
    a172:	strb	r0, [r1, #0]
	}

	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
    a174:	lsls	r3, r4, #27
    a176:	bpl.n	a17e <usb_isr+0x2aa>
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
    a178:	ldr	r3, [pc, #104]	; (a1e4 <usb_isr+0x310>)
    a17a:	movs	r2, #16
    a17c:	strb	r2, [r3, #0]
	}

}
    a17e:	add	sp, #28
    a180:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_EVEN_FIRST;
    a184:	movs	r2, #4
    a186:	strb	r2, [r1, r6]
						break;
    a188:	b.n	a140 <usb_isr+0x26c>
						break;
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						tx_state[endpoint] = TX_STATE_EVEN_FREE;
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_NONE_FREE_ODD_FIRST;
    a18a:	movs	r2, #5
    a18c:	strb	r2, [r1, r6]
						break;
    a18e:	b.n	a140 <usb_isr+0x26c>
					//serial_print("tx packet\n");
					tx_first[endpoint] = packet->next;
					b->addr = packet->buf;
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
						tx_state[endpoint] = TX_STATE_ODD_FREE;
    a190:	movs	r2, #3
    a192:	strb	r2, [r1, r6]
						break;
    a194:	b.n	a140 <usb_isr+0x26c>
    a196:	nop
    a198:	.word	0x1fff0000
    a19c:	.word	0x1fff19fc
    a1a0:	.word	0x1fff19a0
    a1a4:	.word	0x1fff1d74
    a1a8:	.word	0x004000c8
    a1ac:	.word	0x00400088
    a1b0:	.word	0x1fff1a9c
    a1b4:	.word	0x1fff1a15
    a1b8:	.word	0x1fff18ec
    a1bc:	.word	0x1fff1a88
    a1c0:	.word	0x1fff199c
    a1c4:	.word	0x1fff1a14
    a1c8:	.word	0x1fff19b8
    a1cc:	.word	0x1fff1a90
    a1d0:	.word	0x40072098
    a1d4:	.word	0x40072094
    a1d8:	.word	0x1fff1a58
    a1dc:	.word	0x1fff1aa0
    a1e0:	.word	0x40072088
    a1e4:	.word	0x40072080
    a1e8:	.word	0x40072090
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    a1ec:	movw	r4, #770	; 0x302
    a1f0:	cmp	r1, r4
    a1f2:	beq.w	a678 <usb_isr+0x7a4>
    a1f6:	bhi.w	a3d4 <usb_isr+0x500>
    a1fa:	cmp	r1, #130	; 0x82
    a1fc:	beq.w	a6ce <usb_isr+0x7fa>
    a200:	cmp.w	r1, #258	; 0x102
    a204:	beq.w	a6a8 <usb_isr+0x7d4>
    a208:	cmp	r1, #128	; 0x80
    a20a:	bne.w	a3a6 <usb_isr+0x4d2>
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    a20e:	ldr	r4, [pc, #708]	; (a4d4 <usb_isr+0x600>)
		reply_buffer[1] = 0;
		datalen = 2;
    a210:	movs	r0, #2
		reply_buffer[0] = usb_configuration;
		datalen = 1;
		data = reply_buffer;
		break;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    a212:	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    a214:	strb	r2, [r4, #1]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    a216:	ldrh	r2, [r5, #6]
    a218:	cmp	r2, r0
    a21a:	bcs.w	a8e0 <usb_isr+0xa0c>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a21e:	ldr	r1, [pc, #696]	; (a4d8 <usb_isr+0x604>)
    a220:	ldrb	r5, [r1, #0]
    a222:	cmp	r2, #64	; 0x40
    a224:	mov	lr, r2
    a226:	orr.w	ip, r5, #2
    a22a:	it	cs
    a22c:	movcs.w	lr, #64	; 0x40
    a230:	add.w	r3, r4, lr
    a234:	add.w	r0, r9, ip, lsl #3
    a238:	str	r3, [sp, #4]
    a23a:	movs	r3, #1
    a23c:	str	r4, [r0, #4]
    a23e:	mov.w	r8, lr, lsl #16
    a242:	rsb	r0, lr, r2
    a246:	str	r3, [sp, #8]
    a248:	movs	r2, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a24a:	movs	r4, #200	; 0xc8
    a24c:	orr.w	r3, r8, r4
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    a250:	eor.w	r4, r5, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a254:	str.w	r3, [r9, ip, lsl #3]
	ep0_tx_data_toggle ^= 1;
    a258:	strb	r2, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    a25a:	strb	r4, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a25c:	ldr.w	ip, [pc, #648]	; a4e8 <usb_isr+0x614>
	ep0_tx_data_toggle ^= 1;
    a260:	ldr	r3, [pc, #632]	; (a4dc <usb_isr+0x608>)
	ep0_tx_bdt_bank ^= 1;
    a262:	ldr.w	r8, [pc, #628]	; a4d8 <usb_isr+0x604>
	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    a266:	cmp	r0, #0
    a268:	bne.w	a414 <usb_isr+0x540>
    a26c:	cmp.w	lr, #64	; 0x40
    a270:	bne.w	a3ac <usb_isr+0x4d8>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a274:	orr.w	ip, r4, #2
    a278:	add.w	r3, r9, ip, lsl #3
    a27c:	ldr	r4, [sp, #4]
    a27e:	ldr.w	lr, [pc, #616]	; a4e8 <usb_isr+0x614>
    a282:	str	r4, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a284:	cmp	r2, #0
    a286:	bne.w	a440 <usb_isr+0x56c>
    a28a:	lsls	r2, r0, #16
    a28c:	orr.w	r2, r2, #136	; 0x88
	ep0_tx_data_toggle ^= 1;
    a290:	ldrb.w	r3, [sp, #8]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a294:	str.w	r2, [lr, ip, lsl #3]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a298:	add	r4, r0
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    a29a:	strb	r3, [r6, #0]
	ep0_tx_bdt_bank ^= 1;
    a29c:	strb	r5, [r1, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a29e:	mov	r3, r4
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;
    a2a0:	cmp	r0, #64	; 0x40
    a2a2:	bne.w	a3ac <usb_isr+0x4d8>
    a2a6:	movs	r0, #0

	ep0_tx_ptr = data;
	ep0_tx_len = datalen;
    a2a8:	ldr	r2, [pc, #564]	; (a4e0 <usb_isr+0x60c>)
	endpoint0_transmit(data, size);
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	ep0_tx_ptr = data;
    a2aa:	str	r3, [r7, #0]
	ep0_tx_len = datalen;
    a2ac:	strh	r0, [r2, #0]
    a2ae:	b.n	a3ac <usb_isr+0x4d8>
			size = ep0_tx_len;
			if (size > EP0_SIZE) size = EP0_SIZE;
			endpoint0_transmit(data, size);
			data += size;
			ep0_tx_len -= size;
			ep0_tx_ptr = (ep0_tx_len > 0 || size == EP0_SIZE) ? data : NULL;
    a2b0:	cmp.w	lr, #64	; 0x40
    a2b4:	it	ne
    a2b6:	movne	r2, #0
    a2b8:	b.n	a0c8 <usb_isr+0x1f4>
			int i;
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for (i=0; i<7; i++) {
				//serial_phex(*buf);
				*dst++ = *buf++;
    a2ba:	ldr	r2, [pc, #552]	; (a4e4 <usb_isr+0x610>)
    a2bc:	ldrb	r5, [r1, #0]
    a2be:	ldrb	r4, [r1, #1]
    a2c0:	strb	r5, [r2, #0]
    a2c2:	strb	r4, [r2, #1]
    a2c4:	ldrb	r5, [r1, #2]
    a2c6:	ldrb	r4, [r1, #3]
    a2c8:	strb	r5, [r2, #2]
    a2ca:	strb	r4, [r2, #3]
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if (usb_cdc_line_coding[0] == 134) usb_reboot_timer = 15;
    a2cc:	ldr	r4, [r2, #0]
			int i;
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for (i=0; i<7; i++) {
				//serial_phex(*buf);
				*dst++ = *buf++;
    a2ce:	ldrb	r5, [r1, #4]
    a2d0:	strb	r5, [r2, #4]
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if (usb_cdc_line_coding[0] == 134) usb_reboot_timer = 15;
    a2d2:	cmp	r4, #134	; 0x86
			int i;
			uint8_t *dst = (uint8_t *)usb_cdc_line_coding;
			//serial_print("set line coding ");
			for (i=0; i<7; i++) {
				//serial_phex(*buf);
				*dst++ = *buf++;
    a2d4:	ldrb	r5, [r1, #5]
    a2d6:	ldrb	r1, [r1, #6]
    a2d8:	strb	r5, [r2, #5]
    a2da:	strb	r1, [r2, #6]
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if (usb_cdc_line_coding[0] == 134) usb_reboot_timer = 15;
    a2dc:	beq.w	a47e <usb_isr+0x5aa>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a2e0:	ldr	r1, [pc, #500]	; (a4d8 <usb_isr+0x604>)
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a2e2:	ldr	r6, [pc, #504]	; (a4dc <usb_isr+0x608>)
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a2e4:	ldrb	r2, [r1, #0]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a2e6:	ldrb	r4, [r6, #0]
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    a2e8:	eor.w	r5, r2, #1
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a2ec:	cmp	r4, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a2ee:	orr.w	r2, r2, #2
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    a2f2:	strb	r5, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a2f4:	ite	eq
    a2f6:	moveq	r1, #136	; 0x88
    a2f8:	movne	r1, #200	; 0xc8
    a2fa:	str.w	r1, [r9, r2, lsl #3]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a2fe:	add.w	r2, r9, r2, lsl #3
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    a302:	eor.w	r4, r4, #1
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a306:	movs	r1, #0
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
    a308:	strb	r4, [r6, #0]
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a30a:	str	r1, [r2, #4]
    a30c:	b.n	a0ee <usb_isr+0x21a>
			}
#ifdef CDC_DATA_INTERFACE
			t = usb_cdc_transmit_flush_timer;
			if (t) {
				usb_cdc_transmit_flush_timer = --t;
				if (t == 0) usb_serial_flush_callback();
    a30e:	bl	8fe4 <usb_serial_flush_callback>
    a312:	b.n	9fa8 <usb_isr+0xd4>
		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    a314:	ldr	r3, [pc, #464]	; (a4e8 <usb_isr+0x614>)

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    a316:	ldr	r0, [pc, #468]	; (a4ec <usb_isr+0x618>)
		ep0_tx_bdt_bank = 0;
    a318:	ldr	r1, [pc, #444]	; (a4d8 <usb_isr+0x604>)
		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
    a31a:	str	r2, [r3, #16]

	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
    a31c:	mov.w	lr, #2
    a320:	strb.w	lr, [r0]
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    a324:	ldr	r7, [pc, #456]	; (a4f0 <usb_isr+0x61c>)
	if (status & USB_ISTAT_USBRST /* 01 */ ) {
		//serial_print("reset\n");

		// initialize BDT toggle bits
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;
    a326:	strb	r2, [r1, #0]

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
    a328:	ldr	r1, [pc, #456]	; (a4f4 <usb_isr+0x620>)
    a32a:	str	r1, [r3, #0]
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
    a32c:	str	r1, [r3, #8]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    a32e:	ldr	r6, [pc, #456]	; (a4f8 <usb_isr+0x624>)
		USB0_ISTAT = 0xFF;
    a330:	ldr	r5, [pc, #456]	; (a4fc <usb_isr+0x628>)

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    a332:	ldr	r4, [pc, #460]	; (a500 <usb_isr+0x62c>)
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
		table[index(0, TX, EVEN)].desc = 0;
		table[index(0, TX, ODD)].desc = 0;
    a334:	str	r2, [r3, #24]

		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    a336:	movs	r1, #13
    a338:	strb	r1, [r7, #0]

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
    a33a:	movs	r1, #255	; 0xff
    a33c:	strb	r1, [r6, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    a33e:	ldr.w	lr, [pc, #492]	; a52c <usb_isr+0x658>
		// activate endpoint 0
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;

		// clear all ending interrupts
		USB0_ERRSTAT = 0xFF;
		USB0_ISTAT = 0xFF;
    a342:	strb	r1, [r5, #0]

		// set the address to zero during enumeration
		USB0_ADDR = 0;
    a344:	strb	r2, [r4, #0]
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    a346:	ldr	r5, [pc, #444]	; (a504 <usb_isr+0x630>)
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    a348:	ldr	r2, [pc, #444]	; (a508 <usb_isr+0x634>)

		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
    a34a:	strb.w	r1, [lr]
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    a34e:	movs	r7, #159	; 0x9f
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    a350:	movs	r4, #1
		// set the address to zero during enumeration
		USB0_ADDR = 0;

		// enable other interrupts
		USB0_ERREN = 0xFF;
		USB0_INTEN = USB_INTEN_TOKDNEEN |
    a352:	strb.w	r7, [r6, #-4]
		USB0_CTL = USB_CTL_ODDRST;
		ep0_tx_bdt_bank = 0;

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
    a356:	str	r5, [r3, #4]
			USB_INTEN_ERROREN |
			USB_INTEN_USBRSTEN |
			USB_INTEN_SLEEPEN;

		// is this necessary?
		USB0_CTL = USB_CTL_USBENSOFEN;
    a358:	strb	r4, [r0, #0]

		// set up buffers to receive Setup and OUT packets
		table[index(0, RX, EVEN)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, EVEN)].addr = ep0_rx0_buf;
		table[index(0, RX, ODD)].desc = BDT_DESC(EP0_SIZE, 0);
		table[index(0, RX, ODD)].addr = ep0_rx1_buf;
    a35a:	str	r2, [r3, #12]
	if ((status & USB_ISTAT_SLEEP /* 10 */ )) {
		//serial_print("sleep\n");
		USB0_ISTAT = USB_ISTAT_SLEEP;
	}

}
    a35c:	add	sp, #28
    a35e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						//serial_print("rx 1st, epidx=");
						//serial_phex(endpoint);
						//serial_print(", packet=");
						//serial_phex32((uint32_t)packet);
						//serial_print("\n");
						rx_first[endpoint] = packet;
    a362:	str.w	r0, [r3, r6, lsl #2]
    a366:	ldr	r5, [pc, #420]	; (a50c <usb_isr+0x638>)
    a368:	b.n	9f36 <usb_isr+0x62>
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
						usb_rx_memory_needed++;
    a36a:	ldr	r2, [pc, #420]	; (a510 <usb_isr+0x63c>)
						b->desc = BDT_DESC(64,
							((uint32_t)b & 8) ? DATA1 : DATA0);
					} else {
						//serial_print("starving ");
						//serial_phex(endpoint + 1);
						b->desc = 0;
    a36c:	str.w	r0, [r7, r8, lsl #3]
						usb_rx_memory_needed++;
    a370:	ldrb	r3, [r2, #0]
    a372:	adds	r3, #1
    a374:	strb	r3, [r2, #0]
    a376:	b.n	9f68 <usb_isr+0x94>
					}
					b->desc = BDT_DESC(packet->len,
						((uint32_t)b & 8) ? DATA1 : DATA0);
				} else {
					//serial_print("tx no packet\n");
					switch (tx_state[endpoint]) {
    a378:	ldrb	r3, [r1, r6]
    a37a:	cmp	r3, #3
    a37c:	bhi.n	a470 <usb_isr+0x59c>
    a37e:	add	r2, pc, #4	; (adr r2, a384 <usb_isr+0x4b0>)
    a380:	ldr.w	pc, [r2, r3, lsl #2]
    a384:	.word	0x00009f69
    a388:	.word	0x00009f69
    a38c:	.word	0x0000a3cf
    a390:	.word	0x0000a3c9
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    a394:	movw	r2, #26273	; 0x66a1
    a398:	cmp	r1, r2
    a39a:	beq.n	a3a6 <usb_isr+0x4d2>
    a39c:	movw	r2, #26529	; 0x67a1
    a3a0:	cmp	r1, r2
    a3a2:	beq.w	a69e <usb_isr+0x7ca>
volatile uint8_t usb_reboot_timer = 0;


static void endpoint0_stall(void)
{
	USB0_ENDPT0 = USB_ENDPT_EPSTALL | USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    a3a6:	ldr	r2, [pc, #328]	; (a4f0 <usb_isr+0x61c>)
    a3a8:	movs	r3, #15
    a3aa:	strb	r3, [r2, #0]
		serial_print("\n");
#endif
		// actually "do" the setup request
		usb_setup();
		// unfreeze the USB, now that we're ready
		USB0_CTL = USB_CTL_USBENSOFEN; // clear TXSUSPENDTOKENBUSY bit
    a3ac:	ldr	r2, [pc, #316]	; (a4ec <usb_isr+0x618>)
    a3ae:	movs	r3, #1
    a3b0:	strb	r3, [r2, #0]
    a3b2:	b.n	a0f4 <usb_isr+0x220>
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    a3b4:	ldr	r1, [pc, #312]	; (a4f0 <usb_isr+0x61c>)
		USB0_ISTAT = USB_ISTAT_STALL;
    a3b6:	ldr	r3, [pc, #324]	; (a4fc <usb_isr+0x628>)
    a3b8:	movs	r2, #128	; 0x80
	}


	if ((status & USB_ISTAT_STALL /* 80 */ )) {
		//serial_print("stall:\n");
		USB0_ENDPT0 = USB_ENDPT_EPRXEN | USB_ENDPT_EPTXEN | USB_ENDPT_EPHSHK;
    a3ba:	movs	r0, #13
    a3bc:	strb	r0, [r1, #0]
		USB0_ISTAT = USB_ISTAT_STALL;
    a3be:	strb	r2, [r3, #0]
	}
	if ((status & USB_ISTAT_ERROR /* 02 */ )) {
    a3c0:	lsls	r2, r4, #30
    a3c2:	bpl.w	a174 <usb_isr+0x2a0>
    a3c6:	b.n	a166 <usb_isr+0x292>
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
    a3c8:	movs	r3, #1
    a3ca:	strb	r3, [r1, r6]
						break;
    a3cc:	b.n	9f68 <usb_isr+0x94>
					switch (tx_state[endpoint]) {
					  case TX_STATE_BOTH_FREE_EVEN_FIRST:
					  case TX_STATE_BOTH_FREE_ODD_FIRST:
						break;
					  case TX_STATE_EVEN_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    a3ce:	movs	r3, #0
    a3d0:	strb	r3, [r1, r6]
						break;
    a3d2:	b.n	9f68 <usb_isr+0x94>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    a3d4:	cmp.w	r1, #1280	; 0x500
    a3d8:	beq.n	a4cc <usb_isr+0x5f8>
    a3da:	bcc.n	a3a6 <usb_isr+0x4d2>
    a3dc:	sub.w	r1, r1, #1664	; 0x680
    a3e0:	cmp	r1, #1
    a3e2:	bhi.n	a3a6 <usb_isr+0x4d2>
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
			if (list->addr == NULL) break;
    a3e4:	ldr	r2, [pc, #300]	; (a514 <usb_isr+0x640>)
    a3e6:	ldr	r4, [r2, #4]
    a3e8:	cmp	r4, #0
    a3ea:	beq.n	a3a6 <usb_isr+0x4d2>
    a3ec:	ldrh	r0, [r5, #2]
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    a3ee:	ldrh.w	lr, [r5, #4]
    a3f2:	b.n	a3fc <usb_isr+0x528>
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		//serial_print("desc:");
		//serial_phex16(setup.wValue);
		//serial_print("\n");
		for (list = usb_descriptor_list; 1; list++) {
    a3f4:	adds	r2, #12
			if (list->addr == NULL) break;
    a3f6:	ldr	r4, [r2, #4]
    a3f8:	cmp	r4, #0
    a3fa:	beq.n	a3a6 <usb_isr+0x4d2>
			//if (setup.wValue == list->wValue &&
			//(setup.wIndex == list->wIndex) || ((setup.wValue >> 8) == 3)) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    a3fc:	ldrh	r3, [r2, #0]
    a3fe:	cmp	r3, r0
    a400:	bne.n	a3f4 <usb_isr+0x520>
    a402:	ldrh	r3, [r2, #2]
    a404:	cmp	r3, lr
    a406:	bne.n	a3f4 <usb_isr+0x520>
				data = list->addr;
				if ((setup.wValue >> 8) == 3) {
    a408:	lsrs	r0, r0, #8
    a40a:	cmp	r0, #3
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured
					// length.
					datalen = *(list->addr);
    a40c:	ite	eq
    a40e:	ldrbeq	r0, [r4, #0]
				} else {
					datalen = list->length;
    a410:	ldrhne	r0, [r2, #8]
    a412:	b.n	a216 <usb_isr+0x342>
	data += size;
	datalen -= size;
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
    a414:	cmp	r0, #64	; 0x40
    a416:	bls.w	a274 <usb_isr+0x3a0>
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a41a:	orr.w	r4, r4, #2
    a41e:	add.w	r1, ip, r4, lsl #3
    a422:	ldr	r6, [sp, #4]
    a424:	str	r6, [r1, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a426:	cbz	r2, a458 <usb_isr+0x584>
	ep0_tx_data_toggle ^= 1;
    a428:	ldrb.w	r1, [sp, #8]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a42c:	ldr	r2, [pc, #232]	; (a518 <usb_isr+0x644>)
	ep0_tx_data_toggle ^= 1;
    a42e:	strb	r1, [r3, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a430:	mov	r3, r6
    a432:	subs	r0, #64	; 0x40
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    a434:	strb.w	r5, [r8]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a438:	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a43a:	str.w	r2, [ip, r4, lsl #3]
    a43e:	b.n	a2a8 <usb_isr+0x3d4>
	ep0_tx_data_toggle ^= 1;
    a440:	ldrb.w	r3, [sp, #8]
    a444:	strb	r3, [r6, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a446:	lsls	r2, r0, #16
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a448:	ldr	r3, [sp, #4]
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    a44a:	strb	r5, [r1, #0]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a44c:	orr.w	r2, r2, #200	; 0xc8
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a450:	add	r3, r0
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a452:	str.w	r2, [lr, ip, lsl #3]
    a456:	b.n	a2a0 <usb_isr+0x3cc>
	ep0_tx_data_toggle ^= 1;
    a458:	ldrb.w	r1, [sp, #8]
    a45c:	strb	r1, [r3, #0]
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a45e:	ldr	r3, [sp, #4]
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a460:	ldr	r2, [pc, #144]	; (a4f4 <usb_isr+0x620>)
	ep0_tx_data_toggle ^= 1;
	ep0_tx_bdt_bank ^= 1;
    a462:	strb.w	r5, [r8]
    a466:	subs	r0, #64	; 0x40
	if (datalen == 0 && size < EP0_SIZE) return;

	size = datalen;
	if (size > EP0_SIZE) size = EP0_SIZE;
	endpoint0_transmit(data, size);
	data += size;
    a468:	adds	r3, #64	; 0x40
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a46a:	str.w	r2, [ip, r4, lsl #3]
    a46e:	b.n	a2a8 <usb_isr+0x3d4>
						break;
					  case TX_STATE_ODD_FREE:
						tx_state[endpoint] = TX_STATE_BOTH_FREE_ODD_FIRST;
						break;
					  default:
						tx_state[endpoint] = ((uint32_t)b & 8) ?
    a470:	tst.w	r9, #8
    a474:	ite	eq
    a476:	moveq	r3, #2
    a478:	movne	r3, #3
    a47a:	strb	r3, [r1, r6]
						  TX_STATE_ODD_FREE : TX_STATE_EVEN_FREE;
						break;
    a47c:	b.n	9f68 <usb_isr+0x94>
				//serial_phex(*buf);
				*dst++ = *buf++;
			}
			//serial_phex32(usb_cdc_line_coding[0]);
			//serial_print("\n");
			if (usb_cdc_line_coding[0] == 134) usb_reboot_timer = 15;
    a47e:	ldr	r2, [pc, #156]	; (a51c <usb_isr+0x648>)
    a480:	movs	r1, #15
    a482:	strb	r1, [r2, #0]
    a484:	b.n	a2e0 <usb_isr+0x40c>
			}
#endif
		}
		break;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    a486:	ldr	r2, [pc, #152]	; (a520 <usb_isr+0x64c>)
    a488:	ldr	r4, [pc, #72]	; (a4d4 <usb_isr+0x600>)
    a48a:	ldrb	r2, [r2, #0]
    a48c:	strb	r2, [r4, #0]
    a48e:	b.n	a216 <usb_isr+0x342>
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    a490:	ldr.w	ip, [pc, #156]	; a530 <usb_isr+0x65c>
    a494:	ldr	r3, [pc, #140]	; (a524 <usb_isr+0x650>)
		usb_cdc_line_rtsdtr = setup.wValue;
    a496:	ldr	r1, [pc, #144]	; (a528 <usb_isr+0x654>)
    a498:	ldrb	r4, [r5, #2]
		//serial_print("desc: not found\n");
		endpoint0_stall();
		return;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		usb_cdc_line_rtsdtr_millis = systick_millis_count;
    a49a:	ldr.w	r5, [ip]
    a49e:	str	r5, [r3, #0]
		usb_cdc_line_rtsdtr = setup.wValue;
    a4a0:	str	r0, [sp, #8]
    a4a2:	strb	r4, [r1, #0]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    a4a4:	movs	r0, #0
    a4a6:	str	r0, [sp, #4]
    a4a8:	mov	r8, r0
    a4aa:	mov	lr, r0
    a4ac:	mov	r4, r0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a4ae:	ldr	r1, [pc, #40]	; (a4d8 <usb_isr+0x604>)
    a4b0:	ldrb	r5, [r1, #0]
    a4b2:	orr.w	ip, r5, #2
    a4b6:	add.w	r3, r9, ip, lsl #3
    a4ba:	str	r3, [sp, #12]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a4bc:	ldr	r3, [sp, #8]
    a4be:	cmp	r3, #0
	serial_print(",");
	serial_phex16(len);
	serial_print(ep0_tx_bdt_bank ? ", odd" : ", even");
	serial_print(ep0_tx_data_toggle ? ", d1\n" : ", d0\n");
#endif
	table[index(0, TX, ep0_tx_bdt_bank)].addr = (void *)data;
    a4c0:	ldr	r3, [sp, #12]
    a4c2:	str	r4, [r3, #4]
	table[index(0, TX, ep0_tx_bdt_bank)].desc = BDT_DESC(len, ep0_tx_data_toggle);
    a4c4:	ite	eq
    a4c6:	moveq	r4, #136	; 0x88
    a4c8:	movne	r4, #200	; 0xc8
    a4ca:	b.n	a24c <usb_isr+0x378>
	volatile uint8_t *reg;
	uint8_t epconf;
	const uint8_t *cfg;
	int i;

	switch (setup.wRequestAndType) {
    a4cc:	movs	r3, #1
    a4ce:	movs	r2, #0
    a4d0:	str	r3, [sp, #8]
    a4d2:	b.n	a4a4 <usb_isr+0x5d0>
    a4d4:	.word	0x1fff1a94
    a4d8:	.word	0x1fff1a90
    a4dc:	.word	0x1fff1a14
    a4e0:	.word	0x1fff19b8
    a4e4:	.word	0x1fff1d68
    a4e8:	.word	0x1fff0000
    a4ec:	.word	0x40072094
    a4f0:	.word	0x400720c0
    a4f4:	.word	0x00400088
    a4f8:	.word	0x40072088
    a4fc:	.word	0x40072080
    a500:	.word	0x40072098
    a504:	.word	0x1fff19bc
    a508:	.word	0x1fff1a18
    a50c:	.word	0x1fff19a0
    a510:	.word	0x1fff1a91
    a514:	.word	0x0000c7e4
    a518:	.word	0x004000c8
    a51c:	.word	0x1fff1a15
    a520:	.word	0x1fff1a9c
    a524:	.word	0x1fff1d70
    a528:	.word	0x1fff18fc
    a52c:	.word	0x4007208c
    a530:	.word	0x1fff1998
    a534:	ldr	r4, [pc, #724]	; (a80c <usb_isr+0x938>)
    a536:	ldr	r2, [pc, #728]	; (a810 <usb_isr+0x93c>)
    a538:	ldr	r1, [pc, #728]	; (a814 <usb_isr+0x940>)
    a53a:	ldr	r0, [pc, #732]	; (a818 <usb_isr+0x944>)
    a53c:	ldr	r5, [pc, #732]	; (a81c <usb_isr+0x948>)
    a53e:	str	r4, [sp, #4]
		//serial_print("configure\n");
		usb_configuration = setup.wValue;
		reg = &USB0_ENDPT1;
		cfg = usb_endpoint_config_table;
		// clear all BDT entries, free any allocated memory...
		for (i=4; i < (NUM_ENDPOINTS+1)*4; i++) {
    a540:	movs	r3, #0
    a542:	ldr	r4, [pc, #732]	; (a820 <usb_isr+0x94c>)
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    a544:	str	r4, [sp, #8]
    a546:	str	r6, [sp, #20]
    a548:	str	r5, [sp, #12]
    a54a:	mov	r8, r0
    a54c:	mov	r4, r3
    a54e:	str	r7, [sp, #16]
    a550:	mov	r6, r2
    a552:	mov	r5, r1
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
    a554:	ldr	r0, [r6, #0]
			while (p) {
    a556:	cbz	r0, a564 <usb_isr+0x690>
				n = p->next;
    a558:	ldr	r7, [r0, #4]
				usb_free(p);
    a55a:	bl	9c94 <usb_free>
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
			usb_packet_t *p, *n;
			p = rx_first[i];
			while (p) {
    a55e:	mov	r0, r7
    a560:	cmp	r7, #0
    a562:	bne.n	a558 <usb_isr+0x684>
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
    a564:	movs	r3, #0
    a566:	str	r3, [r6, #0]
			rx_last[i] = NULL;
    a568:	ldr	r3, [sp, #12]
			p = tx_first[i];
    a56a:	ldr	r0, [r5, #0]
				n = p->next;
				usb_free(p);
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
    a56c:	mov	r2, r3
    a56e:	movs	r3, #0
    a570:	str.w	r3, [r2, r4, lsl #2]
			p = tx_first[i];
			while (p) {
    a574:	cbz	r0, a582 <usb_isr+0x6ae>
				n = p->next;
    a576:	ldr	r7, [r0, #4]
				usb_free(p);
    a578:	bl	9c94 <usb_free>
				p = n;
			}
			rx_first[i] = NULL;
			rx_last[i] = NULL;
			p = tx_first[i];
			while (p) {
    a57c:	mov	r0, r7
    a57e:	cmp	r7, #0
    a580:	bne.n	a576 <usb_isr+0x6a2>
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    a582:	ldr	r3, [sp, #4]
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    a584:	movs	r2, #0
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
    a586:	ldrb	r3, [r3, #0]
			while (p) {
				n = p->next;
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
    a588:	str	r2, [r5, #0]
			tx_last[i] = NULL;
    a58a:	str.w	r2, [r8], #4
			usb_rx_byte_count_data[i] = 0;
    a58e:	ldr	r2, [sp, #8]
    a590:	mov.w	r1, #0
			switch (tx_state[i]) {
    a594:	subs	r3, #2
				usb_free(p);
				p = n;
			}
			tx_first[i] = NULL;
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
    a596:	strh.w	r1, [r2, r4, lsl #1]
			switch (tx_state[i]) {
    a59a:	cmp	r3, #3
    a59c:	bhi.n	a5ae <usb_isr+0x6da>
    a59e:	tbb	[pc, r3]
    a5a2:	.short	0x0266
    a5a4:	.short	0x0266
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
				break;
			  case TX_STATE_ODD_FREE:
			  case TX_STATE_NONE_FREE_ODD_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_ODD_FIRST;
    a5a6:	ldr	r3, [sp, #4]
    a5a8:	mov.w	r2, #1
    a5ac:	strb	r2, [r3, #0]
    a5ae:	ldr	r3, [sp, #4]
			if (table[i].desc & BDT_OWN) {
				usb_free((usb_packet_t *)((uint8_t *)(table[i].addr) - 8));
			}
		}
		// free all queued packets
		for (i=0; i < NUM_ENDPOINTS; i++) {
    a5b0:	adds	r4, #1
    a5b2:	adds	r3, #1
    a5b4:	cmp	r4, #6
    a5b6:	add.w	r6, r6, #4
    a5ba:	add.w	r5, r5, #4
    a5be:	str	r3, [sp, #4]
    a5c0:	bne.n	a554 <usb_isr+0x680>
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    a5c2:	ldr	r5, [pc, #608]	; (a824 <usb_isr+0x950>)
			*reg = epconf;
    a5c4:	ldr	r1, [pc, #608]	; (a828 <usb_isr+0x954>)
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    a5c6:	ldrb	r2, [r5, #0]
				break;
			  default:
				break;
			}
		}
		usb_rx_memory_needed = 0;
    a5c8:	ldr	r4, [pc, #608]	; (a82c <usb_isr+0x958>)
    a5ca:	ldr	r7, [sp, #16]
    a5cc:	ldr	r6, [sp, #20]
    a5ce:	movs	r0, #0
    a5d0:	strb	r0, [r4, #0]
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    a5d2:	strb	r2, [r1, #0]
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    a5d4:	lsls	r1, r2, #28
    a5d6:	bmi.w	a77c <usb_isr+0x8a8>
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    a5da:	ldrb	r2, [r5, #1]
			*reg = epconf;
    a5dc:	ldr	r1, [pc, #592]	; (a830 <usb_isr+0x95c>)
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a5de:	ldr.w	r8, [pc, #612]	; a844 <usb_isr+0x970>
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    a5e2:	strb	r2, [r1, #0]
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a5e4:	movs	r1, #0
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    a5e6:	lsls	r2, r2, #28
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a5e8:	str.w	r1, [r9, #48]	; 0x30
			table[index(i, TX, ODD)].desc = 0;
    a5ec:	str.w	r1, [r9, #56]	; 0x38
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    a5f0:	bmi.w	a750 <usb_isr+0x87c>
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    a5f4:	ldrb	r2, [r5, #2]
			*reg = epconf;
    a5f6:	ldr	r1, [pc, #572]	; (a834 <usb_isr+0x960>)
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a5f8:	ldr.w	r8, [pc, #584]	; a844 <usb_isr+0x970>
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    a5fc:	strb	r2, [r1, #0]
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    a5fe:	lsls	r3, r2, #28
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a600:	mov.w	r1, #0
    a604:	str.w	r1, [r9, #80]	; 0x50
			table[index(i, TX, ODD)].desc = 0;
    a608:	str.w	r1, [r9, #88]	; 0x58
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    a60c:	bmi.w	a7d2 <usb_isr+0x8fe>
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    a610:	ldrb	r2, [r5, #3]
			*reg = epconf;
    a612:	ldr	r1, [pc, #548]	; (a838 <usb_isr+0x964>)
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a614:	ldr.w	r8, [pc, #556]	; a844 <usb_isr+0x970>
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    a618:	strb	r2, [r1, #0]
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    a61a:	lsls	r0, r2, #28
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a61c:	mov.w	r1, #0
    a620:	str.w	r1, [r9, #112]	; 0x70
			table[index(i, TX, ODD)].desc = 0;
    a624:	str.w	r1, [r9, #120]	; 0x78
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    a628:	bmi.w	a7a8 <usb_isr+0x8d4>
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    a62c:	ldr	r1, [pc, #524]	; (a83c <usb_isr+0x968>)
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    a62e:	ldrb	r2, [r5, #4]
			*reg = epconf;
    a630:	strb	r2, [r1, #0]
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a632:	movs	r1, #0
    a634:	str.w	r1, [r9, #144]	; 0x90
			table[index(i, TX, ODD)].desc = 0;
    a638:	str.w	r1, [r9, #152]	; 0x98
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    a63c:	lsls	r1, r2, #28
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a63e:	ldr.w	r8, [pc, #516]	; a844 <usb_isr+0x970>
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    a642:	bmi.n	a722 <usb_isr+0x84e>
				break;
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
    a644:	ldrb	r2, [r5, #5]
			*reg = epconf;
    a646:	ldr	r1, [pc, #504]	; (a840 <usb_isr+0x96c>)
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a648:	ldr	r5, [pc, #504]	; (a844 <usb_isr+0x970>)
			}
		}
		usb_rx_memory_needed = 0;
		for (i=1; i <= NUM_ENDPOINTS; i++) {
			epconf = *cfg++;
			*reg = epconf;
    a64a:	strb	r2, [r1, #0]
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a64c:	movs	r1, #0
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    a64e:	lsls	r2, r2, #28
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a650:	str.w	r1, [r9, #176]	; 0xb0
			table[index(i, TX, ODD)].desc = 0;
    a654:	str.w	r1, [r9, #184]	; 0xb8
				table[index(i, RX, EVEN)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
				table[index(i, RX, ODD)].addr = usb_audio_receive_buffer;
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
    a658:	bmi.n	a6f4 <usb_isr+0x820>
    a65a:	ldrb	r3, [r6, #0]
    a65c:	str	r3, [sp, #8]
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
				}
			}
			table[index(i, TX, EVEN)].desc = 0;
    a65e:	movs	r1, #0
    a660:	eor.w	r2, r3, #1
    a664:	str.w	r1, [r9, #208]	; 0xd0
			table[index(i, TX, ODD)].desc = 0;
    a668:	str.w	r1, [r9, #216]	; 0xd8
    a66c:	b.n	a4a4 <usb_isr+0x5d0>
			tx_last[i] = NULL;
			usb_rx_byte_count_data[i] = 0;
			switch (tx_state[i]) {
			  case TX_STATE_EVEN_FREE:
			  case TX_STATE_NONE_FREE_EVEN_FIRST:
				tx_state[i] = TX_STATE_BOTH_FREE_EVEN_FIRST;
    a66e:	ldr	r3, [sp, #4]
    a670:	mov.w	r2, #0
    a674:	strb	r2, [r3, #0]
    a676:	b.n	a5ae <usb_isr+0x6da>
    a678:	ldrh	r1, [r5, #4]
    a67a:	and.w	r1, r1, #127	; 0x7f
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
		// TODO: do we need to clear the data toggle here?
		break;
	  case 0x0302: // SET_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    a67e:	cmp	r1, #6
    a680:	bhi.w	a3a6 <usb_isr+0x4d2>
    a684:	ldrh	r2, [r5, #2]
    a686:	cmp	r2, #0
    a688:	bne.w	a3a6 <usb_isr+0x4d2>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) |= 0x02;
    a68c:	ldr	r4, [pc, #440]	; (a848 <usb_isr+0x974>)
    a68e:	str	r0, [sp, #8]
    a690:	lsls	r1, r1, #2
    a692:	add	r4, r1
    a694:	ldrb	r1, [r4, #0]
    a696:	orr.w	r1, r1, #2
    a69a:	strb	r1, [r4, #0]
    a69c:	b.n	a4a4 <usb_isr+0x5d0>
		// TODO: required by PTP spec
		endpoint0_stall();
		return;
	case 0x67A1: // Get Device Statis (PTP spec, 5.2.4, page 10)
		// For now, always respond with status ok.
		reply_buffer[0] = 0x4;
    a69e:	ldr	r4, [pc, #428]	; (a84c <usb_isr+0x978>)
    a6a0:	ldr	r3, [pc, #428]	; (a850 <usb_isr+0x97c>)
    a6a2:	str	r3, [r4, #0]
		reply_buffer[1] = 0;
		reply_buffer[2] = 0x01;
		reply_buffer[3] = 0x20;
		data = reply_buffer;
		datalen = 4;
    a6a4:	movs	r0, #4
    a6a6:	b.n	a216 <usb_isr+0x342>
    a6a8:	ldrh	r1, [r5, #4]
    a6aa:	and.w	r1, r1, #127	; 0x7f
		data = reply_buffer;
		datalen = 2;
		break;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS || setup.wValue != 0) {
    a6ae:	cmp	r1, #6
    a6b0:	bhi.w	a3a6 <usb_isr+0x4d2>
    a6b4:	ldrh	r2, [r5, #2]
    a6b6:	cmp	r2, #0
    a6b8:	bne.w	a3a6 <usb_isr+0x4d2>
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		(*(uint8_t *)(&USB0_ENDPT0 + i * 4)) &= ~0x02;
    a6bc:	ldr	r4, [pc, #392]	; (a848 <usb_isr+0x974>)
    a6be:	str	r0, [sp, #8]
    a6c0:	lsls	r1, r1, #2
    a6c2:	add	r4, r1
    a6c4:	ldrb	r1, [r4, #0]
    a6c6:	bic.w	r1, r1, #2
    a6ca:	strb	r1, [r4, #0]
    a6cc:	b.n	a4a4 <usb_isr+0x5d0>
    a6ce:	ldrh	r1, [r5, #4]
    a6d0:	and.w	r1, r1, #127	; 0x7f
		datalen = 2;
		data = reply_buffer;
		break;
	  case 0x0082: // GET_STATUS (endpoint)
		i = setup.wIndex & 0x7F;
		if (i > NUM_ENDPOINTS) {
    a6d4:	cmp	r1, #6
    a6d6:	bhi.w	a3a6 <usb_isr+0x4d2>
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    a6da:	ldr	r3, [pc, #364]	; (a848 <usb_isr+0x974>)
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    a6dc:	ldr	r4, [pc, #364]	; (a84c <usb_isr+0x978>)
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    a6de:	lsls	r1, r1, #2
    a6e0:	add	r3, r1
		if (i > NUM_ENDPOINTS) {
			// TODO: do we need to handle IN vs OUT here?
			endpoint0_stall();
			return;
		}
		reply_buffer[0] = 0;
    a6e2:	strb	r2, [r4, #0]
		reply_buffer[1] = 0;
    a6e4:	strb	r2, [r4, #1]
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
    a6e6:	ldrb	r2, [r3, #0]
    a6e8:	lsls	r3, r2, #30
    a6ea:	bpl.w	a7fc <usb_isr+0x928>
    a6ee:	strb	r0, [r4, #0]
		data = reply_buffer;
		datalen = 2;
    a6f0:	movs	r0, #2
    a6f2:	b.n	a216 <usb_isr+0x342>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    a6f4:	bl	9c54 <usb_malloc>
				if (p) {
    a6f8:	cmp	r0, #0
    a6fa:	beq.w	a88c <usb_isr+0x9b8>
					table[index(i, RX, EVEN)].addr = p->buf;
    a6fe:	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a700:	ldr	r2, [pc, #336]	; (a854 <usb_isr+0x980>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    a702:	str.w	r0, [r5, #196]	; 0xc4
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a706:	str.w	r2, [r5, #192]	; 0xc0
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    a70a:	bl	9c54 <usb_malloc>
				if (p) {
    a70e:	cmp	r0, #0
    a710:	beq.w	a880 <usb_isr+0x9ac>
					table[index(i, RX, ODD)].addr = p->buf;
    a714:	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    a716:	ldr	r2, [pc, #320]	; (a858 <usb_isr+0x984>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    a718:	str.w	r0, [r9, #204]	; 0xcc
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    a71c:	str.w	r2, [r9, #200]	; 0xc8
    a720:	b.n	a65a <usb_isr+0x786>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    a722:	bl	9c54 <usb_malloc>
				if (p) {
    a726:	cmp	r0, #0
    a728:	beq.w	a8bc <usb_isr+0x9e8>
					table[index(i, RX, EVEN)].addr = p->buf;
    a72c:	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a72e:	ldr	r2, [pc, #292]	; (a854 <usb_isr+0x980>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    a730:	str.w	r0, [r8, #164]	; 0xa4
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a734:	str.w	r2, [r8, #160]	; 0xa0
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    a738:	bl	9c54 <usb_malloc>
				if (p) {
    a73c:	cmp	r0, #0
    a73e:	beq.w	a8b0 <usb_isr+0x9dc>
					table[index(i, RX, ODD)].addr = p->buf;
    a742:	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    a744:	ldr	r2, [pc, #272]	; (a858 <usb_isr+0x984>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    a746:	str.w	r0, [r9, #172]	; 0xac
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    a74a:	str.w	r2, [r9, #168]	; 0xa8
    a74e:	b.n	a644 <usb_isr+0x770>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    a750:	bl	9c54 <usb_malloc>
				if (p) {
    a754:	cmp	r0, #0
    a756:	beq.w	a85c <usb_isr+0x988>
					table[index(i, RX, EVEN)].addr = p->buf;
    a75a:	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a75c:	ldr	r2, [pc, #244]	; (a854 <usb_isr+0x980>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    a75e:	str.w	r0, [r8, #68]	; 0x44
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a762:	str.w	r2, [r8, #64]	; 0x40
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    a766:	bl	9c54 <usb_malloc>
				if (p) {
    a76a:	cmp	r0, #0
    a76c:	beq.n	a800 <usb_isr+0x92c>
					table[index(i, RX, ODD)].addr = p->buf;
    a76e:	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    a770:	ldr	r2, [pc, #228]	; (a858 <usb_isr+0x984>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    a772:	str.w	r0, [r9, #76]	; 0x4c
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    a776:	str.w	r2, [r9, #72]	; 0x48
    a77a:	b.n	a5f4 <usb_isr+0x720>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    a77c:	bl	9c54 <usb_malloc>
				if (p) {
    a780:	cmp	r0, #0
    a782:	beq.w	a8a4 <usb_isr+0x9d0>
					table[index(i, RX, EVEN)].addr = p->buf;
    a786:	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a788:	ldr	r2, [pc, #200]	; (a854 <usb_isr+0x980>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    a78a:	str.w	r0, [r9, #36]	; 0x24
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a78e:	str.w	r2, [r9, #32]
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    a792:	bl	9c54 <usb_malloc>
				if (p) {
    a796:	cmp	r0, #0
    a798:	beq.n	a898 <usb_isr+0x9c4>
					table[index(i, RX, ODD)].addr = p->buf;
    a79a:	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    a79c:	ldr	r2, [pc, #184]	; (a858 <usb_isr+0x984>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    a79e:	str.w	r0, [r9, #44]	; 0x2c
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    a7a2:	str.w	r2, [r9, #40]	; 0x28
    a7a6:	b.n	a5da <usb_isr+0x706>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    a7a8:	bl	9c54 <usb_malloc>
				if (p) {
    a7ac:	cmp	r0, #0
    a7ae:	beq.n	a874 <usb_isr+0x9a0>
					table[index(i, RX, EVEN)].addr = p->buf;
    a7b0:	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a7b2:	ldr	r2, [pc, #160]	; (a854 <usb_isr+0x980>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    a7b4:	str.w	r0, [r8, #132]	; 0x84
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a7b8:	str.w	r2, [r8, #128]	; 0x80
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    a7bc:	bl	9c54 <usb_malloc>
				if (p) {
    a7c0:	cmp	r0, #0
    a7c2:	beq.n	a868 <usb_isr+0x994>
					table[index(i, RX, ODD)].addr = p->buf;
    a7c4:	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    a7c6:	ldr	r2, [pc, #144]	; (a858 <usb_isr+0x984>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    a7c8:	str.w	r0, [r9, #140]	; 0x8c
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    a7cc:	str.w	r2, [r9, #136]	; 0x88
    a7d0:	b.n	a62c <usb_isr+0x758>
				table[index(i, RX, ODD)].desc = (AUDIO_RX_SIZE<<16) | BDT_OWN;
			} else
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
    a7d2:	bl	9c54 <usb_malloc>
				if (p) {
    a7d6:	cmp	r0, #0
    a7d8:	beq.n	a8d4 <usb_isr+0xa00>
					table[index(i, RX, EVEN)].addr = p->buf;
    a7da:	adds	r0, #8
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a7dc:	ldr	r2, [pc, #116]	; (a854 <usb_isr+0x980>)
#endif
			if (epconf & USB_ENDPT_EPRXEN) {
				usb_packet_t *p;
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
    a7de:	str.w	r0, [r8, #100]	; 0x64
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
    a7e2:	str.w	r2, [r8, #96]	; 0x60
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
    a7e6:	bl	9c54 <usb_malloc>
				if (p) {
    a7ea:	cmp	r0, #0
    a7ec:	beq.n	a8c8 <usb_isr+0x9f4>
					table[index(i, RX, ODD)].addr = p->buf;
    a7ee:	adds	r0, #8
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    a7f0:	ldr	r2, [pc, #100]	; (a858 <usb_isr+0x984>)
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
				}
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
    a7f2:	str.w	r0, [r9, #108]	; 0x6c
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
    a7f6:	str.w	r2, [r9, #104]	; 0x68
    a7fa:	b.n	a610 <usb_isr+0x73c>
		}
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if (*(uint8_t *)(&USB0_ENDPT0 + i * 4) & 0x02) reply_buffer[0] = 1;
		data = reply_buffer;
		datalen = 2;
    a7fc:	movs	r0, #2
    a7fe:	b.n	a216 <usb_isr+0x342>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    a800:	ldrb	r2, [r4, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    a802:	str.w	r0, [r9, #72]	; 0x48
					usb_rx_memory_needed++;
    a806:	adds	r2, #1
    a808:	strb	r2, [r4, #0]
    a80a:	b.n	a5f4 <usb_isr+0x720>
    a80c:	.word	0x1fff1aa0
    a810:	.word	0x1fff19fc
    a814:	.word	0x1fff1a58
    a818:	.word	0x1fff1a70
    a81c:	.word	0x1fff19a0
    a820:	.word	0x1fff1d74
    a824:	.word	0x0000c7dc
    a828:	.word	0x400720c4
    a82c:	.word	0x1fff1a91
    a830:	.word	0x400720c8
    a834:	.word	0x400720cc
    a838:	.word	0x400720d0
    a83c:	.word	0x400720d4
    a840:	.word	0x400720d8
    a844:	.word	0x1fff0000
    a848:	.word	0x400720c0
    a84c:	.word	0x1fff1a94
    a850:	.word	0x20010004
    a854:	.word	0x00400088
    a858:	.word	0x004000c8
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    a85c:	ldrb	r2, [r4, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    a85e:	str.w	r0, [r8, #64]	; 0x40
					usb_rx_memory_needed++;
    a862:	adds	r2, #1
    a864:	strb	r2, [r4, #0]
    a866:	b.n	a766 <usb_isr+0x892>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    a868:	ldrb	r2, [r4, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    a86a:	str.w	r0, [r9, #136]	; 0x88
					usb_rx_memory_needed++;
    a86e:	adds	r2, #1
    a870:	strb	r2, [r4, #0]
    a872:	b.n	a62c <usb_isr+0x758>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    a874:	ldrb	r2, [r4, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    a876:	str.w	r0, [r8, #128]	; 0x80
					usb_rx_memory_needed++;
    a87a:	adds	r2, #1
    a87c:	strb	r2, [r4, #0]
    a87e:	b.n	a7bc <usb_isr+0x8e8>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    a880:	ldrb	r2, [r4, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    a882:	str.w	r0, [r9, #200]	; 0xc8
					usb_rx_memory_needed++;
    a886:	adds	r2, #1
    a888:	strb	r2, [r4, #0]
    a88a:	b.n	a65a <usb_isr+0x786>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    a88c:	ldrb	r2, [r4, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    a88e:	str.w	r0, [r5, #192]	; 0xc0
					usb_rx_memory_needed++;
    a892:	adds	r2, #1
    a894:	strb	r2, [r4, #0]
    a896:	b.n	a70a <usb_isr+0x836>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    a898:	ldrb	r2, [r4, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    a89a:	str.w	r0, [r9, #40]	; 0x28
					usb_rx_memory_needed++;
    a89e:	adds	r2, #1
    a8a0:	strb	r2, [r4, #0]
    a8a2:	b.n	a5da <usb_isr+0x706>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    a8a4:	ldrb	r2, [r4, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    a8a6:	str.w	r0, [r9, #32]
					usb_rx_memory_needed++;
    a8aa:	adds	r2, #1
    a8ac:	strb	r2, [r4, #0]
    a8ae:	b.n	a792 <usb_isr+0x8be>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    a8b0:	ldrb	r2, [r4, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    a8b2:	str.w	r0, [r9, #168]	; 0xa8
					usb_rx_memory_needed++;
    a8b6:	adds	r2, #1
    a8b8:	strb	r2, [r4, #0]
    a8ba:	b.n	a644 <usb_isr+0x770>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    a8bc:	ldrb	r2, [r4, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    a8be:	str.w	r0, [r8, #160]	; 0xa0
					usb_rx_memory_needed++;
    a8c2:	adds	r2, #1
    a8c4:	strb	r2, [r4, #0]
    a8c6:	b.n	a738 <usb_isr+0x864>
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
					usb_rx_memory_needed++;
    a8c8:	ldrb	r2, [r4, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, ODD)].addr = p->buf;
					table[index(i, RX, ODD)].desc = BDT_DESC(64, 1);
				} else {
					table[index(i, RX, ODD)].desc = 0;
    a8ca:	str.w	r0, [r9, #104]	; 0x68
					usb_rx_memory_needed++;
    a8ce:	adds	r2, #1
    a8d0:	strb	r2, [r4, #0]
    a8d2:	b.n	a610 <usb_isr+0x73c>
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
					usb_rx_memory_needed++;
    a8d4:	ldrb	r2, [r4, #0]
				p = usb_malloc();
				if (p) {
					table[index(i, RX, EVEN)].addr = p->buf;
					table[index(i, RX, EVEN)].desc = BDT_DESC(64, 0);
				} else {
					table[index(i, RX, EVEN)].desc = 0;
    a8d6:	str.w	r0, [r8, #96]	; 0x60
					usb_rx_memory_needed++;
    a8da:	adds	r2, #1
    a8dc:	strb	r2, [r4, #0]
    a8de:	b.n	a7e6 <usb_isr+0x912>
    a8e0:	cmp	r0, #64	; 0x40
    a8e2:	mov	lr, r0
    a8e4:	it	cs
    a8e6:	movcs.w	lr, #64	; 0x40
    a8ea:	add.w	r3, r4, lr
    a8ee:	str	r3, [sp, #4]
	//serial_phex32(data);
	//serial_print(",");
	//serial_phex16(datalen);
	//serial_print("\n");

	if (datalen > setup.wLength) datalen = setup.wLength;
    a8f0:	movs	r3, #1
    a8f2:	rsb	r0, lr, r0
    a8f6:	mov.w	r8, lr, lsl #16
    a8fa:	movs	r2, #0
    a8fc:	str	r3, [sp, #8]
    a8fe:	b.n	a4ae <usb_isr+0x5da>

0000a900 <usb_init>:
}



void usb_init(void)
{
    a900:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    a904:	ldr	r4, [pc, #144]	; (a998 <usb_init+0x98>)
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    a906:	bl	b350 <usb_init_serialnumber>

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    a90a:	movs	r2, #0
    a90c:	add.w	r0, r4, #200	; 0xc8
	int i;

	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();
    a910:	mov	r3, r4

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
		table[i].desc = 0;
    a912:	str	r2, [r3, #0]
		table[i].addr = 0;
    a914:	str	r2, [r3, #4]
    a916:	adds	r3, #8
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
    a918:	cmp	r3, r0
		table[i].desc = 0;
    a91a:	mov.w	r1, #0
	//serial_begin(BAUD2DIV(115200));
	//serial_print("usb_init\n");

	usb_init_serialnumber();

	for (i=0; i <= NUM_ENDPOINTS*4; i++) {
    a91e:	bne.n	a912 <usb_init+0x12>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    a920:	ldr	r0, [pc, #120]	; (a99c <usb_init+0x9c>)
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    a922:	ldr	r2, [pc, #124]	; (a9a0 <usb_init+0xa0>)
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    a924:	ldr	r3, [r0, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    a926:	ldr.w	lr, [pc, #144]	; a9b8 <usb_init+0xb8>
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    a92a:	ldr	r7, [pc, #120]	; (a9a4 <usb_init+0xa4>)
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    a92c:	ldr	r5, [pc, #120]	; (a9a8 <usb_init+0xa8>)

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
	USB0_OTGISTAT = 0xFF;
    a92e:	ldr	r6, [pc, #124]	; (a9ac <usb_init+0xac>)
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    a930:	ldr.w	r8, [pc, #136]	; a9bc <usb_init+0xbc>
	USB0_ERRSTAT = 0xFF;
    a934:	ldr.w	ip, [pc, #136]	; a9c0 <usb_init+0xc0>
	USB0_OTGISTAT = 0xFF;

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    a938:	ldr.w	r9, [pc, #136]	; a9c4 <usb_init+0xc4>
	// this basically follows the flowchart in the Kinetis
	// Quick Reference User Guide, Rev. 1, 03/2012, page 141

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
    a93c:	orr.w	r3, r3, #262144	; 0x40000
    a940:	str	r3, [r0, #0]
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    a942:	ldr	r3, [r2, #0]
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    a944:	ldr	r0, [pc, #104]	; (a9b0 <usb_init+0xb0>)

	// assume 48 MHz clock already running
	// SIM - enable clock
	SIM_SCGC4 |= SIM_SCGC4_USBOTG;
#ifdef HAS_KINETIS_MPU
	MPU_RGDAAC0 |= 0x03000000;
    a946:	orr.w	r3, r3, #50331648	; 0x3000000
    a94a:	str	r3, [r2, #0]
	// reset USB module
	//USB0_USBTRC0 = USB_USBTRC_USBRESET;
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
    a94c:	ubfx	r3, r4, #8, #8
    a950:	strb.w	r3, [lr]
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
    a954:	ubfx	r3, r4, #16, #8
    a958:	strb	r3, [r7, #0]
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    a95a:	lsrs	r4, r4, #24

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    a95c:	movs	r3, #255	; 0xff
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    a95e:	add.w	r2, r2, #411648	; 0x64800
	//while ((USB0_USBTRC0 & USB_USBTRC_USBRESET) != 0) ; // wait for reset to end

	// set desc table base addr
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;
    a962:	strb	r4, [r5, #0]
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    a964:	add.w	r2, r2, #264	; 0x108
	USB0_BDTPAGE1 = ((uint32_t)table) >> 8;
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
    a968:	strb.w	r3, [r8]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    a96c:	ldr	r5, [pc, #68]	; (a9b4 <usb_init+0xb4>)
	USB0_BDTPAGE2 = ((uint32_t)table) >> 16;
	USB0_BDTPAGE3 = ((uint32_t)table) >> 24;

	// clear all ISR flags
	USB0_ISTAT = 0xFF;
	USB0_ERRSTAT = 0xFF;
    a96e:	strb.w	r3, [ip]
	USB0_OTGISTAT = 0xFF;
    a972:	strb	r3, [r6, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
    a974:	movs	r3, #1
    a976:	strb.w	r3, [r9]

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    a97a:	movs	r6, #112	; 0x70

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    a97c:	strb.w	r1, [lr, #100]	; 0x64
	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    a980:	mov.w	r4, #2097152	; 0x200000

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    a984:	movs	r1, #16
	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;

	// enable reset interrupt
	USB0_INTEN = USB_INTEN_USBRSTEN;
    a986:	strb.w	r3, [r7, #-44]

	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
    a98a:	strb	r6, [r5, #0]
	NVIC_ENABLE_IRQ(IRQ_USBOTG);
    a98c:	str	r4, [r0, #0]

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    a98e:	strb	r1, [r2, #0]

	//USB0_USBTRC0 |= 0x40; // undocumented bit

	// enable USB
	USB0_CTL = USB_CTL_USBENSOFEN;
	USB0_USBCTRL = 0;
    a990:	add.w	lr, lr, #100	; 0x64
	// enable interrupt in NVIC...
	NVIC_SET_PRIORITY(IRQ_USBOTG, 112);
	NVIC_ENABLE_IRQ(IRQ_USBOTG);

	// enable d+ pullup
	USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG;
    a994:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    a998:	.word	0x1fff0000
    a99c:	.word	0x40048034
    a9a0:	.word	0x4000d800
    a9a4:	.word	0x400720b0
    a9a8:	.word	0x400720b4
    a9ac:	.word	0x40072010
    a9b0:	.word	0xe000e104
    a9b4:	.word	0xe000e435
    a9b8:	.word	0x4007209c
    a9bc:	.word	0x40072080
    a9c0:	.word	0x40072088
    a9c4:	.word	0x40072094

0000a9c8 <HardwareSerial::write(unsigned long)>:
	virtual void flush(void)        { serial_flush(); }
	virtual void clear(void)	{ serial_clear(); }
	virtual int availableForWrite(void) { return serial_write_buffer_free(); }
	using Print::write;
	virtual size_t write(uint8_t c) { serial_putchar(c); return 1; }
	virtual size_t write(unsigned long n)   { return write((uint8_t)n); }
    a9c8:	ldr	r3, [r0, #0]
    a9ca:	uxtb	r1, r1
    a9cc:	ldr	r3, [r3, #0]
    a9ce:	bx	r3

0000a9d0 <HardwareSerial::write(long)>:
	virtual size_t write(long n)            { return write((uint8_t)n); }
    a9d0:	ldr	r3, [r0, #0]
    a9d2:	uxtb	r1, r1
    a9d4:	ldr	r3, [r3, #0]
    a9d6:	bx	r3

0000a9d8 <HardwareSerial::write(unsigned int)>:
	virtual size_t write(unsigned int n)    { return write((uint8_t)n); }
    a9d8:	ldr	r3, [r0, #0]
    a9da:	uxtb	r1, r1
    a9dc:	ldr	r3, [r3, #0]
    a9de:	bx	r3

0000a9e0 <HardwareSerial::write(int)>:
	virtual size_t write(int n)             { return write((uint8_t)n); }
    a9e0:	ldr	r3, [r0, #0]
    a9e2:	uxtb	r1, r1
    a9e4:	ldr	r3, [r3, #0]
    a9e6:	bx	r3

0000a9e8 <HardwareSerial::write9bit(unsigned long)>:
	virtual size_t write(const uint8_t *buffer, size_t size)
					{ serial_write(buffer, size); return size; }
        virtual size_t write(const char *str)	{ size_t len = strlen(str);
					  serial_write((const uint8_t *)str, len);
					  return len; }
	virtual size_t write9bit(uint32_t c)	{ serial_putchar(c); return 1; }
    a9e8:	push	{r3, lr}
    a9ea:	mov	r0, r1
    a9ec:	bl	95d0 <serial_putchar>
    a9f0:	movs	r0, #1
    a9f2:	pop	{r3, pc}

0000a9f4 <HardwareSerial::write(unsigned char)>:
	virtual int read(void)          { return serial_getchar(); }
	virtual void flush(void)        { serial_flush(); }
	virtual void clear(void)	{ serial_clear(); }
	virtual int availableForWrite(void) { return serial_write_buffer_free(); }
	using Print::write;
	virtual size_t write(uint8_t c) { serial_putchar(c); return 1; }
    a9f4:	push	{r3, lr}
    a9f6:	mov	r0, r1
    a9f8:	bl	95d0 <serial_putchar>
    a9fc:	movs	r0, #1
    a9fe:	pop	{r3, pc}

0000aa00 <HardwareSerial::write(char const*)>:
	virtual size_t write(long n)            { return write((uint8_t)n); }
	virtual size_t write(unsigned int n)    { return write((uint8_t)n); }
	virtual size_t write(int n)             { return write((uint8_t)n); }
	virtual size_t write(const uint8_t *buffer, size_t size)
					{ serial_write(buffer, size); return size; }
        virtual size_t write(const char *str)	{ size_t len = strlen(str);
    aa00:	push	{r3, r4, r5, lr}
    aa02:	mov	r0, r1
    aa04:	mov	r5, r1
    aa06:	bl	bd40 <strlen>
    aa0a:	mov	r4, r0
					  serial_write((const uint8_t *)str, len);
    aa0c:	mov	r1, r0
    aa0e:	mov	r0, r5
    aa10:	bl	95e4 <serial_write>
					  return len; }
    aa14:	mov	r0, r4
    aa16:	pop	{r3, r4, r5, pc}

0000aa18 <HardwareSerial::write(unsigned char const*, unsigned int)>:
	virtual size_t write(uint8_t c) { serial_putchar(c); return 1; }
	virtual size_t write(unsigned long n)   { return write((uint8_t)n); }
	virtual size_t write(long n)            { return write((uint8_t)n); }
	virtual size_t write(unsigned int n)    { return write((uint8_t)n); }
	virtual size_t write(int n)             { return write((uint8_t)n); }
	virtual size_t write(const uint8_t *buffer, size_t size)
    aa18:	push	{r4, lr}
					{ serial_write(buffer, size); return size; }
    aa1a:	mov	r0, r1
	virtual size_t write(uint8_t c) { serial_putchar(c); return 1; }
	virtual size_t write(unsigned long n)   { return write((uint8_t)n); }
	virtual size_t write(long n)            { return write((uint8_t)n); }
	virtual size_t write(unsigned int n)    { return write((uint8_t)n); }
	virtual size_t write(int n)             { return write((uint8_t)n); }
	virtual size_t write(const uint8_t *buffer, size_t size)
    aa1c:	mov	r4, r2
					{ serial_write(buffer, size); return size; }
    aa1e:	mov	r1, r2
    aa20:	bl	95e4 <serial_write>
    aa24:	mov	r0, r4
    aa26:	pop	{r4, pc}

0000aa28 <HardwareSerial::clear()>:
	virtual bool attachCts(uint8_t pin) { return serial_set_cts(pin); }
	virtual int available(void)     { return serial_available(); }
	virtual int peek(void)          { return serial_peek(); }
	virtual int read(void)          { return serial_getchar(); }
	virtual void flush(void)        { serial_flush(); }
	virtual void clear(void)	{ serial_clear(); }
    aa28:	b.w	97a0 <serial_clear>

0000aa2c <HardwareSerial::attachCts(unsigned char)>:
	virtual void end(void)		{ serial_end(); }
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial_set_cts(pin); }
    aa2c:	push	{r3, lr}
    aa2e:	mov	r0, r1
    aa30:	bl	9580 <serial_set_cts>
    aa34:	adds	r0, #0
    aa36:	it	ne
    aa38:	movne	r0, #1
    aa3a:	pop	{r3, pc}

0000aa3c <HardwareSerial::attachRts(unsigned char)>:
					  serial_format(format); }
	virtual void end(void)		{ serial_end(); }
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial_set_rts(pin); }
    aa3c:	push	{r3, lr}
    aa3e:	mov	r0, r1
    aa40:	bl	953c <serial_set_rts>
    aa44:	adds	r0, #0
    aa46:	it	ne
    aa48:	movne	r0, #1
    aa4a:	pop	{r3, pc}

0000aa4c <HardwareSerial::setTX(unsigned char, bool)>:
					  serial_begin(BAUD2DIV(baud));
					  serial_format(format); }
	virtual void end(void)		{ serial_end(); }
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
    aa4c:	mov	r0, r1
    aa4e:	mov	r1, r2
    aa50:	b.w	9434 <serial_set_tx>

0000aa54 <HardwareSerial::setRX(unsigned char)>:
	virtual void begin(uint32_t baud, uint32_t format) {
					  serial_begin(BAUD2DIV(baud));
					  serial_format(format); }
	virtual void end(void)		{ serial_end(); }
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
    aa54:	mov	r0, r1
    aa56:	b.w	94c8 <serial_set_rx>
    aa5a:	nop

0000aa5c <HardwareSerial::transmitterEnable(unsigned char)>:
	virtual void begin(uint32_t baud) { serial_begin(BAUD2DIV(baud)); }
	virtual void begin(uint32_t baud, uint32_t format) {
					  serial_begin(BAUD2DIV(baud));
					  serial_format(format); }
	virtual void end(void)		{ serial_end(); }
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
    aa5c:	mov	r0, r1
    aa5e:	b.w	93fc <serial_set_transmit_pin>
    aa62:	nop

0000aa64 <HardwareSerial::end()>:
	constexpr HardwareSerial() {}
	virtual void begin(uint32_t baud) { serial_begin(BAUD2DIV(baud)); }
	virtual void begin(uint32_t baud, uint32_t format) {
					  serial_begin(BAUD2DIV(baud));
					  serial_format(format); }
	virtual void end(void)		{ serial_end(); }
    aa64:	b.w	9314 <serial_end>

0000aa68 <HardwareSerial::begin(unsigned long)>:
#include "Stream.h"
class HardwareSerial : public Stream
{
public:
	constexpr HardwareSerial() {}
	virtual void begin(uint32_t baud) { serial_begin(BAUD2DIV(baud)); }
    aa68:	lsrs	r3, r1, #1
    aa6a:	add.w	r0, r3, #191889408	; 0xb700000
    aa6e:	add.w	r0, r0, #110592	; 0x1b000
    aa72:	udiv	r0, r0, r1
    aa76:	b.w	9198 <serial_begin>
    aa7a:	nop

0000aa7c <HardwareSerial::begin(unsigned long, unsigned long)>:
	virtual void begin(uint32_t baud, uint32_t format) {
    aa7c:	push	{r4, lr}
					  serial_begin(BAUD2DIV(baud));
    aa7e:	lsrs	r3, r1, #1
    aa80:	add.w	r0, r3, #191889408	; 0xb700000
class HardwareSerial : public Stream
{
public:
	constexpr HardwareSerial() {}
	virtual void begin(uint32_t baud) { serial_begin(BAUD2DIV(baud)); }
	virtual void begin(uint32_t baud, uint32_t format) {
    aa84:	mov	r4, r2
					  serial_begin(BAUD2DIV(baud));
    aa86:	add.w	r0, r0, #110592	; 0x1b000
    aa8a:	udiv	r0, r0, r1
    aa8e:	bl	9198 <serial_begin>
					  serial_format(format); }
    aa92:	mov	r0, r4
    aa94:	ldmia.w	sp!, {r4, lr}
    aa98:	b.w	92a8 <serial_format>

0000aa9c <HardwareSerial::peek()>:
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial_set_cts(pin); }
	virtual int available(void)     { return serial_available(); }
	virtual int peek(void)          { return serial_peek(); }
    aa9c:	b.w	9770 <serial_peek>

0000aaa0 <HardwareSerial::read()>:
	virtual int read(void)          { return serial_getchar(); }
    aaa0:	b.w	9708 <serial_getchar>

0000aaa4 <HardwareSerial::available()>:
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial_set_cts(pin); }
	virtual int available(void)     { return serial_available(); }
    aaa4:	b.w	96e8 <serial_available>

0000aaa8 <HardwareSerial::flush()>:
	virtual int peek(void)          { return serial_peek(); }
	virtual int read(void)          { return serial_getchar(); }
	virtual void flush(void)        { serial_flush(); }
    aaa8:	b.w	96ac <serial_flush>

0000aaac <HardwareSerial::availableForWrite()>:
	virtual void clear(void)	{ serial_clear(); }
	virtual int availableForWrite(void) { return serial_write_buffer_free(); }
    aaac:	b.w	96c4 <serial_write_buffer_free>

0000aab0 <serialEvent1()>:
#include "HardwareSerial.h"

HardwareSerial Serial1;

void serialEvent1() __attribute__((weak));
void serialEvent1() {}
    aab0:	bx	lr
    aab2:	nop

0000aab4 <EventResponder::triggerEventNotImmediate()>:
bool EventResponder::runningFromYield = false;

// TODO: interrupt disable/enable needed in many places!!!

void EventResponder::triggerEventNotImmediate()
{
    aab4:	push	{r4}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    aab6:	mrs	r2, PRIMASK
		__disable_irq();
    aaba:	cpsid	i
	bool irq = disableInterrupts();
	if (_triggered == false) {
    aabc:	ldrb	r3, [r0, #29]
    aabe:	cbnz	r3, aace <EventResponder::triggerEventNotImmediate()+0x1a>
		// not already triggered
		if (_type == EventTypeYield) {
    aac0:	ldrb	r1, [r0, #28]
    aac2:	cmp	r1, #1
    aac4:	beq.n	aad8 <EventResponder::triggerEventNotImmediate()+0x24>
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
    aac6:	cmp	r1, #3
    aac8:	beq.n	aaec <EventResponder::triggerEventNotImmediate()+0x38>
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
		} else {
			// detached, easy :-)
		}
		_triggered = true;
    aaca:	movs	r3, #1
    aacc:	strb	r3, [r0, #29]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    aace:	cbnz	r2, aad2 <EventResponder::triggerEventNotImmediate()+0x1e>
    aad0:	cpsie	i
	}
	enableInterrupts(irq);
}
    aad2:	ldr.w	r4, [sp], #4
    aad6:	bx	lr
	bool irq = disableInterrupts();
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
    aad8:	ldr	r4, [pc, #68]	; (ab20 <EventResponder::triggerEventNotImmediate()+0x6c>)
    aada:	ldr	r1, [r4, #0]
    aadc:	cbz	r1, ab08 <EventResponder::triggerEventNotImmediate()+0x54>
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
    aade:	ldr	r1, [pc, #68]	; (ab24 <EventResponder::triggerEventNotImmediate()+0x70>)
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
    aae0:	str	r3, [r0, #20]
				_prev = lastYield;
    aae2:	ldr	r3, [r1, #0]
    aae4:	str	r3, [r0, #24]
				_prev->_next = this;
				lastYield = this;
    aae6:	str	r0, [r1, #0]
				firstYield = this;
				lastYield = this;
			} else {
				_next = nullptr;
				_prev = lastYield;
				_prev->_next = this;
    aae8:	str	r0, [r3, #20]
    aaea:	b.n	aaca <EventResponder::triggerEventNotImmediate()+0x16>
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
    aaec:	ldr	r4, [pc, #56]	; (ab28 <EventResponder::triggerEventNotImmediate()+0x74>)
    aaee:	ldr	r1, [r4, #0]
    aaf0:	cbz	r1, ab14 <EventResponder::triggerEventNotImmediate()+0x60>
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
    aaf2:	ldr	r1, [pc, #56]	; (ab2c <EventResponder::triggerEventNotImmediate()+0x78>)
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
    aaf4:	str	r3, [r0, #20]
				_prev = lastInterrupt;
    aaf6:	ldr	r3, [r1, #0]
    aaf8:	str	r3, [r0, #24]
				_prev->_next = this;
				lastInterrupt = this;
    aafa:	str	r0, [r1, #0]
				firstInterrupt = this;
				lastInterrupt = this;
			} else {
				_next = nullptr;
				_prev = lastInterrupt;
				_prev->_next = this;
    aafc:	str	r0, [r3, #20]
				lastInterrupt = this;
			}
			SCB_ICSR = SCB_ICSR_PENDSVSET; // set PendSV interrupt
    aafe:	ldr	r3, [pc, #48]	; (ab30 <EventResponder::triggerEventNotImmediate()+0x7c>)
    ab00:	mov.w	r1, #268435456	; 0x10000000
    ab04:	str	r1, [r3, #0]
    ab06:	b.n	aaca <EventResponder::triggerEventNotImmediate()+0x16>
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstYield = this;
				lastYield = this;
    ab08:	ldr	r3, [pc, #24]	; (ab24 <EventResponder::triggerEventNotImmediate()+0x70>)
	if (_triggered == false) {
		// not already triggered
		if (_type == EventTypeYield) {
			// normal type, called from yield()
			if (firstYield == nullptr) {
				_next = nullptr;
    ab0a:	str	r1, [r0, #20]
				_prev = nullptr;
    ab0c:	str	r1, [r0, #24]
				firstYield = this;
    ab0e:	str	r0, [r4, #0]
				lastYield = this;
    ab10:	str	r0, [r3, #0]
    ab12:	b.n	aaca <EventResponder::triggerEventNotImmediate()+0x16>
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
				_prev = nullptr;
				firstInterrupt = this;
				lastInterrupt = this;
    ab14:	ldr	r3, [pc, #20]	; (ab2c <EventResponder::triggerEventNotImmediate()+0x78>)
				lastYield = this;
			}
		} else if (_type == EventTypeInterrupt) {
			// interrupt, called from software interrupt
			if (firstInterrupt == nullptr) {
				_next = nullptr;
    ab16:	str	r1, [r0, #20]
				_prev = nullptr;
    ab18:	str	r1, [r0, #24]
				firstInterrupt = this;
    ab1a:	str	r0, [r4, #0]
				lastInterrupt = this;
    ab1c:	str	r0, [r3, #0]
    ab1e:	b.n	aafe <EventResponder::triggerEventNotImmediate()+0x4a>
    ab20:	.word	0x1fff1ab8
    ab24:	.word	0x1fff1ab4
    ab28:	.word	0x1fff1aa8
    ab2c:	.word	0x1fff1aac
    ab30:	.word	0xe000ed04

0000ab34 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    ab34:	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    ab36:	mrs	r2, PRIMASK
		__disable_irq();
    ab3a:	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    ab3c:	ldr	r4, [pc, #48]	; (ab70 <EventResponder::runFromInterrupt()+0x3c>)
    ab3e:	ldr	r0, [r4, #0]
		if (first) {
    ab40:	cbz	r0, ab64 <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    ab42:	ldr	r6, [pc, #48]	; (ab74 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    ab44:	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    ab46:	ldr	r3, [r0, #20]
    ab48:	str	r3, [r4, #0]
			if (firstInterrupt) {
    ab4a:	cbz	r3, ab6a <EventResponder::runFromInterrupt()+0x36>
				firstInterrupt->_prev = nullptr;
    ab4c:	str	r5, [r3, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    ab4e:	cbnz	r2, ab52 <EventResponder::runFromInterrupt()+0x1e>
    ab50:	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    ab52:	strb	r5, [r0, #29]
			(*(first->_function))(*first);
    ab54:	ldr	r3, [r0, #8]
    ab56:	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    ab58:	mrs	r2, PRIMASK
		__disable_irq();
    ab5c:	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    ab5e:	ldr	r0, [r4, #0]
		if (first) {
    ab60:	cmp	r0, #0
    ab62:	bne.n	ab46 <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    ab64:	cbnz	r2, ab68 <EventResponder::runFromInterrupt()+0x34>
    ab66:	cpsie	i
    ab68:	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    ab6a:	str	r3, [r6, #0]
    ab6c:	b.n	ab4e <EventResponder::runFromInterrupt()+0x1a>
    ab6e:	nop
    ab70:	.word	0x1fff1aa8
    ab74:	.word	0x1fff1aac

0000ab78 <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    ab78:	b.w	ab34 <EventResponder::runFromInterrupt()>

0000ab7c <MillisTimer::addToActiveList()>:
	enableTimerInterrupt(irq);
}

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
    ab7c:	ldr	r2, [pc, #96]	; (abe0 <MillisTimer::addToActiveList()+0x64>)
	_state = TimerWaiting;
	enableTimerInterrupt(irq);
}

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
    ab7e:	push	{r4, r5}
	if (listActive == nullptr) {
    ab80:	ldr	r4, [r2, #0]
    ab82:	cmp	r4, #0
    ab84:	beq.n	abd6 <MillisTimer::addToActiveList()+0x5a>
		// list is empty, easy case
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
    ab86:	ldr	r3, [r0, #0]
    ab88:	ldr	r1, [r4, #0]
    ab8a:	cmp	r3, r1
    ab8c:	bcs.n	abac <MillisTimer::addToActiveList()+0x30>
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
		listActive->_prev = this;
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
    ab8e:	subs	r3, r1, r3
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
    ab90:	movs	r1, #0
		_next = nullptr;
		_prev = nullptr;
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
    ab92:	str	r4, [r0, #8]
		_prev = nullptr;
    ab94:	str	r1, [r0, #12]
		listActive->_prev = this;
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
    ab96:	str	r3, [r4, #0]
		listActive = this;
	} else if (_ms < listActive->_ms) {
		// this timer triggers before any on the list
		_next = listActive;
		_prev = nullptr;
		listActive->_prev = this;
    ab98:	str	r0, [r4, #12]
		// Decrement the next items wait time be our wait time as to properly handle waits for all other items...
		listActive->_ms -= _ms;	
		listActive = this;
    ab9a:	str	r0, [r2, #0]
		_ms -= timer->_ms;
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
    ab9c:	movs	r3, #2
    ab9e:	strb	r3, [r0, #20]
}
    aba0:	pop	{r4, r5}
    aba2:	bx	lr
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
    aba4:	ldr	r1, [r2, #0]
    aba6:	cmp	r3, r1
    aba8:	mov	r4, r2
    abaa:	bcc.n	abbe <MillisTimer::addToActiveList()+0x42>
		listActive->_ms -= _ms;	
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
    abac:	ldr	r2, [r4, #8]
				_state = TimerActive;
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
    abae:	subs	r3, r3, r1
    abb0:	str	r3, [r0, #0]
		listActive->_ms -= _ms;	
		listActive = this;
	} else {
		// add this timer somewhere after the first already on the list
		MillisTimer *timer = listActive;
		while (timer->_next) {
    abb2:	cmp	r2, #0
    abb4:	bne.n	aba4 <MillisTimer::addToActiveList()+0x28>
				return;
			}
		}
		// add this time at the end of the list
		_ms -= timer->_ms;
		_next = nullptr;
    abb6:	str	r2, [r0, #8]
		_prev = timer;
    abb8:	str	r4, [r0, #12]
		timer->_next = this;
    abba:	str	r0, [r4, #8]
    abbc:	b.n	ab9c <MillisTimer::addToActiveList()+0x20>
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
				_prev = timer->_prev;
    abbe:	ldr	r2, [r2, #12]
    abc0:	str	r2, [r0, #12]
		while (timer->_next) {
			_ms -= timer->_ms;
			timer = timer->_next;
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
    abc2:	str	r4, [r0, #8]
				_prev = timer->_prev;
				timer->_prev = this;
    abc4:	str	r0, [r4, #12]
				_prev->_next = this;
    abc6:	ldr	r5, [r0, #12]
				timer->_ms -= _ms;
    abc8:	subs	r3, r1, r3
				_state = TimerActive;
    abca:	movs	r2, #2
			if (_ms < timer->_ms) {
				// found the right place in the middle of list
				_next = timer;
				_prev = timer->_prev;
				timer->_prev = this;
				_prev->_next = this;
    abcc:	str	r0, [r5, #8]
				timer->_ms -= _ms;
    abce:	str	r3, [r4, #0]
				_state = TimerActive;
    abd0:	strb	r2, [r0, #20]
		_next = nullptr;
		_prev = timer;
		timer->_next = this;
	}
	_state = TimerActive;
}
    abd2:	pop	{r4, r5}
    abd4:	bx	lr

void MillisTimer::addToActiveList() // only called by runFromTimer()
{
	if (listActive == nullptr) {
		// list is empty, easy case
		_next = nullptr;
    abd6:	str	r4, [r0, #8]
		_prev = nullptr;
    abd8:	str	r4, [r0, #12]
		listActive = this;
    abda:	str	r0, [r2, #0]
    abdc:	b.n	ab9c <MillisTimer::addToActiveList()+0x20>
    abde:	nop
    abe0:	.word	0x1fff1ab0

0000abe4 <MillisTimer::runFromTimer()>:
	}
	enableTimerInterrupt(irq);
}

void MillisTimer::runFromTimer()
{
    abe4:	push	{r3, r4, r5, r6, r7, lr}
	MillisTimer *timer = listActive;
    abe6:	ldr	r6, [pc, #136]	; (ac70 <MillisTimer::runFromTimer()+0x8c>)
    abe8:	ldr	r4, [r6, #0]
	while (timer) {
    abea:	cbz	r4, ac38 <MillisTimer::runFromTimer()+0x54>
		if (timer->_ms > 0) {
    abec:	ldr	r3, [r4, #0]
    abee:	cmp	r3, #0
    abf0:	bne.n	ac68 <MillisTimer::runFromTimer()+0x84>
    abf2:	ldr	r7, [pc, #128]	; (ac74 <MillisTimer::runFromTimer()+0x90>)
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
    abf4:	mov	r5, r3
    abf6:	b.n	ac02 <MillisTimer::runFromTimer()+0x1e>
			event.triggerEvent(0, timer);
			if (timer->_reload) {
				timer->_ms = timer->_reload;
				timer->addToActiveList();
			}
			timer = listActive;
    abf8:	ldr	r4, [r6, #0]
}

void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
    abfa:	cbz	r4, ac38 <MillisTimer::runFromTimer()+0x54>
		if (timer->_ms > 0) {
    abfc:	ldr	r3, [r4, #0]
    abfe:	cmp	r3, #0
    ac00:	bne.n	ac68 <MillisTimer::runFromTimer()+0x84>
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
    ac02:	ldr	r3, [r4, #8]
			if (next) next->_prev = nullptr;
    ac04:	cbz	r3, ac08 <MillisTimer::runFromTimer()+0x24>
    ac06:	str	r5, [r3, #12]
			listActive = next;
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
    ac08:	ldr	r0, [r4, #16]
			timer->_ms--;
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
    ac0a:	str	r3, [r6, #0]
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    ac0c:	ldr	r3, [r0, #0]
			break;
		} else {
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
			timer->_state = TimerOff;
    ac0e:	strb	r5, [r4, #20]
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    ac10:	ldr	r3, [r3, #0]
    ac12:	cmp	r3, r7
    ac14:	bne.n	ac5a <MillisTimer::runFromTimer()+0x76>
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
    ac16:	ldrb	r3, [r0, #28]

	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
    ac18:	str	r5, [r0, #4]
		_data = data;
		if (_type == EventTypeImmediate) {
    ac1a:	cmp	r3, #2
	// Trigger the event.  An optional status code and data may be provided.
	// The code triggering the event does NOT control which of the above
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
    ac1c:	str	r4, [r0, #12]
		if (_type == EventTypeImmediate) {
    ac1e:	beq.n	ac62 <MillisTimer::runFromTimer()+0x7e>
			(*_function)(*this);
		} else {
			triggerEventNotImmediate();
    ac20:	bl	aab4 <EventResponder::triggerEventNotImmediate()>
			if (timer->_reload) {
    ac24:	ldr	r3, [r4, #4]
    ac26:	cmp	r3, #0
    ac28:	beq.n	abf8 <MillisTimer::runFromTimer()+0x14>
				timer->_ms = timer->_reload;
    ac2a:	str	r3, [r4, #0]
				timer->addToActiveList();
    ac2c:	mov	r0, r4
    ac2e:	bl	ab7c <MillisTimer::addToActiveList()>
			}
			timer = listActive;
    ac32:	ldr	r4, [r6, #0]
}

void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
    ac34:	cmp	r4, #0
    ac36:	bne.n	abfc <MillisTimer::runFromTimer()+0x18>
	volatile TimerStateType _state = TimerOff;
	static MillisTimer *listWaiting; // single linked list of waiting to start timers
	static MillisTimer *listActive;  // double linked list of running timers
	static bool disableTimerInterrupt() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    ac38:	mrs	r3, PRIMASK
		__disable_irq();
    ac3c:	cpsid	i
			}
			timer = listActive;
		}
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
    ac3e:	ldr	r2, [pc, #56]	; (ac78 <MillisTimer::runFromTimer()+0x94>)
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
    ac40:	movs	r1, #0
			}
			timer = listActive;
		}
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
    ac42:	ldr	r0, [r2, #0]
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
    ac44:	str	r1, [r2, #0]
		return (primask == 0) ? true : false;
	}
	static void enableTimerInterrupt(bool doit) {
		if (doit) __enable_irq();
    ac46:	cbnz	r3, ac4a <MillisTimer::runFromTimer()+0x66>
    ac48:	cpsie	i
	enableTimerInterrupt(irq);
	while (waiting) {
    ac4a:	cbz	r0, ac58 <MillisTimer::runFromTimer()+0x74>
		MillisTimer *next = waiting->_next;
    ac4c:	ldr	r4, [r0, #8]
		waiting->addToActiveList();
    ac4e:	bl	ab7c <MillisTimer::addToActiveList()>
	}
	bool irq = disableTimerInterrupt();
	MillisTimer *waiting = listWaiting;
	listWaiting = nullptr; // TODO: use STREX to avoid interrupt disable
	enableTimerInterrupt(irq);
	while (waiting) {
    ac52:	mov	r0, r4
    ac54:	cmp	r0, #0
    ac56:	bne.n	ac4c <MillisTimer::runFromTimer()+0x68>
    ac58:	pop	{r3, r4, r5, r6, r7, pc}
			MillisTimer *next = timer->_next;
			if (next) next->_prev = nullptr;
			listActive = next;
			timer->_state = TimerOff;
			EventResponderRef event = *(timer->_event);
			event.triggerEvent(0, timer);
    ac5a:	mov	r2, r4
    ac5c:	movs	r1, #0
    ac5e:	blx	r3
    ac60:	b.n	ac24 <MillisTimer::runFromTimer()+0x40>
	// response methods will be used.
	virtual void triggerEvent(int status=0, void *data=nullptr) {
		_status = status;
		_data = data;
		if (_type == EventTypeImmediate) {
			(*_function)(*this);
    ac62:	ldr	r3, [r0, #8]
    ac64:	blx	r3
    ac66:	b.n	ac24 <MillisTimer::runFromTimer()+0x40>
void MillisTimer::runFromTimer()
{
	MillisTimer *timer = listActive;
	while (timer) {
		if (timer->_ms > 0) {
			timer->_ms--;
    ac68:	subs	r3, #1
    ac6a:	str	r3, [r4, #0]
			break;
    ac6c:	b.n	ac38 <MillisTimer::runFromTimer()+0x54>
    ac6e:	nop
    ac70:	.word	0x1fff1ab0
    ac74:	.word	0x000088dd
    ac78:	.word	0x1fff1ac0

0000ac7c <systick_isr>:
// with libraries using mid-to-high priority interrupts.

extern "C" volatile uint32_t systick_millis_count;
void systick_isr(void)
{
	systick_millis_count++;
    ac7c:	ldr	r2, [pc, #8]	; (ac88 <systick_isr+0xc>)
    ac7e:	ldr	r3, [r2, #0]
    ac80:	adds	r3, #1
    ac82:	str	r3, [r2, #0]
	MillisTimer::runFromTimer();
    ac84:	b.w	abe4 <MillisTimer::runFromTimer()>
    ac88:	.word	0x1fff1998

0000ac8c <yield>:
#include <Arduino.h>
#include "EventResponder.h"

void yield(void) __attribute__ ((weak));
void yield(void)
{
    ac8c:	push	{r3, r4, r5, lr}
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
    ac8e:	ldr	r4, [pc, #176]	; (ad40 <yield+0xb4>)
    ac90:	ldrb	r3, [r4, #0]
    ac92:	cbz	r3, ac96 <yield+0xa>
    ac94:	pop	{r3, r4, r5, pc}
	running = 1;
    ac96:	movs	r3, #1
    ac98:	strb	r3, [r4, #0]
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    ac9a:	bl	8dd0 <usb_serial_available>
	if (Serial.available()) serialEvent();
    ac9e:	cmp	r0, #0
    aca0:	bne.n	ad28 <yield+0x9c>
	virtual void transmitterEnable(uint8_t pin) { serial_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial_set_cts(pin); }
	virtual int available(void)     { return serial_available(); }
    aca2:	bl	96e8 <serial_available>
	if (Serial1.available()) serialEvent1();
    aca6:	cmp	r0, #0
    aca8:	bne.n	ad22 <yield+0x96>
	virtual void transmitterEnable(uint8_t pin) { serial2_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial2_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial2_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial2_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial2_set_cts(pin); }
	virtual int available(void)     { return serial2_available(); }
    acaa:	bl	b028 <serial2_available>
	if (Serial2.available()) serialEvent2();
    acae:	cmp	r0, #0
    acb0:	bne.n	ad1c <yield+0x90>
	virtual void transmitterEnable(uint8_t pin) { serial3_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial3_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial3_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial3_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial3_set_cts(pin); }
	virtual int available(void)     { return serial3_available(); }
    acb2:	bl	b418 <serial3_available>
	if (Serial3.available()) serialEvent3();
    acb6:	cbnz	r0, ad16 <yield+0x8a>
	virtual void transmitterEnable(uint8_t pin) { serial4_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial4_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial4_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial4_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial4_set_cts(pin); }
	virtual int available(void)     { return serial4_available(); }
    acb8:	bl	b154 <serial4_available>
#ifdef HAS_KINETISK_UART3
	if (Serial4.available()) serialEvent4();
    acbc:	cbnz	r0, ad10 <yield+0x84>
	virtual void transmitterEnable(uint8_t pin) { serial5_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial5_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial5_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial5_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial5_set_cts(pin); }
	virtual int available(void)     { return serial5_available(); }
    acbe:	bl	ae50 <serial5_available>
#endif
#ifdef HAS_KINETISK_UART4
	if (Serial5.available()) serialEvent5();
    acc2:	cbnz	r0, ad0a <yield+0x7e>
	virtual void transmitterEnable(uint8_t pin) { serial6_set_transmit_pin(pin); }
	virtual void setRX(uint8_t pin) { serial6_set_rx(pin); }
	virtual void setTX(uint8_t pin, bool opendrain=false) { serial6_set_tx(pin, opendrain); }
	virtual bool attachRts(uint8_t pin) { return serial6_set_rts(pin); }
	virtual bool attachCts(uint8_t pin) { return serial6_set_cts(pin); }
	virtual int available(void)     { return serial6_available(); }
    acc4:	bl	b24c <serial6_available>
#endif
#if defined(HAS_KINETISK_UART5) || defined (HAS_KINETISK_LPUART0)
	if (Serial6.available()) serialEvent6();
    acc8:	cbnz	r0, ad04 <yield+0x78>
#endif
	running = 0;
    acca:	movs	r3, #0
    accc:	strb	r3, [r4, #0]

	static void runFromYield() {
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    acce:	mrs	r3, IPSR
		if (ipsr != 0) return;
    acd2:	cmp	r3, #0
    acd4:	bne.n	ac94 <yield+0x8>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    acd6:	mrs	r1, PRIMASK
		__disable_irq();
    acda:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    acdc:	ldr	r3, [pc, #100]	; (ad44 <yield+0xb8>)
    acde:	ldr	r0, [r3, #0]
		if (first == nullptr) {
    ace0:	cbz	r0, ad2e <yield+0xa2>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    ace2:	ldr	r4, [pc, #100]	; (ad48 <yield+0xbc>)
    ace4:	ldrb	r2, [r4, #0]
    ace6:	cbnz	r2, ad2e <yield+0xa2>
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
		firstYield = first->_next;
    ace8:	ldr	r5, [r0, #20]
    acea:	str	r5, [r3, #0]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    acec:	movs	r3, #1
    acee:	strb	r3, [r4, #0]
		firstYield = first->_next;
		if (firstYield) {
    acf0:	cbz	r5, ad36 <yield+0xaa>
			firstYield->_prev = nullptr;
    acf2:	str	r2, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    acf4:	cbnz	r1, acf8 <yield+0x6c>
    acf6:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    acf8:	movs	r5, #0
    acfa:	strb	r5, [r0, #29]
		(*(first->_function))(*first);
    acfc:	ldr	r3, [r0, #8]
    acfe:	blx	r3
		runningFromYield = false;
    ad00:	strb	r5, [r4, #0]
    ad02:	b.n	ac94 <yield+0x8>
#endif
#ifdef HAS_KINETISK_UART4
	if (Serial5.available()) serialEvent5();
#endif
#if defined(HAS_KINETISK_UART5) || defined (HAS_KINETISK_LPUART0)
	if (Serial6.available()) serialEvent6();
    ad04:	bl	ae48 <serialEvent6()>
    ad08:	b.n	acca <yield+0x3e>
	if (Serial3.available()) serialEvent3();
#ifdef HAS_KINETISK_UART3
	if (Serial4.available()) serialEvent4();
#endif
#ifdef HAS_KINETISK_UART4
	if (Serial5.available()) serialEvent5();
    ad0a:	bl	ad50 <serialEvent5()>
    ad0e:	b.n	acc4 <yield+0x38>
	if (Serial.available()) serialEvent();
	if (Serial1.available()) serialEvent1();
	if (Serial2.available()) serialEvent2();
	if (Serial3.available()) serialEvent3();
#ifdef HAS_KINETISK_UART3
	if (Serial4.available()) serialEvent4();
    ad10:	bl	ae34 <serialEvent4()>
    ad14:	b.n	acbe <yield+0x32>
	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
	if (Serial1.available()) serialEvent1();
	if (Serial2.available()) serialEvent2();
	if (Serial3.available()) serialEvent3();
    ad16:	bl	b510 <serialEvent3()>
    ad1a:	b.n	acb8 <yield+0x2c>

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
	if (Serial1.available()) serialEvent1();
	if (Serial2.available()) serialEvent2();
    ad1c:	bl	ae30 <serialEvent2()>
    ad20:	b.n	acb2 <yield+0x26>
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
	if (Serial1.available()) serialEvent1();
    ad22:	bl	aab0 <serialEvent1()>
    ad26:	b.n	acaa <yield+0x1e>
{
	static uint8_t running=0;

	if (running) return; // TODO: does this need to be atomic?
	running = 1;
	if (Serial.available()) serialEvent();
    ad28:	bl	ad7c <serialEvent()>
    ad2c:	b.n	aca2 <yield+0x16>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    ad2e:	cmp	r1, #0
    ad30:	bne.n	ac94 <yield+0x8>
    ad32:	cpsie	i
    ad34:	pop	{r3, r4, r5, pc}
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    ad36:	ldr	r3, [pc, #20]	; (ad4c <yield+0xc0>)
    ad38:	str	r5, [r3, #0]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    ad3a:	cmp	r1, #0
    ad3c:	bne.n	acf8 <yield+0x6c>
    ad3e:	b.n	acf6 <yield+0x6a>
    ad40:	.word	0x1fff1ac4
    ad44:	.word	0x1fff1ab8
    ad48:	.word	0x1fff1abc
    ad4c:	.word	0x1fff1ab4

0000ad50 <serialEvent5()>:
#ifdef HAS_KINETISK_UART4

HardwareSerial5 Serial5;

void serialEvent5() __attribute__((weak));
void serialEvent5() {}
    ad50:	bx	lr
    ad52:	nop

0000ad54 <usb_serial_class::clear()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    ad54:	b.w	8dec <usb_serial_flush_input>

0000ad58 <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    ad58:	b.w	8da0 <usb_serial_peekchar>

0000ad5c <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    ad5c:	b.w	8d58 <usb_serial_getchar>

0000ad60 <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    ad60:	b.w	8dd0 <usb_serial_available>

0000ad64 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    ad64:	b.w	8f8c <usb_serial_flush_output>

0000ad68 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    ad68:	b.w	8f44 <usb_serial_write_buffer_free>

0000ad6c <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    ad6c:	mov	r0, r1
    ad6e:	mov	r1, r2
    ad70:	b.w	8e24 <usb_serial_write>

0000ad74 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    ad74:	mov	r0, r1
    ad76:	b.w	8f2c <usb_serial_putchar>
    ad7a:	nop

0000ad7c <serialEvent()>:
#endif

#endif // F_CPU

void serialEvent() __attribute__((weak));
void serialEvent() {}
    ad7c:	bx	lr
    ad7e:	nop

0000ad80 <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    ad80:	push	{lr}
	uint8_t buf[2]={'\r', '\n'};
    ad82:	ldr	r2, [pc, #24]	; (ad9c <Print::println()+0x1c>)
	return write(buf, 2);
    ad84:	ldr	r3, [r0, #0]
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    ad86:	ldrh	r2, [r2, #0]
	return write(buf, 2);
    ad88:	ldr	r3, [r3, #4]
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    ad8a:	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    ad8c:	add	r1, sp, #4
}


size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    ad8e:	strh.w	r2, [sp, #4]
	return write(buf, 2);
    ad92:	movs	r2, #2
    ad94:	blx	r3
}
    ad96:	add	sp, #12
    ad98:	ldr.w	pc, [sp], #4
    ad9c:	.word	0x0000c7d8

0000ada0 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
}

#else

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    ada0:	push	{r4, r5, r6, r7, lr}
    ada2:	mov	r7, r0
    ada4:	sub	sp, #44	; 0x2c
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    ada6:	cmp	r2, #0
    ada8:	beq.n	ae12 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
		return write((uint8_t)n);
	} else if (base == 1) {
		base = 10;
    adaa:	cmp	r2, #1
    adac:	it	eq
    adae:	moveq	r2, #10
	}


	if (n == 0) {
    adb0:	cbz	r1, ae08 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x68>
    adb2:	movs	r4, #33	; 0x21
    adb4:	b.n	adb8 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x18>
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
			i--;
    adb6:	uxtb	r4, r6
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    adb8:	udiv	r5, r1, r2
    adbc:	mls	r1, r2, r5, r1
    adc0:	uxtb	r0, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    adc2:	cmp	r1, #9
    adc4:	add.w	r1, r0, #48	; 0x30
    adc8:	it	ls
    adca:	uxtbls	r0, r1
    adcc:	add	r1, sp, #40	; 0x28
    adce:	it	hi
    add0:	addhi	r0, #55	; 0x37
    add2:	add	r1, r4
    add4:	it	hi
    add6:	uxtbhi	r0, r0
    add8:	strb.w	r0, [r1, #-36]
			n /= base;
			if (n == 0) break;
			i--;
    addc:	subs	r6, r4, #1
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
    adde:	mov	r1, r5
    ade0:	cmp	r5, #0
    ade2:	bne.n	adb6 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x16>
			i--;
		}
	}
	if (sign) {
    ade4:	cbz	r3, adf4 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x54>
		i--;
    ade6:	subs	r4, #1
    ade8:	uxtb	r4, r4
		buf[i] = '-';
    adea:	add	r3, sp, #40	; 0x28
    adec:	add	r3, r4
    adee:	movs	r2, #45	; 0x2d
    adf0:	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    adf4:	ldr	r3, [r7, #0]
    adf6:	add	r2, sp, #4
    adf8:	adds	r1, r2, r4
    adfa:	ldr	r3, [r3, #4]
    adfc:	mov	r0, r7
    adfe:	rsb	r2, r4, #34	; 0x22
    ae02:	blx	r3
}
    ae04:	add	sp, #44	; 0x2c
    ae06:	pop	{r4, r5, r6, r7, pc}
		base = 10;
	}


	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    ae08:	movs	r2, #48	; 0x30
    ae0a:	strb.w	r2, [sp, #37]	; 0x25
		i = sizeof(buf) - 1;
    ae0e:	movs	r4, #33	; 0x21
    ae10:	b.n	ade4 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x44>

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
		return write((uint8_t)n);
    ae12:	ldr	r3, [r0, #0]
    ae14:	uxtb	r1, r1
    ae16:	ldr	r3, [r3, #0]
    ae18:	blx	r3
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    ae1a:	add	sp, #44	; 0x2c
    ae1c:	pop	{r4, r5, r6, r7, pc}
    ae1e:	nop

0000ae20 <Print::print(long)>:

size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
    ae20:	cmp	r1, #0
		sign = '-';
		n = -n;
    ae22:	itte	lt
    ae24:	neglt	r1, r1
size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
    ae26:	movlt	r3, #45	; 0x2d
}


size_t Print::print(long n)
{
	uint8_t sign=0;
    ae28:	movge	r3, #0

	if (n < 0) {
		sign = '-';
		n = -n;
	}
	return printNumber(n, 10, sign);
    ae2a:	movs	r2, #10
    ae2c:	b.w	ada0 <Print::printNumber(unsigned long, unsigned char, unsigned char)>

0000ae30 <serialEvent2()>:
#include "HardwareSerial.h"

HardwareSerial2 Serial2;

void serialEvent2() __attribute__((weak));
void serialEvent2() {}
    ae30:	bx	lr
    ae32:	nop

0000ae34 <serialEvent4()>:
#ifdef HAS_KINETISK_UART3

HardwareSerial4 Serial4;

void serialEvent4() __attribute__((weak));
void serialEvent4() {}
    ae34:	bx	lr
    ae36:	nop

0000ae38 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    ae38:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    ae3a:	bl	5d0 <setup>
	while (1) {
		loop();
    ae3e:	bl	5f8 <loop>
		yield();
    ae42:	bl	ac8c <yield>
    ae46:	b.n	ae3e <main+0x6>

0000ae48 <serialEvent6()>:
#if defined(HAS_KINETISK_UART5) || defined (HAS_KINETISK_LPUART0)

HardwareSerial6 Serial6;

void serialEvent6() __attribute__((weak));
void serialEvent6() {}
    ae48:	bx	lr
    ae4a:	nop

0000ae4c <operator delete(void*, unsigned int)>:
    ae4c:	b.w	b598 <free>

0000ae50 <serial5_available>:

int serial5_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    ae50:	ldr	r2, [pc, #20]	; (ae68 <serial5_available+0x18>)
	tail = rx_buffer_tail;
    ae52:	ldr	r3, [pc, #24]	; (ae6c <serial5_available+0x1c>)

int serial5_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    ae54:	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    ae56:	ldrb	r3, [r3, #0]

int serial5_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    ae58:	uxtb	r0, r0
	tail = rx_buffer_tail;
    ae5a:	uxtb	r3, r3
	if (head >= tail) return head - tail;
    ae5c:	cmp	r0, r3
	return SERIAL5_RX_BUFFER_SIZE + head - tail;
    ae5e:	it	cc
    ae60:	addcc	r0, #64	; 0x40
    ae62:	subs	r0, r0, r3
}
    ae64:	bx	lr
    ae66:	nop
    ae68:	.word	0x1fff1acc
    ae6c:	.word	0x1fff1acd

0000ae70 <uart4_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart4_status_isr(void)
{
    ae70:	push	{r4, r5}
	uint32_t head, tail, n;
	uint8_t c;

	if (UART4_S1 & UART_S1_RDRF) {
    ae72:	ldr	r3, [pc, #172]	; (af20 <uart4_status_isr+0xb0>)
    ae74:	ldrb	r2, [r3, #4]
    ae76:	lsls	r4, r2, #26
    ae78:	bpl.n	aeba <uart4_status_isr+0x4a>
		if (use9Bits && (UART4_C3 & 0x80)) {
			n = UART4_D | 0x100;
		} else {
			n = UART4_D;
		}
		head = rx_buffer_head + 1;
    ae7a:	ldr	r0, [pc, #168]	; (af24 <uart4_status_isr+0xb4>)

	if (UART4_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART4_C3 & 0x80)) {
			n = UART4_D | 0x100;
		} else {
			n = UART4_D;
    ae7c:	ldrb	r2, [r3, #7]
		}
		head = rx_buffer_head + 1;
    ae7e:	ldrb	r3, [r0, #0]
		if (head >= SERIAL5_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    ae80:	ldr	r1, [pc, #164]	; (af28 <uart4_status_isr+0xb8>)
		if (use9Bits && (UART4_C3 & 0x80)) {
			n = UART4_D | 0x100;
		} else {
			n = UART4_D;
		}
		head = rx_buffer_head + 1;
    ae82:	adds	r3, #1
    ae84:	cmp	r3, #63	; 0x3f
		if (head >= SERIAL5_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    ae86:	ldrb	r1, [r1, #0]
		if (use9Bits && (UART4_C3 & 0x80)) {
			n = UART4_D | 0x100;
		} else {
			n = UART4_D;
		}
		head = rx_buffer_head + 1;
    ae88:	it	gt
    ae8a:	movgt	r3, #0
		if (head >= SERIAL5_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    ae8c:	cmp	r3, r1

	if (UART4_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART4_C3 & 0x80)) {
			n = UART4_D | 0x100;
		} else {
			n = UART4_D;
    ae8e:	uxtb	r2, r2
		}
		head = rx_buffer_head + 1;
		if (head >= SERIAL5_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    ae90:	beq.n	ae9a <uart4_status_isr+0x2a>
			rx_buffer[head] = n;
    ae92:	ldr	r4, [pc, #152]	; (af2c <uart4_status_isr+0xbc>)
			rx_buffer_head = head;
    ae94:	uxtb	r1, r3
			n = UART4_D;
		}
		head = rx_buffer_head + 1;
		if (head >= SERIAL5_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
			rx_buffer[head] = n;
    ae96:	strb	r2, [r4, r3]
			rx_buffer_head = head;
    ae98:	strb	r1, [r0, #0]
		}
		if (rts_pin) {
    ae9a:	ldr	r2, [pc, #148]	; (af30 <uart4_status_isr+0xc0>)
    ae9c:	ldr	r1, [r2, #0]
    ae9e:	cbz	r1, aeba <uart4_status_isr+0x4a>
			int avail;
			tail = tx_buffer_tail;
    aea0:	ldr	r2, [pc, #144]	; (af34 <uart4_status_isr+0xc4>)
    aea2:	ldrb	r2, [r2, #0]
    aea4:	uxtb	r2, r2
			if (head >= tail) avail = head - tail;
    aea6:	cmp	r3, r2
			else avail = SERIAL5_RX_BUFFER_SIZE + head - tail;
    aea8:	itet	cc
    aeaa:	rsbcc	r2, r2, #64	; 0x40
			rx_buffer_head = head;
		}
		if (rts_pin) {
			int avail;
			tail = tx_buffer_tail;
			if (head >= tail) avail = head - tail;
    aeae:	subcs	r3, r3, r2
			else avail = SERIAL5_RX_BUFFER_SIZE + head - tail;
    aeb0:	addcc	r3, r3, r2
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    aeb2:	cmp	r3, #39	; 0x27
    aeb4:	itt	gt
    aeb6:	movgt	r3, #1
    aeb8:	strbgt	r3, [r1, #0]
		}
	}
	c = UART4_C2;
    aeba:	ldr	r2, [pc, #100]	; (af20 <uart4_status_isr+0xb0>)
    aebc:	ldrb	r3, [r2, #3]
    aebe:	uxtb	r3, r3
	if ((c & UART_C2_TIE) && (UART4_S1 & UART_S1_TDRE)) {
    aec0:	lsls	r0, r3, #24
    aec2:	bmi.n	aee8 <uart4_status_isr+0x78>
			if (use9Bits) UART4_C3 = (UART4_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART4_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART4_S1 & UART_S1_TC)) {
    aec4:	lsls	r2, r3, #25
    aec6:	bpl.n	aee4 <uart4_status_isr+0x74>
    aec8:	ldr	r3, [pc, #84]	; (af20 <uart4_status_isr+0xb0>)
    aeca:	ldrb	r3, [r3, #4]
    aecc:	lsls	r3, r3, #25
    aece:	bpl.n	aee4 <uart4_status_isr+0x74>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    aed0:	ldr	r3, [pc, #100]	; (af38 <uart4_status_isr+0xc8>)
			UART4_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART4_S1 & UART_S1_TC)) {
		transmitting = 0;
    aed2:	ldr	r1, [pc, #104]	; (af3c <uart4_status_isr+0xcc>)
		if (transmit_pin) transmit_deassert();
    aed4:	ldr	r3, [r3, #0]
			UART4_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART4_S1 & UART_S1_TC)) {
		transmitting = 0;
    aed6:	movs	r2, #0
    aed8:	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    aeda:	cbz	r3, aede <uart4_status_isr+0x6e>
    aedc:	strb	r2, [r3, #0]
		UART4_C2 = C2_TX_INACTIVE;
    aede:	ldr	r3, [pc, #64]	; (af20 <uart4_status_isr+0xb0>)
    aee0:	movs	r2, #44	; 0x2c
    aee2:	strb	r2, [r3, #3]
	}
}
    aee4:	pop	{r4, r5}
    aee6:	bx	lr
			else avail = SERIAL5_RX_BUFFER_SIZE + head - tail;
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART4_C2;
	if ((c & UART_C2_TIE) && (UART4_S1 & UART_S1_TDRE)) {
    aee8:	ldrb	r1, [r2, #4]
    aeea:	lsls	r1, r1, #24
    aeec:	bpl.n	aec4 <uart4_status_isr+0x54>
		head = tx_buffer_head;
    aeee:	ldr	r1, [pc, #80]	; (af40 <uart4_status_isr+0xd0>)
		tail = tx_buffer_tail;
    aef0:	ldr	r0, [pc, #64]	; (af34 <uart4_status_isr+0xc4>)
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART4_C2;
	if ((c & UART_C2_TIE) && (UART4_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    aef2:	ldrb	r4, [r1, #0]
		tail = tx_buffer_tail;
    aef4:	ldrb	r1, [r0, #0]
    aef6:	uxtb	r1, r1
		if (head == tail) {
    aef8:	cmp	r4, r1
    aefa:	beq.n	af18 <uart4_status_isr+0xa8>
			UART4_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL5_TX_BUFFER_SIZE) tail = 0;
    aefc:	adds	r2, r1, #1
    aefe:	cmp	r2, #39	; 0x27
    af00:	itt	hi
    af02:	movhi	r1, #0
    af04:	movhi	r2, r1
			n = tx_buffer[tail];
    af06:	ldr	r5, [pc, #60]	; (af44 <uart4_status_isr+0xd4>)
			if (use9Bits) UART4_C3 = (UART4_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART4_D = n;
    af08:	ldr	r4, [pc, #20]	; (af20 <uart4_status_isr+0xb0>)
    af0a:	it	ls
    af0c:	uxtbls	r1, r2
		tail = tx_buffer_tail;
		if (head == tail) {
			UART4_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL5_TX_BUFFER_SIZE) tail = 0;
			n = tx_buffer[tail];
    af0e:	ldrb	r2, [r5, r2]
    af10:	uxtb	r2, r2
			if (use9Bits) UART4_C3 = (UART4_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART4_D = n;
    af12:	strb	r2, [r4, #7]
			tx_buffer_tail = tail;
    af14:	strb	r1, [r0, #0]
    af16:	b.n	aec4 <uart4_status_isr+0x54>
	c = UART4_C2;
	if ((c & UART_C2_TIE) && (UART4_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			UART4_C2 = C2_TX_COMPLETING;
    af18:	movs	r1, #108	; 0x6c
    af1a:	strb	r1, [r2, #3]
    af1c:	b.n	aec4 <uart4_status_isr+0x54>
    af1e:	nop
    af20:	.word	0x400ea000
    af24:	.word	0x1fff1acc
    af28:	.word	0x1fff1acd
    af2c:	.word	0x1fff1af8
    af30:	.word	0x1fff1ac8
    af34:	.word	0x1fff1b39
    af38:	.word	0x1fff1b3c
    af3c:	.word	0x1fff1b38
    af40:	.word	0x1fff1b40
    af44:	.word	0x1fff1ad0

0000af48 <analog_init>:
#else
#error "F_BUS must be 128, 120, 108, 96, 90, 80, 72, 64, 60, 56, 54, 48, 40, 36, 24, 4 or 2 MHz"
#endif

void analog_init(void)
{
    af48:	push	{r4, r5}
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    af4a:	ldr	r0, [pc, #164]	; (aff0 <analog_init+0xa8>)
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    af4c:	ldr	r2, [pc, #164]	; (aff4 <analog_init+0xac>)
	#endif

	if (analog_config_bits == 8) {
    af4e:	ldr	r3, [pc, #168]	; (aff8 <analog_init+0xb0>)
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    af50:	ldr	r5, [pc, #168]	; (affc <analog_init+0xb4>)
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    af52:	movs	r4, #96	; 0x60
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    af54:	movs	r1, #225	; 0xe1
void analog_init(void)
{
	uint32_t num;

	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
    af56:	strb	r4, [r0, #0]
	VREF_SC = 0xE1;		// enable 1.2 volt ref
    af58:	strb	r1, [r2, #0]
	#endif

	if (analog_config_bits == 8) {
    af5a:	ldrb	r3, [r3, #0]
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    af5c:	ldr	r4, [pc, #160]	; (b000 <analog_init+0xb8>)
	#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
    af5e:	cmp	r3, #8
    af60:	beq.n	afc4 <analog_init+0x7c>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    af62:	cmp	r3, #10
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    af64:	ldr	r0, [pc, #156]	; (b004 <analog_init+0xbc>)
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    af66:	ldr	r1, [pc, #160]	; (b008 <analog_init+0xc0>)
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
    af68:	beq.n	afda <analog_init+0x92>
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 12) {
    af6a:	cmp	r3, #12
		ADC0_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
    af6c:	ite	eq
    af6e:	moveq	r2, #53	; 0x35
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    af70:	movne	r2, #61	; 0x3d
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    af72:	movs	r3, #18
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_12BIT + ADC_CFG1_MODE(1) + ADC_CFG1_ADLSMP;
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
		#endif
	} else {
		ADC0_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    af74:	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    af76:	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_16BIT + ADC_CFG1_MODE(3) + ADC_CFG1_ADLSMP;
    af78:	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(2);
    af7a:	str	r3, [r1, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    af7c:	ldr	r3, [pc, #140]	; (b00c <analog_init+0xc4>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    af7e:	ldr	r1, [pc, #144]	; (b010 <analog_init+0xc8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    af80:	ldrb	r3, [r3, #0]
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    af82:	ldr	r2, [pc, #144]	; (b014 <analog_init+0xcc>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
	}
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
    af84:	cbz	r3, afb6 <analog_init+0x6e>
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    af86:	movs	r3, #1
    af88:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
    af8a:	str	r3, [r2, #0]
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    af8c:	ldr	r3, [pc, #136]	; (b018 <analog_init+0xd0>)
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    af8e:	ldr	r1, [pc, #140]	; (b01c <analog_init+0xd4>)
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
    af90:	ldrb	r3, [r3, #0]
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    af92:	ldr	r2, [pc, #140]	; (b020 <analog_init+0xd8>)
		ADC0_SC2 = ADC_SC2_REFSEL(1); // vcc
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
    af94:	cmp	r3, #1
    af96:	bls.n	afe6 <analog_init+0x9e>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
    af98:	cmp	r3, #4
    af9a:	bls.n	afbc <analog_init+0x74>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
    af9c:	cmp	r3, #8
    af9e:	bls.n	afde <analog_init+0x96>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
		#endif
	} else if (num <= 16) {
    afa0:	cmp	r3, #16
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
    afa2:	ite	ls
    afa4:	movls	r3, #134	; 0x86
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(2);
		#endif
	} else {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    afa6:	movhi	r3, #135	; 0x87
    afa8:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(3);
    afaa:	str	r3, [r2, #0]
		#endif
	}
	calibrating = 1;
    afac:	ldr	r3, [pc, #116]	; (b024 <analog_init+0xdc>)
    afae:	movs	r2, #1
    afb0:	strb	r2, [r3, #0]
}
    afb2:	pop	{r4, r5}
    afb4:	bx	lr
	#elif defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__)
	if (analog_reference_internal) {
		ADC0_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
		ADC1_SC2 = ADC_SC2_REFSEL(1); // 1.2V ref
	} else {
		ADC0_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    afb6:	str	r3, [r1, #0]
		ADC1_SC2 = ADC_SC2_REFSEL(0); // vcc/ext ref
    afb8:	str	r3, [r2, #0]
    afba:	b.n	af8c <analog_init+0x44>
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
		#endif
	} else if (num <= 4) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    afbc:	movs	r3, #132	; 0x84
    afbe:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
    afc0:	str	r3, [r2, #0]
    afc2:	b.n	afac <analog_init+0x64>

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    afc4:	add.w	r0, r0, #290816	; 0x47000
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    afc8:	ldr	r1, [pc, #60]	; (b008 <analog_init+0xc0>)

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    afca:	adds	r0, #8
	VREF_TRM = 0x60;
	VREF_SC = 0xE1;		// enable 1.2 volt ref
	#endif

	if (analog_config_bits == 8) {
		ADC0_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
    afcc:	movs	r2, #1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    afce:	movs	r3, #19
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    afd0:	str	r2, [r5, #0]
		ADC0_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    afd2:	str	r3, [r4, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    afd4:	str	r2, [r0, #0]
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
    afd6:	str	r3, [r1, #0]
    afd8:	b.n	af7c <analog_init+0x34>
		#ifdef HAS_KINETIS_ADC1
		ADC1_CFG1 = ADC_CFG1_8BIT + ADC_CFG1_MODE(0);
		ADC1_CFG2 = ADC_CFG2_MUXSEL + ADC_CFG2_ADLSTS(3);
		#endif
	} else if (analog_config_bits == 10) {
		ADC0_CFG1 = ADC_CFG1_10BIT + ADC_CFG1_MODE(2) + ADC_CFG1_ADLSMP;
    afda:	movs	r2, #57	; 0x39
    afdc:	b.n	afce <analog_init+0x86>
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(0);
		#endif
	} else if (num <= 8) {
		ADC0_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    afde:	movs	r3, #133	; 0x85
    afe0:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL + ADC_SC3_AVGE + ADC_SC3_AVGS(1);
    afe2:	str	r3, [r2, #0]
    afe4:	b.n	afac <analog_init+0x64>
	}
	#endif

	num = analog_num_average;
	if (num <= 1) {
		ADC0_SC3 = ADC_SC3_CAL;  // begin cal
    afe6:	movs	r3, #128	; 0x80
    afe8:	str	r3, [r1, #0]
		#ifdef HAS_KINETIS_ADC1
		ADC1_SC3 = ADC_SC3_CAL;  // begin cal
    afea:	str	r3, [r2, #0]
    afec:	b.n	afac <analog_init+0x64>
    afee:	nop
    aff0:	.word	0x40074000
    aff4:	.word	0x40074001
    aff8:	.word	0x1fff09ac
    affc:	.word	0x4003b008
    b000:	.word	0x4003b00c
    b004:	.word	0x400bb008
    b008:	.word	0x400bb00c
    b00c:	.word	0x1fff1b42
    b010:	.word	0x4003b020
    b014:	.word	0x400bb020
    b018:	.word	0x1fff09ad
    b01c:	.word	0x4003b024
    b020:	.word	0x400bb024
    b024:	.word	0x1fff1b41

0000b028 <serial2_available>:

int serial2_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b028:	ldr	r2, [pc, #20]	; (b040 <serial2_available+0x18>)
	tail = rx_buffer_tail;
    b02a:	ldr	r3, [pc, #24]	; (b044 <serial2_available+0x1c>)

int serial2_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b02c:	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    b02e:	ldrb	r3, [r3, #0]

int serial2_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b030:	uxtb	r0, r0
	tail = rx_buffer_tail;
    b032:	uxtb	r3, r3
	if (head >= tail) return head - tail;
    b034:	cmp	r0, r3
	return SERIAL2_RX_BUFFER_SIZE + head - tail;
    b036:	it	cc
    b038:	addcc	r0, #64	; 0x40
    b03a:	subs	r0, r0, r3
}
    b03c:	bx	lr
    b03e:	nop
    b040:	.word	0x1fff1bb4
    b044:	.word	0x1fff1b49

0000b048 <uart1_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart1_status_isr(void)
{
    b048:	push	{r4, r5, r6, r7}
	uint8_t c;
#ifdef HAS_KINETISK_UART1_FIFO
	uint32_t newhead;
	uint8_t avail;

	if (UART1_S1 & (UART_S1_RDRF | UART_S1_IDLE)) {
    b04a:	ldr	r3, [pc, #224]	; (b12c <uart1_status_isr+0xe4>)
    b04c:	ldrb	r2, [r3, #4]
    b04e:	tst.w	r2, #48	; 0x30
    b052:	beq.n	b0ae <uart1_status_isr+0x66>
		__disable_irq();
    b054:	cpsid	i
		avail = UART1_RCFIFO;
    b056:	ldrb	r1, [r3, #22]
		if (avail == 0) {
    b058:	and.w	r2, r1, #255	; 0xff
    b05c:	cmp	r1, #0
    b05e:	beq.n	b0dc <uart1_status_isr+0x94>
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
    b060:	cpsie	i
			head = rx_buffer_head;
    b062:	ldr	r7, [pc, #204]	; (b130 <uart1_status_isr+0xe8>)
			tail = rx_buffer_tail;
    b064:	ldr	r1, [pc, #204]	; (b134 <uart1_status_isr+0xec>)
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
    b066:	ldrb	r0, [r7, #0]
			tail = rx_buffer_tail;
    b068:	ldrb	r5, [r1, #0]
				}
				newhead = head + 1;
				if (newhead >= SERIAL2_RX_BUFFER_SIZE) newhead = 0;
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
    b06a:	ldr	r6, [pc, #204]	; (b138 <uart1_status_isr+0xf0>)
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART1_C3 & 0x80)) {
					n = UART1_D | 0x100;
				} else {
					n = UART1_D;
    b06c:	mov	r4, r3
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
			__enable_irq();
		} else {
			__enable_irq();
			head = rx_buffer_head;
    b06e:	uxtb	r0, r0
			tail = rx_buffer_tail;
    b070:	uxtb	r5, r5
				if (use9Bits && (UART1_C3 & 0x80)) {
					n = UART1_D | 0x100;
				} else {
					n = UART1_D;
				}
				newhead = head + 1;
    b072:	adds	r3, r0, #1
				if (newhead >= SERIAL2_RX_BUFFER_SIZE) newhead = 0;
    b074:	cmp	r3, #64	; 0x40
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART1_C3 & 0x80)) {
					n = UART1_D | 0x100;
				} else {
					n = UART1_D;
    b076:	ldrb	r1, [r4, #7]
				}
				newhead = head + 1;
				if (newhead >= SERIAL2_RX_BUFFER_SIZE) newhead = 0;
    b078:	it	cs
    b07a:	movcs	r3, #0
				if (newhead != tail) {
    b07c:	cmp	r3, r5
					head = newhead;
					rx_buffer[head] = n;
				}
			} while (--avail > 0);
    b07e:	add.w	r2, r2, #4294967295
			tail = rx_buffer_tail;
			do {
				if (use9Bits && (UART1_C3 & 0x80)) {
					n = UART1_D | 0x100;
				} else {
					n = UART1_D;
    b082:	uxtb	r1, r1
				}
				newhead = head + 1;
				if (newhead >= SERIAL2_RX_BUFFER_SIZE) newhead = 0;
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
    b084:	itt	ne
    b086:	strbne	r1, [r6, r3]
    b088:	movne	r0, r3
				}
			} while (--avail > 0);
    b08a:	ands.w	r2, r2, #255	; 0xff
    b08e:	bne.n	b072 <uart1_status_isr+0x2a>
			rx_buffer_head = head;
			if (rts_pin) {
    b090:	ldr	r3, [pc, #168]	; (b13c <uart1_status_isr+0xf4>)
    b092:	ldr	r3, [r3, #0]
				if (newhead != tail) {
					head = newhead;
					rx_buffer[head] = n;
				}
			} while (--avail > 0);
			rx_buffer_head = head;
    b094:	uxtb	r2, r0
    b096:	strb	r2, [r7, #0]
			if (rts_pin) {
    b098:	cbz	r3, b0ae <uart1_status_isr+0x66>
				int avail;
				if (head >= tail) avail = head - tail;
    b09a:	cmp	r0, r5
				else avail = SERIAL2_RX_BUFFER_SIZE + head - tail;
    b09c:	itet	cc
    b09e:	rsbcc	r5, r5, #64	; 0x40
				}
			} while (--avail > 0);
			rx_buffer_head = head;
			if (rts_pin) {
				int avail;
				if (head >= tail) avail = head - tail;
    b0a2:	subcs	r0, r0, r5
				else avail = SERIAL2_RX_BUFFER_SIZE + head - tail;
    b0a4:	addcc	r0, r0, r5
				if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    b0a6:	cmp	r0, #39	; 0x27
    b0a8:	itt	gt
    b0aa:	movgt	r2, #1
    b0ac:	strbgt	r2, [r3, #0]
			}
		}
	}
	c = UART1_C2;
    b0ae:	ldr	r1, [pc, #124]	; (b12c <uart1_status_isr+0xe4>)
    b0b0:	ldrb	r2, [r1, #3]
    b0b2:	uxtb	r2, r2
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
    b0b4:	lsls	r5, r2, #24
    b0b6:	bmi.n	b0e6 <uart1_status_isr+0x9e>
			UART1_D = n;
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART1_S1 & UART_S1_TC)) {
    b0b8:	lsls	r2, r2, #25
    b0ba:	bpl.n	b0d8 <uart1_status_isr+0x90>
    b0bc:	ldr	r3, [pc, #108]	; (b12c <uart1_status_isr+0xe4>)
    b0be:	ldrb	r3, [r3, #4]
    b0c0:	lsls	r3, r3, #25
    b0c2:	bpl.n	b0d8 <uart1_status_isr+0x90>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    b0c4:	ldr	r3, [pc, #120]	; (b140 <uart1_status_isr+0xf8>)
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART1_S1 & UART_S1_TC)) {
		transmitting = 0;
    b0c6:	ldr	r1, [pc, #124]	; (b144 <uart1_status_isr+0xfc>)
		if (transmit_pin) transmit_deassert();
    b0c8:	ldr	r3, [r3, #0]
			tx_buffer_tail = tail;
		}
	}
#endif
	if ((c & UART_C2_TCIE) && (UART1_S1 & UART_S1_TC)) {
		transmitting = 0;
    b0ca:	movs	r2, #0
    b0cc:	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    b0ce:	cbz	r3, b0d2 <uart1_status_isr+0x8a>
    b0d0:	strb	r2, [r3, #0]
		UART1_C2 = C2_TX_INACTIVE;
    b0d2:	ldr	r3, [pc, #88]	; (b12c <uart1_status_isr+0xe4>)
    b0d4:	movs	r2, #60	; 0x3c
    b0d6:	strb	r2, [r3, #3]
	}
}
    b0d8:	pop	{r4, r5, r6, r7}
    b0da:	bx	lr
			// the chance, interrupts are disabled so a higher
			// priority interrupt (hopefully) doesn't delay.
			// TODO: change this to disabling the IDLE interrupt
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
    b0dc:	movs	r2, #64	; 0x40
			// to read the data register.  But reading with no
			// data causes a FIFO underrun, which causes the
			// FIFO to return corrupted data.  If anyone from
			// Freescale reads this, what a poor design!  There
			// write should be a write-1-to-clear for IDLE.
			c = UART1_D;
    b0de:	ldrb	r1, [r3, #7]
			// the chance, interrupts are disabled so a higher
			// priority interrupt (hopefully) doesn't delay.
			// TODO: change this to disabling the IDLE interrupt
			// which won't be simple, since we already manage
			// which transmit interrupts are enabled.
			UART1_CFIFO = UART_CFIFO_RXFLUSH;
    b0e0:	strb	r2, [r3, #17]
			__enable_irq();
    b0e2:	cpsie	i
    b0e4:	b.n	b0ae <uart1_status_isr+0x66>
				if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
			}
		}
	}
	c = UART1_C2;
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
    b0e6:	ldrb	r3, [r1, #4]
    b0e8:	lsls	r4, r3, #24
    b0ea:	bpl.n	b0b8 <uart1_status_isr+0x70>
		head = tx_buffer_head;
    b0ec:	ldr	r3, [pc, #88]	; (b148 <uart1_status_isr+0x100>)
		tail = tx_buffer_tail;
    b0ee:	ldr	r6, [pc, #92]	; (b14c <uart1_status_isr+0x104>)
			}
		}
	}
	c = UART1_C2;
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    b0f0:	ldrb	r4, [r3, #0]
		tail = tx_buffer_tail;
    b0f2:	ldrb	r3, [r6, #0]
			}
		}
	}
	c = UART1_C2;
	if ((c & UART_C2_TIE) && (UART1_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    b0f4:	uxtb	r4, r4
		tail = tx_buffer_tail;
    b0f6:	uxtb	r3, r3
		do {
			if (tail == head) break;
    b0f8:	cmp	r4, r3
    b0fa:	beq.n	b11a <uart1_status_isr+0xd2>
    b0fc:	ldr	r5, [pc, #80]	; (b150 <uart1_status_isr+0x108>)
    b0fe:	b.n	b104 <uart1_status_isr+0xbc>
    b100:	cmp	r3, r4
    b102:	beq.n	b11a <uart1_status_isr+0xd2>
			if (++tail >= SERIAL2_TX_BUFFER_SIZE) tail = 0;
    b104:	adds	r3, #1
    b106:	cmp	r3, #40	; 0x28
    b108:	it	cs
    b10a:	movcs	r3, #0
			avail = UART1_S1;
    b10c:	ldrb	r0, [r1, #4]
			n = tx_buffer[tail];
    b10e:	ldrb	r0, [r5, r3]
    b110:	uxtb	r0, r0
			if (use9Bits) UART1_C3 = (UART1_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART1_D = n;
    b112:	strb	r0, [r1, #7]
		} while (UART1_TCFIFO < 8);
    b114:	ldrb	r0, [r1, #20]
    b116:	cmp	r0, #7
    b118:	bls.n	b100 <uart1_status_isr+0xb8>
		tx_buffer_tail = tail;
    b11a:	uxtb	r3, r3
		if (UART1_S1 & UART_S1_TDRE) UART1_C2 = C2_TX_COMPLETING;
    b11c:	ldr	r1, [pc, #12]	; (b12c <uart1_status_isr+0xe4>)
			avail = UART1_S1;
			n = tx_buffer[tail];
			if (use9Bits) UART1_C3 = (UART1_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART1_D = n;
		} while (UART1_TCFIFO < 8);
		tx_buffer_tail = tail;
    b11e:	strb	r3, [r6, #0]
		if (UART1_S1 & UART_S1_TDRE) UART1_C2 = C2_TX_COMPLETING;
    b120:	ldrb	r3, [r1, #4]
    b122:	lsls	r0, r3, #24
    b124:	itt	mi
    b126:	movmi	r3, #124	; 0x7c
    b128:	strbmi	r3, [r1, #3]
    b12a:	b.n	b0b8 <uart1_status_isr+0x70>
    b12c:	.word	0x4006b000
    b130:	.word	0x1fff1bb4
    b134:	.word	0x1fff1b49
    b138:	.word	0x1fff1b74
    b13c:	.word	0x1fff1b44
    b140:	.word	0x1fff1bb8
    b144:	.word	0x1fff1b48
    b148:	.word	0x1fff1bbc
    b14c:	.word	0x1fff1bb5
    b150:	.word	0x1fff1b4c

0000b154 <serial4_available>:

int serial4_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b154:	ldr	r2, [pc, #20]	; (b16c <serial4_available+0x18>)
	tail = rx_buffer_tail;
    b156:	ldr	r3, [pc, #24]	; (b170 <serial4_available+0x1c>)

int serial4_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b158:	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    b15a:	ldrb	r3, [r3, #0]

int serial4_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b15c:	uxtb	r0, r0
	tail = rx_buffer_tail;
    b15e:	uxtb	r3, r3
	if (head >= tail) return head - tail;
    b160:	cmp	r0, r3
	return SERIAL4_RX_BUFFER_SIZE + head - tail;
    b162:	it	cc
    b164:	addcc	r0, #64	; 0x40
    b166:	subs	r0, r0, r3
}
    b168:	bx	lr
    b16a:	nop
    b16c:	.word	0x1fff1bc4
    b170:	.word	0x1fff1bc5

0000b174 <uart3_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart3_status_isr(void)
{
    b174:	push	{r4, r5}
	uint32_t head, tail, n;
	uint8_t c;

	if (UART3_S1 & UART_S1_RDRF) {
    b176:	ldr	r3, [pc, #172]	; (b224 <uart3_status_isr+0xb0>)
    b178:	ldrb	r2, [r3, #4]
    b17a:	lsls	r4, r2, #26
    b17c:	bpl.n	b1be <uart3_status_isr+0x4a>
		if (use9Bits && (UART3_C3 & 0x80)) {
			n = UART3_D | 0x100;
		} else {
			n = UART3_D;
		}
		head = rx_buffer_head + 1;
    b17e:	ldr	r0, [pc, #168]	; (b228 <uart3_status_isr+0xb4>)

	if (UART3_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART3_C3 & 0x80)) {
			n = UART3_D | 0x100;
		} else {
			n = UART3_D;
    b180:	ldrb	r2, [r3, #7]
		}
		head = rx_buffer_head + 1;
    b182:	ldrb	r3, [r0, #0]
		if (head >= SERIAL4_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    b184:	ldr	r1, [pc, #164]	; (b22c <uart3_status_isr+0xb8>)
		if (use9Bits && (UART3_C3 & 0x80)) {
			n = UART3_D | 0x100;
		} else {
			n = UART3_D;
		}
		head = rx_buffer_head + 1;
    b186:	adds	r3, #1
    b188:	cmp	r3, #63	; 0x3f
		if (head >= SERIAL4_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    b18a:	ldrb	r1, [r1, #0]
		if (use9Bits && (UART3_C3 & 0x80)) {
			n = UART3_D | 0x100;
		} else {
			n = UART3_D;
		}
		head = rx_buffer_head + 1;
    b18c:	it	gt
    b18e:	movgt	r3, #0
		if (head >= SERIAL4_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    b190:	cmp	r3, r1

	if (UART3_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART3_C3 & 0x80)) {
			n = UART3_D | 0x100;
		} else {
			n = UART3_D;
    b192:	uxtb	r2, r2
		}
		head = rx_buffer_head + 1;
		if (head >= SERIAL4_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    b194:	beq.n	b19e <uart3_status_isr+0x2a>
			rx_buffer[head] = n;
    b196:	ldr	r4, [pc, #152]	; (b230 <uart3_status_isr+0xbc>)
			rx_buffer_head = head;
    b198:	uxtb	r1, r3
			n = UART3_D;
		}
		head = rx_buffer_head + 1;
		if (head >= SERIAL4_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
			rx_buffer[head] = n;
    b19a:	strb	r2, [r4, r3]
			rx_buffer_head = head;
    b19c:	strb	r1, [r0, #0]
		}
		if (rts_pin) {
    b19e:	ldr	r2, [pc, #148]	; (b234 <uart3_status_isr+0xc0>)
    b1a0:	ldr	r1, [r2, #0]
    b1a2:	cbz	r1, b1be <uart3_status_isr+0x4a>
			int avail;
			tail = tx_buffer_tail;
    b1a4:	ldr	r2, [pc, #144]	; (b238 <uart3_status_isr+0xc4>)
    b1a6:	ldrb	r2, [r2, #0]
    b1a8:	uxtb	r2, r2
			if (head >= tail) avail = head - tail;
    b1aa:	cmp	r3, r2
			else avail = SERIAL4_RX_BUFFER_SIZE + head - tail;
    b1ac:	itet	cc
    b1ae:	rsbcc	r2, r2, #64	; 0x40
			rx_buffer_head = head;
		}
		if (rts_pin) {
			int avail;
			tail = tx_buffer_tail;
			if (head >= tail) avail = head - tail;
    b1b2:	subcs	r3, r3, r2
			else avail = SERIAL4_RX_BUFFER_SIZE + head - tail;
    b1b4:	addcc	r3, r3, r2
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    b1b6:	cmp	r3, #39	; 0x27
    b1b8:	itt	gt
    b1ba:	movgt	r3, #1
    b1bc:	strbgt	r3, [r1, #0]
		}
	}
	c = UART3_C2;
    b1be:	ldr	r2, [pc, #100]	; (b224 <uart3_status_isr+0xb0>)
    b1c0:	ldrb	r3, [r2, #3]
    b1c2:	uxtb	r3, r3
	if ((c & UART_C2_TIE) && (UART3_S1 & UART_S1_TDRE)) {
    b1c4:	lsls	r0, r3, #24
    b1c6:	bmi.n	b1ec <uart3_status_isr+0x78>
			if (use9Bits) UART3_C3 = (UART3_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART3_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART3_S1 & UART_S1_TC)) {
    b1c8:	lsls	r2, r3, #25
    b1ca:	bpl.n	b1e8 <uart3_status_isr+0x74>
    b1cc:	ldr	r3, [pc, #84]	; (b224 <uart3_status_isr+0xb0>)
    b1ce:	ldrb	r3, [r3, #4]
    b1d0:	lsls	r3, r3, #25
    b1d2:	bpl.n	b1e8 <uart3_status_isr+0x74>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    b1d4:	ldr	r3, [pc, #100]	; (b23c <uart3_status_isr+0xc8>)
			UART3_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART3_S1 & UART_S1_TC)) {
		transmitting = 0;
    b1d6:	ldr	r1, [pc, #104]	; (b240 <uart3_status_isr+0xcc>)
		if (transmit_pin) transmit_deassert();
    b1d8:	ldr	r3, [r3, #0]
			UART3_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART3_S1 & UART_S1_TC)) {
		transmitting = 0;
    b1da:	movs	r2, #0
    b1dc:	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    b1de:	cbz	r3, b1e2 <uart3_status_isr+0x6e>
    b1e0:	strb	r2, [r3, #0]
		UART3_C2 = C2_TX_INACTIVE;
    b1e2:	ldr	r3, [pc, #64]	; (b224 <uart3_status_isr+0xb0>)
    b1e4:	movs	r2, #44	; 0x2c
    b1e6:	strb	r2, [r3, #3]
	}
}
    b1e8:	pop	{r4, r5}
    b1ea:	bx	lr
			else avail = SERIAL4_RX_BUFFER_SIZE + head - tail;
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART3_C2;
	if ((c & UART_C2_TIE) && (UART3_S1 & UART_S1_TDRE)) {
    b1ec:	ldrb	r1, [r2, #4]
    b1ee:	lsls	r1, r1, #24
    b1f0:	bpl.n	b1c8 <uart3_status_isr+0x54>
		head = tx_buffer_head;
    b1f2:	ldr	r1, [pc, #80]	; (b244 <uart3_status_isr+0xd0>)
		tail = tx_buffer_tail;
    b1f4:	ldr	r0, [pc, #64]	; (b238 <uart3_status_isr+0xc4>)
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART3_C2;
	if ((c & UART_C2_TIE) && (UART3_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    b1f6:	ldrb	r4, [r1, #0]
		tail = tx_buffer_tail;
    b1f8:	ldrb	r1, [r0, #0]
    b1fa:	uxtb	r1, r1
		if (head == tail) {
    b1fc:	cmp	r4, r1
    b1fe:	beq.n	b21c <uart3_status_isr+0xa8>
			UART3_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL4_TX_BUFFER_SIZE) tail = 0;
    b200:	adds	r2, r1, #1
    b202:	cmp	r2, #39	; 0x27
    b204:	itt	hi
    b206:	movhi	r1, #0
    b208:	movhi	r2, r1
			n = tx_buffer[tail];
    b20a:	ldr	r5, [pc, #60]	; (b248 <uart3_status_isr+0xd4>)
			if (use9Bits) UART3_C3 = (UART3_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART3_D = n;
    b20c:	ldr	r4, [pc, #20]	; (b224 <uart3_status_isr+0xb0>)
    b20e:	it	ls
    b210:	uxtbls	r1, r2
		tail = tx_buffer_tail;
		if (head == tail) {
			UART3_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL4_TX_BUFFER_SIZE) tail = 0;
			n = tx_buffer[tail];
    b212:	ldrb	r2, [r5, r2]
    b214:	uxtb	r2, r2
			if (use9Bits) UART3_C3 = (UART3_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART3_D = n;
    b216:	strb	r2, [r4, #7]
			tx_buffer_tail = tail;
    b218:	strb	r1, [r0, #0]
    b21a:	b.n	b1c8 <uart3_status_isr+0x54>
	c = UART3_C2;
	if ((c & UART_C2_TIE) && (UART3_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			UART3_C2 = C2_TX_COMPLETING;
    b21c:	movs	r1, #108	; 0x6c
    b21e:	strb	r1, [r2, #3]
    b220:	b.n	b1c8 <uart3_status_isr+0x54>
    b222:	nop
    b224:	.word	0x4006d000
    b228:	.word	0x1fff1bc4
    b22c:	.word	0x1fff1bc5
    b230:	.word	0x1fff1bf0
    b234:	.word	0x1fff1bc0
    b238:	.word	0x1fff1c31
    b23c:	.word	0x1fff1c34
    b240:	.word	0x1fff1c30
    b244:	.word	0x1fff1c38
    b248:	.word	0x1fff1bc8

0000b24c <serial6_available>:

int serial6_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b24c:	ldr	r2, [pc, #20]	; (b264 <serial6_available+0x18>)
	tail = rx_buffer_tail;
    b24e:	ldr	r3, [pc, #24]	; (b268 <serial6_available+0x1c>)

int serial6_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b250:	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    b252:	ldrb	r3, [r3, #0]

int serial6_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b254:	uxtb	r0, r0
	tail = rx_buffer_tail;
    b256:	uxtb	r3, r3
	if (head >= tail) return head - tail;
    b258:	cmp	r0, r3
	return SERIAL6_RX_BUFFER_SIZE + head - tail;
    b25a:	it	cc
    b25c:	addcc	r0, #64	; 0x40
    b25e:	subs	r0, r0, r3
}
    b260:	bx	lr
    b262:	nop
    b264:	.word	0x1fff1c40
    b268:	.word	0x1fff1c41

0000b26c <lpuart0_status_isr>:
//   Receive data above watermark   LPUART_STAT_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void lpuart0_status_isr(void)
{
    b26c:	push	{r4, r5}
	uint32_t head, tail, n;
	uint32_t c;

	if (LPUART0_STAT & LPUART_STAT_RDRF) {
    b26e:	ldr	r3, [pc, #176]	; (b320 <lpuart0_status_isr+0xb4>)
    b270:	ldr	r2, [r3, #4]
    b272:	lsls	r4, r2, #10
    b274:	bpl.n	b2b6 <lpuart0_status_isr+0x4a>
//			n = UART5_D | 0x100;
//		} else {
//			n = UART5_D;
//		}
		n = LPUART0_DATA & 0x3ff;	// use only the 10 data bits
		head = rx_buffer_head + 1;
    b276:	ldr	r0, [pc, #172]	; (b324 <lpuart0_status_isr+0xb8>)
//		if (use9Bits && (UART5_C3 & 0x80)) {
//			n = UART5_D | 0x100;
//		} else {
//			n = UART5_D;
//		}
		n = LPUART0_DATA & 0x3ff;	// use only the 10 data bits
    b278:	ldr	r2, [r3, #12]
		head = rx_buffer_head + 1;
    b27a:	ldrb	r3, [r0, #0]
		if (head >= SERIAL6_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    b27c:	ldr	r1, [pc, #168]	; (b328 <lpuart0_status_isr+0xbc>)
//			n = UART5_D | 0x100;
//		} else {
//			n = UART5_D;
//		}
		n = LPUART0_DATA & 0x3ff;	// use only the 10 data bits
		head = rx_buffer_head + 1;
    b27e:	adds	r3, #1
    b280:	cmp	r3, #63	; 0x3f
		if (head >= SERIAL6_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    b282:	ldrb	r1, [r1, #0]
//			n = UART5_D | 0x100;
//		} else {
//			n = UART5_D;
//		}
		n = LPUART0_DATA & 0x3ff;	// use only the 10 data bits
		head = rx_buffer_head + 1;
    b284:	it	gt
    b286:	movgt	r3, #0
		if (head >= SERIAL6_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    b288:	cmp	r3, r1
    b28a:	beq.n	b296 <lpuart0_status_isr+0x2a>
			rx_buffer[head] = n;
    b28c:	ldr	r4, [pc, #156]	; (b32c <lpuart0_status_isr+0xc0>)
    b28e:	uxtb	r2, r2
			rx_buffer_head = head;
    b290:	uxtb	r1, r3
//		}
		n = LPUART0_DATA & 0x3ff;	// use only the 10 data bits
		head = rx_buffer_head + 1;
		if (head >= SERIAL6_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
			rx_buffer[head] = n;
    b292:	strb	r2, [r4, r3]
			rx_buffer_head = head;
    b294:	strb	r1, [r0, #0]
		}
		if (rts_pin) {
    b296:	ldr	r2, [pc, #152]	; (b330 <lpuart0_status_isr+0xc4>)
    b298:	ldr	r1, [r2, #0]
    b29a:	cbz	r1, b2b6 <lpuart0_status_isr+0x4a>
			int avail;
			tail = tx_buffer_tail;
    b29c:	ldr	r2, [pc, #148]	; (b334 <lpuart0_status_isr+0xc8>)
    b29e:	ldrb	r2, [r2, #0]
    b2a0:	uxtb	r2, r2
			if (head >= tail) avail = head - tail;
    b2a2:	cmp	r3, r2
			else avail = SERIAL6_RX_BUFFER_SIZE + head - tail;
    b2a4:	itet	cc
    b2a6:	rsbcc	r2, r2, #64	; 0x40
			rx_buffer_head = head;
		}
		if (rts_pin) {
			int avail;
			tail = tx_buffer_tail;
			if (head >= tail) avail = head - tail;
    b2aa:	subcs	r3, r3, r2
			else avail = SERIAL6_RX_BUFFER_SIZE + head - tail;
    b2ac:	addcc	r3, r3, r2
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    b2ae:	cmp	r3, #39	; 0x27
    b2b0:	itt	gt
    b2b2:	movgt	r3, #1
    b2b4:	strbgt	r3, [r1, #0]
		}
	}
	c = LPUART0_CTRL;
    b2b6:	ldr	r2, [pc, #104]	; (b320 <lpuart0_status_isr+0xb4>)
    b2b8:	ldr	r3, [r2, #8]
	if ((c & LPUART_CTRL_TIE) && (LPUART0_STAT & LPUART_STAT_TDRE)) {
    b2ba:	lsls	r0, r3, #8
    b2bc:	bpl.n	b2c4 <lpuart0_status_isr+0x58>
    b2be:	ldr	r2, [r2, #4]
    b2c0:	lsls	r1, r2, #8
    b2c2:	bmi.n	b2e8 <lpuart0_status_isr+0x7c>
			//if (use9Bits) UART5_C3 = (UART5_C3 & ~0x40) | ((n & 0x100) >> 2);
			LPUART0_DATA = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & LPUART_CTRL_TCIE) && (LPUART0_STAT & LPUART_STAT_TC)) {
    b2c4:	lsls	r2, r3, #9
    b2c6:	bpl.n	b2e4 <lpuart0_status_isr+0x78>
    b2c8:	ldr	r3, [pc, #84]	; (b320 <lpuart0_status_isr+0xb4>)
    b2ca:	ldr	r3, [r3, #4]
    b2cc:	lsls	r3, r3, #9
    b2ce:	bpl.n	b2e4 <lpuart0_status_isr+0x78>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    b2d0:	ldr	r3, [pc, #100]	; (b338 <lpuart0_status_isr+0xcc>)
			LPUART0_DATA = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & LPUART_CTRL_TCIE) && (LPUART0_STAT & LPUART_STAT_TC)) {
		transmitting = 0;
    b2d2:	ldr	r1, [pc, #104]	; (b33c <lpuart0_status_isr+0xd0>)
		if (transmit_pin) transmit_deassert();
    b2d4:	ldr	r3, [r3, #0]
			LPUART0_DATA = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & LPUART_CTRL_TCIE) && (LPUART0_STAT & LPUART_STAT_TC)) {
		transmitting = 0;
    b2d6:	movs	r2, #0
    b2d8:	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    b2da:	cbz	r3, b2de <lpuart0_status_isr+0x72>
    b2dc:	strb	r2, [r3, #0]
		BITBAND_CLR_BIT(LPUART0_CTRL, TCIE_BIT);
    b2de:	ldr	r3, [pc, #96]	; (b340 <lpuart0_status_isr+0xd4>)
    b2e0:	movs	r2, #0
    b2e2:	str	r2, [r3, #0]
		// LPUART0_CTRL &= ~LPUART_CTRL_TCIE; // Actually wondering if we can just leave this one on...
	}
}
    b2e4:	pop	{r4, r5}
    b2e6:	bx	lr
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = LPUART0_CTRL;
	if ((c & LPUART_CTRL_TIE) && (LPUART0_STAT & LPUART_STAT_TDRE)) {
		head = tx_buffer_head;
    b2e8:	ldr	r2, [pc, #88]	; (b344 <lpuart0_status_isr+0xd8>)
		tail = tx_buffer_tail;
    b2ea:	ldr	r1, [pc, #72]	; (b334 <lpuart0_status_isr+0xc8>)
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = LPUART0_CTRL;
	if ((c & LPUART_CTRL_TIE) && (LPUART0_STAT & LPUART_STAT_TDRE)) {
		head = tx_buffer_head;
    b2ec:	ldrb	r0, [r2, #0]
		tail = tx_buffer_tail;
    b2ee:	ldrb	r2, [r1, #0]
    b2f0:	uxtb	r2, r2
		if (head == tail) {
    b2f2:	cmp	r0, r2
    b2f4:	beq.n	b312 <lpuart0_status_isr+0xa6>
			BITBAND_CLR_BIT(LPUART0_CTRL, TIE_BIT);
			BITBAND_SET_BIT(LPUART0_CTRL, TCIE_BIT);
			//LPUART0_CTRL &= ~LPUART_CTRL_TIE; 
  			//LPUART0_CTRL |= LPUART_CTRL_TCIE; // Actually wondering if we can just leave this one on...
		} else {
			if (++tail >= SERIAL6_TX_BUFFER_SIZE) tail = 0;
    b2f6:	adds	r2, #1
    b2f8:	cmp	r2, #39	; 0x27
    b2fa:	itt	hi
    b2fc:	movhi	r0, #0
    b2fe:	movhi	r2, r0
			n = tx_buffer[tail];
    b300:	ldr	r5, [pc, #68]	; (b348 <lpuart0_status_isr+0xdc>)
			//if (use9Bits) UART5_C3 = (UART5_C3 & ~0x40) | ((n & 0x100) >> 2);
			LPUART0_DATA = n;
    b302:	ldr	r4, [pc, #28]	; (b320 <lpuart0_status_isr+0xb4>)
    b304:	it	ls
    b306:	uxtbls	r0, r2
			BITBAND_SET_BIT(LPUART0_CTRL, TCIE_BIT);
			//LPUART0_CTRL &= ~LPUART_CTRL_TIE; 
  			//LPUART0_CTRL |= LPUART_CTRL_TCIE; // Actually wondering if we can just leave this one on...
		} else {
			if (++tail >= SERIAL6_TX_BUFFER_SIZE) tail = 0;
			n = tx_buffer[tail];
    b308:	ldrb	r2, [r5, r2]
    b30a:	uxtb	r2, r2
			//if (use9Bits) UART5_C3 = (UART5_C3 & ~0x40) | ((n & 0x100) >> 2);
			LPUART0_DATA = n;
    b30c:	str	r2, [r4, #12]
			tx_buffer_tail = tail;
    b30e:	strb	r0, [r1, #0]
    b310:	b.n	b2c4 <lpuart0_status_isr+0x58>
	c = LPUART0_CTRL;
	if ((c & LPUART_CTRL_TIE) && (LPUART0_STAT & LPUART_STAT_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			BITBAND_CLR_BIT(LPUART0_CTRL, TIE_BIT);
    b312:	ldr	r0, [pc, #56]	; (b34c <lpuart0_status_isr+0xe0>)
			BITBAND_SET_BIT(LPUART0_CTRL, TCIE_BIT);
    b314:	ldr	r2, [pc, #40]	; (b340 <lpuart0_status_isr+0xd4>)
	c = LPUART0_CTRL;
	if ((c & LPUART_CTRL_TIE) && (LPUART0_STAT & LPUART_STAT_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			BITBAND_CLR_BIT(LPUART0_CTRL, TIE_BIT);
    b316:	movs	r4, #0
			BITBAND_SET_BIT(LPUART0_CTRL, TCIE_BIT);
    b318:	movs	r1, #1
	c = LPUART0_CTRL;
	if ((c & LPUART_CTRL_TIE) && (LPUART0_STAT & LPUART_STAT_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			BITBAND_CLR_BIT(LPUART0_CTRL, TIE_BIT);
    b31a:	str	r4, [r0, #0]
			BITBAND_SET_BIT(LPUART0_CTRL, TCIE_BIT);
    b31c:	str	r1, [r2, #0]
    b31e:	b.n	b2c4 <lpuart0_status_isr+0x58>
    b320:	.word	0x400c4000
    b324:	.word	0x1fff1c40
    b328:	.word	0x1fff1c41
    b32c:	.word	0x1fff1c6c
    b330:	.word	0x1fff1c3c
    b334:	.word	0x1fff1cad
    b338:	.word	0x1fff1cb0
    b33c:	.word	0x1fff1cac
    b340:	.word	0x43880158
    b344:	.word	0x1fff1cb4
    b348:	.word	0x1fff1c44
    b34c:	.word	0x4388015c

0000b350 <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	__disable_irq();
    b350:	cpsid	i
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    b352:	ldr	r2, [pc, #96]	; (b3b4 <usb_init_serialnumber+0x64>)
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    b354:	ldr	r3, [pc, #96]	; (b3b8 <usb_init_serialnumber+0x68>)
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
    b356:	ldr	r1, [pc, #100]	; (b3bc <usb_init_serialnumber+0x6c>)
    b358:	str	r1, [r2, #0]
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    b35a:	movs	r2, #112	; 0x70
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    b35c:	movs	r1, #128	; 0x80
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
    b35e:	strb	r2, [r3, #0]
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    b360:	mov	r2, r3
	num = *(uint32_t *)&FTFL_FCCOB7;
#elif defined(HAS_KINETIS_FLASH_FTFE)
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
    b362:	strb	r1, [r3, #0]
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
    b364:	ldrb	r3, [r2, #0]
    b366:	lsls	r3, r3, #24
    b368:	bpl.n	b364 <usb_init_serialnumber+0x14>
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    b36a:	push	{r4, lr}
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
    b36c:	ldr	r3, [pc, #80]	; (b3c0 <usb_init_serialnumber+0x70>)
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    b36e:	sub	sp, #16
	kinetis_hsrun_disable();
	FTFL_FSTAT = FTFL_FSTAT_RDCOLERR | FTFL_FSTAT_ACCERR | FTFL_FSTAT_FPVIOL;
	*(uint32_t *)&FTFL_FCCOB3 = 0x41070000;
	FTFL_FSTAT = FTFL_FSTAT_CCIF;
	while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF)) ; // wait
	num = *(uint32_t *)&FTFL_FCCOBB;
    b370:	ldr	r0, [r3, #0]
	kinetis_hsrun_enable();
#endif
	__enable_irq();
    b372:	cpsie	i
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    b374:	ldr	r3, [pc, #76]	; (b3c4 <usb_init_serialnumber+0x74>)
    b376:	ldr	r4, [pc, #80]	; (b3c8 <usb_init_serialnumber+0x78>)
    b378:	cmp	r0, r3
    b37a:	it	ls
    b37c:	addls.w	r0, r0, r0, lsl #2
	ultoa(num, buf, 10);
    b380:	add	r1, sp, #4
	num = *(uint32_t *)&FTFL_FCCOBB;
	kinetis_hsrun_enable();
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    b382:	it	ls
    b384:	lslls	r0, r0, #1
	ultoa(num, buf, 10);
    b386:	movs	r2, #10
    b388:	bl	b3cc <ultoa>
    b38c:	add	r1, sp, #4
    b38e:	mov	r0, r4
	for (i=0; i<10; i++) {
    b390:	movs	r3, #0
		char c = buf[i];
    b392:	ldrb.w	r2, [r1], #1
    b396:	adds	r3, #1
		if (!c) break;
    b398:	cbz	r2, b3aa <usb_init_serialnumber+0x5a>
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    b39a:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    b39c:	strh.w	r2, [r0, #2]!
#endif
	__enable_irq();
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    b3a0:	bne.n	b392 <usb_init_serialnumber+0x42>
    b3a2:	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    b3a4:	strb	r3, [r4, #0]
}
    b3a6:	add	sp, #16
    b3a8:	pop	{r4, pc}
    b3aa:	lsls	r3, r3, #1
    b3ac:	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    b3ae:	strb	r3, [r4, #0]
}
    b3b0:	add	sp, #16
    b3b2:	pop	{r4, pc}
    b3b4:	.word	0x40020004
    b3b8:	.word	0x40020000
    b3bc:	.word	0x41070000
    b3c0:	.word	0x4002000c
    b3c4:	.word	0x0098967f
    b3c8:	.word	0x1fff0a84

0000b3cc <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    b3cc:	push	{r4, r5, r6, r7}
    b3ce:	subs	r5, r1, #1
    b3d0:	mov	r6, r5
	unsigned digit;
	int i=0, j;
    b3d2:	movs	r4, #0
    b3d4:	b.n	b3d8 <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    b3d6:	adds	r4, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    b3d8:	udiv	r3, r0, r2
    b3dc:	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    b3e0:	cmp	r0, #9
    b3e2:	add.w	r7, r0, #48	; 0x30
    b3e6:	itet	hi
    b3e8:	addhi	r0, #55	; 0x37
    b3ea:	uxtbls	r0, r7
    b3ec:	uxtbhi	r0, r0
    b3ee:	strb.w	r0, [r6, #1]!
		val /= radix;
		if (val == 0) break;
    b3f2:	mov	r0, r3
    b3f4:	cmp	r3, #0
    b3f6:	bne.n	b3d6 <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    b3f8:	adds	r2, r1, r4
    b3fa:	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    b3fc:	cbz	r4, b412 <ultoa+0x46>
		t = buf[j];
		buf[j] = buf[i];
    b3fe:	ldrb	r0, [r2, #0]
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
		t = buf[j];
    b400:	ldrb.w	r6, [r5, #1]!
		buf[j] = buf[i];
    b404:	strb	r0, [r5, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    b406:	adds	r3, #1
    b408:	subs	r0, r4, r3
    b40a:	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    b40c:	strb.w	r6, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    b410:	blt.n	b3fe <ultoa+0x32>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    b412:	mov	r0, r1
    b414:	pop	{r4, r5, r6, r7}
    b416:	bx	lr

0000b418 <serial3_available>:

int serial3_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b418:	ldr	r2, [pc, #20]	; (b430 <serial3_available+0x18>)
	tail = rx_buffer_tail;
    b41a:	ldr	r3, [pc, #24]	; (b434 <serial3_available+0x1c>)

int serial3_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b41c:	ldrb	r0, [r2, #0]
	tail = rx_buffer_tail;
    b41e:	ldrb	r3, [r3, #0]

int serial3_available(void)
{
	uint32_t head, tail;

	head = rx_buffer_head;
    b420:	uxtb	r0, r0
	tail = rx_buffer_tail;
    b422:	uxtb	r3, r3
	if (head >= tail) return head - tail;
    b424:	cmp	r0, r3
	return SERIAL3_RX_BUFFER_SIZE + head - tail;
    b426:	it	cc
    b428:	addcc	r0, #64	; 0x40
    b42a:	subs	r0, r0, r3
}
    b42c:	bx	lr
    b42e:	nop
    b430:	.word	0x1fff1cbc
    b434:	.word	0x1fff1cbd

0000b438 <uart2_status_isr>:
//   Receive data above watermark   UART_S1_RDRF
//   LIN break detect		    UART_S2_LBKDIF
//   RxD pin active edge	    UART_S2_RXEDGIF

void uart2_status_isr(void)
{
    b438:	push	{r4, r5}
	uint32_t head, tail, n;
	uint8_t c;

	if (UART2_S1 & UART_S1_RDRF) {
    b43a:	ldr	r3, [pc, #172]	; (b4e8 <uart2_status_isr+0xb0>)
    b43c:	ldrb	r2, [r3, #4]
    b43e:	lsls	r4, r2, #26
    b440:	bpl.n	b482 <uart2_status_isr+0x4a>
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
    b442:	ldr	r0, [pc, #168]	; (b4ec <uart2_status_isr+0xb4>)

	if (UART2_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
    b444:	ldrb	r2, [r3, #7]
		}
		head = rx_buffer_head + 1;
    b446:	ldrb	r3, [r0, #0]
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    b448:	ldr	r1, [pc, #164]	; (b4f0 <uart2_status_isr+0xb8>)
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
    b44a:	adds	r3, #1
    b44c:	cmp	r3, #63	; 0x3f
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    b44e:	ldrb	r1, [r1, #0]
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
    b450:	it	gt
    b452:	movgt	r3, #0
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    b454:	cmp	r3, r1

	if (UART2_S1 & UART_S1_RDRF) {
		if (use9Bits && (UART2_C3 & 0x80)) {
			n = UART2_D | 0x100;
		} else {
			n = UART2_D;
    b456:	uxtb	r2, r2
		}
		head = rx_buffer_head + 1;
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
    b458:	beq.n	b462 <uart2_status_isr+0x2a>
			rx_buffer[head] = n;
    b45a:	ldr	r4, [pc, #152]	; (b4f4 <uart2_status_isr+0xbc>)
			rx_buffer_head = head;
    b45c:	uxtb	r1, r3
			n = UART2_D;
		}
		head = rx_buffer_head + 1;
		if (head >= SERIAL3_RX_BUFFER_SIZE) head = 0;
		if (head != rx_buffer_tail) {
			rx_buffer[head] = n;
    b45e:	strb	r2, [r4, r3]
			rx_buffer_head = head;
    b460:	strb	r1, [r0, #0]
		}
		if (rts_pin) {
    b462:	ldr	r2, [pc, #148]	; (b4f8 <uart2_status_isr+0xc0>)
    b464:	ldr	r1, [r2, #0]
    b466:	cbz	r1, b482 <uart2_status_isr+0x4a>
			int avail;
			tail = tx_buffer_tail;
    b468:	ldr	r2, [pc, #144]	; (b4fc <uart2_status_isr+0xc4>)
    b46a:	ldrb	r2, [r2, #0]
    b46c:	uxtb	r2, r2
			if (head >= tail) avail = head - tail;
    b46e:	cmp	r3, r2
			else avail = SERIAL3_RX_BUFFER_SIZE + head - tail;
    b470:	itet	cc
    b472:	rsbcc	r2, r2, #64	; 0x40
			rx_buffer_head = head;
		}
		if (rts_pin) {
			int avail;
			tail = tx_buffer_tail;
			if (head >= tail) avail = head - tail;
    b476:	subcs	r3, r3, r2
			else avail = SERIAL3_RX_BUFFER_SIZE + head - tail;
    b478:	addcc	r3, r3, r2
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
    b47a:	cmp	r3, #39	; 0x27
    b47c:	itt	gt
    b47e:	movgt	r3, #1
    b480:	strbgt	r3, [r1, #0]
		}
	}
	c = UART2_C2;
    b482:	ldr	r2, [pc, #100]	; (b4e8 <uart2_status_isr+0xb0>)
    b484:	ldrb	r3, [r2, #3]
    b486:	uxtb	r3, r3
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
    b488:	lsls	r0, r3, #24
    b48a:	bmi.n	b4b0 <uart2_status_isr+0x78>
			if (use9Bits) UART2_C3 = (UART2_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART2_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART2_S1 & UART_S1_TC)) {
    b48c:	lsls	r2, r3, #25
    b48e:	bpl.n	b4ac <uart2_status_isr+0x74>
    b490:	ldr	r3, [pc, #84]	; (b4e8 <uart2_status_isr+0xb0>)
    b492:	ldrb	r3, [r3, #4]
    b494:	lsls	r3, r3, #25
    b496:	bpl.n	b4ac <uart2_status_isr+0x74>
		transmitting = 0;
		if (transmit_pin) transmit_deassert();
    b498:	ldr	r3, [pc, #100]	; (b500 <uart2_status_isr+0xc8>)
			UART2_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART2_S1 & UART_S1_TC)) {
		transmitting = 0;
    b49a:	ldr	r1, [pc, #104]	; (b504 <uart2_status_isr+0xcc>)
		if (transmit_pin) transmit_deassert();
    b49c:	ldr	r3, [r3, #0]
			UART2_D = n;
			tx_buffer_tail = tail;
		}
	}
	if ((c & UART_C2_TCIE) && (UART2_S1 & UART_S1_TC)) {
		transmitting = 0;
    b49e:	movs	r2, #0
    b4a0:	strb	r2, [r1, #0]
		if (transmit_pin) transmit_deassert();
    b4a2:	cbz	r3, b4a6 <uart2_status_isr+0x6e>
    b4a4:	strb	r2, [r3, #0]
		UART2_C2 = C2_TX_INACTIVE;
    b4a6:	ldr	r3, [pc, #64]	; (b4e8 <uart2_status_isr+0xb0>)
    b4a8:	movs	r2, #44	; 0x2c
    b4aa:	strb	r2, [r3, #3]
	}
}
    b4ac:	pop	{r4, r5}
    b4ae:	bx	lr
			else avail = SERIAL3_RX_BUFFER_SIZE + head - tail;
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART2_C2;
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
    b4b0:	ldrb	r1, [r2, #4]
    b4b2:	lsls	r1, r1, #24
    b4b4:	bpl.n	b48c <uart2_status_isr+0x54>
		head = tx_buffer_head;
    b4b6:	ldr	r1, [pc, #80]	; (b508 <uart2_status_isr+0xd0>)
		tail = tx_buffer_tail;
    b4b8:	ldr	r0, [pc, #64]	; (b4fc <uart2_status_isr+0xc4>)
			if (avail >= RTS_HIGH_WATERMARK) rts_deassert();
		}
	}
	c = UART2_C2;
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
    b4ba:	ldrb	r4, [r1, #0]
		tail = tx_buffer_tail;
    b4bc:	ldrb	r1, [r0, #0]
    b4be:	uxtb	r1, r1
		if (head == tail) {
    b4c0:	cmp	r4, r1
    b4c2:	beq.n	b4e0 <uart2_status_isr+0xa8>
			UART2_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL3_TX_BUFFER_SIZE) tail = 0;
    b4c4:	adds	r2, r1, #1
    b4c6:	cmp	r2, #39	; 0x27
    b4c8:	itt	hi
    b4ca:	movhi	r1, #0
    b4cc:	movhi	r2, r1
			n = tx_buffer[tail];
    b4ce:	ldr	r5, [pc, #60]	; (b50c <uart2_status_isr+0xd4>)
			if (use9Bits) UART2_C3 = (UART2_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART2_D = n;
    b4d0:	ldr	r4, [pc, #20]	; (b4e8 <uart2_status_isr+0xb0>)
    b4d2:	it	ls
    b4d4:	uxtbls	r1, r2
		tail = tx_buffer_tail;
		if (head == tail) {
			UART2_C2 = C2_TX_COMPLETING;
		} else {
			if (++tail >= SERIAL3_TX_BUFFER_SIZE) tail = 0;
			n = tx_buffer[tail];
    b4d6:	ldrb	r2, [r5, r2]
    b4d8:	uxtb	r2, r2
			if (use9Bits) UART2_C3 = (UART2_C3 & ~0x40) | ((n & 0x100) >> 2);
			UART2_D = n;
    b4da:	strb	r2, [r4, #7]
			tx_buffer_tail = tail;
    b4dc:	strb	r1, [r0, #0]
    b4de:	b.n	b48c <uart2_status_isr+0x54>
	c = UART2_C2;
	if ((c & UART_C2_TIE) && (UART2_S1 & UART_S1_TDRE)) {
		head = tx_buffer_head;
		tail = tx_buffer_tail;
		if (head == tail) {
			UART2_C2 = C2_TX_COMPLETING;
    b4e0:	movs	r1, #108	; 0x6c
    b4e2:	strb	r1, [r2, #3]
    b4e4:	b.n	b48c <uart2_status_isr+0x54>
    b4e6:	nop
    b4e8:	.word	0x4006c000
    b4ec:	.word	0x1fff1cbc
    b4f0:	.word	0x1fff1cbd
    b4f4:	.word	0x1fff1ce8
    b4f8:	.word	0x1fff1cb8
    b4fc:	.word	0x1fff1d29
    b500:	.word	0x1fff1d2c
    b504:	.word	0x1fff1d28
    b508:	.word	0x1fff1d30
    b50c:	.word	0x1fff1cc0

0000b510 <serialEvent3()>:
#include "HardwareSerial.h"

HardwareSerial3 Serial3;

void serialEvent3() __attribute__((weak));
void serialEvent3() {}
    b510:	bx	lr
    b512:	nop

0000b514 <__aeabi_atexit>:
    b514:	mov	r3, r1
    b516:	mov	r1, r0
    b518:	mov	r0, r3
    b51a:	b.w	b520 <__cxa_atexit>
    b51e:	nop

0000b520 <__cxa_atexit>:
    b520:	mov	r3, r2
    b522:	mov	r2, r1
    b524:	mov	r1, r0
    b526:	movs	r0, #2
    b528:	b.w	bebc <__register_exitproc>

0000b52c <__errno>:
    b52c:	ldr	r3, [pc, #4]	; (b534 <__errno+0x8>)
    b52e:	ldr	r0, [r3, #0]
    b530:	bx	lr
    b532:	nop
    b534:	.word	0x1fff0ec8

0000b538 <__libc_init_array>:
    b538:	push	{r4, r5, r6, lr}
    b53a:	ldr	r6, [pc, #60]	; (b578 <__libc_init_array+0x40>)
    b53c:	ldr	r5, [pc, #60]	; (b57c <__libc_init_array+0x44>)
    b53e:	subs	r6, r6, r5
    b540:	asrs	r6, r6, #2
    b542:	it	ne
    b544:	movne	r4, #0
    b546:	beq.n	b554 <__libc_init_array+0x1c>
    b548:	adds	r4, #1
    b54a:	ldr.w	r3, [r5], #4
    b54e:	blx	r3
    b550:	cmp	r6, r4
    b552:	bne.n	b548 <__libc_init_array+0x10>
    b554:	ldr	r6, [pc, #40]	; (b580 <__libc_init_array+0x48>)
    b556:	ldr	r5, [pc, #44]	; (b584 <__libc_init_array+0x4c>)
    b558:	subs	r6, r6, r5
    b55a:	bl	c848 <_init>
    b55e:	asrs	r6, r6, #2
    b560:	it	ne
    b562:	movne	r4, #0
    b564:	beq.n	b574 <__libc_init_array+0x3c>
    b566:	adds	r4, #1
    b568:	ldr.w	r3, [r5], #4
    b56c:	blx	r3
    b56e:	cmp	r6, r4
    b570:	bne.n	b566 <__libc_init_array+0x2e>
    b572:	pop	{r4, r5, r6, pc}
    b574:	pop	{r4, r5, r6, pc}
    b576:	nop
    b578:	.word	0x0000c854
    b57c:	.word	0x0000c854
    b580:	.word	0x0000c864
    b584:	.word	0x0000c854

0000b588 <malloc>:
    b588:	ldr	r3, [pc, #8]	; (b594 <malloc+0xc>)
    b58a:	mov	r1, r0
    b58c:	ldr	r0, [r3, #0]
    b58e:	b.w	b5a8 <_malloc_r>
    b592:	nop
    b594:	.word	0x1fff0ec8

0000b598 <free>:
    b598:	ldr	r3, [pc, #8]	; (b5a4 <free+0xc>)
    b59a:	mov	r1, r0
    b59c:	ldr	r0, [r3, #0]
    b59e:	b.w	c044 <_free_r>
    b5a2:	nop
    b5a4:	.word	0x1fff0ec8

0000b5a8 <_malloc_r>:
    b5a8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b5ac:	add.w	r5, r1, #11
    b5b0:	cmp	r5, #22
    b5b2:	sub	sp, #12
    b5b4:	mov	r6, r0
    b5b6:	bls.w	b6f8 <_malloc_r+0x150>
    b5ba:	bics.w	r5, r5, #7
    b5be:	bmi.w	b740 <_malloc_r+0x198>
    b5c2:	cmp	r1, r5
    b5c4:	bhi.w	b740 <_malloc_r+0x198>
    b5c8:	bl	bc18 <__malloc_lock>
    b5cc:	cmp.w	r5, #504	; 0x1f8
    b5d0:	bcc.w	bb0c <_malloc_r+0x564>
    b5d4:	lsrs	r3, r5, #9
    b5d6:	beq.w	b74e <_malloc_r+0x1a6>
    b5da:	cmp	r3, #4
    b5dc:	bhi.w	b8e6 <_malloc_r+0x33e>
    b5e0:	lsrs	r0, r5, #6
    b5e2:	add.w	lr, r0, #57	; 0x39
    b5e6:	mov.w	r3, lr, lsl #1
    b5ea:	adds	r0, #56	; 0x38
    b5ec:	ldr	r7, [pc, #784]	; (b900 <_malloc_r+0x358>)
    b5ee:	add.w	r3, r7, r3, lsl #2
    b5f2:	sub.w	r1, r3, #8
    b5f6:	ldr	r4, [r3, #4]
    b5f8:	cmp	r1, r4
    b5fa:	bne.n	b60c <_malloc_r+0x64>
    b5fc:	b.n	b758 <_malloc_r+0x1b0>
    b5fe:	cmp	r2, #0
    b600:	bge.w	b75c <_malloc_r+0x1b4>
    b604:	ldr	r4, [r4, #12]
    b606:	cmp	r1, r4
    b608:	beq.w	b758 <_malloc_r+0x1b0>
    b60c:	ldr	r3, [r4, #4]
    b60e:	bic.w	r3, r3, #3
    b612:	subs	r2, r3, r5
    b614:	cmp	r2, #15
    b616:	ble.n	b5fe <_malloc_r+0x56>
    b618:	ldr	r1, [pc, #740]	; (b900 <_malloc_r+0x358>)
    b61a:	ldr	r4, [r7, #16]
    b61c:	add.w	lr, r1, #8
    b620:	cmp	r4, lr
    b622:	beq.w	b98c <_malloc_r+0x3e4>
    b626:	ldr	r3, [r4, #4]
    b628:	bic.w	r3, r3, #3
    b62c:	subs	r2, r3, r5
    b62e:	cmp	r2, #15
    b630:	bgt.w	b966 <_malloc_r+0x3be>
    b634:	cmp	r2, #0
    b636:	str.w	lr, [r1, #20]
    b63a:	str.w	lr, [r1, #16]
    b63e:	bge.w	b77e <_malloc_r+0x1d6>
    b642:	cmp.w	r3, #512	; 0x200
    b646:	bcs.w	b918 <_malloc_r+0x370>
    b64a:	lsrs	r3, r3, #3
    b64c:	add.w	ip, r3, #1
    b650:	movs	r2, #1
    b652:	asrs	r3, r3, #2
    b654:	lsl.w	r3, r2, r3
    b658:	ldr	r2, [r1, #4]
    b65a:	ldr.w	r8, [r1, ip, lsl #3]
    b65e:	str.w	r8, [r4, #8]
    b662:	add.w	r9, r1, ip, lsl #3
    b666:	orrs	r2, r3
    b668:	sub.w	r3, r9, #8
    b66c:	str	r3, [r4, #12]
    b66e:	str	r2, [r1, #4]
    b670:	str.w	r4, [r1, ip, lsl #3]
    b674:	str.w	r4, [r8, #12]
    b678:	asrs	r3, r0, #2
    b67a:	movs	r4, #1
    b67c:	lsls	r4, r3
    b67e:	cmp	r4, r2
    b680:	bhi.w	b798 <_malloc_r+0x1f0>
    b684:	tst	r4, r2
    b686:	bne.n	b696 <_malloc_r+0xee>
    b688:	bic.w	r0, r0, #3
    b68c:	lsls	r4, r4, #1
    b68e:	tst	r4, r2
    b690:	add.w	r0, r0, #4
    b694:	beq.n	b68c <_malloc_r+0xe4>
    b696:	add.w	r9, r7, r0, lsl #3
    b69a:	mov	ip, r9
    b69c:	mov	r8, r0
    b69e:	ldr.w	r1, [ip, #12]
    b6a2:	cmp	ip, r1
    b6a4:	bne.n	b6b6 <_malloc_r+0x10e>
    b6a6:	b.n	b990 <_malloc_r+0x3e8>
    b6a8:	cmp	r2, #0
    b6aa:	bge.w	b9b0 <_malloc_r+0x408>
    b6ae:	ldr	r1, [r1, #12]
    b6b0:	cmp	ip, r1
    b6b2:	beq.w	b990 <_malloc_r+0x3e8>
    b6b6:	ldr	r3, [r1, #4]
    b6b8:	bic.w	r3, r3, #3
    b6bc:	subs	r2, r3, r5
    b6be:	cmp	r2, #15
    b6c0:	ble.n	b6a8 <_malloc_r+0x100>
    b6c2:	mov	r4, r1
    b6c4:	ldr.w	ip, [r1, #12]
    b6c8:	ldr.w	r8, [r4, #8]!
    b6cc:	adds	r3, r1, r5
    b6ce:	orr.w	r5, r5, #1
    b6d2:	str	r5, [r1, #4]
    b6d4:	orr.w	r1, r2, #1
    b6d8:	str.w	ip, [r8, #12]
    b6dc:	mov	r0, r6
    b6de:	str.w	r8, [ip, #8]
    b6e2:	str	r3, [r7, #20]
    b6e4:	str	r3, [r7, #16]
    b6e6:	str.w	lr, [r3, #12]
    b6ea:	str.w	lr, [r3, #8]
    b6ee:	str	r1, [r3, #4]
    b6f0:	str	r2, [r3, r2]
    b6f2:	bl	bc1c <__malloc_unlock>
    b6f6:	b.n	b738 <_malloc_r+0x190>
    b6f8:	cmp	r1, #16
    b6fa:	bhi.n	b740 <_malloc_r+0x198>
    b6fc:	bl	bc18 <__malloc_lock>
    b700:	movs	r5, #16
    b702:	movs	r3, #6
    b704:	movs	r0, #2
    b706:	ldr	r7, [pc, #504]	; (b900 <_malloc_r+0x358>)
    b708:	add.w	r3, r7, r3, lsl #2
    b70c:	sub.w	r2, r3, #8
    b710:	ldr	r4, [r3, #4]
    b712:	cmp	r4, r2
    b714:	beq.w	b9a2 <_malloc_r+0x3fa>
    b718:	ldr	r3, [r4, #4]
    b71a:	ldr	r1, [r4, #12]
    b71c:	ldr	r5, [r4, #8]
    b71e:	bic.w	r3, r3, #3
    b722:	add	r3, r4
    b724:	mov	r0, r6
    b726:	ldr	r2, [r3, #4]
    b728:	str	r1, [r5, #12]
    b72a:	orr.w	r2, r2, #1
    b72e:	str	r5, [r1, #8]
    b730:	str	r2, [r3, #4]
    b732:	bl	bc1c <__malloc_unlock>
    b736:	adds	r4, #8
    b738:	mov	r0, r4
    b73a:	add	sp, #12
    b73c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b740:	movs	r4, #0
    b742:	movs	r3, #12
    b744:	mov	r0, r4
    b746:	str	r3, [r6, #0]
    b748:	add	sp, #12
    b74a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b74e:	movs	r3, #128	; 0x80
    b750:	mov.w	lr, #64	; 0x40
    b754:	movs	r0, #63	; 0x3f
    b756:	b.n	b5ec <_malloc_r+0x44>
    b758:	mov	r0, lr
    b75a:	b.n	b618 <_malloc_r+0x70>
    b75c:	add	r3, r4
    b75e:	ldr	r1, [r4, #12]
    b760:	ldr	r2, [r3, #4]
    b762:	ldr	r5, [r4, #8]
    b764:	orr.w	r2, r2, #1
    b768:	str	r1, [r5, #12]
    b76a:	mov	r0, r6
    b76c:	str	r5, [r1, #8]
    b76e:	str	r2, [r3, #4]
    b770:	bl	bc1c <__malloc_unlock>
    b774:	adds	r4, #8
    b776:	mov	r0, r4
    b778:	add	sp, #12
    b77a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b77e:	add	r3, r4
    b780:	mov	r0, r6
    b782:	ldr	r2, [r3, #4]
    b784:	orr.w	r2, r2, #1
    b788:	str	r2, [r3, #4]
    b78a:	bl	bc1c <__malloc_unlock>
    b78e:	adds	r4, #8
    b790:	mov	r0, r4
    b792:	add	sp, #12
    b794:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b798:	ldr	r4, [r7, #8]
    b79a:	ldr	r3, [r4, #4]
    b79c:	bic.w	r8, r3, #3
    b7a0:	cmp	r8, r5
    b7a2:	bcc.n	b7ae <_malloc_r+0x206>
    b7a4:	rsb	r3, r5, r8
    b7a8:	cmp	r3, #15
    b7aa:	bgt.w	b8c6 <_malloc_r+0x31e>
    b7ae:	ldr	r3, [pc, #340]	; (b904 <_malloc_r+0x35c>)
    b7b0:	ldr.w	r9, [pc, #352]	; b914 <_malloc_r+0x36c>
    b7b4:	ldr	r2, [r3, #0]
    b7b6:	ldr.w	r3, [r9]
    b7ba:	adds	r3, #1
    b7bc:	add	r2, r5
    b7be:	add.w	sl, r4, r8
    b7c2:	beq.w	ba86 <_malloc_r+0x4de>
    b7c6:	add.w	r2, r2, #4096	; 0x1000
    b7ca:	adds	r2, #15
    b7cc:	bic.w	r2, r2, #4080	; 0xff0
    b7d0:	bic.w	r2, r2, #15
    b7d4:	mov	r1, r2
    b7d6:	mov	r0, r6
    b7d8:	str	r2, [sp, #4]
    b7da:	bl	bc20 <_sbrk_r>
    b7de:	cmp.w	r0, #4294967295
    b7e2:	mov	fp, r0
    b7e4:	ldr	r2, [sp, #4]
    b7e6:	beq.w	ba9a <_malloc_r+0x4f2>
    b7ea:	cmp	sl, r0
    b7ec:	bhi.w	b9e8 <_malloc_r+0x440>
    b7f0:	ldr	r3, [pc, #276]	; (b908 <_malloc_r+0x360>)
    b7f2:	ldr	r1, [r3, #0]
    b7f4:	cmp	sl, fp
    b7f6:	add	r1, r2
    b7f8:	str	r1, [r3, #0]
    b7fa:	beq.w	baa4 <_malloc_r+0x4fc>
    b7fe:	ldr.w	r0, [r9]
    b802:	ldr.w	lr, [pc, #272]	; b914 <_malloc_r+0x36c>
    b806:	adds	r0, #1
    b808:	ittet	ne
    b80a:	rsbne	sl, sl, fp
    b80e:	addne	r1, sl
    b810:	streq.w	fp, [lr]
    b814:	strne	r1, [r3, #0]
    b816:	ands.w	r1, fp, #7
    b81a:	beq.w	ba4c <_malloc_r+0x4a4>
    b81e:	rsb	r0, r1, #8
    b822:	rsb	r1, r1, #4096	; 0x1000
    b826:	add	fp, r0
    b828:	adds	r1, #8
    b82a:	add	r2, fp
    b82c:	ubfx	r2, r2, #0, #12
    b830:	rsb	r9, r2, r1
    b834:	mov	r1, r9
    b836:	mov	r0, r6
    b838:	str	r3, [sp, #4]
    b83a:	bl	bc20 <_sbrk_r>
    b83e:	adds	r3, r0, #1
    b840:	ldr	r3, [sp, #4]
    b842:	beq.w	bac4 <_malloc_r+0x51c>
    b846:	rsb	r2, fp, r0
    b84a:	add	r2, r9
    b84c:	orr.w	r2, r2, #1
    b850:	ldr	r1, [r3, #0]
    b852:	str.w	fp, [r7, #8]
    b856:	add	r1, r9
    b858:	cmp	r4, r7
    b85a:	str.w	r2, [fp, #4]
    b85e:	str	r1, [r3, #0]
    b860:	ldr.w	r9, [pc, #164]	; b908 <_malloc_r+0x360>
    b864:	beq.n	b894 <_malloc_r+0x2ec>
    b866:	cmp.w	r8, #15
    b86a:	bls.w	ba68 <_malloc_r+0x4c0>
    b86e:	ldr	r2, [r4, #4]
    b870:	sub.w	r3, r8, #12
    b874:	bic.w	r3, r3, #7
    b878:	adds	r0, r4, r3
    b87a:	and.w	r2, r2, #1
    b87e:	mov.w	lr, #5
    b882:	orrs	r2, r3
    b884:	cmp	r3, #15
    b886:	str	r2, [r4, #4]
    b888:	str.w	lr, [r0, #4]
    b88c:	str.w	lr, [r0, #8]
    b890:	bhi.w	bacc <_malloc_r+0x524>
    b894:	ldr	r3, [pc, #116]	; (b90c <_malloc_r+0x364>)
    b896:	ldr	r4, [r7, #8]
    b898:	ldr	r2, [r3, #0]
    b89a:	cmp	r1, r2
    b89c:	it	hi
    b89e:	strhi	r1, [r3, #0]
    b8a0:	ldr	r3, [pc, #108]	; (b910 <_malloc_r+0x368>)
    b8a2:	ldr	r2, [r3, #0]
    b8a4:	cmp	r1, r2
    b8a6:	ldr	r2, [r4, #4]
    b8a8:	it	hi
    b8aa:	strhi	r1, [r3, #0]
    b8ac:	bic.w	r2, r2, #3
    b8b0:	cmp	r5, r2
    b8b2:	sub.w	r3, r2, r5
    b8b6:	bhi.n	b8bc <_malloc_r+0x314>
    b8b8:	cmp	r3, #15
    b8ba:	bgt.n	b8c6 <_malloc_r+0x31e>
    b8bc:	mov	r0, r6
    b8be:	bl	bc1c <__malloc_unlock>
    b8c2:	movs	r4, #0
    b8c4:	b.n	b738 <_malloc_r+0x190>
    b8c6:	adds	r2, r4, r5
    b8c8:	orr.w	r3, r3, #1
    b8cc:	orr.w	r5, r5, #1
    b8d0:	str	r5, [r4, #4]
    b8d2:	mov	r0, r6
    b8d4:	str	r2, [r7, #8]
    b8d6:	str	r3, [r2, #4]
    b8d8:	bl	bc1c <__malloc_unlock>
    b8dc:	adds	r4, #8
    b8de:	mov	r0, r4
    b8e0:	add	sp, #12
    b8e2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b8e6:	cmp	r3, #20
    b8e8:	bls.n	b9ce <_malloc_r+0x426>
    b8ea:	cmp	r3, #84	; 0x54
    b8ec:	bhi.w	ba38 <_malloc_r+0x490>
    b8f0:	lsrs	r0, r5, #12
    b8f2:	add.w	lr, r0, #111	; 0x6f
    b8f6:	mov.w	r3, lr, lsl #1
    b8fa:	adds	r0, #110	; 0x6e
    b8fc:	b.n	b5ec <_malloc_r+0x44>
    b8fe:	nop
    b900:	.word	0x1fff0ecc
    b904:	.word	0x1fff1d3c
    b908:	.word	0x1fff1d40
    b90c:	.word	0x1fff1d38
    b910:	.word	0x1fff1d34
    b914:	.word	0x1fff12d8
    b918:	lsrs	r2, r3, #9
    b91a:	cmp	r2, #4
    b91c:	bls.n	b9dc <_malloc_r+0x434>
    b91e:	cmp	r2, #20
    b920:	bhi.w	ba8a <_malloc_r+0x4e2>
    b924:	add.w	r1, r2, #92	; 0x5c
    b928:	lsls	r1, r1, #1
    b92a:	adds	r2, #91	; 0x5b
    b92c:	add.w	ip, r7, r1, lsl #2
    b930:	ldr.w	r1, [r7, r1, lsl #2]
    b934:	ldr.w	r8, [pc, #476]	; bb14 <_malloc_r+0x56c>
    b938:	sub.w	ip, ip, #8
    b93c:	cmp	ip, r1
    b93e:	beq.w	ba52 <_malloc_r+0x4aa>
    b942:	ldr	r2, [r1, #4]
    b944:	bic.w	r2, r2, #3
    b948:	cmp	r3, r2
    b94a:	bcs.n	b952 <_malloc_r+0x3aa>
    b94c:	ldr	r1, [r1, #8]
    b94e:	cmp	ip, r1
    b950:	bne.n	b942 <_malloc_r+0x39a>
    b952:	ldr.w	ip, [r1, #12]
    b956:	ldr	r2, [r7, #4]
    b958:	str.w	ip, [r4, #12]
    b95c:	str	r1, [r4, #8]
    b95e:	str.w	r4, [ip, #8]
    b962:	str	r4, [r1, #12]
    b964:	b.n	b678 <_malloc_r+0xd0>
    b966:	adds	r3, r4, r5
    b968:	orr.w	r7, r2, #1
    b96c:	orr.w	r5, r5, #1
    b970:	str	r5, [r4, #4]
    b972:	mov	r0, r6
    b974:	str	r3, [r1, #20]
    b976:	str	r3, [r1, #16]
    b978:	str.w	lr, [r3, #12]
    b97c:	str.w	lr, [r3, #8]
    b980:	str	r7, [r3, #4]
    b982:	str	r2, [r3, r2]
    b984:	adds	r4, #8
    b986:	bl	bc1c <__malloc_unlock>
    b98a:	b.n	b738 <_malloc_r+0x190>
    b98c:	ldr	r2, [r1, #4]
    b98e:	b.n	b678 <_malloc_r+0xd0>
    b990:	add.w	r8, r8, #1
    b994:	tst.w	r8, #3
    b998:	add.w	ip, ip, #8
    b99c:	bne.w	b69e <_malloc_r+0xf6>
    b9a0:	b.n	ba04 <_malloc_r+0x45c>
    b9a2:	ldr	r4, [r3, #12]
    b9a4:	cmp	r3, r4
    b9a6:	it	eq
    b9a8:	addeq	r0, #2
    b9aa:	beq.w	b618 <_malloc_r+0x70>
    b9ae:	b.n	b718 <_malloc_r+0x170>
    b9b0:	add	r3, r1
    b9b2:	mov	r4, r1
    b9b4:	ldr	r2, [r3, #4]
    b9b6:	ldr	r1, [r1, #12]
    b9b8:	ldr.w	r5, [r4, #8]!
    b9bc:	orr.w	r2, r2, #1
    b9c0:	str	r2, [r3, #4]
    b9c2:	mov	r0, r6
    b9c4:	str	r1, [r5, #12]
    b9c6:	str	r5, [r1, #8]
    b9c8:	bl	bc1c <__malloc_unlock>
    b9cc:	b.n	b738 <_malloc_r+0x190>
    b9ce:	add.w	lr, r3, #92	; 0x5c
    b9d2:	add.w	r0, r3, #91	; 0x5b
    b9d6:	mov.w	r3, lr, lsl #1
    b9da:	b.n	b5ec <_malloc_r+0x44>
    b9dc:	lsrs	r2, r3, #6
    b9de:	add.w	r1, r2, #57	; 0x39
    b9e2:	lsls	r1, r1, #1
    b9e4:	adds	r2, #56	; 0x38
    b9e6:	b.n	b92c <_malloc_r+0x384>
    b9e8:	cmp	r4, r7
    b9ea:	ldr	r3, [pc, #296]	; (bb14 <_malloc_r+0x56c>)
    b9ec:	beq.w	b7f0 <_malloc_r+0x248>
    b9f0:	ldr	r4, [r3, #8]
    b9f2:	ldr	r2, [r4, #4]
    b9f4:	bic.w	r2, r2, #3
    b9f8:	b.n	b8b0 <_malloc_r+0x308>
    b9fa:	ldr.w	r3, [r9], #-8
    b9fe:	cmp	r9, r3
    ba00:	bne.w	bb08 <_malloc_r+0x560>
    ba04:	tst.w	r0, #3
    ba08:	add.w	r0, r0, #4294967295
    ba0c:	bne.n	b9fa <_malloc_r+0x452>
    ba0e:	ldr	r3, [r7, #4]
    ba10:	bic.w	r3, r3, r4
    ba14:	str	r3, [r7, #4]
    ba16:	lsls	r4, r4, #1
    ba18:	cmp	r4, r3
    ba1a:	bhi.w	b798 <_malloc_r+0x1f0>
    ba1e:	cmp	r4, #0
    ba20:	beq.w	b798 <_malloc_r+0x1f0>
    ba24:	tst	r4, r3
    ba26:	mov	r0, r8
    ba28:	bne.w	b696 <_malloc_r+0xee>
    ba2c:	lsls	r4, r4, #1
    ba2e:	tst	r4, r3
    ba30:	add.w	r0, r0, #4
    ba34:	beq.n	ba2c <_malloc_r+0x484>
    ba36:	b.n	b696 <_malloc_r+0xee>
    ba38:	cmp.w	r3, #340	; 0x154
    ba3c:	bhi.n	ba70 <_malloc_r+0x4c8>
    ba3e:	lsrs	r0, r5, #15
    ba40:	add.w	lr, r0, #120	; 0x78
    ba44:	mov.w	r3, lr, lsl #1
    ba48:	adds	r0, #119	; 0x77
    ba4a:	b.n	b5ec <_malloc_r+0x44>
    ba4c:	mov.w	r1, #4096	; 0x1000
    ba50:	b.n	b82a <_malloc_r+0x282>
    ba52:	movs	r1, #1
    ba54:	ldr.w	r3, [r8, #4]
    ba58:	asrs	r2, r2, #2
    ba5a:	lsl.w	r2, r1, r2
    ba5e:	orrs	r2, r3
    ba60:	str.w	r2, [r8, #4]
    ba64:	mov	r1, ip
    ba66:	b.n	b958 <_malloc_r+0x3b0>
    ba68:	movs	r3, #1
    ba6a:	str.w	r3, [fp, #4]
    ba6e:	b.n	b8bc <_malloc_r+0x314>
    ba70:	movw	r2, #1364	; 0x554
    ba74:	cmp	r3, r2
    ba76:	bhi.n	baba <_malloc_r+0x512>
    ba78:	lsrs	r0, r5, #18
    ba7a:	add.w	lr, r0, #125	; 0x7d
    ba7e:	mov.w	r3, lr, lsl #1
    ba82:	adds	r0, #124	; 0x7c
    ba84:	b.n	b5ec <_malloc_r+0x44>
    ba86:	adds	r2, #16
    ba88:	b.n	b7d4 <_malloc_r+0x22c>
    ba8a:	cmp	r2, #84	; 0x54
    ba8c:	bhi.n	badc <_malloc_r+0x534>
    ba8e:	lsrs	r2, r3, #12
    ba90:	add.w	r1, r2, #111	; 0x6f
    ba94:	lsls	r1, r1, #1
    ba96:	adds	r2, #110	; 0x6e
    ba98:	b.n	b92c <_malloc_r+0x384>
    ba9a:	ldr	r4, [r7, #8]
    ba9c:	ldr	r2, [r4, #4]
    ba9e:	bic.w	r2, r2, #3
    baa2:	b.n	b8b0 <_malloc_r+0x308>
    baa4:	ubfx	r0, sl, #0, #12
    baa8:	cmp	r0, #0
    baaa:	bne.w	b7fe <_malloc_r+0x256>
    baae:	add	r2, r8
    bab0:	ldr	r3, [r7, #8]
    bab2:	orr.w	r2, r2, #1
    bab6:	str	r2, [r3, #4]
    bab8:	b.n	b894 <_malloc_r+0x2ec>
    baba:	movs	r3, #254	; 0xfe
    babc:	mov.w	lr, #127	; 0x7f
    bac0:	movs	r0, #126	; 0x7e
    bac2:	b.n	b5ec <_malloc_r+0x44>
    bac4:	movs	r2, #1
    bac6:	mov.w	r9, #0
    baca:	b.n	b850 <_malloc_r+0x2a8>
    bacc:	add.w	r1, r4, #8
    bad0:	mov	r0, r6
    bad2:	bl	c044 <_free_r>
    bad6:	ldr.w	r1, [r9]
    bada:	b.n	b894 <_malloc_r+0x2ec>
    badc:	cmp.w	r2, #340	; 0x154
    bae0:	bhi.n	baee <_malloc_r+0x546>
    bae2:	lsrs	r2, r3, #15
    bae4:	add.w	r1, r2, #120	; 0x78
    bae8:	lsls	r1, r1, #1
    baea:	adds	r2, #119	; 0x77
    baec:	b.n	b92c <_malloc_r+0x384>
    baee:	movw	r1, #1364	; 0x554
    baf2:	cmp	r2, r1
    baf4:	bhi.n	bb02 <_malloc_r+0x55a>
    baf6:	lsrs	r2, r3, #18
    baf8:	add.w	r1, r2, #125	; 0x7d
    bafc:	lsls	r1, r1, #1
    bafe:	adds	r2, #124	; 0x7c
    bb00:	b.n	b92c <_malloc_r+0x384>
    bb02:	movs	r1, #254	; 0xfe
    bb04:	movs	r2, #126	; 0x7e
    bb06:	b.n	b92c <_malloc_r+0x384>
    bb08:	ldr	r3, [r7, #4]
    bb0a:	b.n	ba16 <_malloc_r+0x46e>
    bb0c:	lsrs	r0, r5, #3
    bb0e:	adds	r3, r0, #1
    bb10:	lsls	r3, r3, #1
    bb12:	b.n	b706 <_malloc_r+0x15e>
    bb14:	.word	0x1fff0ecc

0000bb18 <memcmp>:
    bb18:	cmp	r2, #3
    bb1a:	push	{r4, r5, r6}
    bb1c:	bls.n	bb6c <memcmp+0x54>
    bb1e:	orr.w	r3, r0, r1
    bb22:	lsls	r3, r3, #30
    bb24:	beq.n	bb4a <memcmp+0x32>
    bb26:	ldrb	r4, [r0, #0]
    bb28:	ldrb	r5, [r1, #0]
    bb2a:	cmp	r4, r5
    bb2c:	bne.n	bb74 <memcmp+0x5c>
    bb2e:	add	r2, r0
    bb30:	adds	r3, r0, #1
    bb32:	b.n	bb40 <memcmp+0x28>
    bb34:	ldrb.w	r4, [r3], #1
    bb38:	ldrb.w	r5, [r1, #1]!
    bb3c:	cmp	r4, r5
    bb3e:	bne.n	bb74 <memcmp+0x5c>
    bb40:	cmp	r3, r2
    bb42:	bne.n	bb34 <memcmp+0x1c>
    bb44:	movs	r0, #0
    bb46:	pop	{r4, r5, r6}
    bb48:	bx	lr
    bb4a:	mov	r4, r1
    bb4c:	mov	r3, r0
    bb4e:	ldr	r6, [r3, #0]
    bb50:	ldr	r5, [r4, #0]
    bb52:	cmp	r6, r5
    bb54:	mov	r0, r3
    bb56:	mov	r1, r4
    bb58:	add.w	r3, r3, #4
    bb5c:	add.w	r4, r4, #4
    bb60:	bne.n	bb26 <memcmp+0xe>
    bb62:	subs	r2, #4
    bb64:	cmp	r2, #3
    bb66:	mov	r0, r3
    bb68:	mov	r1, r4
    bb6a:	bhi.n	bb4e <memcmp+0x36>
    bb6c:	cmp	r2, #0
    bb6e:	bne.n	bb26 <memcmp+0xe>
    bb70:	mov	r0, r2
    bb72:	b.n	bb46 <memcmp+0x2e>
    bb74:	subs	r0, r4, r5
    bb76:	pop	{r4, r5, r6}
    bb78:	bx	lr
    bb7a:	nop

0000bb7c <memset>:
    bb7c:	push	{r4, r5, r6}
    bb7e:	lsls	r4, r0, #30
    bb80:	beq.n	bc10 <memset+0x94>
    bb82:	subs	r4, r2, #1
    bb84:	cmp	r2, #0
    bb86:	beq.n	bc0c <memset+0x90>
    bb88:	uxtb	r5, r1
    bb8a:	mov	r3, r0
    bb8c:	b.n	bb94 <memset+0x18>
    bb8e:	subs	r2, r4, #1
    bb90:	cbz	r4, bc0c <memset+0x90>
    bb92:	mov	r4, r2
    bb94:	strb.w	r5, [r3], #1
    bb98:	lsls	r2, r3, #30
    bb9a:	bne.n	bb8e <memset+0x12>
    bb9c:	cmp	r4, #3
    bb9e:	bls.n	bbfe <memset+0x82>
    bba0:	uxtb	r5, r1
    bba2:	orr.w	r5, r5, r5, lsl #8
    bba6:	cmp	r4, #15
    bba8:	orr.w	r5, r5, r5, lsl #16
    bbac:	bls.n	bbe2 <memset+0x66>
    bbae:	add.w	r2, r3, #16
    bbb2:	mov	r6, r4
    bbb4:	subs	r6, #16
    bbb6:	cmp	r6, #15
    bbb8:	str.w	r5, [r2, #-16]
    bbbc:	str.w	r5, [r2, #-12]
    bbc0:	str.w	r5, [r2, #-8]
    bbc4:	str.w	r5, [r2, #-4]
    bbc8:	add.w	r2, r2, #16
    bbcc:	bhi.n	bbb4 <memset+0x38>
    bbce:	sub.w	r2, r4, #16
    bbd2:	bic.w	r2, r2, #15
    bbd6:	and.w	r4, r4, #15
    bbda:	adds	r2, #16
    bbdc:	cmp	r4, #3
    bbde:	add	r3, r2
    bbe0:	bls.n	bbfe <memset+0x82>
    bbe2:	mov	r6, r3
    bbe4:	mov	r2, r4
    bbe6:	subs	r2, #4
    bbe8:	cmp	r2, #3
    bbea:	str.w	r5, [r6], #4
    bbee:	bhi.n	bbe6 <memset+0x6a>
    bbf0:	subs	r2, r4, #4
    bbf2:	bic.w	r2, r2, #3
    bbf6:	adds	r2, #4
    bbf8:	add	r3, r2
    bbfa:	and.w	r4, r4, #3
    bbfe:	cbz	r4, bc0c <memset+0x90>
    bc00:	uxtb	r1, r1
    bc02:	add	r4, r3
    bc04:	strb.w	r1, [r3], #1
    bc08:	cmp	r3, r4
    bc0a:	bne.n	bc04 <memset+0x88>
    bc0c:	pop	{r4, r5, r6}
    bc0e:	bx	lr
    bc10:	mov	r4, r2
    bc12:	mov	r3, r0
    bc14:	b.n	bb9c <memset+0x20>
    bc16:	nop

0000bc18 <__malloc_lock>:
    bc18:	bx	lr
    bc1a:	nop

0000bc1c <__malloc_unlock>:
    bc1c:	bx	lr
    bc1e:	nop

0000bc20 <_sbrk_r>:
    bc20:	push	{r3, r4, r5, lr}
    bc22:	ldr	r4, [pc, #28]	; (bc40 <_sbrk_r+0x20>)
    bc24:	movs	r3, #0
    bc26:	mov	r5, r0
    bc28:	mov	r0, r1
    bc2a:	str	r3, [r4, #0]
    bc2c:	bl	908c <_sbrk>
    bc30:	adds	r3, r0, #1
    bc32:	beq.n	bc36 <_sbrk_r+0x16>
    bc34:	pop	{r3, r4, r5, pc}
    bc36:	ldr	r3, [r4, #0]
    bc38:	cmp	r3, #0
    bc3a:	beq.n	bc34 <_sbrk_r+0x14>
    bc3c:	str	r3, [r5, #0]
    bc3e:	pop	{r3, r4, r5, pc}
    bc40:	.word	0x1fff1d80

0000bc44 <strcat>:
    bc44:	lsls	r3, r0, #30
    bc46:	push	{r4, lr}
    bc48:	mov	r4, r0
    bc4a:	bne.n	bc6e <strcat+0x2a>
    bc4c:	ldr	r2, [r0, #0]
    bc4e:	sub.w	r3, r2, #16843009	; 0x1010101
    bc52:	bic.w	r3, r3, r2
    bc56:	tst.w	r3, #2155905152	; 0x80808080
    bc5a:	bne.n	bc6e <strcat+0x2a>
    bc5c:	ldr.w	r2, [r0, #4]!
    bc60:	sub.w	r3, r2, #16843009	; 0x1010101
    bc64:	bic.w	r3, r3, r2
    bc68:	tst.w	r3, #2155905152	; 0x80808080
    bc6c:	beq.n	bc5c <strcat+0x18>
    bc6e:	ldrb	r3, [r0, #0]
    bc70:	cbz	r3, bc7a <strcat+0x36>
    bc72:	ldrb.w	r3, [r0, #1]!
    bc76:	cmp	r3, #0
    bc78:	bne.n	bc72 <strcat+0x2e>
    bc7a:	bl	bc84 <strcpy>
    bc7e:	mov	r0, r4
    bc80:	pop	{r4, pc}
    bc82:	nop

0000bc84 <strcpy>:
    bc84:	eor.w	r2, r0, r1
    bc88:	mov	ip, r0
    bc8a:	tst.w	r2, #3
    bc8e:	bne.n	bd30 <strcpy+0xac>
    bc90:	tst.w	r1, #3
    bc94:	bne.n	bcfc <strcpy+0x78>
    bc96:	str.w	r4, [sp, #-4]!
    bc9a:	tst.w	r1, #4
    bc9e:	ldr.w	r3, [r1], #4
    bca2:	beq.n	bcbc <strcpy+0x38>
    bca4:	sub.w	r2, r3, #16843009	; 0x1010101
    bca8:	bics	r2, r3
    bcaa:	tst.w	r2, #2155905152	; 0x80808080
    bcae:	itt	eq
    bcb0:	streq.w	r3, [ip], #4
    bcb4:	ldreq.w	r3, [r1], #4
    bcb8:	bne.n	bce8 <strcpy+0x64>
    bcba:	nop
    bcbc:	ldr.w	r4, [r1], #4
    bcc0:	sub.w	r2, r3, #16843009	; 0x1010101
    bcc4:	bics	r2, r3
    bcc6:	tst.w	r2, #2155905152	; 0x80808080
    bcca:	sub.w	r2, r4, #16843009	; 0x1010101
    bcce:	bne.n	bce8 <strcpy+0x64>
    bcd0:	str.w	r3, [ip], #4
    bcd4:	bics	r2, r4
    bcd6:	tst.w	r2, #2155905152	; 0x80808080
    bcda:	itt	eq
    bcdc:	ldreq.w	r3, [r1], #4
    bce0:	streq.w	r4, [ip], #4
    bce4:	beq.n	bcbc <strcpy+0x38>
    bce6:	mov	r3, r4
    bce8:	strb.w	r3, [ip], #1
    bcec:	tst.w	r3, #255	; 0xff
    bcf0:	mov.w	r3, r3, ror #8
    bcf4:	bne.n	bce8 <strcpy+0x64>
    bcf6:	ldr.w	r4, [sp], #4
    bcfa:	bx	lr
    bcfc:	tst.w	r1, #1
    bd00:	beq.n	bd10 <strcpy+0x8c>
    bd02:	ldrb.w	r2, [r1], #1
    bd06:	strb.w	r2, [ip], #1
    bd0a:	cmp	r2, #0
    bd0c:	it	eq
    bd0e:	bxeq	lr
    bd10:	tst.w	r1, #2
    bd14:	beq.n	bc96 <strcpy+0x12>
    bd16:	ldrh.w	r2, [r1], #2
    bd1a:	tst.w	r2, #255	; 0xff
    bd1e:	itet	ne
    bd20:	strhne.w	r2, [ip], #2
    bd24:	strbeq.w	r2, [ip]
    bd28:	tstne.w	r2, #65280	; 0xff00
    bd2c:	bne.n	bc96 <strcpy+0x12>
    bd2e:	bx	lr
    bd30:	ldrb.w	r2, [r1], #1
    bd34:	strb.w	r2, [ip], #1
    bd38:	cmp	r2, #0
    bd3a:	bne.n	bd30 <strcpy+0xac>
    bd3c:	bx	lr
    bd3e:	nop

0000bd40 <strlen>:
    bd40:	pld	[r0]
    bd44:	strd	r4, r5, [sp, #-8]!
    bd48:	bic.w	r1, r0, #7
    bd4c:	mvn.w	ip, #0
    bd50:	ands.w	r4, r0, #7
    bd54:	pld	[r1, #32]
    bd58:	bne.w	bdee <strlen+0xae>
    bd5c:	mov.w	r4, #0
    bd60:	mvn.w	r0, #7
    bd64:	ldrd	r2, r3, [r1]
    bd68:	pld	[r1, #64]	; 0x40
    bd6c:	add.w	r0, r0, #8
    bd70:	uadd8	r2, r2, ip
    bd74:	sel	r2, r4, ip
    bd78:	uadd8	r3, r3, ip
    bd7c:	sel	r3, r2, ip
    bd80:	cbnz	r3, bdd6 <strlen+0x96>
    bd82:	ldrd	r2, r3, [r1, #8]
    bd86:	uadd8	r2, r2, ip
    bd8a:	add.w	r0, r0, #8
    bd8e:	sel	r2, r4, ip
    bd92:	uadd8	r3, r3, ip
    bd96:	sel	r3, r2, ip
    bd9a:	cbnz	r3, bdd6 <strlen+0x96>
    bd9c:	ldrd	r2, r3, [r1, #16]
    bda0:	uadd8	r2, r2, ip
    bda4:	add.w	r0, r0, #8
    bda8:	sel	r2, r4, ip
    bdac:	uadd8	r3, r3, ip
    bdb0:	sel	r3, r2, ip
    bdb4:	cbnz	r3, bdd6 <strlen+0x96>
    bdb6:	ldrd	r2, r3, [r1, #24]
    bdba:	add.w	r1, r1, #32
    bdbe:	uadd8	r2, r2, ip
    bdc2:	add.w	r0, r0, #8
    bdc6:	sel	r2, r4, ip
    bdca:	uadd8	r3, r3, ip
    bdce:	sel	r3, r2, ip
    bdd2:	cmp	r3, #0
    bdd4:	beq.n	bd64 <strlen+0x24>
    bdd6:	cmp	r2, #0
    bdd8:	itt	eq
    bdda:	addeq	r0, #4
    bddc:	moveq	r2, r3
    bdde:	rev	r2, r2
    bde0:	clz	r2, r2
    bde4:	ldrd	r4, r5, [sp], #8
    bde8:	add.w	r0, r0, r2, lsr #3
    bdec:	bx	lr
    bdee:	ldrd	r2, r3, [r1]
    bdf2:	and.w	r5, r4, #3
    bdf6:	rsb	r0, r4, #0
    bdfa:	mov.w	r5, r5, lsl #3
    bdfe:	tst.w	r4, #4
    be02:	pld	[r1, #64]	; 0x40
    be06:	lsl.w	r5, ip, r5
    be0a:	orn	r2, r2, r5
    be0e:	itt	ne
    be10:	ornne	r3, r3, r5
    be14:	movne	r2, ip
    be16:	mov.w	r4, #0
    be1a:	b.n	bd70 <strlen+0x30>

0000be1c <strncmp>:
    be1c:	cmp	r2, #0
    be1e:	beq.n	bea4 <strncmp+0x88>
    be20:	orr.w	r3, r0, r1
    be24:	ands.w	r3, r3, #3
    be28:	push	{r4, r5, r6, r7}
    be2a:	bne.n	be78 <strncmp+0x5c>
    be2c:	cmp	r2, #3
    be2e:	bls.n	be78 <strncmp+0x5c>
    be30:	ldr	r4, [r0, #0]
    be32:	ldr	r5, [r1, #0]
    be34:	cmp	r4, r5
    be36:	bne.n	be78 <strncmp+0x5c>
    be38:	subs	r2, #4
    be3a:	beq.n	bea8 <strncmp+0x8c>
    be3c:	sub.w	r5, r4, #16843009	; 0x1010101
    be40:	bic.w	r4, r5, r4
    be44:	tst.w	r4, #2155905152	; 0x80808080
    be48:	bne.n	beae <strncmp+0x92>
    be4a:	adds	r7, r0, #4
    be4c:	adds	r5, r1, #4
    be4e:	b.n	be6c <strncmp+0x50>
    be50:	ldr.w	r3, [r7], #4
    be54:	ldr	r6, [r1, #0]
    be56:	sub.w	r4, r3, #16843009	; 0x1010101
    be5a:	cmp	r3, r6
    be5c:	bic.w	r4, r4, r3
    be60:	bne.n	be78 <strncmp+0x5c>
    be62:	subs	r2, #4
    be64:	beq.n	bea8 <strncmp+0x8c>
    be66:	tst.w	r4, #2155905152	; 0x80808080
    be6a:	bne.n	beb4 <strncmp+0x98>
    be6c:	cmp	r2, #3
    be6e:	mov	r1, r5
    be70:	mov	r0, r7
    be72:	add.w	r5, r5, #4
    be76:	bhi.n	be50 <strncmp+0x34>
    be78:	ldrb	r3, [r0, #0]
    be7a:	ldrb	r4, [r1, #0]
    be7c:	cmp	r4, r3
    be7e:	add.w	r2, r2, #4294967295
    be82:	bne.n	be9e <strncmp+0x82>
    be84:	cbz	r2, bea8 <strncmp+0x8c>
    be86:	cbnz	r4, be8e <strncmp+0x72>
    be88:	b.n	beb8 <strncmp+0x9c>
    be8a:	cbz	r2, bea8 <strncmp+0x8c>
    be8c:	cbz	r3, beae <strncmp+0x92>
    be8e:	ldrb.w	r3, [r0, #1]!
    be92:	ldrb.w	r4, [r1, #1]!
    be96:	cmp	r3, r4
    be98:	add.w	r2, r2, #4294967295
    be9c:	beq.n	be8a <strncmp+0x6e>
    be9e:	subs	r0, r3, r4
    bea0:	pop	{r4, r5, r6, r7}
    bea2:	bx	lr
    bea4:	mov	r0, r2
    bea6:	bx	lr
    bea8:	mov	r0, r2
    beaa:	pop	{r4, r5, r6, r7}
    beac:	bx	lr
    beae:	mov	r0, r3
    beb0:	pop	{r4, r5, r6, r7}
    beb2:	bx	lr
    beb4:	movs	r0, #0
    beb6:	b.n	bea0 <strncmp+0x84>
    beb8:	mov	r0, r4
    beba:	b.n	bea0 <strncmp+0x84>

0000bebc <__register_exitproc>:
    bebc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    bec0:	ldr	r4, [pc, #148]	; (bf58 <__register_exitproc+0x9c>)
    bec2:	ldr	r5, [r4, #0]
    bec4:	ldr.w	r4, [r5, #328]	; 0x148
    bec8:	mov	r6, r0
    beca:	mov	r8, r1
    becc:	mov	sl, r2
    bece:	mov	r9, r3
    bed0:	cbz	r4, bf44 <__register_exitproc+0x88>
    bed2:	ldr	r0, [r4, #4]
    bed4:	cmp	r0, #31
    bed6:	bgt.n	bf08 <__register_exitproc+0x4c>
    bed8:	adds	r3, r0, #1
    beda:	cbz	r6, befa <__register_exitproc+0x3e>
    bedc:	add.w	r5, r4, r0, lsl #2
    bee0:	movs	r2, #1
    bee2:	str.w	sl, [r5, #136]	; 0x88
    bee6:	ldr.w	r1, [r4, #392]	; 0x188
    beea:	lsls	r2, r0
    beec:	orrs	r1, r2
    beee:	cmp	r6, #2
    bef0:	str.w	r1, [r4, #392]	; 0x188
    bef4:	str.w	r9, [r5, #264]	; 0x108
    bef8:	beq.n	bf38 <__register_exitproc+0x7c>
    befa:	adds	r0, #2
    befc:	str	r3, [r4, #4]
    befe:	str.w	r8, [r4, r0, lsl #2]
    bf02:	movs	r0, #0
    bf04:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bf08:	ldr	r3, [pc, #80]	; (bf5c <__register_exitproc+0xa0>)
    bf0a:	cbz	r3, bf4e <__register_exitproc+0x92>
    bf0c:	mov.w	r0, #400	; 0x190
    bf10:	bl	b588 <malloc>
    bf14:	mov	r4, r0
    bf16:	cbz	r0, bf4e <__register_exitproc+0x92>
    bf18:	ldr.w	r3, [r5, #328]	; 0x148
    bf1c:	movs	r7, #0
    bf1e:	stmia.w	r0, {r3, r7}
    bf22:	str.w	r4, [r5, #328]	; 0x148
    bf26:	mov	r0, r7
    bf28:	movs	r3, #1
    bf2a:	str.w	r7, [r4, #392]	; 0x188
    bf2e:	str.w	r7, [r4, #396]	; 0x18c
    bf32:	cmp	r6, #0
    bf34:	beq.n	befa <__register_exitproc+0x3e>
    bf36:	b.n	bedc <__register_exitproc+0x20>
    bf38:	ldr.w	r1, [r4, #396]	; 0x18c
    bf3c:	orrs	r2, r1
    bf3e:	str.w	r2, [r4, #396]	; 0x18c
    bf42:	b.n	befa <__register_exitproc+0x3e>
    bf44:	add.w	r4, r5, #332	; 0x14c
    bf48:	str.w	r4, [r5, #328]	; 0x148
    bf4c:	b.n	bed2 <__register_exitproc+0x16>
    bf4e:	mov.w	r0, #4294967295
    bf52:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bf56:	nop
    bf58:	.word	0x0000c844
    bf5c:	.word	0x0000b589

0000bf60 <register_fini>:
    bf60:	ldr	r3, [pc, #8]	; (bf6c <register_fini+0xc>)
    bf62:	cbz	r3, bf6a <register_fini+0xa>
    bf64:	ldr	r0, [pc, #8]	; (bf70 <register_fini+0x10>)
    bf66:	b.w	bf74 <atexit>
    bf6a:	bx	lr
    bf6c:	.word	0x00000000
    bf70:	.word	0x0000bf81

0000bf74 <atexit>:
    bf74:	movs	r3, #0
    bf76:	mov	r1, r0
    bf78:	mov	r2, r3
    bf7a:	mov	r0, r3
    bf7c:	b.w	bebc <__register_exitproc>

0000bf80 <__libc_fini_array>:
    bf80:	push	{r3, r4, r5, lr}
    bf82:	ldr	r5, [pc, #28]	; (bfa0 <__libc_fini_array+0x20>)
    bf84:	ldr	r4, [pc, #28]	; (bfa4 <__libc_fini_array+0x24>)
    bf86:	subs	r4, r5, r4
    bf88:	asrs	r4, r4, #2
    bf8a:	beq.n	bf98 <__libc_fini_array+0x18>
    bf8c:	subs	r4, #1
    bf8e:	ldr.w	r3, [r5, #-4]!
    bf92:	blx	r3
    bf94:	cmp	r4, #0
    bf96:	bne.n	bf8c <__libc_fini_array+0xc>
    bf98:	ldmia.w	sp!, {r3, r4, r5, lr}
    bf9c:	b.w	c864 <__init_array_end>
	...

0000bfa8 <_malloc_trim_r>:
    bfa8:	push	{r3, r4, r5, r6, r7, lr}
    bfaa:	ldr	r7, [pc, #140]	; (c038 <_malloc_trim_r+0x90>)
    bfac:	mov	r4, r1
    bfae:	mov	r6, r0
    bfb0:	bl	bc18 <__malloc_lock>
    bfb4:	ldr	r3, [r7, #8]
    bfb6:	ldr	r5, [r3, #4]
    bfb8:	bic.w	r5, r5, #3
    bfbc:	subs	r1, r5, r4
    bfbe:	addw	r1, r1, #4079	; 0xfef
    bfc2:	bic.w	r1, r1, #4080	; 0xff0
    bfc6:	bic.w	r1, r1, #15
    bfca:	sub.w	r4, r1, #4096	; 0x1000
    bfce:	cmp.w	r4, #4096	; 0x1000
    bfd2:	blt.n	bfe4 <_malloc_trim_r+0x3c>
    bfd4:	movs	r1, #0
    bfd6:	mov	r0, r6
    bfd8:	bl	bc20 <_sbrk_r>
    bfdc:	ldr	r3, [r7, #8]
    bfde:	add	r3, r5
    bfe0:	cmp	r0, r3
    bfe2:	beq.n	bfee <_malloc_trim_r+0x46>
    bfe4:	mov	r0, r6
    bfe6:	bl	bc1c <__malloc_unlock>
    bfea:	movs	r0, #0
    bfec:	pop	{r3, r4, r5, r6, r7, pc}
    bfee:	negs	r1, r4
    bff0:	mov	r0, r6
    bff2:	bl	bc20 <_sbrk_r>
    bff6:	adds	r0, #1
    bff8:	beq.n	c016 <_malloc_trim_r+0x6e>
    bffa:	ldr	r3, [pc, #64]	; (c03c <_malloc_trim_r+0x94>)
    bffc:	ldr	r2, [r7, #8]
    bffe:	ldr	r1, [r3, #0]
    c000:	subs	r5, r5, r4
    c002:	orr.w	r5, r5, #1
    c006:	mov	r0, r6
    c008:	subs	r1, r1, r4
    c00a:	str	r5, [r2, #4]
    c00c:	str	r1, [r3, #0]
    c00e:	bl	bc1c <__malloc_unlock>
    c012:	movs	r0, #1
    c014:	pop	{r3, r4, r5, r6, r7, pc}
    c016:	movs	r1, #0
    c018:	mov	r0, r6
    c01a:	bl	bc20 <_sbrk_r>
    c01e:	ldr	r2, [r7, #8]
    c020:	subs	r3, r0, r2
    c022:	cmp	r3, #15
    c024:	ble.n	bfe4 <_malloc_trim_r+0x3c>
    c026:	ldr	r4, [pc, #24]	; (c040 <_malloc_trim_r+0x98>)
    c028:	ldr	r1, [pc, #16]	; (c03c <_malloc_trim_r+0x94>)
    c02a:	ldr	r4, [r4, #0]
    c02c:	orr.w	r3, r3, #1
    c030:	subs	r0, r0, r4
    c032:	str	r3, [r2, #4]
    c034:	str	r0, [r1, #0]
    c036:	b.n	bfe4 <_malloc_trim_r+0x3c>
    c038:	.word	0x1fff0ecc
    c03c:	.word	0x1fff1d40
    c040:	.word	0x1fff12d8

0000c044 <_free_r>:
    c044:	cmp	r1, #0
    c046:	beq.n	c0d4 <_free_r+0x90>
    c048:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    c04c:	mov	r5, r1
    c04e:	mov	r8, r0
    c050:	bl	bc18 <__malloc_lock>
    c054:	ldr.w	r7, [r5, #-4]
    c058:	ldr	r1, [pc, #424]	; (c204 <_free_r+0x1c0>)
    c05a:	bic.w	r3, r7, #1
    c05e:	sub.w	r4, r5, #8
    c062:	adds	r2, r4, r3
    c064:	ldr	r6, [r1, #8]
    c066:	ldr	r0, [r2, #4]
    c068:	cmp	r2, r6
    c06a:	bic.w	r0, r0, #3
    c06e:	beq.n	c136 <_free_r+0xf2>
    c070:	lsls	r6, r7, #31
    c072:	str	r0, [r2, #4]
    c074:	bmi.n	c08e <_free_r+0x4a>
    c076:	ldr.w	r7, [r5, #-8]
    c07a:	subs	r4, r4, r7
    c07c:	add.w	lr, r1, #8
    c080:	ldr	r5, [r4, #8]
    c082:	cmp	r5, lr
    c084:	add	r3, r7
    c086:	beq.n	c168 <_free_r+0x124>
    c088:	ldr	r7, [r4, #12]
    c08a:	str	r7, [r5, #12]
    c08c:	str	r5, [r7, #8]
    c08e:	adds	r5, r2, r0
    c090:	ldr	r5, [r5, #4]
    c092:	lsls	r5, r5, #31
    c094:	bpl.n	c11c <_free_r+0xd8>
    c096:	orr.w	r2, r3, #1
    c09a:	str	r2, [r4, #4]
    c09c:	str	r3, [r4, r3]
    c09e:	cmp.w	r3, #512	; 0x200
    c0a2:	bcs.n	c0d6 <_free_r+0x92>
    c0a4:	lsrs	r3, r3, #3
    c0a6:	adds	r2, r3, #1
    c0a8:	ldr	r5, [r1, #4]
    c0aa:	ldr.w	r7, [r1, r2, lsl #3]
    c0ae:	str	r7, [r4, #8]
    c0b0:	movs	r0, #1
    c0b2:	asrs	r3, r3, #2
    c0b4:	lsl.w	r3, r0, r3
    c0b8:	add.w	r0, r1, r2, lsl #3
    c0bc:	orrs	r5, r3
    c0be:	subs	r0, #8
    c0c0:	str	r0, [r4, #12]
    c0c2:	str	r5, [r1, #4]
    c0c4:	str.w	r4, [r1, r2, lsl #3]
    c0c8:	str	r4, [r7, #12]
    c0ca:	mov	r0, r8
    c0cc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    c0d0:	b.w	bc1c <__malloc_unlock>
    c0d4:	bx	lr
    c0d6:	lsrs	r2, r3, #9
    c0d8:	cmp	r2, #4
    c0da:	bhi.n	c184 <_free_r+0x140>
    c0dc:	lsrs	r2, r3, #6
    c0de:	add.w	r7, r2, #57	; 0x39
    c0e2:	lsls	r7, r7, #1
    c0e4:	add.w	r5, r2, #56	; 0x38
    c0e8:	add.w	r0, r1, r7, lsl #2
    c0ec:	ldr.w	r2, [r1, r7, lsl #2]
    c0f0:	ldr	r1, [pc, #272]	; (c204 <_free_r+0x1c0>)
    c0f2:	subs	r0, #8
    c0f4:	cmp	r0, r2
    c0f6:	beq.n	c194 <_free_r+0x150>
    c0f8:	ldr	r1, [r2, #4]
    c0fa:	bic.w	r1, r1, #3
    c0fe:	cmp	r3, r1
    c100:	bcs.n	c108 <_free_r+0xc4>
    c102:	ldr	r2, [r2, #8]
    c104:	cmp	r0, r2
    c106:	bne.n	c0f8 <_free_r+0xb4>
    c108:	ldr	r0, [r2, #12]
    c10a:	str	r0, [r4, #12]
    c10c:	str	r2, [r4, #8]
    c10e:	str	r4, [r0, #8]
    c110:	str	r4, [r2, #12]
    c112:	mov	r0, r8
    c114:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    c118:	b.w	bc1c <__malloc_unlock>
    c11c:	ldr	r5, [r2, #8]
    c11e:	ldr	r7, [pc, #232]	; (c208 <_free_r+0x1c4>)
    c120:	cmp	r5, r7
    c122:	add	r3, r0
    c124:	beq.n	c1a6 <_free_r+0x162>
    c126:	ldr	r0, [r2, #12]
    c128:	str	r0, [r5, #12]
    c12a:	orr.w	r2, r3, #1
    c12e:	str	r5, [r0, #8]
    c130:	str	r2, [r4, #4]
    c132:	str	r3, [r4, r3]
    c134:	b.n	c09e <_free_r+0x5a>
    c136:	lsls	r7, r7, #31
    c138:	add	r3, r0
    c13a:	bmi.n	c14c <_free_r+0x108>
    c13c:	ldr.w	r2, [r5, #-8]
    c140:	subs	r4, r4, r2
    c142:	add	r3, r2
    c144:	ldr	r0, [r4, #8]
    c146:	ldr	r2, [r4, #12]
    c148:	str	r2, [r0, #12]
    c14a:	str	r0, [r2, #8]
    c14c:	ldr	r2, [pc, #188]	; (c20c <_free_r+0x1c8>)
    c14e:	ldr	r2, [r2, #0]
    c150:	orr.w	r0, r3, #1
    c154:	cmp	r3, r2
    c156:	str	r0, [r4, #4]
    c158:	str	r4, [r1, #8]
    c15a:	bcc.n	c0ca <_free_r+0x86>
    c15c:	ldr	r3, [pc, #176]	; (c210 <_free_r+0x1cc>)
    c15e:	mov	r0, r8
    c160:	ldr	r1, [r3, #0]
    c162:	bl	bfa8 <_malloc_trim_r>
    c166:	b.n	c0ca <_free_r+0x86>
    c168:	adds	r1, r2, r0
    c16a:	ldr	r1, [r1, #4]
    c16c:	lsls	r1, r1, #31
    c16e:	bmi.n	c1fa <_free_r+0x1b6>
    c170:	ldr	r1, [r2, #8]
    c172:	ldr	r2, [r2, #12]
    c174:	str	r2, [r1, #12]
    c176:	add	r3, r0
    c178:	orr.w	r0, r3, #1
    c17c:	str	r1, [r2, #8]
    c17e:	str	r0, [r4, #4]
    c180:	str	r3, [r4, r3]
    c182:	b.n	c0ca <_free_r+0x86>
    c184:	cmp	r2, #20
    c186:	bhi.n	c1b8 <_free_r+0x174>
    c188:	add.w	r7, r2, #92	; 0x5c
    c18c:	lsls	r7, r7, #1
    c18e:	add.w	r5, r2, #91	; 0x5b
    c192:	b.n	c0e8 <_free_r+0xa4>
    c194:	asrs	r2, r5, #2
    c196:	ldr	r3, [r1, #4]
    c198:	movs	r5, #1
    c19a:	lsl.w	r2, r5, r2
    c19e:	orrs	r3, r2
    c1a0:	str	r3, [r1, #4]
    c1a2:	mov	r2, r0
    c1a4:	b.n	c10a <_free_r+0xc6>
    c1a6:	orr.w	r2, r3, #1
    c1aa:	str	r4, [r1, #20]
    c1ac:	str	r4, [r1, #16]
    c1ae:	str	r5, [r4, #12]
    c1b0:	str	r5, [r4, #8]
    c1b2:	str	r2, [r4, #4]
    c1b4:	str	r3, [r4, r3]
    c1b6:	b.n	c0ca <_free_r+0x86>
    c1b8:	cmp	r2, #84	; 0x54
    c1ba:	bhi.n	c1ca <_free_r+0x186>
    c1bc:	lsrs	r2, r3, #12
    c1be:	add.w	r7, r2, #111	; 0x6f
    c1c2:	lsls	r7, r7, #1
    c1c4:	add.w	r5, r2, #110	; 0x6e
    c1c8:	b.n	c0e8 <_free_r+0xa4>
    c1ca:	cmp.w	r2, #340	; 0x154
    c1ce:	bhi.n	c1de <_free_r+0x19a>
    c1d0:	lsrs	r2, r3, #15
    c1d2:	add.w	r7, r2, #120	; 0x78
    c1d6:	lsls	r7, r7, #1
    c1d8:	add.w	r5, r2, #119	; 0x77
    c1dc:	b.n	c0e8 <_free_r+0xa4>
    c1de:	movw	r0, #1364	; 0x554
    c1e2:	cmp	r2, r0
    c1e4:	bhi.n	c1f4 <_free_r+0x1b0>
    c1e6:	lsrs	r2, r3, #18
    c1e8:	add.w	r7, r2, #125	; 0x7d
    c1ec:	lsls	r7, r7, #1
    c1ee:	add.w	r5, r2, #124	; 0x7c
    c1f2:	b.n	c0e8 <_free_r+0xa4>
    c1f4:	movs	r7, #254	; 0xfe
    c1f6:	movs	r5, #126	; 0x7e
    c1f8:	b.n	c0e8 <_free_r+0xa4>
    c1fa:	orr.w	r2, r3, #1
    c1fe:	str	r2, [r4, #4]
    c200:	str	r3, [r4, r3]
    c202:	b.n	c0ca <_free_r+0x86>
    c204:	.word	0x1fff0ecc
    c208:	.word	0x1fff0ed4
    c20c:	.word	0x1fff12d4
    c210:	.word	0x1fff1d3c

0000c214 <vtable for StreamFile<FsBaseFile, unsigned long long>>:
	...
    c21c:	U.......m.......
    c22c:	............

0000c238 <vtable for FsFile>:
	...
    c240:	U.......m.......
    c250:	............MTP 
    c260:	test....loop....
    c270:	DBG_FAIL: ..ExFa
    c280:	tFile.cpp...ExFa
    c290:	tPartition.cpp..
    c2a0:	EXFAT...ExFatFil
    c2b0:	eWrite.cpp..FatF
    c2c0:	ile.cpp.FatParti
    c2d0:	tion.cpp....FatF
    c2e0:	ileLFN.cpp..DBG_
    c2f0:	HALT ...C:\Users
    c300:	\zimme\Documents
    c310:	\Arduino\librari
    c320:	es/SdFat-beta/sr
    c330:	c/FatLib/FatFile
    c340:	LFN.cpp.FatFileS
    c350:	FN.cpp..

0000c358 <vtable for SdSpiCard>:
	...
    c360:	1H..5H...H...M..
    c370:	.L...O..!H..EH..
    c380:	.N...H...H...I..
    c390:	.L...L...K...G..
    c3a0:	.H..EP..1N..9O..

0000c3b0 <vtable for SdioCard>:
	...
    c3b8:	IR...R..]_...W..
    c3c8:	.T...Y...X..qX..
    c3d8:	YU...Q...Q...S..
    c3e8:	.R...R..9R..MS..
    c3f8:	.R...V..uW...V..

0000c408 <vtable for MTPStorage_SD>:
	...
    c410:	-`..1`...a..aa..
    c420:	.l...d...d..-e..
    c430:	me...j...i...a..
    c440:	.e..If...g...h..
    c450:	.a../mtpindex.da
    c460:	t.../...SdError:
    c470:	 0X.,0X.Check SD
    c480:	 format.....erro
    c490:	r: .SD.begin fai
    c4a0:	led.

0000c4a4 <supported_op>:
    c4a4:	................
    c4b4:	................
    c4c4:	....

0000c4c8 <propertyList>:
    c4c8:	................
    c4d8:	A.D. len = . typ
    c4e8:	e = .... op = ..
    c4f8:	 transaction_id 
    c508:	= .. p..Teensy..
    c518:	microsoft.com: 1
    c528:	.0;.PJRC....1.0.
    c538:	???.SD Card.

0000c544 <monthDays>:
    c544:	............

0000c550 <digital_pin_to_info_PGM>:
    c550:	@..C@..@D..CD..@
    c560:	...C...@0..C0..@
    c570:	4..C4..@...C...@
    c580:	...C...@...C...@
    c590:	...C...@...C...@
    c5a0:	...C...@...C...@
    c5b0:	...C...@...C...@
    c5c0:	...C...@...C...@
    c5d0:	...C...@...C...@
    c5e0:	...C...@...C...@
    c5f0:	...C...@...C...@
    c600:	...C...@...C...@
    c610:	h .Ch..@...C...@
    c620:	8..C8..@<..C<..@
    c630:	@..C@..@H..CH..@
    c640:	L..CL..@(..C(..@
    c650:	,..C,..@` .C`..@
    c660:	d .Cd..@ ..C ..@
    c670:	$..C$..@(..C(..@
    c680:	,..C,..@D..CD..@
    c690:	p..Cp..@t..Ct..@
    c6a0:	h..Ch..@P..CP..@
    c6b0:	X..CX..@\..C\..@
    c6c0:	T..CT..@ ..C ..@
    c6d0:	$..C$..@...C...@
    c6e0:	...C...@8..C8..@
    c6f0:	4..C4..@0..C0..@
    c700:	<..C<..@,..C,..@
    c710:	( .C(..@, .C,..@
    c720:	. .C...@. .C...@
    c730:	. .C...@. .C...@
    c740:	. .C...@. .C...@

0000c750 <vtable for HardwareSerial>:
	...
    c758:	................
    c768:	............i...
    c778:	}...e...]...U...
    c788:	M...=...-...)...
    c798:	................
    c7a8:	........

0000c7b0 <vtable for usb_serial_class>:
	...
    c7b8:	u...m...i...e...
    c7c8:	a...]...Y...U...
    c7d8:	....

0000c7dc <usb_endpoint_config_table>:
    c7dc:	........

0000c7e4 <usb_descriptor_list>:
    c7e4:	................
    c7f4:	....i.......H...
    c804:	................
    c814:	................
    c824:	P...............
	...

0000c844 <_global_impure_ptr>:
    c844:	....

0000c848 <_init>:
    c848:	push	{r3, r4, r5, r6, r7, lr}
    c84a:	nop
    c84c:	pop	{r3, r4, r5, r6, r7}
    c84e:	pop	{r3}
    c850:	mov	lr, r3
    c852:	bx	lr

0000c854 <__init_array_start>:
    c854:	.word	0x0000bf61

0000c858 <__frame_dummy_init_array_entry>:
    c858:	5...5....n..

Disassembly of section .fini:

0000c864 <_fini>:
    c864:	push	{r3, r4, r5, r6, r7, lr}
    c866:	nop
